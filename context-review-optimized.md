This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

# File Summary

## Purpose
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.ts, src/**/*.tsx, **/*.config.ts, **/*.config.js, **/*.config.json, tsconfig.json, package.json, pnpm-lock.yaml, AGENTS.md, CLAUDE.md
- Files matching these patterns are excluded: node_modules/**, dist/**, .next/**, build/**, .env*, **/*.test.ts, **/*.spec.ts, src/**/__tests__/**, docs/architecture/decisions/superseded/**, docs/plans/archive/**, docs/review/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
src/
  ai/
    agents/
      accommodation-agent.ts
      agent-factory.ts
      budget-agent.ts
      chat-agent.ts
      destination-agent.ts
      flight-agent.ts
      index.ts
      instructions.ts
      itinerary-agent.ts
      memory-agent.ts
      router-agent.ts
      types.ts
    lib/
      registry-utils.ts
      tool-factory.ts
      tool-type-utils.ts
    models/
      registry.ts
    services/
      hotel-personalization.ts
    tools/
      schemas/
        accommodations.ts
        activities.ts
        flights.ts
        google-places.ts
        maps.ts
        planning.ts
        tools.ts
        travel-advisory.ts
        weather.ts
        web-crawl.ts
        web-search-batch.ts
        web-search.ts
      server/
        travel-advisory/
          providers/
            state-department.ts
          providers.ts
          utils.ts
        accommodations.ts
        activities.ts
        approvals.ts
        calendar.ts
        constants.ts
        errors.ts
        flights.ts
        google-places.ts
        injection.ts
        maps.ts
        memory.ts
        planning.schema.ts
        planning.ts
        rag.ts
        travel-advisory.ts
        weather.ts
        web-crawl.ts
        web-search-batch.ts
        web-search-normalize.ts
        web-search.ts
      index.ts
    constants.ts
  app/
    (auth)/
      login/
        page.tsx
      register/
        page.tsx
      reset-password/
        page.tsx
      error.tsx
      layout.tsx
    (marketing)/
      ai-demo/
        page.tsx
      layout.tsx
      page.tsx
    api/
      _helpers/
        attachments.ts
      accommodations/
        personalize/
          route.ts
        popular-destinations/
          route.ts
        search/
          route.ts
      activities/
        [id]/
          route.ts
        search/
          route.ts
      agents/
        accommodations/
          route.ts
        budget/
          route.ts
        destinations/
          route.ts
        flights/
          route.ts
        itineraries/
          route.ts
        memory/
          route.ts
        router/
          route.ts
      ai/
        stream/
          route.ts
      attachments/
        files/
          route.ts
      auth/
        login/
          route.ts
        mfa/
          backup/
            regenerate/
              route.ts
            verify/
              route.ts
          challenge/
            route.ts
          factors/
            list/
              route.ts
          sessions/
            revoke/
              route.ts
          setup/
            route.ts
          verify/
            route.ts
      calendar/
        events/
          route.ts
        freebusy/
          route.ts
        ics/
          export/
            route.ts
          import/
            route.ts
        status/
          route.ts
      chat/
        attachments/
          route.ts
        sessions/
          [id]/
            messages/
              route.ts
            route.ts
          _handlers.ts
          route.ts
        stream/
          _handler.ts
          route.ts
      config/
        agents/
          [agentType]/
            rollback/
              [versionId]/
                route.ts
            versions/
              route.ts
            route.ts
      dashboard/
        route.ts
      embeddings/
        route.ts
      flights/
        popular-destinations/
          route.ts
        popular-routes/
          route.ts
        search/
          route.ts
      geocode/
        route.ts
      hooks/
        cache/
          route.ts
        files/
          route.ts
        trips/
          route.ts
      itineraries/
        _handler.ts
        route.ts
      jobs/
        memory-sync/
          route.ts
        notify-collaborators/
          route.ts
      keys/
        [service]/
          route.ts
        validate/
          route.ts
        _error-mapping.ts
        _handlers.ts
        _rate-limiter.ts
        _telemetry.ts
        route.ts
      memory/
        context/
          [userId]/
            route.ts
        conversations/
          route.ts
        insights/
          [userId]/
            route.ts
        preferences/
          [userId]/
            route.ts
        search/
          route.ts
        stats/
          [userId]/
            route.ts
        user/
          [userId]/
            route.ts
      places/
        details/
          [id]/
            route.ts
        nearby/
          route.ts
        photo/
          route.ts
        search/
          route.ts
      rag/
        index/
          _handler.ts
          route.ts
        search/
          _handler.ts
          route.ts
      route-matrix/
        route.ts
      routes/
        route.ts
      security/
        events/
          route.ts
        metrics/
          route.ts
        sessions/
          [sessionId]/
            route.ts
          _handlers.ts
          route.ts
      telemetry/
        activities/
          route.ts
        ai-demo/
          route.ts
      timezone/
        route.ts
      trips/
        [id]/
          route.ts
        suggestions/
          route.ts
        _handler.ts
        route.ts
      user-settings/
        route.ts
    auth/
      callback/
        route.ts
      confirm/
        route.ts
      delete/
        route.ts
      email/
        resend/
          route.ts
        verify/
          route.ts
      logout/
        route.ts
      me/
        route.ts
      password/
        change/
          route.ts
        reset/
          route.ts
        reset-request/
          route.ts
      register/
        route.ts
    chat/
      chat-client.tsx
      layout.tsx
      page.tsx
    dashboard/
      admin/
        configuration/
          page.tsx
      agent-status/
        page.tsx
      calendar/
        page.tsx
      demo/
        realtime/
          page.tsx
      profile/
        page.tsx
      search/
        activities/
          actions.ts
          activities-search-client.tsx
          loading.tsx
          page.tsx
        destinations/
          actions.ts
          destination-comparison-modal.tsx
          destinations-search-client.tsx
          loading.tsx
          page.tsx
        flights/
          results/
            page.tsx
          actions.ts
          flights-search-client.tsx
          loading.tsx
          page.tsx
        hotels/
          actions.ts
          hotel-mapping.ts
          hotels-search-client.tsx
          loading.tsx
          page.tsx
        unified/
          actions.ts
          loading.tsx
          page.tsx
          unified-search-client.tsx
        page.tsx
        search-hub-client.tsx
      security/
        page.tsx
      settings/
        api-keys/
          actions.ts
          page.tsx
        page.tsx
      trips/
        [id]/
          collaborate/
            page.tsx
          page.tsx
        loading.tsx
        page.tsx
      error.tsx
      layout.tsx
      loading.tsx
      page.tsx
    error.tsx
    global-error.tsx
    layout.tsx
    loading.tsx
  components/
    admin/
      configuration-actions.ts
      configuration-manager.tsx
    ai-elements/
      budget-chart.tsx
      code-block.tsx
      conversation.tsx
      destination-card.tsx
      flight-card.tsx
      itinerary-timeline.tsx
      message.tsx
      prompt-input.tsx
      reasoning.tsx
      response.tsx
      shimmer.tsx
      sources.tsx
      stay-card.tsx
      streamdown-config.ts
      tool.tsx
    auth/
      login-form.tsx
      register-form.tsx
      reset-password-form.tsx
    calendar/
      calendar-connect-client-wrapper.tsx
      calendar-connect-client.tsx
      calendar-connection-card.tsx
      calendar-event-form.tsx
      calendar-event-list.tsx
    charts/
      chart-wrapper.tsx
    chat/
      message-item.tsx
    error/
      error-boundary.tsx
      error-fallback.tsx
    features/
      agent-monitoring/
        communication/
          agent-collaboration-hub.tsx
        dashboard/
          agent-status-dashboard-lazy.tsx
          agent-status-dashboard.tsx
      budget/
        budget-form.tsx
      dashboard/
        dashboard-metrics.tsx
        metrics-card.tsx
        metrics-chart.tsx
        quick-actions.tsx
        recent-trips.tsx
        trip-suggestions.tsx
        upcoming-flights.tsx
      profile/
        account-settings-section.tsx
        personal-info-section.tsx
        personalization-insights.tsx
        preferences-section.tsx
      realtime/
        connection-status-monitor.tsx
        optimistic-trip-updates.tsx
      search/
        cards/
          accommodation-card.tsx
          activity-card.tsx
          amenities.tsx
          destination-card.tsx
          flight-card.tsx
          hotel-card.tsx
          rating-stars.tsx
        common/
          format.ts
          number-input-field.tsx
          search-form-shell.tsx
          use-search-form.ts
        filters/
          api-payload.ts
          constants.ts
          filter-checkbox-group.tsx
          filter-panel.tsx
          filter-presets.tsx
          filter-range.tsx
          filter-toggle-options.tsx
          utils.ts
        forms/
          activity-search-form.tsx
          destination-search-form.tsx
          flight-search-form.tsx
          hotel-search-form.tsx
        modals/
          activity-comparison-modal.tsx
          trip-selection-modal.tsx
        results/
          shared/
            results-controls-bar.tsx
            results-empty-state.tsx
            results-loading-skeleton.tsx
            use-results-list.ts
          activity-results.tsx
          flight-results.tsx
          hotel-results.tsx
        search-analytics.tsx
        search-collections.tsx
      security/
        mfa-panel.tsx
        security-dashboard-client.tsx
        security-dashboard.tsx
      shared/
        connection-status.tsx
      trips/
        budget-tracker.tsx
        itinerary-builder.tsx
        trip-card.tsx
        trip-timeline.tsx
    layouts/
      auth-layout.tsx
      chat-layout.tsx
      dashboard-layout.tsx
      navbar.tsx
      search-layout.tsx
      sidebar-nav.tsx
      user-nav.tsx
    providers/
      performance-provider.tsx
      query-error-boundary.tsx
      query-provider.tsx
      realtime-auth-provider.tsx
      telemetry-provider.tsx
      theme-provider.tsx
    search/
      search-page-skeleton.tsx
    settings/
      api-keys-content.tsx
    ui/
      __mocks__/
        use-toast.ts
      accordion.tsx
      alert-dialog.tsx
      alert.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      card.tsx
      checkbox.tsx
      collapsible.tsx
      command.tsx
      current-year.tsx
      dialog.tsx
      drawer.tsx
      dropdown-menu.tsx
      form.tsx
      hover-card.tsx
      input-group.tsx
      input.tsx
      label.tsx
      loading-skeletons.tsx
      loading-spinner.tsx
      loading-states.tsx
      loading.tsx
      menubar.tsx
      popover.tsx
      progress.tsx
      query-states.tsx
      radio-group.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      skeleton.tsx
      slider.tsx
      switch.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      theme-toggle.tsx
      toaster.tsx
      toggle-group.tsx
      toggle.tsx
      tooltip.tsx
      travel-skeletons.tsx
      use-toast.ts
    Map.tsx
    PlacesAutocomplete.tsx
  config/
    bot-protection.ts
  domain/
    accommodations/
      providers/
        amadeus-adapter.ts
        types.ts
      booking-orchestrator.ts
      constants.ts
      container.ts
      errors.ts
      service.ts
    activities/
      container.ts
      errors.ts
      service.ts
      types.ts
    amadeus/
      amadeus.d.ts
      chain-codes.ts
      client.ts
      mappers.ts
      schemas.ts
    flights/
      providers/
        duffel.ts
      mappers.ts
      service.ts
    schemas/
      shared/
        media.ts
        money.ts
        person.ts
        time.ts
      ui/
        error-boundary.ts
        loading.ts
        theme-provider.ts
      accommodations.ts
      agent-status.ts
      agents.ts
      api.ts
      attachments.ts
      auth.ts
      budget.ts
      calendar.ts
      chat.ts
      configuration.ts
      contact.ts
      currency.ts
      dashboard.ts
      deals.ts
      embeddings.ts
      env.ts
      errors.ts
      flights.ts
      memory.ts
      mfa.ts
      profile.ts
      providers.ts
      rag.ts
      realtime.ts
      registry.ts
      search.ts
      security.ts
      stores.ts
      supabase.ts
      telemetry.ts
      temporal.ts
      tokens.ts
      trips.ts
      validation.ts
      webhooks.ts
  hooks/
    chat/
      use-agent-status-websocket.ts
      use-optimistic-chat.ts
      use-websocket-chat.ts
    search/
      utils/
        response-mappers.ts
      use-destination-search.ts
      use-search-orchestration.ts
      use-search.ts
    supabase/
      use-realtime-channel.ts
      use-supabase-chat.ts
      use-supabase-realtime.ts
    use-authenticated-api.ts
    use-budget.ts
    use-currency.ts
    use-dashboard-metrics.ts
    use-deals.ts
    use-error-handler.ts
    use-loading.ts
    use-memory.ts
    use-performance.ts
    use-trips.ts
    use-zod-form.ts
  lib/
    activities/
      booking.ts
    agents/
      config-resolver.ts
      error-recovery.ts
    api/
      guards/
        multipart.ts
      api-client.ts
      error-types.ts
      factory.ts
      route-helpers.ts
    auth/
      actions.ts
      confirm-next.ts
      redirect-server.ts
      redirect.ts
      server.ts
      supabase-errors.ts
    cache/
      hash.ts
      keys.ts
      next-cache.ts
      registry.ts
      tags.ts
      upstash.ts
    calendar/
      auth.ts
      calendar-integration.ts
      google.ts
      ics.ts
      trip-export.ts
    circuit-breaker/
      index.ts
    client/
      clipboard.ts
      session.ts
    config/
      helpers.ts
    constants/
      images.ts
    dates/
      recurring-rules.ts
      unified-date-utils.ts
    env/
      client.ts
      index.ts
      runtime-env.ts
      server.ts
    errors/
      get-unknown-error-message.ts
    flights/
      popular-routes-cache.ts
    google/
      caching.ts
      client.ts
      places-activities.ts
      places-enrichment.ts
      places-format.ts
      places-geocoding.ts
      places-utils.ts
      polyline.ts
    http/
      body.ts
      ip.ts
      retry.ts
    idempotency/
      redis.ts
    memory/
      mem0-adapter.ts
      orchestrator.ts
      supabase-adapter.ts
      turn-utils.ts
      upstash-adapter.ts
    metrics/
      aggregate.ts
      api-metrics.ts
    notifications/
      collaborators.ts
    payments/
      booking-payment.ts
      stripe-client.ts
    qstash/
      client.ts
      config.ts
      dlq.ts
      memory-sync.ts
      receiver.ts
    query/
      config.ts
    rag/
      indexer.ts
      pgvector.ts
      reranker.ts
      retriever.ts
    ratelimit/
      config.ts
      headers.ts
      identifier.ts
      routes.ts
    realtime/
      backoff.ts
      status.ts
    repositories/
      trips-repo.ts
    schema/
      json-schema.ts
    security/
      api-key-validation.ts
      botid.ts
      internal-key.ts
      mfa-client.ts
      mfa-error.ts
      mfa.ts
      prompt-sanitizer.ts
      random.ts
      service.ts
      sessions.ts
      webhook.ts
    supabase/
      admin.ts
      client.ts
      database.types.ts
      factory.ts
      guards.ts
      index.ts
      rpc.ts
      server.ts
      typed-helpers.ts
    telemetry/
      agents.ts
      alerts.ts
      client-errors.ts
      client-sanitize.ts
      client.ts
      constants.ts
      degraded-mode.ts
      identifiers.ts
      logger.ts
      redis.ts
      route-key.ts
      span.ts
      store-logger.ts
      tracer.ts
    tokens/
      budget.ts
      limits.ts
    trips/
      mappers.ts
      parse-trip-date.ts
    ui/
      parse-schema-card.ts
    url/
      client-origin.ts
      safe-href.ts
      server-origin.ts
    utils/
      amenity-categorization.ts
      build-phase.ts
      type-guards.ts
    variants/
      status.ts
    webhooks/
      errors.ts
      handler.ts
      payload.ts
      rate-limit.ts
    collection-utils.ts
    error-service.ts
    geo.ts
    query-keys.ts
    redis.ts
    routes.ts
    utils.ts
  mocks/
    unified-search-mocks.ts
  prompts/
    agents.ts
  stores/
    auth/
      auth-core.ts
      auth-session.ts
      auth-validation.ts
      reset-auth.ts
    chat/
      chat-messages.ts
      chat-realtime.ts
    middleware/
      computed.ts
    search-filters/
      filter-configs.ts
    search-history/
      analytics.ts
      collections.ts
      index.ts
      quick.ts
      recent.ts
      saved.ts
      selectors.ts
      suggestions.ts
      types.ts
    search-params/
      handlers/
        accommodation-handler.ts
        activity-handler.ts
        destination-handler.ts
        flight-handler.ts
        index.ts
      registry.ts
      types.ts
    selectors/
      search-selectors.ts
    ui/
      command-palette.ts
      features.ts
      index.ts
      loading.ts
      modal.ts
      navigation.ts
      notifications.ts
      selectors.ts
      sidebar.ts
      theme.ts
      types.ts
    agent-status-store.ts
    budget-store.ts
    comparison-store.ts
    currency-store.ts
    deals-store.ts
    helpers.ts
    realtime-connection-store.ts
    search-filters-store.ts
    search-params-store.ts
    search-results-store.ts
    trip-itinerary-store.ts
  test/
    ai-sdk/
      mock-model.ts
      stream-utils.ts
    factories/
      api-response-factory.ts
      auth-user-factory.ts
      calendar-factory.ts
      chat-factory.ts
      filter-factory.ts
      form-data-factory.ts
      realtime-factory.ts
      reset.ts
      search-factory.ts
      stores.ts
      trip-factory.ts
      user-factory.ts
    fixtures/
      deals.ts
      flights.ts
    helpers/
      api-route.ts
      env.ts
      make-request.ts
      mock.ts
      query-client.ts
      query.tsx
      route.ts
      schema.ts
      store.ts
      trip-store.ts
      unsafe-cast.ts
    mocks/
      botid.ts
      cache.ts
      media-query.ts
      observers.ts
      rehype-harden.ts
      server-only.ts
      storage.ts
      supabase.ts
      toast.ts
    msw/
      handlers/
        amadeus.ts
        api-routes.ts
        auth-routes.ts
        auth.ts
        chat.ts
        error-reporting.ts
        external-apis.ts
        google-places.ts
        providers.ts
        stripe.ts
        supabase.ts
        telemetry.ts
        upstash.ts
        utils.ts
      server.ts
    upstash/
      constants.ts
      emulator.ts
      index.ts
      qstash-mock.ts
      ratelimit-mock.ts
      redis-mock.ts
      setup.ts
    utils/
      with-fake-timers.ts
    setup-jsdom.ts
    setup-node.ts
    setup.ts
    test-utils.tsx
  instrumentation.ts
  proxy.ts
AGENTS.md
next.config.ts
package.json
playwright.config.ts
tsconfig.json
vitest.config.ts
```

# Files

## File: src/ai/agents/accommodation-agent.ts
````typescript
/**
 * @fileoverview Accommodation search agent for travel planning.
 *
 * Reusable ToolLoopAgent that autonomously searches for properties, retrieves
 * details, checks availability, and handles bookings via multi-step tool calling.
 * Uses AI SDK v6 structured output and phased tool selection.
 */
⋮----
import {
  bookAccommodation,
  checkAvailability,
  getAccommodationDetails,
  searchAccommodations,
} from "@ai/tools";
import type { AccommodationSearchRequest } from "@schemas/agents";
import type { AgentConfig } from "@schemas/configuration";
import type { ToolSet } from "ai";
import type { ChatMessage } from "@/lib/tokens/budget";
import { clampMaxTokens } from "@/lib/tokens/budget";
import { buildAccommodationPrompt } from "@/prompts/agents";
⋮----
import { createTripSageAgent } from "./agent-factory";
import type { AgentDependencies, TripSageAgentResult } from "./types";
import { extractAgentParameters } from "./types";
⋮----
/** Schema version for accommodation stay responses. */
⋮----
/**
 * Tools available to the accommodation search agent with built-in
 * guardrails for caching, rate limiting, and telemetry.
 */
⋮----
/**
 * Creates an accommodation search agent for autonomous property search, availability checks, and bookings.
 *
 * Uses phased tool selection: search → details → availability/booking.
 * Returns structured AccommodationSearchResult via Output.object().
 *
 * @param deps - Runtime dependencies (model, identifiers).
 * @param config - Agent configuration from database.
 * @param input - Accommodation search request (destination, dates, guests).
 * @returns Configured ToolLoopAgent for accommodation search.
 */
export function createAccommodationAgent(
  deps: AgentDependencies,
  config: AgentConfig,
  input: AccommodationSearchRequest
): TripSageAgentResult<typeof ACCOMMODATION_TOOLS>
⋮----
// Token budgeting: clamp max output tokens based on prompt length
⋮----
// Note: For structured output, pass Output.object({ schema: accommodationSearchResultSchema })
// when calling agent.generate() or agent.stream()
// Phased tool selection for accommodation workflow
⋮----
// Phase 1 (steps 0-2): Search for accommodations
⋮----
// Phase 2 (steps 3-5): Get details for promising options
⋮----
// Phase 3 (steps 6+): Check availability and allow booking
⋮----
/** Exported type for the accommodation agent's tool set. */
export type AccommodationAgentTools = typeof ACCOMMODATION_TOOLS;
````

## File: src/ai/agents/budget-agent.ts
````typescript
/**
 * @fileoverview Budget planning agent using AI SDK v6 ToolLoopAgent.
 *
 * Autonomously researches destinations, gathers pricing data, and generates
 * structured budget allocations through multi-step tool calling with phased
 * tool selection (research → pricing → allocation).
 */
⋮----
import {
  combineSearchResults,
  getTravelAdvisory,
  lookupPoiContext,
  webSearchBatch,
} from "@ai/tools";
import type { BudgetPlanRequest } from "@schemas/agents";
import type { AgentConfig } from "@schemas/configuration";
import type { ToolSet } from "ai";
import type { ChatMessage } from "@/lib/tokens/budget";
import { clampMaxTokens } from "@/lib/tokens/budget";
import { buildBudgetPrompt } from "@/prompts/agents";
⋮----
import { createTripSageAgent } from "./agent-factory";
import type { AgentDependencies, TripSageAgentResult } from "./types";
import { extractAgentParameters } from "./types";
⋮----
/**
 * Tools available to the budget planning agent with built-in
 * guardrails for caching, rate limiting, and telemetry.
 */
⋮----
/**
 * Creates a budget planning agent using AI SDK v6 ToolLoopAgent.
 *
 * Autonomously researches destinations, gathers pricing data, and generates
 * structured budget allocations through phased tool calling (research → pricing → allocation).
 * Uses Output.object() for structured results and prepareStep for dynamic tool selection.
 *
 * @param deps - Runtime dependencies including model and identifiers.
 * @param config - Agent configuration from database.
 * @param input - Validated budget plan request.
 * @returns Configured ToolLoopAgent for budget planning.
 *
 * @example
 * ```typescript
 * const { agent } = createBudgetAgent(deps, config, {
 *   destination: "Tokyo, Japan",
 *   durationDays: 7,
 *   travelStyle: "mid-range",
 * });
 * return agent.stream({ prompt: "Plan my budget" });
 * ```
 */
export function createBudgetAgent(
  deps: AgentDependencies,
  config: AgentConfig,
  input: BudgetPlanRequest
): TripSageAgentResult<typeof BUDGET_TOOLS>
⋮----
// Token budgeting: clamp max output tokens based on prompt length
⋮----
// Note: For structured output, pass Output.object({ schema: budgetPlanResultSchema })
// when calling agent.generate() or agent.stream()
// Phased tool selection for budget workflow
⋮----
// Phase 1 (steps 0-3): Research destination costs and advisories
⋮----
// Phase 2 (steps 4+): Combine and finalize budget allocation
⋮----
/** Exported type for the budget agent's tool set. */
export type BudgetAgentTools = typeof BUDGET_TOOLS;
````

## File: src/ai/agents/destination-agent.ts
````typescript
/**
 * @fileoverview Destination research agent for travel planning.
 *
 * Reusable ToolLoopAgent that gathers destination information including attractions,
 * weather, safety advisories, and local insights via multi-step tool calling.
 * Uses phased tool selection for comprehensive research workflows.
 */
⋮----
import {
  crawlSite,
  getCurrentWeather,
  getTravelAdvisory,
  lookupPoiContext,
  webSearch,
  webSearchBatch,
} from "@ai/tools";
import type { DestinationResearchRequest } from "@schemas/agents";
import type { AgentConfig } from "@schemas/configuration";
import type { ToolSet } from "ai";
import type { ChatMessage } from "@/lib/tokens/budget";
import { clampMaxTokens } from "@/lib/tokens/budget";
import { buildDestinationPrompt } from "@/prompts/agents";
⋮----
import { createTripSageAgent } from "./agent-factory";
import type { AgentDependencies, TripSageAgentResult } from "./types";
import { extractAgentParameters } from "./types";
⋮----
/**
 * Tools available to the destination research agent with built-in
 * guardrails for caching, rate limiting, and telemetry.
 */
⋮----
/**
 * Creates a destination research agent for travel research.
 *
 * Returns a reusable ToolLoopAgent with phased tool selection:
 * - Phase 1: Initial search and context gathering
 * - Phase 2: Deep research via web crawling
 * - Phase 3: Weather and advisory checks
 *
 * @param deps - Runtime dependencies including model and identifiers.
 * @param config - Agent configuration from database.
 * @param input - Validated destination research request.
 * @returns Configured ToolLoopAgent for destination research.
 *
 * @example
 * ```typescript
 * const { agent } = createDestinationAgent(deps, config, {
 *   destination: "Kyoto, Japan",
 *   travelDates: "March 2025",
 *   specificInterests: ["temples", "cherry blossoms"],
 * });
 * const stream = agent.stream({ prompt: "Research this destination" });
 * ```
 */
export function createDestinationAgent(
  deps: AgentDependencies,
  config: AgentConfig,
  input: DestinationResearchRequest
): TripSageAgentResult<typeof DESTINATION_TOOLS>
⋮----
// Token budgeting: clamp max output tokens based on prompt length
⋮----
// Destination research may need more steps for gathering
⋮----
// Note: For structured output, pass Output.object({ schema: destinationResearchResultSchema })
// when calling agent.generate() or agent.stream()
// Phased tool selection for destination research workflow
⋮----
// Phase 1: Initial search and POI context
⋮----
// Phase 2: Deep research via crawling
⋮----
// Phase 3: Weather and safety information
⋮----
/** Exported type for the destination agent's tool set. */
export type DestinationAgentTools = typeof DESTINATION_TOOLS;
````

## File: src/ai/agents/flight-agent.ts
````typescript
/**
 * @fileoverview Flight search agent for travel planning.
 *
 * Reusable ToolLoopAgent that searches flights, resolves airport codes,
 * and summarizes options via multi-step tool calling with phased tool selection.
 */
⋮----
import { distanceMatrix, geocode, lookupPoiContext, searchFlights } from "@ai/tools";
import type { AgentConfig } from "@schemas/configuration";
import type { FlightSearchRequest } from "@schemas/flights";
import type { ToolSet } from "ai";
import type { ChatMessage } from "@/lib/tokens/budget";
import { clampMaxTokens } from "@/lib/tokens/budget";
import { buildFlightPrompt } from "@/prompts/agents";
⋮----
import { createTripSageAgent } from "./agent-factory";
import type { AgentDependencies, TripSageAgentResult } from "./types";
import { extractAgentParameters } from "./types";
⋮----
/**
 * Tools available to the flight search agent with built-in guardrails
 * for caching, rate limiting, and telemetry.
 */
⋮----
/**
 * Creates a flight search agent with phased tool selection.
 *
 * Phases:
 * - Phase 1: Resolve locations via geocoding and POI lookup
 * - Phase 2: Search flights and compute distances
 *
 * @param deps - Runtime dependencies including model and identifiers.
 * @param config - Agent configuration from database.
 * @param input - Validated flight search request.
 * @param contextMessages - Optional context messages to include.
 * @returns Configured ToolLoopAgent for flight search.
 *
 * @example
 * ```typescript
 * const { agent } = createFlightAgent(deps, config, {
 *   origin: "New York",
 *   destination: "Tokyo",
 *   departureDate: "2025-03-15",
 *   passengers: 2,
 *   cabinClass: "economy",
 *   currency: "USD",
 * });
 * const stream = agent.stream({ prompt: "Find flights" });
 * ```
 */
export function createFlightAgent(
  deps: AgentDependencies,
  config: AgentConfig,
  input: FlightSearchRequest,
  contextMessages: ChatMessage[] = []
): TripSageAgentResult<typeof FLIGHT_TOOLS>
⋮----
// Note: For structured output, pass Output.object({ schema: flightSearchResultSchema })
// when calling agent.generate() or agent.stream()
// Phased tool selection for flight search workflow
⋮----
// Phase 1 (steps 0-2): Resolve locations
⋮----
// Phase 2 (steps 3+): Search flights
⋮----
/** Exported type for the flight agent's tool set. */
export type FlightAgentTools = typeof FLIGHT_TOOLS;
````

## File: src/ai/agents/itinerary-agent.ts
````typescript
/**
 * @fileoverview Itinerary planning agent for travel plans.
 *
 * Reusable ToolLoopAgent that researches destinations, gathers POI information,
 * and creates day-by-day travel plans via multi-step tool calling with phased
 * tool selection for research, planning, and persistence.
 */
⋮----
import {
  createTravelPlan,
  lookupPoiContext,
  saveTravelPlan,
  webSearch,
  webSearchBatch,
} from "@ai/tools";
import { wrapToolsWithUserId } from "@ai/tools/server/injection";
import type { ItineraryPlanRequest } from "@schemas/agents";
import type { AgentConfig } from "@schemas/configuration";
import type { ToolSet } from "ai";
import type { ChatMessage } from "@/lib/tokens/budget";
import { clampMaxTokens } from "@/lib/tokens/budget";
import { buildItineraryPrompt } from "@/prompts/agents";
⋮----
import { createTripSageAgent } from "./agent-factory";
import type { AgentDependencies, TripSageAgentResult } from "./types";
import { extractAgentParameters } from "./types";
⋮----
/**
 * Base tools available to the itinerary planning agent.
 *
 * These tools are imported from @ai/tools where they are already
 * created with createAiTool and have built-in guardrails for caching,
 * rate limiting, and telemetry.
 */
⋮----
/**
 * Creates an itinerary planning agent with phased tool selection.
 *
 * Phases:
 * - Phase 1: Research destination via web search and POI lookup
 * - Phase 2: Create the travel plan structure
 * - Phase 3: Save and finalize the plan
 *
 * @param deps - Runtime dependencies including model and identifiers.
 * @param config - Agent configuration from database.
 * @param input - Validated itinerary plan request.
 * @returns Configured ToolLoopAgent for itinerary planning.
 *
 * @example
 * ```typescript
 * const { agent } = createItineraryAgent(deps, config, {
 *   destination: "Rome, Italy",
 *   durationDays: 5,
 *   interests: ["history", "food", "art"],
 * });
 * const stream = agent.stream({ prompt: "Plan my trip" });
 * ```
 */
export function createItineraryAgent(
  deps: AgentDependencies,
  config: AgentConfig,
  input: ItineraryPlanRequest
): TripSageAgentResult<typeof BASE_ITINERARY_TOOLS>
⋮----
// Token budgeting: clamp max output tokens based on prompt length
⋮----
// Itinerary planning may need more steps for comprehensive plans
⋮----
// Define phased tool sets with type safety
type ToolName = keyof typeof BASE_ITINERARY_TOOLS;
⋮----
// Compute phase boundaries from maxSteps (40% research, 33% planning, 27% save)
⋮----
// Wrap tools that require userId for user-scoped operations
// createTravelPlan and saveTravelPlan require userId in their input schema
⋮----
// Note: For structured output, pass Output.object({ schema: itineraryPlanResultSchema })
// when calling agent.generate() or agent.stream()
// Phased tool selection for itinerary workflow
⋮----
// Phase 1: Research destination
⋮----
// Phase 2: Create the plan
⋮----
// Phase 3: Save and finalize
⋮----
/** Exported type for the itinerary agent's tool set. */
export type ItineraryAgentTools = typeof BASE_ITINERARY_TOOLS;
````

## File: src/ai/agents/router-agent.ts
````typescript
/**
 * @fileoverview Router agent for classifying user messages into workflows.
 *
 * Uses AI SDK v6 generateText with Output.object() to classify user messages
 * into agent workflows with confidence scores and reasoning. Enhanced with:
 * - Telemetry via experimental_telemetry
 * - Output.object() for structured schema validation (v6 unified API)
 *
 * Note: This agent uses generateText with structured output directly, not
 * ToolLoopAgent, because message classification is a single-shot structured
 * output operation - not an agentic multi-step workflow.
 */
⋮----
import type { RouterClassification } from "@schemas/agents";
import { routerClassificationSchema } from "@schemas/agents";
import type { LanguageModel } from "ai";
import { generateText, Output } from "ai";
import { sanitizeWithInjectionDetection } from "@/lib/security/prompt-sanitizer";
import { buildRouterPrompt } from "@/prompts/agents";
⋮----
/**
 * Router agent dependencies.
 */
export interface RouterAgentDeps {
  /** Language model for classification. */
  model: LanguageModel;
  /** Optional identifier for internal diagnostics (NOT sent to AI provider telemetry). */
  identifier?: string;
  /** Optional model ID for telemetry. */
  modelId?: string;
}
⋮----
/** Language model for classification. */
⋮----
/** Optional identifier for internal diagnostics (NOT sent to AI provider telemetry). */
⋮----
/** Optional model ID for telemetry. */
⋮----
export class InvalidPatternsError extends Error
⋮----
constructor(
    message = "User message contains only invalid patterns and cannot be processed"
)
⋮----
/**
 * Classify a user message into an agent workflow.
 *
 * Uses AI SDK v6 generateText with Output.object() for structured output.
 * This is the v6 unified API that replaces deprecated generateObject().
 *
 * @param deps Language model and optional telemetry identifiers.
 * @param userMessage User message to classify.
 * @returns Promise resolving to router classification result.
 * @throws Error if userMessage is invalid or classification fails.
 */
export async function classifyUserMessage(
  deps: RouterAgentDeps,
  userMessage: string
): Promise<RouterClassification>
⋮----
// Validate input
⋮----
// Sanitize message to prevent prompt injection attacks
⋮----
// biome-ignore lint/style/useNamingConvention: AI SDK API uses snake_case
⋮----
// Output.object() is the v6 unified API for structured output
⋮----
// Low temperature for consistent classification
````

## File: src/ai/agents/types.ts
````typescript
/**
 * @fileoverview Type definitions for TripSage AI agents using ToolLoopAgent.
 *
 * Defines configuration, dependencies, and result types for agent creation
 * and execution.
 */
⋮----
import type { AgentWorkflowKind } from "@schemas/agents";
import type { AgentConfig } from "@schemas/configuration";
import type {
  FlexibleSchema,
  GenerateTextOnStepFinishCallback,
  InferAgentUIMessage,
  LanguageModel,
  ModelMessage,
  Output,
  PrepareStepFunction,
  StopCondition,
  SystemModelMessage,
  ToolLoopAgent,
  ToolSet,
} from "ai";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
import type { ChatMessage } from "@/lib/tokens/budget";
⋮----
// Re-export AI SDK types for downstream consumers
⋮----
export type StructuredOutput<OutputType> = ReturnType<typeof Output.object<OutputType>>;
⋮----
/** Dependencies required for agent creation and execution. */
export interface AgentDependencies {
  /** Resolved language model for the agent. */
  model: LanguageModel;

  /** Optional dedicated model for structured repair tasks. */
  repairModel?: LanguageModel;

  /** Model identifier for logging and token counting. */
  modelId: string;

  /** Optional identifier for the repair model. */
  repairModelId?: string;

  /** Stable identifier for rate limiting (user ID or hashed IP). */
  identifier: string;

  /** Optional user ID for user-scoped tool operations. */
  userId?: string;

  /** Optional session ID for memory persistence. */
  sessionId?: string;

  /** Optional Supabase client for database operations. */
  supabase?: TypedServerSupabase;

  /** Optional abort signal for request cancellation. */
  abortSignal?: AbortSignal;
}
⋮----
/** Resolved language model for the agent. */
⋮----
/** Optional dedicated model for structured repair tasks. */
⋮----
/** Model identifier for logging and token counting. */
⋮----
/** Optional identifier for the repair model. */
⋮----
/** Stable identifier for rate limiting (user ID or hashed IP). */
⋮----
/** Optional user ID for user-scoped tool operations. */
⋮----
/** Optional session ID for memory persistence. */
⋮----
/** Optional Supabase client for database operations. */
⋮----
/** Optional abort signal for request cancellation. */
⋮----
/**
 * Prepare call function signature. Called before agent execution to modify settings.
 *
 * @template OptionsT - Call options type from callOptionsSchema.
 * @template ToolsT - Tool set type for the agent.
 */
export type PrepareCallFunction<
  OptionsT = unknown,
  ToolsT extends ToolSet = ToolSet,
> = (context: {
  options: OptionsT;
  instructions: string | SystemModelMessage;
  tools: ToolsT;
  model: LanguageModel;
}) => Promise<Partial<PrepareCallResult<ToolsT>>> | Partial<PrepareCallResult<ToolsT>>;
⋮----
/** Result type for prepareCall function. */
export interface PrepareCallResult<ToolsT extends ToolSet = ToolSet> {
  /** Modified system instructions. */
  instructions?: string | SystemModelMessage;
  /** Modified tool set. */
  tools?: ToolsT;
  /** Modified model. */
  model?: LanguageModel;
  /** Active tools subset. */
  activeTools?: Array<keyof ToolsT & string>;
  /** Tool choice override. */
  toolChoice?: "auto" | "none" | "required" | { type: "tool"; toolName: string };
}
⋮----
/** Modified system instructions. */
⋮----
/** Modified tool set. */
⋮----
/** Modified model. */
⋮----
/** Active tools subset. */
⋮----
/** Tool choice override. */
⋮----
/**
 * Configuration for creating a TripSage agent.
 *
 * Combines runtime dependencies with agent-specific configuration
 * for ToolLoopAgent instantiation.
 */
export interface TripSageAgentConfig<
  ToolsType extends ToolSet = ToolSet,
  CallOptionsType = never,
  OutputType = unknown,
> {
  /** Unique agent type identifier. */
  agentType: AgentWorkflowKind;

  /** Human-readable agent name for logging. */
  name: string;

  /** System instructions for the agent. */
  instructions: string | SystemModelMessage;

  /** Tools available to the agent. */
  tools: ToolsType;

  /**
   * Default conversation messages to send with the agent.
   * Must include the user prompt instructing the model to return
   * the correct schemaVersion payload.
   */
  defaultMessages: ChatMessage[];

  /** Maximum tool execution steps (used with stepCountIs). */
  maxSteps?: number;

  /** Maximum output tokens (after clamping). */
  maxOutputTokens?: number;

  /** Temperature for generation (0-1). */
  temperature?: number;

  /** Top-p nucleus sampling parameter. */
  topP?: number;

  /**
   * Schema for type-safe call options.
   * When provided, options are required when calling generate() or stream().
   */
  callOptionsSchema?: FlexibleSchema<CallOptionsType>;

  /**
   * Prepare call function for dynamic configuration.
   * Called before agent execution to modify settings.
   */
  prepareCall?: PrepareCallFunction<CallOptionsType, ToolsType>;

  /**
   * Prepare step function for per-step configuration.
   * Called before each step to modify settings.
   */
  prepareStep?: PrepareStepFunction<ToolsType>;

  /** Callback invoked after each agent step completes. */
  onStepFinish?: GenerateTextOnStepFinishCallback<ToolsType>;

  /**
   * Structured output specification.
   *
   * Stored in config but not passed to ToolLoopAgent constructor.
   * Pass output when calling agent.generate({ output }) or agent.stream({ output }).
   */
  output?: StructuredOutput<OutputType>;

  /**
   * Active tools subset for this agent.
   * Limits which tools are available to the model.
   */
  activeTools?: Array<keyof ToolsType & string>;

  /**
   * Custom stop conditions beyond stepCountIs().
   * Can be a single condition or array of conditions.
   */
  stopWhen?: StopCondition<ToolsType> | Array<StopCondition<ToolsType>>;
}
⋮----
/** Unique agent type identifier. */
⋮----
/** Human-readable agent name for logging. */
⋮----
/** System instructions for the agent. */
⋮----
/** Tools available to the agent. */
⋮----
/**
   * Default conversation messages to send with the agent.
   * Must include the user prompt instructing the model to return
   * the correct schemaVersion payload.
   */
⋮----
/** Maximum tool execution steps (used with stepCountIs). */
⋮----
/** Maximum output tokens (after clamping). */
⋮----
/** Temperature for generation (0-1). */
⋮----
/** Top-p nucleus sampling parameter. */
⋮----
/**
   * Schema for type-safe call options.
   * When provided, options are required when calling generate() or stream().
   */
⋮----
/**
   * Prepare call function for dynamic configuration.
   * Called before agent execution to modify settings.
   */
⋮----
/**
   * Prepare step function for per-step configuration.
   * Called before each step to modify settings.
   */
⋮----
/** Callback invoked after each agent step completes. */
⋮----
/**
   * Structured output specification.
   *
   * Stored in config but not passed to ToolLoopAgent constructor.
   * Pass output when calling agent.generate({ output }) or agent.stream({ output }).
   */
⋮----
/**
   * Active tools subset for this agent.
   * Limits which tools are available to the model.
   */
⋮----
/**
   * Custom stop conditions beyond stepCountIs().
   * Can be a single condition or array of conditions.
   */
⋮----
/** Result type for agent creation. Contains the configured ToolLoopAgent instance. */
export interface TripSageAgentResult<
  TagentTools extends ToolSet = ToolSet,
  CallOptionsType = never,
  OutputType = unknown,
> {
  /** The configured ToolLoopAgent instance. */
  agent: ToolLoopAgent<CallOptionsType, TagentTools, StructuredOutput<OutputType>>;

  /** Agent type identifier for routing and logging. */
  agentType: AgentWorkflowKind;

  /** Resolved model identifier. */
  modelId: string;

  /** Default schema-enforcing messages to stream with the agent. */
  defaultMessages: ChatMessage[];

  /**
   * Optional structured output spec associated with this agent.
   *
   * ToolLoopAgent does not accept `output` at construction time; callers should pass
   * this value explicitly to `agent.generate({ output })` / `agent.stream({ output })`.
   */
  output?: StructuredOutput<OutputType>;
}
⋮----
/** The configured ToolLoopAgent instance. */
⋮----
/** Agent type identifier for routing and logging. */
⋮----
/** Resolved model identifier. */
⋮----
/** Default schema-enforcing messages to stream with the agent. */
⋮----
/**
   * Optional structured output spec associated with this agent.
   *
   * ToolLoopAgent does not accept `output` at construction time; callers should pass
   * this value explicitly to `agent.generate({ output })` / `agent.stream({ output })`.
   */
⋮----
/** Type helper for inferring UI message types from a TripSage agent. */
// biome-ignore lint/style/useNamingConvention: TypeScript generic convention
export type InferTripSageUIMessage<TAgent extends ToolLoopAgent> =
  InferAgentUIMessage<TAgent>;
⋮----
/** Factory function signature for creating workflow-specific agents. */
// biome-ignore lint/style/useNamingConvention: TypeScript generic convention
export type AgentFactory<TInput, TagentTools extends ToolSet = ToolSet> = (
  deps: AgentDependencies,
  config: AgentConfig,
  input: TInput
) => TripSageAgentResult<TagentTools>;
⋮----
/** Metadata for agent execution tracking. */
export interface AgentExecutionMeta {
  /** Unique request identifier. */
  requestId: string;

  /** Agent type being executed. */
  agentType: AgentWorkflowKind;

  /** Model identifier used. */
  modelId: string;

  /** Provider name (e.g., "openai", "anthropic"). */
  provider?: string;

  /** Start timestamp in milliseconds. */
  startedAt: number;

  /** Optional user identifier. */
  userId?: string;

  /** Optional session identifier. */
  sessionId?: string;
}
⋮----
/** Unique request identifier. */
⋮----
/** Agent type being executed. */
⋮----
/** Model identifier used. */
⋮----
/** Provider name (e.g., "openai", "anthropic"). */
⋮----
/** Start timestamp in milliseconds. */
⋮----
/** Optional user identifier. */
⋮----
/** Optional session identifier. */
⋮----
/**
 * Tool lifecycle hook context for AI SDK v6.
 *
 * These hooks are passed to streamText/streamObject at call time,
 * not to ToolLoopAgent creation. They enable observing tool input
 * construction during streaming.
 *
 * @example
 * ```typescript
 * const result = streamText({
 *   model: provider.model,
 *   messages,
 *   tools: myTools,
 *   onInputStart: ({ toolName, toolCallId }) => {
 *     console.log(`Tool ${toolName} input starting...`);
 *   },
 *   onInputDelta: ({ toolName, inputTextDelta }) => {
 *     console.log(`Tool ${toolName} input delta: ${inputTextDelta}`);
 *   },
 *   onInputAvailable: ({ toolName, input }) => {
 *     console.log(`Tool ${toolName} input ready:`, input);
 *   },
 * });
 * ```
 */
export interface ToolLifecycleHooks {
  /**
   * Called when tool input parsing starts.
   * Use for showing loading indicators.
   */
  onInputStart?: (context: {
    toolName: string;
    toolCallId: string;
  }) => void | Promise<void>;

  /**
   * Called as tool input is streamed incrementally.
   * Use for real-time progress indicators.
   */
  onInputDelta?: (context: {
    toolName: string;
    toolCallId: string;
    inputTextDelta: string;
  }) => void | Promise<void>;

  /**
   * Called when full tool input is available.
   * Use for logging or pre-execution validation.
   */
  onInputAvailable?: (context: {
    toolName: string;
    toolCallId: string;
    input: unknown;
  }) => void | Promise<void>;
}
⋮----
/**
   * Called when tool input parsing starts.
   * Use for showing loading indicators.
   */
⋮----
/**
   * Called as tool input is streamed incrementally.
   * Use for real-time progress indicators.
   */
⋮----
/**
   * Called when full tool input is available.
   * Use for logging or pre-execution validation.
   */
⋮----
/**
 * Creates tool lifecycle hooks with consistent interface.
 *
 * Wraps optional callbacks in a complete ToolLifecycleHooks object.
 * The agentType and requestId parameters are reserved for future
 * telemetry integration.
 *
 * @param _agentType - Agent type for telemetry context (reserved).
 * @param _requestId - Request ID for telemetry context (reserved).
 * @param hooks - Optional custom hooks to wrap.
 * @returns Complete tool lifecycle hooks object.
 *
 * @example
 * ```typescript
 * const hooks = createToolLifecycleHooks("flightSearch", requestId, {
 *   onInputAvailable: ({ toolName, input }) => {
 *     logger.info(`Tool ${toolName} ready`, { input });
 *   },
 * });
 *
 * const result = streamText({
 *   model,
 *   messages,
 *   tools,
 *   ...hooks,
 * });
 * ```
 */
export function createToolLifecycleHooks(
  _agentType: AgentWorkflowKind,
  _requestId: string,
  hooks?: Partial<ToolLifecycleHooks>
): ToolLifecycleHooks
⋮----
/** Common agent parameters extracted from AgentConfig. */
export interface AgentParameters {
  /** Maximum output tokens. */
  maxTokens: number;

  /** Temperature for generation. */
  temperature: number;

  /** Top-p nucleus sampling. */
  topP?: number;

  /** Maximum tool execution steps. */
  maxSteps: number;
}
⋮----
/** Maximum output tokens. */
⋮----
/** Temperature for generation. */
⋮----
/** Top-p nucleus sampling. */
⋮----
/** Maximum tool execution steps. */
⋮----
/**
 * Extracts typed agent parameters from AgentConfig with defaults.
 *
 * @param config - Agent configuration from database.
 * @returns Typed agent parameters with sensible defaults.
 */
export function extractAgentParameters(config: AgentConfig): AgentParameters
````

## File: src/ai/lib/tool-type-utils.ts
````typescript
/**
 * @fileoverview AI SDK v6 type utilities and patterns.
 *
 * Re-exports AI SDK v6 type helpers and provides utility types
 * for common patterns in our tool/agent system.
 */
⋮----
/**
 * Infer tool input type from a tool definition.
 *
 * @example
 * ```typescript
 * type SearchInput = InferToolInput<typeof searchTool>;
 * ```
 */
export type InferToolInput<T> = T extends {
  execute: (input: infer I, ...args: unknown[]) => unknown;
}
  ? I
  : T extends { inputSchema: infer S }
    ? S extends { _output: infer O }
      ? O
      : unknown
    : unknown;
⋮----
/**
 * Infer tool output type from a tool definition.
 *
 * @example
 * ```typescript
 * type SearchOutput = InferToolOutput<typeof searchTool>;
 * ```
 */
export type InferToolOutput<T> = T extends {
  execute: (...args: unknown[]) => infer R;
}
  ? Awaited<R>
  : unknown;
⋮----
/**
 * Type guard for non-dynamic tool calls.
 * Enables type narrowing in tool result processing.
 *
 * @example
 * ```typescript
 * if (!isStaticToolCall(toolCall)) return;
 * // Now TypeScript knows toolCall is static
 * switch (toolCall.toolName) {
 *   case 'weather': ...
 * }
 * ```
 */
export function isStaticToolCall<T extends import("ai").ToolSet>(
  toolCall: import("ai").TypedToolCall<T>
): toolCall is Extract<import("ai").TypedToolCall<T>,
````

## File: src/ai/models/registry.ts
````typescript
/**
 * @fileoverview Provider registry and model resolution for AI SDK v6.
 * Centralizes BYOK key lookup via Supabase RPC and returns a ready
 * LanguageModel for downstream routes (no client-side secrets).
 */
⋮----
import { createAnthropic } from "@ai-sdk/anthropic";
import { createOpenAI } from "@ai-sdk/openai";
import { createXai } from "@ai-sdk/xai";
import type { ModelMapper, ProviderId, ProviderResolution } from "@schemas/providers";
import { createGateway } from "ai";
import {
  getUserAllowGatewayFallback,
  getUserApiKey,
  getUserGatewayBaseUrl,
  touchUserApiKey,
} from "@/lib/supabase/rpc";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Provider preference order for BYOK key resolution.
 * Earlier providers in this array take precedence when multiple keys are available.
 */
⋮----
/**
 * Extracts the host from a URL string.
 *
 * @param url - The URL string to parse.
 * @returns The host portion of the URL, or undefined if parsing fails.
 */
function extractHost(url: string | undefined): string | undefined
⋮----
// ignore parse errors for malformed URLs
⋮----
/**
 * Maps model hints to provider-specific identifiers with sensible defaults.
 *
 * @param provider - The provider identifier.
 * @param modelHint - The model hint to map.
 * @returns The provider-specific model identifier.
 */
const DEFAULT_MODEL_MAPPER: ModelMapper = (
  provider: ProviderId,
  modelHint?: string
): string =>
⋮----
// Sensible defaults per provider
⋮----
// For OpenRouter, accept fully-qualified ids like "provider/model"
⋮----
// For others, return hint as-is; callers supply proper ids.
⋮----
/**
 * Type-asserts and validates that a resolved model is a valid LanguageModel.
 *
 * @param model - The resolved model object from a provider client.
 * @param provider - The provider identifier for error reporting.
 * @param modelId - The model identifier for error reporting.
 * @returns The validated LanguageModel instance.
 * @throws Error if the model is not a valid LanguageModel.
 */
function toLanguageModel(
  model: unknown,
  provider: ProviderId,
  modelId: string
): import("ai").LanguageModel
⋮----
/**
 * Resolve user's preferred provider and return a ready AI SDK model.
 *
 * @param userId Supabase auth user id; used to fetch BYOK keys server-side.
 * @param modelHint Optional generic model hint (e.g., "gpt-4o-mini").
 * @returns ProviderResolution including provider id, model id, and model instance.
 * @throws Error if no provider key is found for the user.
 */
export async function resolveProvider(
  userId: string,
  modelHint?: string
): Promise<ProviderResolution>
⋮----
// 0) Per-user Gateway key (if present): highest precedence
⋮----
// biome-ignore lint/style/useNamingConvention: provider option name
⋮----
// 1) Check for BYOK keys concurrently (OpenAI, OpenRouter, Anthropic, xAI)
⋮----
// Fire-and-forget: update last used timestamp (ignore errors)
⋮----
// biome-ignore lint/style/useNamingConvention: provider option name
⋮----
// Fire-and-forget: update last used timestamp (ignore errors)
⋮----
// Fire-and-forget: update last used timestamp (ignore errors)
⋮----
// Fire-and-forget: update last used timestamp (ignore errors)
⋮----
// Fallback to server-side API keys when BYOK is not available
// Check in preference order for server-side keys
⋮----
// biome-ignore lint/style/useNamingConvention: provider option name
⋮----
// Final fallback: Vercel AI Gateway (if configured)
// Gateway provides unified routing, budgets, retries, and observability
⋮----
// biome-ignore lint/style/useNamingConvention: provider option name
````

## File: src/ai/services/hotel-personalization.ts
````typescript
/**
 * @fileoverview AI-powered hotel personalization service.
 *
 * Uses AI SDK v6 structured output to produce personalized recommendations:
 * - Personalized tags based on user preferences
 * - Recommendation reason explaining the match
 * - Recommendation score (1-10)
 * - Vibe classification (luxury, business, family, romantic, adventure)
 */
⋮----
import { resolveProvider } from "@ai/models/registry";
import { generateText, Output } from "ai";
import { z } from "zod";
import { hashInputForCache } from "@/lib/cache/hash";
import { deleteCachedJson, getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import { sanitizeArray, sanitizeForPrompt } from "@/lib/security/prompt-sanitizer";
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { recordTelemetryEvent, withTelemetrySpan } from "@/lib/telemetry/span";
import packageJson from "../../../package.json";
⋮----
/** Cache TTL for personalization results (30 minutes). */
⋮----
/** Hotel vibe classification */
export type HotelVibe = "luxury" | "business" | "family" | "romantic" | "adventure";
⋮----
/** User preference context for personalization */
export interface UserPreferences {
  /** User's travel style (e.g., "budget", "luxury", "adventure") */
  travelStyle?: string;
  /** Preferred amenities */
  preferredAmenities?: string[];
  /** Purpose of travel */
  tripPurpose?: string;
  /** Whether traveling with family */
  withFamily?: boolean;
  /** Whether traveling for business */
  forBusiness?: boolean;
}
⋮----
/** User's travel style (e.g., "budget", "luxury", "adventure") */
⋮----
/** Preferred amenities */
⋮----
/** Purpose of travel */
⋮----
/** Whether traveling with family */
⋮----
/** Whether traveling for business */
⋮----
/** Hotel data for personalization */
export interface HotelForPersonalization {
  /** Hotel name */
  name: string;
  /** Brand (e.g., "Marriott", "Hilton") */
  brand?: string;
  /** Star rating (1-5) */
  starRating?: number;
  /** Available amenities */
  amenities: string[];
  /** Property category */
  category?: string;
  /** Location description */
  location: string;
  /** Price per night */
  pricePerNight: number;
  /** User rating */
  rating?: number;
}
⋮----
/** Hotel name */
⋮----
/** Brand (e.g., "Marriott", "Hilton") */
⋮----
/** Star rating (1-5) */
⋮----
/** Available amenities */
⋮----
/** Property category */
⋮----
/** Location description */
⋮----
/** Price per night */
⋮----
/** User rating */
⋮----
/** Personalization result for a single hotel */
export interface HotelPersonalization {
  /** Personalized tags for the user (max 3) */
  personalizedTags: string[];
  /** Why this hotel is recommended for the user */
  reason: string;
  /** Recommendation score (1-10) */
  score: number;
  /** Hotel vibe classification */
  vibe: HotelVibe;
}
⋮----
/** Personalized tags for the user (max 3) */
⋮----
/** Why this hotel is recommended for the user */
⋮----
/** Recommendation score (1-10) */
⋮----
/** Hotel vibe classification */
⋮----
/** Cached personalization keyed by stable hotel identifier */
interface IndexedPersonalization extends HotelPersonalization {
  /** Stable hotel identifier used for cache lookups */
  hotelId: string;
}
⋮----
/** Stable hotel identifier used for cache lookups */
⋮----
/** Schema for batch personalization response */
⋮----
/** Hotel index in the input array */
⋮----
/** Personalized tags (max 3) */
⋮----
/** Recommendation reason */
⋮----
/** Recommendation score 1-10 */
⋮----
/** Vibe classification */
⋮----
function buildHotelIdentifiers(hotels: HotelForPersonalization[]): string[]
⋮----
/**
 * Build cache key for personalization request.
 * Uses sorted copy of hotel identifiers to ensure deterministic cache keys.
 */
function buildPersonalizationCacheKey(
  userId: string,
  hotelIds: string[],
  preferences: UserPreferences
): string
⋮----
// Sort a copy to avoid mutating the input array
⋮----
/**
 * Build prompt for hotel personalization.
 * All user inputs are sanitized to prevent prompt injection.
 */
function buildPersonalizationPrompt(
  hotels: HotelForPersonalization[],
  preferences: UserPreferences
): string
⋮----
/**
 * Personalize hotels for a user using AI.
 *
 * Analyzes hotels against user preferences to generate:
 * - Personalized tags
 * - Match explanations
 * - Recommendation scores
 * - Vibe classifications
 *
 * Results are cached per-user for 30 minutes.
 *
 * @param userId - User ID for caching and provider resolution
 * @param hotels - Hotels to personalize
 * @param preferences - User travel preferences
 * @returns Map of hotel index to personalization result
 */
export async function personalizeHotels(
  userId: string,
  hotels: HotelForPersonalization[],
  preferences: UserPreferences
): Promise<Map<number, HotelPersonalization>>
⋮----
// Skip if no hotels
⋮----
// Check cache - use stable hotel identifier to avoid order-dependent mismatches
⋮----
// Cache entry missing for this hotel; fall back to deterministic default
⋮----
// Generate via AI
⋮----
// Build result map and indexed cache array
⋮----
continue; // Skip invalid indices from AI
⋮----
continue; // Skip duplicate indices to avoid overwriting earlier results
⋮----
// Store with hotelId for correct cache reconstruction regardless of order
⋮----
// Fill gaps for any hotels the AI skipped to keep result and cache aligned
⋮----
// Cache indexed results to preserve hotel indices
⋮----
/**
 * Removes cached hotel personalization results for a specific user, hotel set, and preferences.
 *
 * Call this when hotel data changes (pricing, amenities, availability) to trigger fresh AI generation.
 * The cache key combines user ID, sorted hotel identifiers, and preference hash.
 *
 * @param userId - Unique user identifier
 * @param hotels - Array of hotels to invalidate cache for
 * @param preferences - User's travel preferences affecting personalization
 * @returns Promise resolving when cache is deleted
 * @throws Error if hotels array exceeds maximum allowed size (20)
 */
export async function invalidatePersonalizationCache(
  userId: string,
  hotels: HotelForPersonalization[],
  preferences: UserPreferences
): Promise<void>
⋮----
/**
 * Get default personalization for a hotel when AI is unavailable.
 *
 * Uses heuristics based on hotel data to provide basic personalization.
 *
 * @param hotel - Hotel to personalize
 * @returns Default personalization result
 */
export function getDefaultPersonalization(
  hotel: HotelForPersonalization
): HotelPersonalization
⋮----
// Determine vibe from category and amenities
⋮----
// Generate basic tags
⋮----
// Default score based on rating
⋮----
Math.round((hotel.rating ?? 3) * 2) // map 0.5–5 rating to 1–10 score; default 3 → 6; clamp to bounds
````

## File: src/ai/tools/schemas/google-places.ts
````typescript
/**
 * @fileoverview Zod schemas for Google Places API responses and Google Places tool inputs.
 *
 * Core schemas: Google Places API parameters and data structures
 * Tool schemas: Input validation for Google Places tools (POI lookup)
 */
⋮----
import { z } from "zod";
⋮----
/** Schema for lookupPoiContext tool input. */
⋮----
// ===== TOOL OUTPUT SCHEMAS =====
⋮----
/** Normalized POI shape returned by Google Places lookups. */
⋮----
/**
 * Schema for lookupPoiContext tool response.
 *
 * Represents either an error response or a successful POI lookup result.
 * Uses a discriminated union with explicit status field for unambiguous parsing.
 */
⋮----
/** TypeScript type for lookupPoiContext tool response. */
export type LookupPoiResponse = z.infer<typeof lookupPoiResponseSchema>;
````

## File: src/ai/tools/schemas/weather.ts
````typescript
/**
 * @fileoverview Centralized Zod schemas for weather tools.
 *
 * Core schemas: Weather API results and data structures.
 * Tool schemas: Input validation for weather tools (current weather).
 */
⋮----
import { z } from "zod";
⋮----
// ===== CORE SCHEMAS =====
⋮----
/**
 * Zod schema for weather API response data.
 * Contains current weather conditions and forecast information.
 */
⋮----
/** TypeScript type for weather result data. */
export type WeatherResult = z.infer<typeof WEATHER_RESULT_SCHEMA>;
⋮----
// ===== TOOL INPUT SCHEMAS =====
⋮----
/** Zod schema for weather tool input validation. */
````

## File: src/ai/tools/schemas/web-search.ts
````typescript
/**
 * @fileoverview Zod v4 schemas for web search API responses and web search tool inputs.
 *
 * Core schemas: Web search API parameters, results, and data structures
 * Tool schemas: Input validation for web search tools (search, batch search)
 */
⋮----
import { z } from "zod";
⋮----
/** TypeScript type for web search query parameters. */
export type WebSearchParams = {
  query: string;
  limit?: number;
  fresh?: boolean;
  sources?: ("web" | "news" | "images")[];
  categories?: string[];
  tbs?: string;
  location?: string;
  timeoutMs?: number;
  // UNVERIFIED forward-compat fields
  region?: string;
  freshness?: string;
  userId?: string;
};
⋮----
// UNVERIFIED forward-compat fields
⋮----
/** TypeScript type for web search result source metadata. */
export type WebSearchSource = {
  url: string;
  title?: string;
  snippet?: string;
  publishedAt?: string;
};
⋮----
/** Zod schema for web search API response data. */
⋮----
/** TypeScript type for web search results. */
export type WebSearchResult = z.infer<typeof WEB_SEARCH_OUTPUT_SCHEMA>;
⋮----
/** Zod schema for batch web search API response data. */
⋮----
/** TypeScript type for batch web search results. */
export type WebSearchBatchResult = z.infer<typeof WEB_SEARCH_BATCH_OUTPUT_SCHEMA>;
⋮----
// ===== TOOL INPUT SCHEMAS =====
// Schemas for web search tool input validation
⋮----
/** Schema for web search tool input. */
⋮----
freshness: z.string().nullable().describe("Time-based freshness filter"), // UNVERIFIED
⋮----
region: z.string().nullable().describe("Region code for search"), // UNVERIFIED
````

## File: src/ai/tools/server/travel-advisory/providers/state-department.ts
````typescript
/**
 * @fileoverview US State Department Travel Advisories API provider.
 *
 * Implements AdvisoryProvider for the US State Department's
 * official travel advisories API.
 */
⋮----
import { createServerLogger } from "@/lib/telemetry/logger";
import type { AdvisoryProvider, SafetyResult } from "../providers";
import {
  extractSafetyCategories,
  htmlToPlainText,
  levelToScore,
  mapToCountryCode,
  parseAdvisoryLevel,
} from "../utils";
⋮----
/**
 * State Department API advisory response structure.
 *
 * Note: Property names match the API response format (PascalCase).
 */
interface StateDepartmentAdvisory {
  // biome-ignore lint/style/useNamingConvention: API format
  Title: string;
  // biome-ignore lint/style/useNamingConvention: API format
  Link: string;
  // biome-ignore lint/style/useNamingConvention: API format
  Category: string[];
  // biome-ignore lint/style/useNamingConvention: API format
  Summary: string;
  id: string;
  // biome-ignore lint/style/useNamingConvention: API format
  Published: string;
  // biome-ignore lint/style/useNamingConvention: API format
  Updated: string;
}
⋮----
// biome-ignore lint/style/useNamingConvention: API format
⋮----
// biome-ignore lint/style/useNamingConvention: API format
⋮----
// biome-ignore lint/style/useNamingConvention: API format
⋮----
// biome-ignore lint/style/useNamingConvention: API format
⋮----
// biome-ignore lint/style/useNamingConvention: API format
⋮----
// biome-ignore lint/style/useNamingConvention: API format
⋮----
/**
 * State Department Travel Advisories API provider.
 *
 * Fetches and normalizes travel advisory data from the US State
 * Department's official API.
 */
export class StateDepartmentProvider implements AdvisoryProvider
⋮----
private readonly feedCacheTtl = 24 * 60 * 60 * 1000; // 24 hours
⋮----
/**
   * Get provider name for attribution.
   *
   * @returns Provider identifier.
   */
getProviderName(): string
⋮----
/**
   * Fetch and cache the full State Department advisories feed.
   *
   * @returns Promise resolving to array of advisories.
   * @throws Error if API request fails.
   */
private async fetchFeed(): Promise<StateDepartmentAdvisory[]>
⋮----
// biome-ignore lint/style/useNamingConvention: HTTP header name
⋮----
/**
   * Find advisory for a specific country code.
   *
   * @param feed Full advisories feed.
   * @param countryCode ISO-3166-1 alpha-2 country code.
   * @returns Matching advisory or null if not found.
   */
private findAdvisoryByCountryCode(
    feed: StateDepartmentAdvisory[],
    countryCode: string
): StateDepartmentAdvisory | null
⋮----
/**
   * Normalize State Department advisory to SafetyResult.
   *
   * Transforms raw API response (PascalCase) to normalized structure (camelCase),
   * extracts advisory level, parses HTML summary, and identifies safety categories.
   *
   * @param advisory Raw advisory from API.
   * @param countryCode ISO country code.
   * @returns Normalized safety result.
   */
private normalizeAdvisory(
    advisory: StateDepartmentAdvisory,
    countryCode: string
): SafetyResult
⋮----
/**
   * Get travel advisory for a country by ISO-3166-1 alpha-2 code.
   *
   * @param countryCode Two-letter ISO country code (for example, "US", "FR").
   * @returns Promise resolving to safety result or null if not found.
   */
async getCountryAdvisory(countryCode: string): Promise<SafetyResult | null>
⋮----
/**
 * Create the State Department provider.
 *
 * @returns Provider instance.
 */
export function createStateDepartmentProvider(): AdvisoryProvider
````

## File: src/ai/tools/server/travel-advisory/providers.ts
````typescript
/**
 * @fileoverview Provider abstraction for travel advisory APIs.
 *
 * Defines the interface for travel advisory providers, enabling
 * multiple data sources (State Department, GeoSure, etc.) with
 * a unified API.
 */
⋮----
import type { SafetyCategory, SafetyResult } from "@ai/tools/schemas/tools";
⋮----
// Re-export types from schemas for convenience.
⋮----
/**
 * Interface for travel advisory providers.
 *
 * Providers implement this interface to supply travel safety
 * data from various sources (government APIs, commercial services, etc.).
 */
export interface AdvisoryProvider {
  /**
   * Get travel advisory for a country by ISO-3166-1 alpha-2 code.
   *
   * @param countryCode Two-letter ISO country code (for example, "US", "FR").
   * @returns Promise resolving to safety result or null if not found.
   */
  getCountryAdvisory(countryCode: string): Promise<SafetyResult | null>;

  /**
   * Get provider name for attribution.
   *
   * @returns Provider identifier string.
   */
  getProviderName(): string;
}
⋮----
/**
   * Get travel advisory for a country by ISO-3166-1 alpha-2 code.
   *
   * @param countryCode Two-letter ISO country code (for example, "US", "FR").
   * @returns Promise resolving to safety result or null if not found.
   */
getCountryAdvisory(countryCode: string): Promise<SafetyResult | null>;
⋮----
/**
   * Get provider name for attribution.
   *
   * @returns Provider identifier string.
   */
getProviderName(): string;
⋮----
/**
 * Registry of available advisory providers.
 *
 * Maps provider names to their implementations. Used for
 * provider selection and fallback logic.
 */
⋮----
/**
 * Register an advisory provider.
 *
 * @param provider Provider implementation to register.
 */
export function registerProvider(provider: AdvisoryProvider): void
⋮----
/**
 * Get a registered provider by name.
 *
 * @param name Provider name.
 * @returns Provider instance or undefined if not found.
 */
export function getProvider(name: string): AdvisoryProvider | undefined
⋮----
/**
 * Get the default provider (State Department).
 *
 * @returns Default provider instance or undefined if not registered.
 */
export function getDefaultProvider(): AdvisoryProvider | undefined
````

## File: src/ai/tools/server/travel-advisory/utils.ts
````typescript
/**
 * @fileoverview Utility functions for travel advisory processing.
 *
 * Provides country code mapping, HTML parsing, and score conversion
 * utilities used by advisory providers.
 */
⋮----
import { convert } from "html-to-text";
import countries from "i18n-iso-countries";
import enLocale from "i18n-iso-countries/langs/en.json";
⋮----
// Register English locale for country names.
⋮----
/**
 * Convert US State Department advisory level to safety score (0-100).
 *
 * Level 1: Exercise Normal Precautions → 85
 * Level 2: Exercise Increased Caution → 60
 * Level 3: Reconsider Travel → 35
 * Level 4: Do Not Travel → 10
 *
 * @param level Advisory level (1-4).
 * @returns Safety score from 0-100.
 */
export function levelToScore(level: number): number
⋮----
// Unknown level, return neutral score.
⋮----
/**
 * Parse advisory level from State Department title string.
 *
 * Extracts level number from strings like
 * "Austria - Level 1: Exercise Normal Precautions".
 *
 * @param title Advisory title containing level information.
 * @returns Level number (1-4) or null if not found.
 */
export function parseAdvisoryLevel(title: string): number | null
⋮----
/**
 * Convert HTML content to plain text.
 *
 * Strips HTML tags, preserves line breaks, and sanitizes content.
 *
 * @param html HTML content to convert.
 * @returns Plain text with line breaks preserved.
 */
export function htmlToPlainText(html: string): string
⋮----
/**
 * Map country name or code to ISO-3166-1 alpha-2 code.
 *
 * Handles various formats:
 * - ISO codes: "US", "FR" → "US", "FR"
 * - Country names: "United States", "France" → "US", "FR"
 * - Category arrays: ["AU"] or ["Austria", "Europe"] → "AU"
 *
 * @param input Country name, code, or category array.
 * @returns ISO-3166-1 alpha-2 code or null if not found.
 */
export function mapToCountryCode(input: string | string[]): string | null
⋮----
// Check if already an ISO code (2 letters).
⋮----
// Try to find by country name.
⋮----
// Try fuzzy matching with common variations.
⋮----
/**
 * Extract safety categories from advisory summary.
 *
 * Parses HTML summary to identify mentioned risk categories
 * (crime, terrorism, health, civil unrest, etc.).
 *
 * @param summary Plain text summary of advisory.
 * @returns Array of safety categories with descriptions.
 */
export function extractSafetyCategories(
  summary: string
): Array<
⋮----
// Common risk categories and their keywords.
````

## File: src/ai/tools/server/approvals.ts
````typescript
/**
 * @fileoverview Minimal approval flow utilities backed by Upstash Redis.
 * Server-only: do not import from client components.
 */
⋮----
import type { ApprovalStatus, ToolExecutionContext } from "@ai/tools/schemas/tools";
import { getRedis } from "@/lib/redis";
⋮----
const KEY = (sessionId: string, action: string, idempotencyKey?: string)
⋮----
// Re-export type from schemas
⋮----
/**
 * Require approval for a sensitive action. Throws if not yet approved.
 *
 * @param action - The action to require approval for.
 * @param ctx - The tool execution context.
 * @returns A promise that resolves when the action is approved.
 * @throws {Error} Error with `code` property set to "approval_required" if the action is not approved.
 */
export async function requireApproval(
  action: string,
  ctx: Pick<ToolExecutionContext, "sessionId"> & { idempotencyKey?: string }
): Promise<void>
⋮----
// Mark as pending for the UI to surface.
⋮----
// Attach metadata for the UI handler to render a dialog.
⋮----
/**
 * Get approval status for a given action and optional idempotency key.
 *
 * @param sessionId - The session ID.
 * @param action - The action to get the approval status for.
 * @param idempotencyKey - The idempotency key.
 * @returns The approval status.
 */
export async function getApprovalStatus(
  sessionId: string,
  action: string,
  idempotencyKey?: string
): Promise<ApprovalStatus>
⋮----
/**
 * Grant approval for a given action in the current session.
 *
 * @param sessionId - The session ID.
 * @param action - The action to grant approval for.
 * @param idempotencyKey - The idempotency key.
 */
export async function grantApproval(
  sessionId: string,
  action: string,
  idempotencyKey?: string
): Promise<void>
⋮----
/**
 * Deny approval for a given action in the current session.
 *
 * @param sessionId - The session ID.
 * @param action - The action to deny approval for.
 * @param idempotencyKey - The idempotency key.
 */
export async function denyApproval(
  sessionId: string,
  action: string,
  idempotencyKey?: string
): Promise<void>
````

## File: src/ai/tools/server/constants.ts
````typescript
/**
 * @fileoverview Shared constants for planning tools.
 */
⋮----
export const RATE_CREATE_PER_DAY = 20; // per user
export const RATE_UPDATE_PER_MIN = 60; // per plan
⋮----
export const TTL_DRAFT_SECONDS = 86400 * 7; // 7 days
export const TTL_FINAL_SECONDS = 86400 * 30; // 30 days
⋮----
/**
 * Cache TTL for accommodation search results (5 minutes).
 * Used by searchAccommodations tool.
 */
⋮----
/**
 * Cache TTL for weather results (10 minutes).
 * Used by getCurrentWeather tool.
 */
````

## File: src/ai/tools/server/injection.ts
````typescript
/**
 * @fileoverview Helpers to inject user context into AI SDK tools.
 *
 * Used by chat streaming to ensure selected tools always receive userId and
 * optional sessionId in their input payloads, without mutating the original
 * tool registry.
 */
⋮----
type ToolWithExecute = {
  description?: string;
  execute?: (params: unknown, callOptions?: unknown) => Promise<unknown> | unknown;
  inputSchema?: unknown;
  name?: string;
};
⋮----
/**
 * Wrap tools by name to inject `{ userId, sessionId? }` into their execute input.
 *
 * The original tools object is left untouched; a shallow copy is returned with
 * wrapped execute functions for the selected keys.
 *
 * @param tools Record of tool definitions to wrap.
 * @param userId User identifier to inject.
 * @param onlyKeys Array of tool names to wrap (others pass through unchanged).
 * @param sessionId Optional session identifier to inject.
 * @returns Record of wrapped tools with injected context.
 */
export function wrapToolsWithUserId<T extends Record<string, unknown>>(
  tools: T,
  userId: string,
  onlyKeys: string[],
  sessionId?: string
): T
⋮----
async execute(input: unknown, callOptions?: unknown)
````

## File: src/ai/tools/server/planning.schema.ts
````typescript
/**
 * @fileoverview Canonical Zod schema for travel plans.
 * Defines the persisted shape and exported TypeScript type.
 */
⋮----
import { z } from "zod";
⋮----
export type Plan = z.infer<typeof planSchema>;
````

## File: src/ai/tools/server/web-search-normalize.ts
````typescript
/**
 * @fileoverview Normalization utilities for web search tool results.
 *
 * Strips extra fields from Firecrawl API responses to ensure strict schema
 * compliance. Firecrawl may return additional fields (for example content,
 * score, source) that are not part of our strict output schema.
 */
⋮----
import type { WebSearchSource } from "@ai/tools/schemas/web-search";
⋮----
/**
 * Normalizes a single search result item to match the strict schema.
 *
 * Extracts only the allowed fields (url, title, snippet, publishedAt) and
 * filters out any extra fields that Firecrawl may include.
 *
 * @param item Raw result item from Firecrawl API (may contain extra fields).
 * @returns Normalized result matching WebSearchSource schema, or null if invalid.
 */
export function normalizeWebSearchResult(item: unknown): WebSearchSource | null
⋮----
/**
 * Normalizes an array of search results.
 *
 * Filters out invalid items and normalizes valid ones to match the strict schema.
 *
 * @param items Array of raw result items from Firecrawl API.
 * @returns Array of normalized results matching WebSearchSource schema.
 */
export function normalizeWebSearchResults(items: unknown[]): WebSearchSource[]
````

## File: src/ai/tools/index.ts
````typescript
/**
 * @fileoverview Central tool registry.
 *
 * Exports all server-side tools for use in chat routes and agents and
 * provides a typed registry object for higher-level agents.
 */
⋮----
import type { ToolSet, TypedToolCall, TypedToolResult } from "ai";
import {
  bookAccommodation,
  checkAvailability,
  getAccommodationDetails,
  searchAccommodations,
} from "./server/accommodations";
import { getActivityDetails, searchActivities } from "./server/activities";
import {
  denyApproval,
  getApprovalStatus,
  grantApproval,
  requireApproval,
} from "./server/approvals";
import {
  createCalendarEvent,
  exportItineraryToIcs,
  getAvailability,
} from "./server/calendar";
import { searchFlights } from "./server/flights";
import { lookupPoiContext } from "./server/google-places";
import { distanceMatrix, geocode } from "./server/maps";
import { addConversationMemory, searchUserMemories } from "./server/memory";
import {
  combineSearchResults,
  createTravelPlan,
  deleteTravelPlan,
  saveTravelPlan,
  updateTravelPlan,
} from "./server/planning";
import { ragSearch } from "./server/rag";
import { getTravelAdvisory } from "./server/travel-advisory";
import { getCurrentWeather } from "./server/weather";
import { crawlSite, crawlUrl } from "./server/web-crawl";
import { webSearch } from "./server/web-search";
import { webSearchBatch } from "./server/web-search-batch";
⋮----
/**
 * Typed tool registry for AI SDK v6 generateText/streamText.
 * Satisfies ToolSet for compile-time validation; includes only executable tools.
 */
⋮----
/** Type for the complete tool registry. */
export type TripSageToolRegistry = typeof toolRegistry;
⋮----
/**
 * Typed tool call for TripSage tools.
 *
 * Use for type-safe access to tool call inputs in step handlers.
 *
 * @example
 * ```typescript
 * const toolCall: TripSageToolCall = step.toolCalls[0];
 * if (toolCall.toolName === 'searchFlights') {
 *   console.log(toolCall.args.origin); // Type-safe access
 * }
 * ```
 */
export type TripSageToolCall = TypedToolCall<TripSageToolRegistry>;
⋮----
/**
 * Typed tool result for TripSage tools.
 *
 * Use for type-safe access to tool results in step handlers.
 *
 * @example
 * ```typescript
 * const toolResult: TripSageToolResult = step.toolResults[0];
 * if (toolResult.toolName === 'searchFlights') {
 *   console.log(toolResult.result.flights); // Type-safe access
 * }
 * ```
 */
export type TripSageToolResult = TypedToolResult<TripSageToolRegistry>;
````

## File: src/ai/constants.ts
````typescript
/**
 * Shared AI agent constants.
 */
````

## File: src/app/(auth)/login/page.tsx
````typescript
/**
 * @fileoverview Login page component for the TripSage application.
 */
⋮----
import type { Metadata } from "next";
import Link from "next/link";
import { LoginForm } from "@/components/auth/login-form";
⋮----
/** The metadata for the login page. */
⋮----
/** The login page component. */
export default async function LoginPage({
  searchParams,
}: {
  searchParams: Promise<{ from?: string; error?: string }>;
})
⋮----
{/* Left side - Branding and imagery */}
⋮----
{/* Right side - Login form */}
````

## File: src/app/(auth)/register/page.tsx
````typescript
/**
 * @fileoverview Register page component for the TripSage application.
 */
⋮----
import type { Metadata } from "next";
import Link from "next/link";
import { RegisterForm } from "@/components/auth/register-form";
⋮----
/** The metadata for the register page. */
⋮----
/** The register page component. */
export default async function RegisterPage({
  searchParams,
}: {
  searchParams: Promise<{ from?: string; status?: string; error?: string }>;
})
⋮----
{/* Left side - Register form (on mobile, this is the only visible part) */}
⋮----
{/* Right side - Branding and imagery */}
````

## File: src/app/(auth)/reset-password/page.tsx
````typescript
import type { Metadata } from "next";
import Link from "next/link";
import { redirect } from "next/navigation";
import { ResetPasswordForm } from "@/components/auth/reset-password-form";
import { createServerSupabase, getCurrentUser } from "@/lib/supabase/server";
⋮----
export default async function ResetPasswordPage()
⋮----
// Use unified getCurrentUser to eliminate duplicate auth.getUser() calls
⋮----
{/* Background pattern */}
⋮----
{/* Content */}
⋮----
{/* Logo */}
⋮----
{/* Form */}
⋮----
{/* Additional help */}
````

## File: src/app/(auth)/error.tsx
````typescript
/**
 * @fileoverview Authentication-level error boundary for the auth directory.
 * This catches errors within the auth layout and pages.
 */
⋮----
import { useEffect } from "react";
import { ErrorFallback } from "@/components/error/error-fallback";
import { getSessionId } from "@/lib/client/session";
import { errorService } from "@/lib/error-service";
import { fireAndForget } from "@/lib/utils";
⋮----
/**
 * Authentication-level error boundary
 * Catches errors within the auth layout and pages
 */
export default function AuthError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
reset: ()
⋮----
// Report the auth error
⋮----
// Log error in development
````

## File: src/app/(auth)/layout.tsx
````typescript
import { AuthLayout } from "@/components/layouts/auth-layout";
⋮----
export default function Layout(
````

## File: src/app/(marketing)/ai-demo/page.tsx
````typescript
/**
 * @fileoverview Minimal AI SDK v6 demo page rendering a conversation area and
 * a PromptInput from AI Elements, wired to the demo streaming route.
 */
⋮----
import { useCallback, useState } from "react";
import {
  Conversation,
  ConversationContent,
  ConversationEmptyState,
} from "@/components/ai-elements/conversation";
import {
  PromptInput,
  PromptInputBody,
  PromptInputFooter,
  PromptInputSubmit,
  PromptInputTextarea,
} from "@/components/ai-elements/prompt-input";
import { Response } from "@/components/ai-elements/response";
⋮----
/**
 * Render the AI SDK v6 demo page.
 *
 * Submits user input to `/api/_health/stream` and appends streamed chunks to
 * a preview area. This page intentionally keeps logic minimal for foundations.
 *
 * @returns The demo page component.
 */
⋮----
// Ignore telemetry failures
⋮----
/**
   * Handle prompt submission by streaming response from AI API.
   *
   * @param prompt - The user input text to send to the AI service.
   */
⋮----
// Parse UI Message Stream events and append text parts
⋮----
// Keep the last partial chunk in buffer
⋮----
// Ignore malformed chunks
⋮----
onSubmit=
````

## File: src/app/(marketing)/layout.tsx
````typescript
/**
 * @fileoverview Marketing/public pages layout with navigation.
 *
 * Provides the public Navbar for unauthenticated visitors.
 * Route group doesn't affect URL paths.
 */
⋮----
import { type ReactNode, Suspense } from "react";
import { Navbar } from "@/components/layouts/navbar";
import { Skeleton } from "@/components/ui/skeleton";
⋮----
function NavbarFallback()
⋮----
/**
 * Marketing route-group layout that renders the public Navbar (via Suspense) and page content.
 *
 * Uses a skeleton fallback to preserve navbar layout while the Navbar loads.
 */
export default function MarketingLayout(
````

## File: src/app/(marketing)/page.tsx
````typescript
/**
 * @fileoverview Landing page component for TripSage AI, showcasing the main marketing
 * content, feature highlights, and call-to-action buttons for user registration
 * and demo access.
 */
⋮----
import Image from "next/image";
import Link from "next/link";
import { Suspense } from "react";
import { Button } from "@/components/ui/button";
// caching handled at app level via cacheComponents; no per-file directive
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { CurrentYear } from "@/components/ui/current-year";
import { ROUTES } from "@/lib/routes";
⋮----
/**
 * Main landing page component for TripSage AI.
 *
 * Renders the homepage with hero section, feature cards, and footer navigation.
 * Includes call-to-action buttons for user registration and demo access.
 *
 * @returns The home page component.
 */
````

## File: src/app/api/_helpers/attachments.ts
````typescript
/**
 * @fileoverview Helpers for UI attachments mapping and validation.
 */
⋮----
import type { FileUIPart, UIMessage } from "ai";
⋮----
/**
 * Type representing the result of attachment validation.
 */
export type Validation = { valid: true } | { valid: false; reason: string };
⋮----
/**
 * Validates that any file parts are image/* and contain a media type.
 *
 * @param messages - Array of UI messages to validate for attachments.
 * @returns Validation result indicating success or failure with reason.
 */
export function validateImageAttachments(messages: UIMessage[]): Validation
⋮----
/**
 * Converts UI file parts to model file format for AI SDK compatibility.
 *
 * @param part - UI message part to convert.
 * @returns FilePart object for AI SDK or undefined if not convertible.
 */
export function convertUiFilePartToImage(part: FileUIPart)
⋮----
/**
 * Extracts text content from UI messages for token budgeting purposes.
 *
 * @param messages - Array of UI messages to extract text from.
 * @returns Array of text strings found in the messages.
 */
export function extractTexts(messages: UIMessage[]): string[]
````

## File: src/app/api/accommodations/personalize/route.ts
````typescript
/**
 * @fileoverview AI-powered hotel personalization endpoint.
 *
 * Generates personalized recommendations for hotels based on user preferences:
 * - Personalized tags
 * - Match explanations
 * - Recommendation scores (1-10)
 * - Vibe classifications
 */
⋮----
import {
  getDefaultPersonalization,
  type HotelForPersonalization,
  personalizeHotels,
} from "@ai/services/hotel-personalization";
import {
  type HotelPersonalizeRequest,
  hotelPersonalizeRequestSchema,
} from "@schemas/api";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { requireUserId } from "@/lib/api/route-helpers";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/**
 * POST /api/accommodations/personalize
 *
 * Personalizes hotels for the authenticated user based on their preferences.
 * Results are cached per-user for 30 minutes.
 *
 * @param req - Next.js request object
 * @param context - Route context with user and supabase client
 * @param validated - Validated request body
 * @returns JSON response with personalized hotel recommendations
 */
⋮----
// Convert request hotels to service format
⋮----
// Attempt AI personalization
⋮----
// Build response with fallbacks for missing personalizations
⋮----
// Fallback to default personalization
⋮----
// Log error and return fallback with proper error status
⋮----
// Return default personalizations with 503 status to indicate service degradation
````

## File: src/app/api/accommodations/popular-destinations/route.ts
````typescript
/**
 * @fileoverview API route returning cached popular hotel destinations.
 *
 * Returns personalized destinations based on user's search history if available,
 * falling back to global popular hotel destinations.
 */
⋮----
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import type { Database } from "@/lib/supabase/database.types";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** Popular hotel destination returned to the client. */
interface PopularDestination {
  /** City or destination name */
  city: string;
  /** Country name */
  country?: string;
  /** Average nightly price */
  avgPrice?: string;
  /** Optional image URL */
  imageUrl?: string;
}
⋮----
/** City or destination name */
⋮----
/** Country name */
⋮----
/** Average nightly price */
⋮----
/** Optional image URL */
⋮----
/** Row from the search_hotels table. */
type SearchHotelsDestinationRow = Pick<
  Database["public"]["Tables"]["search_hotels"]["Row"],
  "destination"
>;
⋮----
const POPULAR_DESTINATIONS_TTL_SECONDS = 60 * 60; // 1 hour
⋮----
/** Global popular hotel destinations with typical pricing. */
⋮----
/**
 * Fetches personalized hotel destinations for a user from the search_hotels table.
 *
 * @param supabase - Supabase client instance
 * @param userId - User ID
 * @returns Promise resolving to an array of PopularDestination
 *          objects or null if no destinations are found
 */
async function fetchPersonalizedDestinations(
  supabase: TypedServerSupabase,
  userId: string
): Promise<PopularDestination[] | null>
⋮----
/**
 * Handles GET /api/accommodations/popular-destinations.
 *
 * Returns personalized destinations if user has search history,
 * otherwise returns global popular destinations.
 *
 * @param _req - Request object
 * @param contextUser - User from the context
 * @param supabase - Supabase client instance
 * @returns Promise resolving to a NextResponse with the popular destinations
 */
// Note: personalization is user-scoped; this route now requires auth to avoid
// any accidental leakage of user-derived history. Responses remain private.
⋮----
const resolvedUser = contextUser; // Now guaranteed non-null
````

## File: src/app/api/agents/accommodations/route.ts
````typescript
/**
 * @fileoverview Accommodation agent route handler using AI SDK v6 ToolLoopAgent.
 * - Supabase SSR auth → userId
 * - Provider resolution (BYOK/Gateway)
 * - Guardrails (cache, ratelimit, telemetry) around tools
 * - AI SDK v6 ToolLoopAgent with createAgentUIStreamResponse
 */
⋮----
import { createAccommodationAgent } from "@ai/agents";
import { resolveProvider } from "@ai/models/registry";
import type { AccommodationSearchRequest } from "@schemas/agents";
import { agentSchemas } from "@schemas/agents";
import { createAgentUIStreamResponse } from "ai";
import type { NextRequest } from "next/server";
import { resolveAgentConfig } from "@/lib/agents/config-resolver";
import { createErrorHandler } from "@/lib/agents/error-recovery";
import { withApiGuards } from "@/lib/api/factory";
import { requireUserId } from "@/lib/api/route-helpers";
⋮----
/**
 * POST /api/agents/accommodations
 *
 * Validates request, resolves provider, and streams ToolLoopAgent response.
 */
````

## File: src/app/api/agents/budget/route.ts
````typescript
/**
 * @fileoverview Budget agent route handler using AI SDK v6 ToolLoopAgent.
 * - Supabase SSR auth → userId
 * - Provider resolution (BYOK/Gateway)
 * - Guardrails (cache, ratelimit, telemetry) around tools
 * - AI SDK v6 ToolLoopAgent with createAgentUIStreamResponse
 */
⋮----
import { createBudgetAgent } from "@ai/agents";
import { resolveProvider } from "@ai/models/registry";
import { agentSchemas } from "@schemas/agents";
import { createAgentUIStreamResponse } from "ai";
import type { NextRequest } from "next/server";
import { resolveAgentConfig } from "@/lib/agents/config-resolver";
import { createErrorHandler } from "@/lib/agents/error-recovery";
import { withApiGuards } from "@/lib/api/factory";
import { parseJsonBody, requireUserId, validateSchema } from "@/lib/api/route-helpers";
⋮----
/**
 * POST /api/agents/budget
 *
 * Validates request, resolves provider, and streams ToolLoopAgent response.
 */
````

## File: src/app/api/agents/destinations/route.ts
````typescript
/**
 * @fileoverview Destination agent route handler using AI SDK v6 ToolLoopAgent.
 * - Supabase SSR auth → userId
 * - Provider resolution (BYOK/Gateway)
 * - Guardrails (cache, ratelimit, telemetry) around tools
 * - AI SDK v6 ToolLoopAgent with createAgentUIStreamResponse
 */
⋮----
import { createDestinationAgent } from "@ai/agents";
import { resolveProvider } from "@ai/models/registry";
import { agentSchemas } from "@schemas/agents";
import { createAgentUIStreamResponse } from "ai";
import type { NextRequest } from "next/server";
import { resolveAgentConfig } from "@/lib/agents/config-resolver";
import { createErrorHandler } from "@/lib/agents/error-recovery";
import { withApiGuards } from "@/lib/api/factory";
import { parseJsonBody, requireUserId, validateSchema } from "@/lib/api/route-helpers";
⋮----
/**
 * POST /api/agents/destinations
 *
 * Validates request, resolves provider, and streams ToolLoopAgent response.
 */
````

## File: src/app/api/agents/flights/route.ts
````typescript
/**
 * @fileoverview Flight agent route handler using AI SDK v6 ToolLoopAgent.
 * - Supabase SSR auth → userId
 * - Provider resolution (BYOK/Gateway)
 * - Guardrails (cache, ratelimit, telemetry) around tools
 * - AI SDK v6 ToolLoopAgent with createAgentUIStreamResponse
 */
⋮----
import { createFlightAgent } from "@ai/agents";
import { resolveProvider } from "@ai/models/registry";
import { flightSearchRequestSchema } from "@schemas/flights";
import { createAgentUIStreamResponse } from "ai";
import type { NextRequest } from "next/server";
import { resolveAgentConfig } from "@/lib/agents/config-resolver";
import { createErrorHandler } from "@/lib/agents/error-recovery";
import { withApiGuards } from "@/lib/api/factory";
import { parseJsonBody, requireUserId, validateSchema } from "@/lib/api/route-helpers";
⋮----
/**
 * POST /api/agents/flights
 *
 * Validates request, resolves provider, and streams ToolLoopAgent response.
 */
````

## File: src/app/api/agents/itineraries/route.ts
````typescript
/**
 * @fileoverview Itinerary agent route handler using AI SDK v6 ToolLoopAgent.
 * - Supabase SSR auth → userId
 * - Provider resolution (BYOK/Gateway)
 * - Guardrails (cache, ratelimit, telemetry) around tools
 * - AI SDK v6 ToolLoopAgent with createAgentUIStreamResponse
 */
⋮----
import { createItineraryAgent } from "@ai/agents";
import { resolveProvider } from "@ai/models/registry";
import { agentSchemas } from "@schemas/agents";
import { createAgentUIStreamResponse } from "ai";
import type { NextRequest } from "next/server";
import { resolveAgentConfig } from "@/lib/agents/config-resolver";
import { createErrorHandler } from "@/lib/agents/error-recovery";
import { withApiGuards } from "@/lib/api/factory";
import { parseJsonBody, requireUserId, validateSchema } from "@/lib/api/route-helpers";
⋮----
/**
 * POST /api/agents/itineraries
 *
 * Validates request, resolves provider, and streams ToolLoopAgent response.
 */
````

## File: src/app/api/agents/memory/route.ts
````typescript
/**
 * @fileoverview Memory agent route handler (frontend-only).
 * - Supabase SSR auth → userId
 * - Provider resolution (BYOK/Gateway)
 * - Guardrails (rate limiting, telemetry)
 * - AI SDK v6 streaming summary response
 */
⋮----
import { runMemoryAgent } from "@ai/agents/memory-agent";
import { resolveProvider } from "@ai/models/registry";
import { agentSchemas } from "@schemas/agents";
import type { NextRequest } from "next/server";
import { resolveAgentConfig } from "@/lib/agents/config-resolver";
import { createErrorHandler } from "@/lib/agents/error-recovery";
import { withApiGuards } from "@/lib/api/factory";
import { parseJsonBody, requireUserId, validateSchema } from "@/lib/api/route-helpers";
⋮----
/**
 * POST /api/agents/memory
 *
 * Validates request, resolves provider, and streams a confirmation response.
 */
````

## File: src/app/api/agents/router/route.ts
````typescript
/**
 * @fileoverview Router agent route handler (frontend-only).
 * - Supabase SSR auth → userId
 * - Provider resolution (BYOK/Gateway)
 * - Classifies user messages into agent workflows
 */
⋮----
import { classifyUserMessage, InvalidPatternsError } from "@ai/agents/router-agent";
import { resolveProvider } from "@ai/models/registry";
import { agentSchemas } from "@schemas/agents";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import {
  errorResponse,
  parseJsonBody,
  requireUserId,
  validateSchema,
} from "@/lib/api/route-helpers";
⋮----
/**
 * POST /api/agents/router
 *
 * Classifies user message into an agent workflow.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with classification result
 */
````

## File: src/app/api/auth/mfa/backup/verify/route.ts
````typescript
/**
 * @fileoverview API route for verifying MFA backup codes.
 */
⋮----
import { backupCodeVerifyInputSchema } from "@schemas/mfa";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import {
  errorResponse,
  getClientIpFromHeaders,
  unauthorizedResponse,
} from "@/lib/api/route-helpers";
import { InvalidBackupCodeError, verifyBackupCode } from "@/lib/security/mfa";
import { getAdminSupabase } from "@/lib/supabase/admin";
⋮----
/** The POST handler for the MFA backup code verify API. */
⋮----
// Note: No requireAal2() check here - backup codes must be usable at AAL1
// when the primary MFA factor is unavailable (account recovery scenario)
````

## File: src/app/api/auth/mfa/challenge/route.ts
````typescript
/**
 * @fileoverview The API route for issuing a MFA challenge.
 */
⋮----
import { mfaChallengeInputSchema } from "@schemas/mfa";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { challengeTotp } from "@/lib/security/mfa";
import { classifyMfaError, logMfaError } from "@/lib/security/mfa-error";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** The POST handler for the MFA challenge API. */
````

## File: src/app/api/auth/mfa/factors/list/route.ts
````typescript
/**
 * @fileoverview The API route for listing MFA factors.
 */
⋮----
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { listFactors, refreshAal } from "@/lib/security/mfa";
import { classifyMfaError, logMfaError } from "@/lib/security/mfa-error";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** The GET handler for the MFA factors list API. */
````

## File: src/app/api/auth/mfa/setup/route.ts
````typescript
/**
 * @fileoverview The API route for setting up MFA.
 */
⋮----
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { startTotpEnrollment } from "@/lib/security/mfa";
import { classifyMfaError, logMfaError } from "@/lib/security/mfa-error";
import { getAdminSupabase } from "@/lib/supabase/admin";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** The POST handler for the MFA setup API. */
````

## File: src/app/api/auth/mfa/verify/route.ts
````typescript
/**
 * @fileoverview The API route for verifying a MFA code.
 */
⋮----
import { mfaVerificationInputSchema } from "@schemas/mfa";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import {
  errorResponse,
  getClientIpFromHeaders,
  unauthorizedResponse,
} from "@/lib/api/route-helpers";
import {
  InvalidTotpError,
  regenerateBackupCodes,
  TotpVerificationInternalError,
  verifyTotp,
} from "@/lib/security/mfa";
import { getAdminSupabase } from "@/lib/supabase/admin";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** The POST handler for the MFA verify API. */
⋮----
// Only generate backup codes during initial MFA enrollment, not on subsequent logins
// Additional safeguard: verify user doesn't already have backup codes (prevents regeneration on regular challenges)
⋮----
// Defensive check: only generate backup codes if user doesn't already have any
// This prevents regeneration during regular MFA challenges where isInitialEnrollment might be incorrectly true
````

## File: src/app/api/calendar/events/route.ts
````typescript
/**
 * @fileoverview Calendar events CRUD endpoint.
 *
 * Handles GET (list), POST (create), PATCH (update), and DELETE operations
 * for calendar events via Google Calendar API.
 *
 * Note: Calendar data is NOT cached in Redis because:
 * 1. Google Calendar API has its own response caching
 * 2. Event changes can occur from multiple sources (mobile, web, etc.)
 * 3. Staleness risk outweighs caching benefits for real-time calendar data
 */
⋮----
import {
  createEventRequestSchema,
  eventsListRequestSchema,
  updateEventRequestSchema,
} from "@schemas/calendar";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { parseJsonBody, validateSchema } from "@/lib/api/route-helpers";
import {
  createEvent,
  deleteEvent,
  listEvents,
  updateEvent,
} from "@/lib/calendar/google";
⋮----
/**
 * Extracts calendar ID from body or query params with default fallback.
 *
 * @param source - Source object (body or searchParams).
 * @param key - Key to extract (defaults to "calendarId").
 * @returns Calendar ID string.
 */
function getCalendarId(
  source: Record<string, unknown> | URLSearchParams,
  key = "calendarId"
): string
⋮----
/**
 * GET /api/calendar/events
 *
 * List events from a calendar.
 *
 * @param req - Next.js request object.
 * @returns JSON response with events list.
 */
⋮----
/**
 * POST /api/calendar/events
 *
 * Create a new calendar event.
 *
 * @param req - Next.js request object.
 * @returns JSON response with created event.
 */
⋮----
/**
 * PATCH /api/calendar/events?eventId=...&calendarId=...
 *
 * Update an existing calendar event.
 *
 * @param req - Next.js request object.
 * @returns JSON response with updated event.
 */
⋮----
/**
 * DELETE /api/calendar/events?eventId=...&calendarId=...
 *
 * Delete a calendar event.
 *
 * @param req - Next.js request object.
 * @returns JSON response with success status.
 */
````

## File: src/app/api/calendar/freebusy/route.ts
````typescript
/**
 * @fileoverview Free/busy query endpoint.
 *
 * Queries Google Calendar free/busy information for specified calendars.
 */
⋮----
// Security: Route handlers are dynamic by default with Cache Components.
// Using withApiGuards({ auth: true }) ensures this route uses cookies/headers,
// making it dynamic and preventing caching of user-specific data.
⋮----
import { freeBusyRequestSchema } from "@schemas/calendar";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { parseJsonBody, validateSchema } from "@/lib/api/route-helpers";
import { queryFreeBusy } from "@/lib/calendar/google";
⋮----
/**
 * POST /api/calendar/freebusy
 *
 * Query free/busy information for calendars.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with free/busy data
 */
````

## File: src/app/api/calendar/ics/import/route.ts
````typescript
/**
 * @fileoverview ICS import endpoint.
 *
 * Parses ICS file/text and returns events payload. Optionally validates
 * without writing to calendar (requires approval for writes).
 */
⋮----
// Security: Route handlers are dynamic by default with Cache Components.
// Using withApiGuards({ auth: true }) ensures this route uses cookies/headers,
// making it dynamic and preventing caching of user-specific data.
⋮----
import {
  calendarEventSchema,
  type IcsImportRequest,
  icsImportRequestSchema,
} from "@schemas/calendar";
import ICAL from "ical.js";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { RecurringDateGenerator } from "@/lib/dates/recurring-rules";
import { DateUtils } from "@/lib/dates/unified-date-utils";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** Parsed ICS event structure from ical.js. */
type ParsedIcsEvent = {
  type: "VEVENT";
  summary?: string;
  description?: string;
  location?: string;
  start?: Date;
  end?: Date;
  rrule?: string;
  attendees?: Array<{ val: string; params?: Record<string, string> }>;
  uid?: string;
  created?: Date;
  lastmodified?: Date;
};
⋮----
/**
 * Parses raw ICS data into a keyed map of VEVENT entries using ical.js library.
 * Handles RFC 5545 compliance, line folding, property parameters, and timezone handling.
 *
 * @param icsData - Raw ICS document string.
 * @returns Event map keyed by incremental ids.
 */
function parseICS(icsData: string): Record<string, ParsedIcsEvent>
⋮----
// Parse ICS data into jCal format
⋮----
// Extract basic properties
⋮----
// Extract dates (ical.js handles timezone conversion)
⋮----
// Extract RRULE
⋮----
// Extract CREATED and LAST-MODIFIED
⋮----
// Extract attendees with parameters
⋮----
// Common attendee parameters
⋮----
// Parameter names are case-insensitive in ICS, normalize to uppercase
⋮----
// Convert value to string (attendee values are typically mailto: URLs)
⋮----
// If parsing fails, throw error to be caught by caller
⋮----
/**
 * Validates ICS payloads, performs rudimentary parsing, and returns structured
 * event objects while applying rate limiting and auth guards.
 *
 * @param req - Request containing raw ICS data and validation flag.
 * @param routeContext - Route context from withApiGuards
 * @returns Response containing normalized events or an error payload.
 */
⋮----
// Parse ICS data
⋮----
// Convert parsed events to calendar event format
⋮----
continue; // Skip events without valid dates
⋮----
// Strip mailto: prefix from email if present
⋮----
displayName: att.params?.CN?.replace(/^"(.*)"$/, "$1"), // Strip surrounding quotes
⋮----
// Validate against schema - use parsed result or skip invalid events
⋮----
// Log validation error but skip invalid events
````

## File: src/app/api/calendar/status/route.ts
````typescript
/**
 * @fileoverview Calendar connection status endpoint.
 *
 * Returns connection status, granted scopes, and list of calendars for the
 * authenticated user.
 */
⋮----
// Security: Route handlers are dynamic by default with Cache Components.
// Using withApiGuards({ auth: true }) ensures this route uses cookies/headers,
// making it dynamic and preventing caching of user-specific data.
⋮----
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { hasGoogleCalendarScopes } from "@/lib/calendar/auth";
import { listCalendars } from "@/lib/calendar/google";
⋮----
/**
 * GET /api/calendar/status
 *
 * Get calendar connection status and list of calendars.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with calendar status and list
 */
⋮----
// Check if user has Google Calendar scopes
⋮----
// Fetch calendar list
````

## File: src/app/api/chat/attachments/route.ts
````typescript
/**
 * @fileoverview Chat attachment upload endpoint using Supabase Storage.
 *
 * Handles multipart form data uploads directly to Supabase Storage bucket,
 * with metadata stored in Supabase file_attachments table. See ADR-0058 and SPEC-0036.
 */
⋮----
import {
  ATTACHMENT_ALLOWED_MIME_TYPES,
  ATTACHMENT_MAX_FILE_SIZE,
  ATTACHMENT_MAX_FILES,
  ATTACHMENT_MAX_TOTAL_SIZE,
  isAllowedMimeType,
  sanitizeFilename,
} from "@schemas/attachments";
import { fileTypeFromBuffer } from "file-type";
import { revalidateTag } from "next/cache";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, requireUserId } from "@/lib/api/route-helpers";
import { bumpTag } from "@/lib/cache/tags";
import { secureUuid } from "@/lib/security/random";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
import { recordErrorOnActiveSpan } from "@/lib/telemetry/span";
⋮----
/** Storage bucket name for chat attachments. */
⋮----
/**
 * Validates files from form data for upload.
 *
 * @param formData - FormData object containing files.
 * @returns Validation result with files or error response.
 */
function validateUploadFiles(
  formData: FormData
):
⋮----
/**
 * Verifies file MIME type using magic bytes.
 *
 * Compares detected MIME type from file contents against declared type.
 * Prevents malware disguised as allowed file types.
 *
 * @param buffer - File contents as Uint8Array.
 * @param declaredType - MIME type declared by client.
 * @returns Validation result with detected type or error.
 */
async function verifyMimeType(
  buffer: Uint8Array,
  declaredType: string
): Promise<
  | { valid: true; detectedType: string }
  | { detectedType?: string; reason: string; valid: false }
> {
  const detected = await fileTypeFromBuffer(buffer);
⋮----
// For files without detectable magic bytes (e.g., text/csv, text/plain),
// trust the declared type if it's in allowed list
⋮----
// Make detected MIME the source of truth - must be in allowed list
⋮----
// Require exact match - no category-based relaxation (prevents malware disguised as images)
⋮----
/** Result of a single file upload operation. */
interface UploadResult {
  file: File;
  path: string;
  detectedType?: string;
  errorKind?: "validation" | "storage";
  error: Error | null;
}
⋮----
/**
 * Uploads a single file to Supabase Storage.
 *
 * @param file - File to upload.
 * @param userId - User ID for path prefix.
 * @param supabase - Supabase client.
 * @returns Upload result with path or error.
 */
async function uploadToSupabaseStorage(
  file: File,
  userId: string,
  supabase: TypedServerSupabase
): Promise<UploadResult>
⋮----
// Path format per SPEC-0036: chat/{userId}/filename
⋮----
// Convert File to Buffer for magic byte verification
⋮----
// Verify MIME type using magic bytes
⋮----
// Upload to Supabase Storage
⋮----
/**
 * Deletes a file from Supabase Storage.
 *
 * @param path - File path within the bucket.
 * @param supabase - Supabase client.
 */
async function deleteFromStorage(
  path: string,
  supabase: TypedServerSupabase
): Promise<void>
⋮----
/** Shape of an uploaded file record in the response. */
interface UploadedFileRecord {
  id: string;
  name: string;
  size: number;
  status: "uploading" | "completed" | "failed";
  type: string;
  url: string | null;
}
⋮----
// Validate content type
⋮----
// Enforce total size limit before buffering
⋮----
// Extract and validate user ID
⋮----
// Parse form data
⋮----
// Validate and extract files
⋮----
// Upload files to Supabase Storage in parallel
⋮----
// Process upload results and store metadata
⋮----
const uploadedPaths: string[] = []; // Track successful uploads for cleanup
const insertedAttachmentIds: string[] = []; // Track inserted metadata for rollback
⋮----
// Upload promise itself rejected (unexpected error)
⋮----
continue; // Don't return yet - need to cleanup uploaded files
⋮----
// Upload returned an error (validation or storage error)
⋮----
continue; // Don't return yet - need to cleanup uploaded files
⋮----
// Track this successful upload for potential cleanup
⋮----
// Generate file ID for metadata
⋮----
// Insert metadata into Supabase
// Note: filename = storage key (UUID), original_filename = user-facing name
⋮----
filename: fileId, // Storage key (UUID)
⋮----
original_filename: file.name, // User-facing name
⋮----
// Clean up uploaded file on metadata failure
⋮----
// Mark this file as failed but continue with others
⋮----
// Generate signed URL for the uploaded file (1 hour expiry)
⋮----
// If any upload failed, cleanup all successfully uploaded files
⋮----
// Delete all successfully uploaded files
⋮----
// Log cleanup failures but don't block the error response
⋮----
// Invalidate attachment caches
⋮----
// Ignore cache revalidation errors in non-Next runtime test environments
````

## File: src/app/api/chat/sessions/[id]/messages/route.ts
````typescript
/**
 * @fileoverview Chat session messages API route handlers.
 *
 * Methods: GET (list messages), POST (create message).
 */
⋮----
// Security: Route handlers are dynamic by default with Cache Components.
// Using withApiGuards({ auth: true }) ensures this route uses cookies/headers,
// making it dynamic and preventing caching of user-specific data.
⋮----
import { createMessageRequestSchema } from "@schemas/chat";
import type { NextRequest } from "next/server";
import type { RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import {
  parseJsonBody,
  parseStringId,
  requireUserId,
  validateSchema,
} from "@/lib/api/route-helpers";
import { createMessage, listMessages } from "../../_handlers";
⋮----
/**
 * Retrieves all messages for a specific chat session.
 *
 * @param req NextRequest object.
 * @param context Route context containing the session ID parameter.
 * @returns Promise resolving to Response with array of messages.
 */
export function GET(req: NextRequest, context:
⋮----
/**
 * Creates a new message in a specific chat session.
 *
 * Request body must contain message data.
 *
 * @param req NextRequest containing message data in body.
 * @param context Route context containing the session ID parameter.
 * @returns Promise resolving to Response with no content on success.
 */
export function POST(req: NextRequest, context:
⋮----
// Transform validated content to parts format expected by handler
````

## File: src/app/api/chat/sessions/[id]/route.ts
````typescript
/**
 * @fileoverview Chat session detail API route handlers.
 *
 * Methods: GET (get session if owned), DELETE (delete session owner only).
 */
⋮----
// Security: Route handlers are dynamic by default with Cache Components.
// Using withApiGuards({ auth: true }) ensures this route uses cookies/headers,
// making it dynamic and preventing caching of user-specific data.
⋮----
import type { NextRequest } from "next/server";
import type { RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import { parseStringId, requireUserId } from "@/lib/api/route-helpers";
import { deleteSession, getSession } from "../_handlers";
⋮----
/**
 * Retrieves a specific chat session if owned by the authenticated user.
 *
 * @param req NextRequest object.
 * @param context Route context containing the session ID parameter.
 * @returns Promise resolving to Response with session data or error.
 */
export function GET(
  req: NextRequest,
  context: { params: Promise<{ id: string }> }
): Promise<Response>
⋮----
/**
 * Deletes a specific chat session if owned by the authenticated user.
 *
 * @param req NextRequest object.
 * @param context Route context containing the session ID parameter.
 * @returns Promise resolving to Response with no content or error.
 */
export function DELETE(
  req: NextRequest,
  context: { params: Promise<{ id: string }> }
): Promise<Response>
````

## File: src/app/api/chat/sessions/_handlers.ts
````typescript
/**
 * @fileoverview DI handlers for chat sessions/messages routes.
 *
 * These handlers encapsulate CRUD operations for chat sessions and messages.
 * Adapters (route.ts files) provide SSR-only dependencies and translate the
 * HTTP details to simple POJOs used here.
 *
 * All handlers accept `userId` as a parameter since the route adapter already
 * guarantees authentication via `withApiGuards({ auth: true })`.
 */
import { NextResponse } from "next/server";
import { errorResponse, notFoundResponse } from "@/lib/api/route-helpers";
import { nowIso, secureUuid } from "@/lib/security/random";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { insertSingle } from "@/lib/supabase/typed-helpers";
⋮----
/**
 * Dependencies interface for sessions handlers.
 */
export interface SessionsDeps {
  supabase: TypedServerSupabase;
  userId: string;
}
⋮----
/**
 * Create a chat session owned by the authenticated user.
 * @param deps Collaborators with Supabase client and authenticated userId.
 * @param title Optional title (stored in metadata).
 */
export async function createSession(
  deps: SessionsDeps,
  title?: string
): Promise<Response>
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
/**
 * List sessions for the authenticated user.
 */
export async function listSessions(deps: SessionsDeps): Promise<Response>
⋮----
/**
 * Get a single session by id (owner-only).
 */
export async function getSession(deps: SessionsDeps, id: string): Promise<Response>
⋮----
/**
 * Delete a session by id (owner-only).
 */
export async function deleteSession(deps: SessionsDeps, id: string): Promise<Response>
⋮----
/**
 * List messages for a session.
 */
export async function listMessages(deps: SessionsDeps, id: string): Promise<Response>
⋮----
/**
 * Create a message within a session for the authenticated user.
 */
export async function createMessage(
  deps: SessionsDeps,
  id: string,
  payload: { role?: string; parts?: unknown[] }
): Promise<Response>
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
````

## File: src/app/api/chat/sessions/route.ts
````typescript
/**
 * @fileoverview Chat sessions API route handlers.
 *
 * Methods: POST (create session), GET (list sessions for current user).
 */
⋮----
// Security: Route handlers are dynamic by default with Cache Components.
// Using withApiGuards({ auth: true }) ensures this route uses cookies/headers,
// making it dynamic and preventing caching of user-specific data.
⋮----
import type { NextRequest } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { parseJsonBody, requireUserId } from "@/lib/api/route-helpers";
import { createSession, listSessions } from "./_handlers";
⋮----
/**
 * Creates a new chat session for the authenticated user.
 *
 * Request body may contain optional `title` field.
 *
 * @param req NextRequest containing optional title in body.
 * @returns Promise resolving to Response with created session ID.
 */
⋮----
// Title is optional, so gracefully handle parsing errors
⋮----
/**
 * Retrieves all chat sessions for the authenticated user.
 *
 * @returns Promise resolving to Response with array of user's chat sessions.
 */
````

## File: src/app/api/chat/stream/_handler.ts
````typescript
/**
 * @fileoverview Pure handler for chat streaming using AI SDK v6 ToolLoopAgent.
 *
 * The handler composes validation, memory hydration, and ToolLoopAgent-based
 * streaming. It is fully dependency-injected to ensure deterministic tests.
 *
 * Uses createAgentUIStreamResponse for proper agent loop handling with
 * autonomous multi-step tool execution.
 */
⋮----
import {
  CHAT_DEFAULT_SYSTEM_PROMPT,
  type ChatAgentConfig,
  createChatAgent,
  validateChatMessages,
} from "@ai/agents";
import type { ProviderResolution } from "@schemas/providers";
import type { UIMessage } from "ai";
import { createAgentUIStreamResponse } from "ai";
import { handleMemoryIntent } from "@/lib/memory/orchestrator";
import {
  assistantResponseToMemoryTurn,
  persistMemoryTurn,
  uiMessageToMemoryTurn,
} from "@/lib/memory/turn-utils";
import { secureUuid } from "@/lib/security/random";
import type { InsertTables, Json } from "@/lib/supabase/database.types";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { insertSingle } from "@/lib/supabase/typed-helpers";
⋮----
/**
 * Function type for resolving AI provider configurations.
 *
 * @param userId - The user ID for the chat.
 * @param modelHint - An optional model hint to resolve.
 * @returns Promise resolving to a ProviderResolution.
 */
export type ProviderResolver = (
  userId: string,
  modelHint?: string
) => Promise<ProviderResolution>;
⋮----
/**
 * Function type for rate limiting requests.
 *
 * @param identifier - The identifier for the chat.
 * @returns Promise resolving to a dict with success, limit, remaining, and reset.
 */
export type RateLimiter = (identifier: string) => Promise<{
  success: boolean;
  limit?: number;
  remaining?: number;
  reset?: number;
}>;
⋮----
/**
 * Interface defining dependencies required for chat stream handling.
 *
 * All dependencies are injected to enable deterministic testing and
 * avoid module-scope state per AGENTS.md requirements.
 */
export interface ChatDeps {
  supabase: TypedServerSupabase;
  resolveProvider: ProviderResolver;
  limit?: RateLimiter;
  logger?: {
    info: (msg: string, meta?: Record<string, unknown>) => void;
    error: (msg: string, meta?: Record<string, unknown>) => void;
  };
  clock?: { now: () => number };
  config?: { defaultMaxTokens?: number };
}
⋮----
/**
 * Type representing the payload for chat streaming.
 */
export interface ChatPayload {
  messages?: UIMessage[];
  sessionId?: string;
  model?: string;
  desiredMaxTokens?: number;
  ip?: string;
}
⋮----
/**
 * Handles chat streaming requests using AI SDK v6 ToolLoopAgent.
 *
 * This implementation uses createAgentUIStreamResponse for proper agent loop
 * handling with autonomous tool execution. The agent runs until a stop
 * condition is met (default: 10 steps).
 *
 * @param deps - Dependencies required for chat stream handling.
 * @param payload - Chat request payload containing messages and configuration.
 * @returns Promise resolving to a Response with streamed chat data.
 */
export async function handleChatStream(
  deps: ChatDeps,
  payload: ChatPayload
): Promise<Response>
⋮----
// SSR auth via injected supabase
⋮----
// Rate limit
⋮----
// Validate attachments
⋮----
// Provider resolution
⋮----
// Memory hydration: fetch context summary for system prompt enrichment
⋮----
// Memory enrichment is best-effort; ignore orchestrator failures
⋮----
// Persist user message to memory
⋮----
// Configure the chat agent
⋮----
// Create the chat agent using ToolLoopAgent
⋮----
// Use createAgentUIStreamResponse for proper agent loop handling
⋮----
// Handle errors during streaming
⋮----
// Handle stream completion for memory persistence and logging
⋮----
// Persist assistant response to memory
⋮----
// Some deployments may expose request_id; keep optional to avoid schema breakage
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// Store requestId at top-level when column exists; otherwise remains in metadata
````

## File: src/app/api/chat/stream/route.ts
````typescript
/**
 * @fileoverview Hardened Next.js route handler for streaming chat responses.
 * - SSR auth via Supabase cookies
 * - Upstash Ratelimit sliding window (40/min)
 * - Provider registry + BYOK (SSR-only)
 * - Token clamping + usage metadata via messageMetadata
 * - Attachments mapping (image-only) and basic validation
 * - Minimal structured logs with redaction (no prompt logging)
 */
⋮----
import { resolveProvider } from "@ai/models/registry";
import type { UIMessage } from "ai";
import type { NextRequest } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { getClientIpFromHeaders, parseJsonBody } from "@/lib/api/route-helpers";
import { createServerLogger } from "@/lib/telemetry/logger";
import { handleChatStream } from "./_handler";
⋮----
// Allow streaming responses for up to 60 seconds
⋮----
/**
 * Type definition for the incoming request body structure.
 */
type IncomingBody = {
  messages?: UIMessage[];
  sessionId?: string;
  model?: string;
  desiredMaxTokens?: number;
};
⋮----
/**
 * Handles POST requests for streaming chat responses with AI SDK.
 *
 * Performs authentication, rate limiting, provider resolution, token budgeting,
 * memory integration, and streams AI responses with comprehensive error handling
 * and usage metadata.
 *
 * @param req - The Next.js request object.
 * @param routeContext - Route context from withApiGuards
 * @returns Promise resolving to a Response with streamed chat data.
 */
⋮----
// Parse with fallback to empty messages
⋮----
limit: undefined, // Rate limiting handled by factory
````

## File: src/app/api/config/agents/[agentType]/rollback/[versionId]/route.ts
````typescript
/**
 * @fileoverview Agent configuration rollback API.
 * Route: POST /api/config/agents/[agentType]/rollback/[versionId]
 */
⋮----
import {
  type AgentConfig,
  agentTypeSchema,
  configurationAgentConfigSchema,
} from "@schemas/configuration";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { z } from "zod";
import type { RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import {
  errorResponse,
  parseStringId,
  requireUserId,
  validateSchema,
} from "@/lib/api/route-helpers";
import { bumpTag } from "@/lib/cache/tags";
import { ensureAdmin, scopeSchema } from "@/lib/config/helpers";
import { nowIso, secureId } from "@/lib/security/random";
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
⋮----
/**
 * Builds a rollback configuration for an agent.
 *
 * @param existing - The existing agent configuration.
 * @param scope - The scope of the agent configuration.
 * @returns The rollback configuration.
 */
function buildRollbackConfig(existing: AgentConfig, scope: string): AgentConfig
⋮----
/**
 * POST /api/config/agents/[agentType]/rollback/[versionId]
 *
 * Rolls back an agent configuration to a previous version.
 * Only allows admins to rollback configurations.
 */
⋮----
// Extract and validate agentType from route params and catch any errors
````

## File: src/app/api/config/agents/[agentType]/versions/route.ts
````typescript
/**
 * @fileoverview Agent configuration version history API.
 * Route: GET /api/config/agents/[agentType]/versions
 */
⋮----
import { agentTypeSchema } from "@schemas/configuration";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { z } from "zod";
import type { RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, parseStringId, validateSchema } from "@/lib/api/route-helpers";
import { ensureAdmin, scopeSchema } from "@/lib/config/helpers";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
const parseScopeParam = (raw: string | null)
````

## File: src/app/api/config/agents/[agentType]/route.ts
````typescript
/**
 * @fileoverview Agent configuration read/update API.
 * Routes: GET/PUT /api/config/agents/[agentType]
 * - Authenticated admin-only via RLS + explicit check.
 * - GET resolves active config (cached) via resolver.
 * - PUT validates input, builds config payload, upserts via Supabase function, and bumps cache tags.
 */
⋮----
import {
  type AgentConfig,
  type AgentType,
  agentConfigRequestSchema,
  agentTypeSchema,
  configurationAgentConfigSchema,
} from "@schemas/configuration";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import type { z } from "zod";
import { resolveAgentConfig } from "@/lib/agents/config-resolver";
import type { RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import {
  errorResponse,
  parseJsonBody,
  parseStringId,
  requireUserId,
  validateSchema,
} from "@/lib/api/route-helpers";
import { bumpTag } from "@/lib/cache/tags";
import { ensureAdmin, scopeSchema } from "@/lib/config/helpers";
import { nowIso, secureId } from "@/lib/security/random";
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { recordTelemetryEvent, withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
const parseScopeParam = (raw: string | null)
⋮----
function buildConfigPayload(
  agentType: AgentType,
  scope: string,
  body: z.infer<typeof configUpdateBodySchema>,
  existing?: AgentConfig
): AgentConfig
````

## File: src/app/api/dashboard/route.ts
````typescript
/**
 * @fileoverview Dashboard metrics API route handler.
 *
 * Returns aggregated dashboard metrics with time window filtering.
 * Uses aggregation with Redis cache-aside handled inside `aggregateDashboardMetrics`.
 *
 * Auth: Required
 * Rate limit: dashboard:metrics (30 req/min)
 */
⋮----
import {
  dashboardMetricsSchema,
  dashboardQuerySchema,
  windowToHours,
} from "@schemas/dashboard";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { validateSchema } from "@/lib/api/route-helpers";
import { aggregateDashboardMetrics } from "@/lib/metrics/aggregate";
⋮----
/**
 * GET /api/dashboard
 *
 * Returns aggregated dashboard metrics.
 *
 * Query Parameters:
 * - window: Time window for metrics ("24h" | "7d" | "30d" | "all")
 *
 * Response:
 * - 200: Dashboard metrics object
 * - 400: Bad request (invalid query parameters)
 * - 401: Unauthorized
 * - 429: Rate limit exceeded
 * - 500: Internal server error
 */
⋮----
// Parse and validate query parameters
⋮----
// Aggregate metrics
⋮----
// Validate response shape (defense in depth)
````

## File: src/app/api/flights/popular-destinations/route.ts
````typescript
/**
 * @fileoverview API route returning cached popular flight destinations.
 */
⋮----
import type { User } from "@supabase/supabase-js";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import type { TypedServerSupabase } from "@/lib/supabase/server";
⋮----
/** Popular destination returned to the client. */
interface PopularDestination {
  code: string;
  name: string;
  savings?: string;
  country?: string;
}
⋮----
/** Row from the search_flights table. */
type SearchFlightsDestinationRow = {
  destination: string | null;
};
⋮----
const POPULAR_DESTINATIONS_TTL_SECONDS = 60 * 60; // 1 hour
⋮----
/** Global popular destinations. */
⋮----
/**
 * Resolves the user from the context or the database.
 *
 * @param supabase - Supabase client instance
 * @param userFromContext - User from the context
 * @returns Promise resolving to the user or null if no user is found
 */
async function resolveUser(
  supabase: TypedServerSupabase,
  userFromContext: User | null
): Promise<User | null>
⋮----
/**
 * Fetches personalized destinations for a user from the search_flights table.
 *
 * @param supabase - Supabase client instance
 * @param userId - User ID
 * @returns Promise resolving to an array of PopularDestination
 *          objects or null if no destinations are found
 */
async function fetchPersonalizedDestinations(
  supabase: TypedServerSupabase,
  userId: string
): Promise<PopularDestination[] | null>
⋮----
/**
 * Handles GET /api/flights/popular-destinations.
 *
 * @param _req - Request object
 * @param contextUser - User from the context
 * @param supabase - Supabase client instance
 * @returns Promise resolving to a NextResponse with the popular destinations
 */
````

## File: src/app/api/flights/popular-routes/route.ts
````typescript
/**
 * @fileoverview API route returning cached popular flight routes.
 */
⋮----
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import { POPULAR_ROUTES_CACHE_KEY_GLOBAL } from "@/lib/flights/popular-routes-cache";
⋮----
/**
 * Popular flight route entry returned to the client.
 *
 * @property {string} date - ISO date string (YYYY-MM-DD) for the example flight date.
 * @property {string} destination - Destination city/market name.
 * @property {string} origin - Origin city/market name.
 * @property {number} price - Example price shown to the user.
 */
interface PopularRoute {
  date: string;
  destination: string;
  origin: string;
  price: number;
}
⋮----
const POPULAR_ROUTES_TTL_SECONDS = 24 * 60 * 60; // 24 hours
⋮----
/**
 * Builds a static list of popular flight routes for the next year.
 *
 * @returns Array of popular routes with example dates, destinations, and prices.
 */
function buildGlobalPopularRoutes(): PopularRoute[]
⋮----
/**
 * Handles GET /api/flights/popular-routes.
 *
 * @returns Popular routes list.
 */
````

## File: src/app/api/flights/search/route.ts
````typescript
/**
 * @fileoverview Flight search API route.
 *
 * POST /api/flights/search
 * Searches for flights using Duffel provider.
 */
⋮----
import { searchFlightsService } from "@domain/flights/service";
import { flightSearchRequestSchema } from "@schemas/flights";
import { withApiGuards } from "@/lib/api/factory";
⋮----
auth: false, // Allow anonymous searches
⋮----
// Note: The flights service performs its own validation via
// flightSearchRequestSchema.parse(params) because it is invoked from multiple
// entry points (including AI tools) that bypass withApiGuards. It also
// intentionally omits ServiceContext/userId and rate limiting at the service
// layer—unlike accommodations—by API design.
````

## File: src/app/api/geocode/route.ts
````typescript
/**
 * @fileoverview Google Maps Geocoding API wrapper endpoint.
 *
 * Thin wrapper for Geocoding API with compliance and caching TTL limits.
 * Enforces 30-day max TTL for cached lat/lng per Google Maps Platform policy.
 */
⋮----
import {
  type GeocodeRequest,
  geocodeRequestSchema,
  upstreamGeocodeResponseSchema,
} from "@schemas/api";
import { type NextRequest, NextResponse } from "next/server";
import type { z } from "zod";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { cacheLatLng, getCachedLatLng } from "@/lib/google/caching";
import { getGeocode, getReverseGeocode } from "@/lib/google/client";
⋮----
async function parseAndValidateGeocodeResponse(
  response: Response
): Promise<
  | { data: z.output<typeof upstreamGeocodeResponseSchema> }
  | { error: ReturnType<typeof errorResponse> }
> {
  let rawData: unknown;
  try {
    rawData = await response.json();
⋮----
/**
 * POST /api/geocode
 *
 * Geocode an address to coordinates or reverse geocode coordinates to address.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with geocoding results
 */
⋮----
// Forward geocoding: address -> lat/lng
⋮----
// Check cache
⋮----
// Cache with 30-day max TTL
⋮----
// Reverse geocoding: lat/lng -> address
````

## File: src/app/api/hooks/cache/route.ts
````typescript
/**
 * @fileoverview Cache invalidation webhook handler for database changes.
 *
 * Uses the shared webhook handler abstraction and cache registry.
 * Adds idempotency to prevent unnecessary cache version bumps.
 */
⋮----
import { getTagsForTable } from "@/lib/cache/registry";
import { bumpTags } from "@/lib/cache/tags";
import { createWebhookHandler } from "@/lib/webhooks/handler";
⋮----
/**
 * Handles database change webhooks to invalidate related cache tags.
 *
 * Features (via handler abstraction):
 * - Rate limiting (100 req/min per IP)
 * - Body size validation (64KB max)
 * - HMAC signature verification
 * - Idempotency via Redis (prevents duplicate cache bumps)
 */
⋮----
// Idempotency settings (grouped for readability)
⋮----
async handle(payload, _eventKey, span)
⋮----
// Get tags from centralized registry
⋮----
// Bump version counters for all affected tags
⋮----
idempotencyTTL: 60, // Cache invalidations can be replayed safely; shorter window avoids suppressing legitimate rapid updates
````

## File: src/app/api/hooks/files/route.ts
````typescript
/**
 * @fileoverview File attachment webhook handler for upload status changes.
 *
 * Uses the shared webhook handler abstraction to reduce boilerplate.
 */
⋮----
import { getAdminSupabase } from "@/lib/supabase/admin";
import type { Database } from "@/lib/supabase/database.types";
import { createWebhookHandler } from "@/lib/webhooks/handler";
⋮----
type FileAttachmentRow = Database["public"]["Tables"]["file_attachments"]["Row"];
⋮----
/**
 * Handles file attachment database change webhooks.
 *
 * Features (via handler abstraction):
 * - Rate limiting (100 req/min per IP)
 * - Body size validation (64KB max)
 * - HMAC signature verification
 * - Table filtering (file_attachments only)
 * - Idempotency via Redis
 */
⋮----
async handle(payload, _eventKey, span)
⋮----
// Verify file attachment exists on INSERT with uploading status
⋮----
throw error; // Will be caught by handler and return 500
````

## File: src/app/api/hooks/trips/route.ts
````typescript
/**
 * @fileoverview Trip collaborator webhook handler with async notification queuing.
 *
 * Uses the shared webhook handler abstraction to reduce boilerplate.
 * Enqueues notifications via QStash with ADR-0048 retry policy.
 */
⋮----
import { after } from "next/server";
import { sendCollaboratorNotifications } from "@/lib/notifications/collaborators";
import { tryEnqueueJob } from "@/lib/qstash/client";
import { getAdminSupabase } from "@/lib/supabase/admin";
import type { Database } from "@/lib/supabase/database.types";
import { createServerLogger } from "@/lib/telemetry/logger";
import { recordErrorOnSpan, withTelemetrySpan } from "@/lib/telemetry/span";
import { createWebhookHandler } from "@/lib/webhooks/handler";
⋮----
type TripCollaboratorRow = Database["public"]["Tables"]["trip_collaborators"]["Row"];
⋮----
/**
 * Handles trip collaborator database change webhooks with async notification processing.
 *
 * Features (via handler abstraction):
 * - Rate limiting (100 req/min per IP)
 * - Body size validation (64KB max)
 * - HMAC signature verification
 * - Table filtering (trip_collaborators only)
 * - Idempotency via Redis
 */
⋮----
async handle(payload, eventKey, span)
⋮----
// Validate trip exists (optional integrity check)
⋮----
throw error; // Will be caught by handler and return 500
⋮----
// Primary path: enqueue to QStash worker for durable retries
⋮----
// Fallback: fire-and-forget via after() if QStash unavailable
⋮----
// Swallow to avoid rethrowing inside after(); span already recorded the error
````

## File: src/app/api/itineraries/route.ts
````typescript
/**
 * @fileoverview Itinerary items CRUD API route handlers.
 */
⋮----
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, parseJsonBody, requireUserId } from "@/lib/api/route-helpers";
import { createServerLogger } from "@/lib/telemetry/logger";
import { handleCreateItineraryItem, handleListItineraryItems } from "./_handler";
⋮----
/**
 * GET /api/itineraries
 *
 * Returns itinerary items, optionally filtered by tripId.
 */
⋮----
/**
 * POST /api/itineraries
 *
 * Creates a new itinerary item for the authenticated user.
 */
````

## File: src/app/api/keys/[service]/route.ts
````typescript
/**
 * @fileoverview BYOK delete route. Removes a user API key from Supabase Vault.
 * Route: DELETE /api/keys/[service]
 */
⋮----
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import type { RateLimitResult } from "@/app/api/keys/_rate-limiter";
import { buildKeySpanAttributes } from "@/app/api/keys/_telemetry";
import type { RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import {
  errorResponse,
  parseStringId,
  redactErrorForLogging,
  requireUserId,
} from "@/lib/api/route-helpers";
import { deleteUserApiKey, deleteUserGatewayBaseUrl } from "@/lib/supabase/rpc";
import { recordTelemetryEvent, withTelemetrySpan } from "@/lib/telemetry/span";
import { vaultUnavailableResponse } from "../_error-mapping";
⋮----
type IdentifierType = "user" | "ip";
⋮----
/**
 * Handle DELETE /api/keys/[service] to remove a user's provider API key.
 *
 * @param req Next.js request.
 * @param context Route params including the service identifier.
 * @param routeContext Route context from withApiGuards
 * @returns 204 No Content on success; 400/401/429/500 on error.
 */
export function DELETE(
  req: NextRequest,
  context: { params: Promise<{ service: string }> }
): Promise<Response>
⋮----
// Custom telemetry handled below
⋮----
// Rate limit metadata not available from factory, using undefined for custom telemetry
````

## File: src/app/api/keys/_error-mapping.ts
````typescript
import { errorResponse } from "@/lib/api/route-helpers";
⋮----
export type PlannedErrorCode =
  (typeof PLANNED_ERROR_CODES)[keyof typeof PLANNED_ERROR_CODES];
⋮----
export function vaultUnavailableResponse(reason: string, err?: unknown): Response
⋮----
export function mapProviderStatusToCode(status: number): PlannedErrorCode
⋮----
export function mapProviderExceptionToCode(_error: unknown): PlannedErrorCode
````

## File: src/app/api/keys/_handlers.ts
````typescript
/**
 * @fileoverview DI handlers for BYOK key routes (POST/GET).
 *
 * These handlers encapsulate the business logic for API key storage and
 * retrieval. The Next.js route adapters handle SSR-only concerns and pass in
 * typed dependencies.
 *
 * All handlers accept `userId` as a parameter since the route adapter already
 * guarantees authentication via `withApiGuards({ auth: true })`.
 */
⋮----
import type { PostKeyBody } from "@schemas/api";
import { NextResponse } from "next/server";
import { errorResponse } from "@/lib/api/route-helpers";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { vaultUnavailableResponse } from "./_error-mapping";
⋮----
/** Set of allowed API service providers for key storage. */
⋮----
/**
 * Dependencies interface for keys handlers.
 */
export interface KeysDeps {
  supabase: TypedServerSupabase;
  userId: string;
  insertUserApiKey: (userId: string, service: string, apiKey: string) => Promise<void>;
  upsertUserGatewayBaseUrl?: (userId: string, baseUrl: string) => Promise<void>;
}
⋮----
/**
 * Insert or replace a user's provider API key.
 *
 * Expects a validated body from postKeyBodySchema. Service normalization and
 * validation are performed here before calling the RPC.
 *
 * @param deps Collaborators with a typed Supabase client, authenticated userId, and RPC inserter.
 * @param body Validated payload containing service and apiKey.
 * @returns 204 on success; otherwise a JSON error Response.
 */
export async function postKey(deps: KeysDeps, body: PostKeyBody): Promise<Response>
⋮----
// Normalize service names once so every adapter and RPC sees the canonical lowercase id.
⋮----
// If service is gateway and baseUrl provided, persist base URL metadata
⋮----
/**
 * List key metadata for the authenticated user.
 *
 * @param deps Collaborators with a typed Supabase client and authenticated userId.
 * @returns List of key summaries or an error Response.
 */
export async function getKeys(deps: {
  supabase: TypedServerSupabase;
  userId: string;
}): Promise<Response>
⋮----
type ApiKeyRow = {
    // biome-ignore lint/style/useNamingConvention: mirrors DB columns
    created_at: string | null;
    // biome-ignore lint/style/useNamingConvention: mirrors DB columns
    last_used: string | null;
    service: string;
  };
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors DB columns
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors DB columns
````

## File: src/app/api/memory/context/[userId]/route.ts
````typescript
/**
 * @fileoverview Memory context API route.
 *
 * Returns user memory context using the memory orchestrator.
 * Server-only route that uses handleMemoryIntent for fetchContext.
 */
⋮----
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, requireUserId } from "@/lib/api/route-helpers";
import { handleMemoryIntent } from "@/lib/memory/orchestrator";
⋮----
/**
 * GET /api/memory/context/[userId]
 *
 * Fetch memory context for a user using the orchestrator.
 */
````

## File: src/app/api/memory/conversations/route.ts
````typescript
/**
 * @fileoverview Conversation memory API route.
 *
 * Adds conversation memory using memory tools.
 * Server-only route that uses addConversationMemory tool.
 */
⋮----
import { addConversationMemory } from "@ai/tools";
import {
  type MemoryAddConversationRequest,
  memoryAddConversationSchema,
} from "@schemas/memory";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
⋮----
/**
 * POST /api/memory/conversations
 *
 * Add conversation memory using memory tools.
 */
⋮----
// AI SDK tools require context parameter (toolCallId, messages)
````

## File: src/app/api/memory/insights/[userId]/route.ts
````typescript
/**
 * @fileoverview Memory insights API route.
 *
 * Returns user memory insights using the memory orchestrator.
 * Server-only route that aggregates memory context for insights.
 */
⋮----
import { resolveProvider } from "@ai/models/registry";
import type { MemoryContextResponse } from "@schemas/chat";
import type { MemoryInsightsResponse } from "@schemas/memory";
import { MEMORY_INSIGHTS_RESPONSE_SCHEMA } from "@schemas/memory";
import { generateText, Output } from "ai";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, requireUserId } from "@/lib/api/route-helpers";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import { handleMemoryIntent } from "@/lib/memory/orchestrator";
import {
  FILTERED_MARKER,
  sanitizeWithInjectionDetection,
} from "@/lib/security/prompt-sanitizer";
import { nowIso } from "@/lib/security/random";
import { createServerLogger } from "@/lib/telemetry/logger";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
⋮----
/**
 * GET /api/memory/insights/[userId]
 *
 * Generates personalized travel memory insights for an authenticated user.
 *
 * Retrieves memory context from the orchestrator, generates AI-powered insights
 * (budget patterns, destination preferences, travel personality), and returns
 * structured analysis. Results are cached for performance. Falls back to
 * low-confidence insights if AI generation fails.
 *
 * @param _req - The incoming HTTP request (unused).
 * @param user - Authenticated user context (from `withApiGuards`).
 * @returns JSON response with memory insights, or an error response.
 *
 * **Response codes:**
 * - `200`: Insights generated successfully (may be fallback if AI fails).
 * - `401`: User not authenticated.
 * - `429`: Rate limit exceeded.
 * - `500`: Internal server error during memory retrieval or processing.
 */
⋮----
/**
 * Formats memory context items into a human-readable summary string.
 *
 * Each memory is numbered and includes its relevance score. Items are separated
 * by dividers for clarity. Content is sanitized to prevent prompt injection.
 *
 * @param contextItems - Array of memory context responses to summarize.
 * @returns Formatted summary string, or "No memories available." if empty.
 */
function buildContextSummary(contextItems: MemoryContextResponse[]): string
⋮----
// Sanitize memory content to prevent prompt injection from stored user data
⋮----
/**
 * Constructs the prompt for AI-powered memory insights generation.
 *
 * Provides instructions for analyzing memory snippets and generating structured
 * insights focusing on budget patterns, destination preferences, travel
 * personality, and recommendations.
 *
 * @param contextSummary - Formatted summary of memory context items.
 * @param count - Number of memory snippets being analyzed.
 * @returns Complete prompt string for the AI model.
 */
function buildInsightsPrompt(contextSummary: string, count: number): string
⋮----
/**
 * Estimates the temporal coverage of memory data in months.
 *
 * Uses a heuristic approximation: 3 memories ≈ 1 month of coverage. Returns
 * a value between 1 and 12 months, or 0 if no memories are available.
 *
 * @param contextItems - Array of memory context responses.
 * @returns Estimated coverage in months (0-12).
 */
function estimateDataCoverageMonths(contextItems: MemoryContextResponse[]): number
⋮----
// Lacking timestamps, approximate coverage by volume (3 memories ≈ 1 month).
⋮----
/**
 * Generates fallback insights when AI generation fails.
 *
 * Returns a low-confidence response structure with empty or minimal data,
 * indicating insufficient information for reliable analysis. Confidence level
 * is set based on whether any memory data exists.
 *
 * @param contextItems - Array of memory context responses (may be empty).
 * @returns Fallback insights response with `success: false` and low confidence.
 */
function buildFallbackInsights(
  contextItems: MemoryContextResponse[]
): MemoryInsightsResponse
````

## File: src/app/api/memory/preferences/[userId]/route.ts
````typescript
/**
 * @fileoverview Memory preferences API route.
 *
 * Updates user preferences using memory tools.
 * Server-only route that uses addConversationMemory tool.
 */
⋮----
import { addConversationMemory } from "@ai/tools";
import {
  type MemoryUpdatePreferencesRequest,
  memoryUpdatePreferencesSchema,
} from "@schemas/memory";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
⋮----
/**
 * POST /api/memory/preferences/[userId]
 *
 * Update user preferences using memory tools.
 */
⋮----
// Store preferences as memory entries
⋮----
// AI SDK tools require context parameter (toolCallId, messages)
````

## File: src/app/api/memory/search/route.ts
````typescript
/**
 * @fileoverview Memory search API route.
 *
 * Searches user memories using the memory orchestrator.
 * Server-only route that uses handleMemoryIntent for fetchContext with filtering.
 */
⋮----
import { type MemorySearchRequest, memorySearchRequestSchema } from "@schemas/memory";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, requireUserId } from "@/lib/api/route-helpers";
import { handleMemoryIntent } from "@/lib/memory/orchestrator";
import { nowIso, secureUuid } from "@/lib/security/random";
⋮----
/**
 * POST /api/memory/search
 *
 * Search user memories using the orchestrator.
 */
⋮----
// Apply query filter if provided
````

## File: src/app/api/memory/stats/[userId]/route.ts
````typescript
/**
 * @fileoverview Memory statistics API route.
 *
 * Returns user memory statistics using the memory orchestrator.
 * Server-only route that queries memory context for stats.
 */
⋮----
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, requireUserId } from "@/lib/api/route-helpers";
import { handleMemoryIntent } from "@/lib/memory/orchestrator";
⋮----
/**
 * GET /api/memory/stats/[userId]
 *
 * Fetch memory statistics for a user using the orchestrator.
 */
⋮----
limit: 100, // Get more for stats
````

## File: src/app/api/memory/user/[userId]/route.ts
````typescript
/**
 * @fileoverview Delete user memories API route.
 *
 * Deletes user memories from the memories schema.
 * Server-only route that directly deletes from memories.turns.
 */
⋮----
import { NextResponse } from "next/server";
import type { RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import {
  errorResponse,
  forbiddenResponse,
  parseStringId,
  requireUserId,
} from "@/lib/api/route-helpers";
import { createAdminSupabase } from "@/lib/supabase/admin";
⋮----
/**
 * POST /api/memory/user/[userId]
 *
 * Delete all memories for a user.
 * Only allows users to delete their own memories.
 */
⋮----
// Extract and validate userId from route params
⋮----
// Only allow users to delete their own memories
⋮----
// Delete turns and sessions in parallel since they're independent operations
⋮----
// Check for errors and provide specific error messages
````

## File: src/app/api/places/details/[id]/route.ts
````typescript
/**
 * @fileoverview Google Places API (New) Place Details endpoint.
 *
 * Server-side route for Place Details with minimal field mask. Terminates
 * autocomplete sessions when called after autocomplete selection.
 */
⋮----
import {
  type PlacesDetailsRequest,
  placesDetailsRequestSchema,
  upstreamPlaceSchema,
} from "@schemas/api";
import { type NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import type { RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, parseStringId, validateSchema } from "@/lib/api/route-helpers";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { getPlaceDetails } from "@/lib/google/client";
⋮----
/**
 * GET /api/places/details/[id]
 *
 * Get place details using Google Places API (New) Place Details.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @param routeParams - Route parameters containing id
 * @returns JSON response with place details
 */
export function GET(req: NextRequest, context:
⋮----
// Field mask: minimal fields for place details
⋮----
// Client validation errors (e.g., invalid placeId format)
⋮----
// Validate upstream response
````

## File: src/app/api/places/nearby/route.ts
````typescript
/**
 * @fileoverview Google Places API (New) Nearby Search endpoint.
 *
 * Server-side route for finding nearby landmarks, transit, and points of interest.
 * Used to enrich hotel listings with location context.
 */
⋮----
import {
  type PlacesNearbyRequest,
  placesNearbyRequestSchema,
  upstreamPlaceSchema,
} from "@schemas/api";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { postNearbySearch } from "@/lib/google/client";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
⋮----
/**
 * Field mask for nearby search results.
 */
⋮----
/**
 * POST /api/places/nearby
 *
 * Search for nearby places using Google Places API (New) Nearby Search.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with nearby places
 */
````

## File: src/app/api/places/photo/route.ts
````typescript
/**
 * @fileoverview Google Places API (New) Photo Media proxy endpoint.
 *
 * Proxies photo bytes from places.photos.getMedia with cache-friendly headers.
 * Does not persist photos server-side per Google Maps Platform policy.
 */
⋮----
import { placesPhotoRequestSchema } from "@schemas/api";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, validateSchema } from "@/lib/api/route-helpers";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { getPlacePhoto } from "@/lib/google/client";
⋮----
/**
 * GET /api/places/photo
 *
 * Proxy photo bytes from Google Places API (New) getMedia endpoint.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns Photo bytes with cache headers
 */
⋮----
// Stream photo bytes with cache-friendly headers
⋮----
"Cache-Control": "public, max-age=86400", // 24h client cache
````

## File: src/app/api/places/search/route.ts
````typescript
/**
 * @fileoverview Google Places API (New) Text Search endpoint.
 *
 * Server-side route for Places Text Search with field masks and location bias.
 * Complies with Google Maps Platform policies.
 */
⋮----
import {
  type PlacesSearchRequest,
  placesSearchRequestSchema,
  upstreamPlacesSearchResponseSchema,
} from "@schemas/api";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { postPlacesSearch } from "@/lib/google/client";
⋮----
/**
 * POST /api/places/search
 *
 * Search for places using Google Places API (New) Text Search.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with places search results
 */
⋮----
// Field mask: only fields we render
⋮----
// Parse JSON with error handling for malformed responses
⋮----
// Validate upstream response
````

## File: src/app/api/rag/index/_handler.ts
````typescript
/**
 * @fileoverview Pure handler for RAG indexing requests.
 *
 * Business logic lives here; route.ts should only wrap and delegate.
 */
⋮----
import type { RagIndexRequest } from "@schemas/rag";
import { NextResponse } from "next/server";
import { indexDocuments } from "@/lib/rag/indexer";
import type { TypedServerSupabase } from "@/lib/supabase/server";
⋮----
export interface RagIndexDeps {
  supabase: TypedServerSupabase;
}
⋮----
export async function handleRagIndex(
  deps: RagIndexDeps,
  body: RagIndexRequest
): Promise<Response>
````

## File: src/app/api/rag/index/route.ts
````typescript
/**
 * @fileoverview RAG document indexing endpoint.
 *
 * Batch indexes documents with chunking and embedding generation.
 * POST /api/rag/index
 */
⋮----
import { ragIndexRequestSchema } from "@schemas/rag";
import type { NextRequest } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { handleRagIndex } from "./_handler";
⋮----
/**
 * POST /api/rag/index
 *
 * Index documents into the RAG store with automatic chunking and embedding.
 *
 * @param req - Request with documents array.
 * @returns Index result with counts and failed documents. Always returns HTTP 200;
 *          partial success is conveyed via `success: false` and per-item failures.
 *
 * @example
 * ```bash
 * curl -X POST /api/rag/index \
 *   -H "Content-Type: application/json" \
 *   -d '{
 *     "documents": [{ "content": "Travel guide..." }],
 *     "namespace": "travel_tips",
 *     "chunkSize": 512
 *   }'
 * ```
 */
````

## File: src/app/api/rag/search/_handler.ts
````typescript
/**
 * @fileoverview Pure handler for RAG search requests.
 *
 * Business logic lives here; route.ts should only wrap and delegate.
 */
⋮----
import type { RagSearchRequest } from "@schemas/rag";
import { NextResponse } from "next/server";
import { createReranker } from "@/lib/rag/reranker";
import { retrieveDocuments } from "@/lib/rag/retriever";
import type { TypedServerSupabase } from "@/lib/supabase/server";
⋮----
export interface RagSearchDeps {
  supabase: TypedServerSupabase;
}
⋮----
export async function handleRagSearch(
  deps: RagSearchDeps,
  body: RagSearchRequest
): Promise<Response>
````

## File: src/app/api/rag/search/route.ts
````typescript
/**
 * @fileoverview RAG document search endpoint.
 *
 * Hybrid search with vector similarity, lexical matching, and reranking.
 * POST /api/rag/search
 */
⋮----
import { ragSearchRequestSchema } from "@schemas/rag";
import type { NextRequest } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { handleRagSearch } from "./_handler";
⋮----
/**
 * POST /api/rag/search
 *
 * Search documents using hybrid search with optional reranking.
 *
 * @param req - Request with search query and options.
 * @returns Search results with scores and metadata.
 *
 * @example
 * ```bash
 * curl -X POST /api/rag/search \
 *   -H "Content-Type: application/json" \
 *   -d '{
 *     "query": "best hotels in Paris",
 *     "namespace": "accommodations",
 *     "limit": 10,
 *     "useReranking": true
 *   }'
 * ```
 */
⋮----
auth: true, // Authentication required for search
````

## File: src/app/api/route-matrix/route.ts
````typescript
/**
 * @fileoverview Google Maps Routes API computeRouteMatrix endpoint.
 *
 * Server-side route for Routes API computeRouteMatrix with quota-aware batching.
 */
⋮----
import {
  type RouteMatrixRequest,
  routeMatrixRequestSchema,
  upstreamRouteMatrixResponseSchema,
} from "@schemas/api";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { parseNdjsonResponse, postComputeRouteMatrix } from "@/lib/google/client";
⋮----
/**
 * POST /api/route-matrix
 *
 * Compute route matrix using Google Maps Routes API computeRouteMatrix.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with route matrix data
 */
⋮----
// Quota-aware batching: limit origins/destinations
⋮----
// Field mask: request only fields needed by client
⋮----
// Parse NDJSON stream: computeRouteMatrix returns newline-delimited JSON
⋮----
// Validate upstream response (array of matrix entries)
````

## File: src/app/api/routes/route.ts
````typescript
/**
 * @fileoverview Google Maps Routes API computeRoutes endpoint.
 *
 * Server-side route for Routes API computeRoutes with explicit field masks
 * and retry/backoff logic.
 */
⋮----
import {
  type ComputeRoutesRequest,
  computeRoutesRequestSchema,
  upstreamRoutesResponseSchema,
} from "@schemas/api";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { postComputeRoutes } from "@/lib/google/client";
⋮----
/**
 * POST /api/routes
 *
 * Compute route using Google Maps Routes API computeRoutes.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with route data
 */
⋮----
// Field mask: only fields we render
⋮----
// Validate upstream response
````

## File: src/app/api/security/events/route.ts
````typescript
/**
 * @fileoverview Security events API. Returns recent auth audit events for the current user.
 */
⋮----
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { requireUserId } from "@/lib/api/route-helpers";
import { getUserSecurityEvents } from "@/lib/security/service";
import { createAdminSupabase } from "@/lib/supabase/admin";
⋮----
/**
 * GET handler for the security events API.
 *
 * @param _req - The Next.js request object.
 * @param user - The authenticated user.
 * @returns The security events.
 */
````

## File: src/app/api/security/metrics/route.ts
````typescript
/**
 * @fileoverview Security metrics API. Aggregates recent auth activity for the current user.
 */
⋮----
import { securityMetricsSchema } from "@schemas/security";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, requireUserId } from "@/lib/api/route-helpers";
import { getUserSecurityMetrics } from "@/lib/security/service";
import { createAdminSupabase } from "@/lib/supabase/admin";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** GET handler for the security metrics API. */
⋮----
// Log full validation error server-side for observability
⋮----
// Log unexpected errors server-side
````

## File: src/app/api/security/sessions/[sessionId]/route.ts
````typescript
/**
 * @fileoverview Route for deleting a specific active session for the authenticated user.
 */
⋮----
import type { NextRequest } from "next/server";
import { type RouteParamsContext, withApiGuards } from "@/lib/api/factory";
import { parseStringId, requireUserId } from "@/lib/api/route-helpers";
import { createAdminSupabase } from "@/lib/supabase/admin";
import { terminateSessionHandler } from "../_handlers";
⋮----
/** Deletes a specific active session for the authenticated user. */
````

## File: src/app/api/telemetry/activities/route.ts
````typescript
/**
 * @fileoverview Telemetry endpoint for activity booking events.
 *
 * Allows client-side booking interactions to be recorded via OTEL spans.
 */
⋮----
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { parseJsonBody } from "@/lib/api/route-helpers";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
⋮----
/** Shape of activity booking telemetry payloads accepted by this route. */
type ActivityTelemetryPayload = {
  attributes?: Record<string, string | number | boolean>;
  eventName: string;
  level?: "info" | "warning" | "error";
};
⋮----
/** Constants for telemetry validation. */
⋮----
/**
 * Validates the attributes object to ensure it only contains primitive values.
 *
 * @param attributes - The attributes object to validate.
 * @returns True if the attributes are valid, false otherwise.
 */
function validateAttributes(
  attributes?: Record<string, unknown>
): attributes is Record<string, string | number | boolean>
⋮----
/**
 * Record booking-related telemetry events from client interactions.
 *
 * Accepts JSON payloads and forwards them to OTEL spans without persisting user data.
 */
````

## File: src/app/api/timezone/route.ts
````typescript
/**
 * @fileoverview Google Maps Time Zone API wrapper endpoint.
 *
 * Thin wrapper for Time Zone API with compliance and caching TTL limits.
 */
⋮----
import {
  type TimezoneRequest,
  timezoneRequestSchema,
  upstreamTimezoneResponseSchema,
} from "@schemas/api";
import { type NextRequest, NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { getTimezone } from "@/lib/google/client";
⋮----
/**
 * POST /api/timezone
 *
 * Get time zone information for coordinates.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with timezone data
 */
⋮----
// Validate upstream response
````

## File: src/app/api/trips/[id]/route.ts
````typescript
/**
 * @fileoverview Trip detail route handlers (GET, PUT, DELETE).
 *
 * Provides per-trip CRUD for authenticated users with cache invalidation and
 * strict validation against Supabase schemas.
 */
⋮----
import { tripsRowSchema, tripsUpdateSchema } from "@schemas/supabase";
import { tripUpdateSchema } from "@schemas/trips";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import type { z } from "zod";
import { withApiGuards } from "@/lib/api/factory";
import {
  errorResponse,
  notFoundResponse,
  parseJsonBody,
  parseNumericId,
  requireUserId,
  validateSchema,
} from "@/lib/api/route-helpers";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { deleteSingle, getSingle, updateSingle } from "@/lib/supabase/typed-helpers";
import { mapDbTripToUi } from "@/lib/trips/mappers";
import { invalidateUserTripsCache } from "../_handler";
⋮----
/**
 * Maps validated trip update payload from camelCase API contract
 * to the database update shape expected by Supabase.
 *
 * @param payload - Validated trip update payload
 * @returns Database update object ready for Supabase
 */
function mapUpdatePayloadToDb(payload: z.infer<typeof tripUpdateSchema>)
⋮----
// API "preferences" maps to DB "flexibility" column
⋮----
/**
 * Fetches a trip by ID for the authenticated user.
 *
 * @param supabase - The Supabase client instance
 * @param userId - The authenticated user ID
 * @param tripId - The numeric ID of the trip to fetch
 * @returns The trip data in UI format or an error response
 */
async function getTripById(
  supabase: TypedServerSupabase,
  userId: string,
  tripId: number
)
⋮----
// Parse through schema to ensure type compatibility with mapDbTripToUi
⋮----
/**
 * Updates a trip by ID for the authenticated user.
 *
 * @param req - The incoming HTTP request
 * @param supabase - The Supabase client instance
 * @param userId - The authenticated user ID
 * @param tripId - The numeric ID of the trip to update
 * @returns The updated trip data in UI format or an error response
 */
async function updateTripById(
  req: NextRequest,
  supabase: TypedServerSupabase,
  userId: string,
  tripId: number
)
⋮----
// Parse through schema to ensure type compatibility with mapDbTripToUi
⋮----
/**
 * Deletes a trip by ID for the authenticated user.
 *
 * @param supabase - The Supabase client instance
 * @param userId - The authenticated user ID
 * @param tripId - The numeric ID of the trip to delete
 * @returns A success response or an error response
 */
async function deleteTripById(
  supabase: TypedServerSupabase,
  userId: string,
  tripId: number
)
⋮----
/**
 * GET /api/trips/[id] - Fetch a trip owned by the authenticated user.
 */
⋮----
/**
 * PUT /api/trips/[id] - Update a trip owned by the authenticated user.
 */
⋮----
/**
 * DELETE /api/trips/[id] - Delete a trip owned by the authenticated user.
 */
````

## File: src/app/api/trips/suggestions/route.ts
````typescript
/**
 * @fileoverview AI-generated trip suggestions with Upstash Redis caching.
 *
 * Generates trip suggestions using AI SDK v6 structured outputs.
 * Results cached per-user in Redis with 15-minute TTL to reduce
 * redundant AI calls while maintaining freshness.
 */
⋮----
import { resolveProvider } from "@ai/models/registry";
import type { TripSuggestion } from "@schemas/trips";
import { tripSuggestionSchema } from "@schemas/trips";
import { generateText, Output } from "ai";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { z } from "zod";
import { withApiGuards } from "@/lib/api/factory";
import { requireUserId } from "@/lib/api/route-helpers";
import { canonicalizeParamsForCache } from "@/lib/cache/keys";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import {
  isFilteredValue,
  sanitizeWithInjectionDetection,
} from "@/lib/security/prompt-sanitizer";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** Cache TTL for AI suggestions (15 minutes). */
⋮----
/**
 * Request query parameters for trip suggestion generation.
 */
interface TripSuggestionsQueryParams {
  readonly limit?: number;
  readonly budgetMax?: number;
  readonly category?: string;
}
⋮----
/**
 * Builds cache key for trip suggestions.
 *
 * @param userId - Authenticated user ID.
 * @param params - Query parameters.
 * @returns Redis cache key.
 */
function buildSuggestionsCacheKey(
  userId: string,
  params: TripSuggestionsQueryParams
): string
⋮----
/**
 * Parses query-string parameters into a normalized suggestion input object.
 *
 * @param req - Next.js request object for this route.
 * @returns Parsed query parameter object.
 */
function parseSuggestionQueryParams(req: NextRequest): TripSuggestionsQueryParams
⋮----
/**
 * Builds a model prompt for trip suggestions based on user filters.
 *
 * @param params - Parsed query parameters.
 * @returns Prompt string for the language model.
 */
function buildSuggestionPrompt(params: TripSuggestionsQueryParams): string
⋮----
// Sanitize category to prevent prompt injection (with injection detection)
⋮----
/**
 * Generates trip suggestions, checking cache first.
 *
 * @param userId - Authenticated user ID.
 * @param params - Parsed query parameters.
 * @returns Array of trip suggestions.
 */
async function generateSuggestionsWithCache(
  userId: string,
  params: TripSuggestionsQueryParams
): Promise<TripSuggestion[]>
⋮----
// Check cache
⋮----
// Generate via AI
⋮----
/**
 * GET /api/trips/suggestions
 *
 * Returns AI-generated trip suggestions for the authenticated user.
 * Response cached in Redis with 15-minute TTL.
 */
````

## File: src/app/api/trips/_handler.ts
````typescript
/**
 * @fileoverview Dependency-injected handlers for trip CRUD routes.
 */
⋮----
import type { TripsInsert } from "@schemas/supabase";
import { tripsInsertSchema, tripsRowSchema } from "@schemas/supabase";
import type { TripCreateInput, TripFilters } from "@schemas/trips";
import { NextResponse } from "next/server";
import { errorResponse } from "@/lib/api/route-helpers";
import { canonicalizeParamsForCache } from "@/lib/cache/keys";
import { bumpTag, versionedKey } from "@/lib/cache/tags";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
import { mapDbTripToUi } from "@/lib/trips/mappers";
⋮----
/**
 * Escapes SQL LIKE/ILIKE wildcard characters in user input.
 *
 * Prevents unintended wildcard matches by escaping '%', '_', and backslashes.
 * The escaped value can then be safely wrapped with '%' for substring search.
 */
function escapeIlikePattern(input: string): string
⋮----
export interface TripsDeps {
  supabase: TypedServerSupabase;
}
⋮----
/** Cache TTL for trip listings (5 minutes). */
⋮----
/**
 * Generates a user-scoped cache tag for trips.
 *
 * @param userId - The user's ID
 * @returns A cache tag scoped to that user's trips
 */
export function getUserTripsCacheTag(userId: string): string
⋮----
/**
 * Builds versioned cache key for trip listings.
 *
 * Uses cache tag versioning to enable efficient invalidation of all
 * filter variants when trips are created or updated.
 */
function buildTripsCacheKey(userId: string, filters: TripFilters): Promise<string>
⋮----
/**
 * Invalidates all trip cache entries for a specific user.
 *
 * Uses cache tag versioning to invalidate all filter variants
 * (e.g., "all", "status:active", "destination:paris", etc.) by
 * bumping the user-scoped tag version. Subsequent reads will generate
 * new versioned keys, causing cache misses for that user only.
 *
 * @param userId - The user whose trip cache should be invalidated
 */
export async function invalidateUserTripsCache(userId: string): Promise<void>
⋮----
/**
 * Maps validated trip creation payload to Supabase trips insert shape.
 *
 * Keeps request/response validation layered on top of the generated
 * Supabase table schemas, avoiding direct coupling between API contracts
 * and database column names.
 *
 * @returns The insert payload or null if validation fails
 */
function mapCreatePayloadToInsert(
  payload: TripCreateInput,
  userId: string
): TripsInsert | null
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase column name
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase column name
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase column name
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase column name
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase column name
⋮----
export async function handleListTrips(
  deps: TripsDeps,
  params: { userId: string; filters: TripFilters }
): Promise<Response>
⋮----
// Parse rows with safeParse to avoid crashing on invalid DB records
⋮----
// Log any rows that failed validation
⋮----
export async function handleCreateTrip(
  deps: TripsDeps,
  params: { userId: string; payload: TripCreateInput }
): Promise<Response>
````

## File: src/app/api/trips/route.ts
````typescript
/**
 * @fileoverview Trip CRUD API route handlers.
 */
⋮----
import { tripCreateSchema, tripFiltersSchema } from "@schemas/trips";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, parseJsonBody, requireUserId } from "@/lib/api/route-helpers";
import { handleCreateTrip, handleListTrips } from "./_handler";
⋮----
/**
 * GET /api/trips
 *
 * Returns the authenticated user's trips filtered by optional query params.
 * Response cached in Redis with 5-minute TTL.
 *
 * @param req - NextRequest object.
 * @param supabase - Supabase client.
 * @param user - Authenticated user.
 * @returns NextResponse object.
 */
⋮----
/**
 * POST /api/trips
 *
 * Creates a new trip owned by the authenticated user.
 * Invalidates trips cache on success.
 */
````

## File: src/app/auth/delete/route.ts
````typescript
/**
 * @fileoverview Authenticated account deletion route.
 * Deletes the current user via Supabase admin API using the service-role key.
 */
⋮----
import { NextResponse } from "next/server";
import { requireUser } from "@/lib/auth/server";
import { createAdminSupabase } from "@/lib/supabase/admin";
⋮----
/**
 * Handles DELETE /auth/delete requests from client-side consumers.
 *
 * Deletes the current user via Supabase admin API using the service-role key.
 */
export async function DELETE(): Promise<NextResponse>
````

## File: src/app/auth/email/resend/route.ts
````typescript
/**
 * @fileoverview Email verification resend route handler.
 *
 * Authenticated route that triggers Supabase Auth to resend a signup
 * verification email to the current user's email address.
 */
⋮----
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { requireUser } from "@/lib/auth/server";
import { ROUTES } from "@/lib/routes";
⋮----
export async function POST(_request: NextRequest): Promise<NextResponse>
````

## File: src/app/auth/logout/route.ts
````typescript
/**
 * @fileoverview Supabase logout route handler.
 *
 * Provides POST and GET handlers to sign the current user out using Supabase
 * SSR cookies. POST is used by client-side stores, while GET supports simple
 * hyperlink-based logout flows.
 */
⋮----
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { createServerSupabase } from "@/lib/supabase/server";
⋮----
/**
 * Handles POST /auth/logout requests from client-side consumers.
 *
 * Clears the Supabase session via supabase.auth.signOut() and returns a JSON
 * response. Clients are responsible for updating their own view state.
 */
export async function POST(_request: NextRequest): Promise<NextResponse>
⋮----
/**
 * Handles GET /auth/logout for hyperlink-based logout.
 *
 * Signs the user out and redirects them to the login page.
 */
export async function GET(request: NextRequest): Promise<NextResponse>
````

## File: src/app/auth/me/route.ts
````typescript
/**
 * @fileoverview Auth session introspection route.
 *
 * Returns the current authenticated user in the frontend AuthUser shape using
 * Supabase SSR cookies as the session source of truth.
 */
⋮----
import type { AuthUser } from "@schemas/stores";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { getOptionalUser, mapSupabaseUserToAuthUser } from "@/lib/auth/server";
⋮----
interface MeResponse {
  user: AuthUser | null;
}
⋮----
/**
 * Handles GET /auth/me.
 *
 * When authenticated, returns `{ user }` with the mapped AuthUser shape.
 * When unauthenticated, returns `{ user: null }` with HTTP 401.
 */
export async function GET(_req: NextRequest): Promise<NextResponse<MeResponse>>
````

## File: src/app/auth/register/route.ts
````typescript
/**
 * @fileoverview Supabase email/password registration route handler.
 *
 * Handles POST submissions from the /register page using Supabase SSR. This
 * route uses cookie-based sessions and sends confirmation links via Supabase
 * Auth email flows.
 */
⋮----
import { registerFormSchema } from "@schemas/auth";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { createServerSupabase } from "@/lib/supabase/server";
⋮----
/**
 * Builds an absolute URL for a given path relative to the incoming request.
 *
 * @param request - Incoming Next.js request
 * @param path - Path to redirect to (must start with "/")
 * @returns Absolute URL instance
 */
function buildRedirectUrl(request: NextRequest, path: string): URL
⋮----
/**
 * Creates a redirect back to the /register page with an error message.
 *
 * @param request - Incoming Next.js request
 * @param message - Error message to display
 * @returns Redirect response to /register with query parameters
 */
function redirectWithError(request: NextRequest, message: string): NextResponse
⋮----
/**
 * Handles POST /auth/register form submissions for email/password sign-up.
 *
 * Uses Supabase SSR client to create a new user account and sends a
 * confirmation link to /auth/confirm.
 */
export async function POST(request: NextRequest): Promise<NextResponse>
````

## File: src/app/chat/chat-client.tsx
````typescript
/**
 * @fileoverview Client chat shell using AI SDK v6 useChat hook for real streaming.
 */
⋮----
import { useChat } from "@ai-sdk/react";
import { DefaultChatTransport } from "ai";
import { RefreshCwIcon, StopCircleIcon } from "lucide-react";
import type { ReactElement } from "react";
import { useState } from "react";
import {
  Conversation,
  ConversationContent,
  ConversationEmptyState,
  ConversationScrollButton,
} from "@/components/ai-elements/conversation";
import {
  PromptInput,
  PromptInputBody,
  PromptInputFooter,
  PromptInputHeader,
  PromptInputSubmit,
  PromptInputTextarea,
} from "@/components/ai-elements/prompt-input";
import { ChatMessageItem } from "@/components/chat/message-item";
import { Button } from "@/components/ui/button";
⋮----
/**
 * Client-side chat container using AI SDK v6 useChat hook.
 * Connects to /api/chat/stream for real-time streaming responses.
 */
⋮----
const handleSubmit = async (text?: string) =>
⋮----
<PromptInput onSubmit=
⋮----
{/* Streaming controls */}
⋮----
onClick=
⋮----
{/* Regenerate button - only show when ready and there are messages */}
⋮----
{/* Error display with retry */}
````

## File: src/app/chat/layout.tsx
````typescript
/**
 * @fileoverview Chat route layout implementation.
 *
 * Implements and exports the ChatLayout component used by the chat route group.
 */
⋮----
import type { ReactNode } from "react";
import { requireUser } from "@/lib/auth/server";
import { ROUTES } from "@/lib/routes";
⋮----
/**
 * Chat route layout that requires an authenticated user.
 *
 * If the request is unauthenticated, this layout triggers a redirect to the login
 * page with `next=/chat` so the user returns here after signing in.
 *
 * @param props - Layout props.
 * @param props.children - Nested route content.
 * @returns The nested route content once authentication is verified.
 */
export default async function ChatLayout({
  children,
}: {
  children: ReactNode;
}): Promise<ReactNode>
````

## File: src/app/chat/page.tsx
````typescript
/**
 * @fileoverview Chat page shell that hosts the client chat experience with an error boundary.
 */
⋮----
import type { ReactElement } from "react";
import { ErrorBoundary } from "@/components/error/error-boundary";
import { ChatClient } from "./chat-client";
⋮----
export default function ChatPage(): ReactElement
````

## File: src/app/dashboard/admin/configuration/page.tsx
````typescript
/**
 * Admin Configuration Page
 *
 * Next.js page component for the configuration management interface.
 * Provides access to the ConfigurationManager component with proper authentication.
 */
⋮----
import type { AgentType } from "@schemas/configuration";
import type { Metadata } from "next";
import { Suspense } from "react";
import { fetchAgentBundle } from "@/components/admin/configuration-actions";
import ConfigurationManager from "@/components/admin/configuration-manager";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
export default async function ConfigurationPage()
````

## File: src/app/dashboard/agent-status/page.tsx
````typescript
/**
 * @fileoverview Agent monitoring dashboard page component powered by the shared
 * agent status store and realtime hook.
 */
⋮----
import { ActivityIcon, BrainIcon, NetworkIcon, ZapIcon } from "lucide-react";
import { useMemo } from "react";
import { AgentStatusDashboard } from "@/components/features/agent-monitoring/dashboard/agent-status-dashboard";
import { ConnectionStatus } from "@/components/features/shared/connection-status";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { useAgentStatusWebSocket } from "@/hooks/chat/use-agent-status-websocket";
import { cn } from "@/lib/utils";
import { useAgentStatusStore } from "@/stores/agent-status-store";
⋮----
/**
 * Agent dashboard colors aligned with statusVariants.
 * Active states use green (aligned with urgency.low/status.active),
 * errors use red (aligned with urgency.high/status.error).
 */
⋮----
/** Unified connection status for UI state management. */
type AgentConnectionStatus = "connected" | "disconnected" | "error";
⋮----
/** Button labels mapped to each connection status. */
⋮----
/**
 * Derives unified connection status from websocket state.
 *
 * @param isConnected - Whether websocket is actively subscribed
 * @param connectionStatus - Raw connection status from websocket hook
 * @returns Unified status for UI consumption
 */
function getConnectionStatus(
  isConnected: boolean,
  connectionStatus: "subscribed" | "error" | "disconnected" | (string & {})
): AgentConnectionStatus
⋮----
/**
 * Renders the agent monitoring dashboard with realtime controls and metrics.
 *
 * @returns Agent monitoring layout with connection controls and dashboard
 * widgets.
 */
⋮----
const toggleRealtime = () =>
⋮----
<div className=
⋮----
<p className=
````

## File: src/app/dashboard/calendar/page.tsx
````typescript
/**
 * @fileoverview Calendar page for managing Google Calendar integration.
 *
 * Provides UI for connecting Google Calendar, viewing events, creating events,
 * and exporting/importing ICS files.
 */
⋮----
import { useRouter } from "next/navigation";
import { useMemo, useState } from "react";
import { CalendarConnectionCard } from "@/components/calendar/calendar-connection-card";
import { CalendarEventForm } from "@/components/calendar/calendar-event-form";
import { CalendarEventList } from "@/components/calendar/calendar-event-list";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useToast } from "@/components/ui/use-toast";
import { DateUtils } from "@/lib/dates/unified-date-utils";
⋮----
/**
 * Renders the calendar integration dashboard with connection status, events,
 * and creation workflow tabs.
 *
 * @returns Calendar management layout with tabbed controls.
 */
export default function CalendarPage()
⋮----
toast({
                description: "Your calendar event has been created successfully.",
                title: "Event created",
              });
setActiveTab("events");
router.refresh();
⋮----
toast({
                description: error,
                title: "Failed to create event",
                variant: "destructive",
              });
````

## File: src/app/dashboard/demo/realtime/page.tsx
````typescript
/**
 * @fileoverview Demo realtime page showcasing live trip collaboration.
 */
⋮----
import {
  ActivityIcon,
  CheckCircleIcon,
  MessageSquareIcon,
  UploadIcon,
  UsersIcon,
  WifiIcon,
  XCircleIcon,
  ZapIcon,
} from "lucide-react";
import { useState } from "react";
import { ConnectionStatusMonitor } from "@/components/features/realtime/connection-status-monitor";
import {
  CollaborationIndicator,
  OptimisticTripUpdates,
} from "@/components/features/realtime/optimistic-trip-updates";
import { Badge } from "@/components/ui/badge";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useTrips } from "@/hooks/use-trips";
import { statusVariants } from "@/lib/variants/status";
⋮----
type DemoStatus = "completed" | "pending";
⋮----
type DemoCard = {
  description: string;
  details: string[];
  icon: React.ReactNode;
  id: string;
  status: DemoStatus;
  title: string;
};
⋮----
/**
 * Maps demo status to status variant props.
 */
const getStatusVariant = (status: DemoStatus)
⋮----
/**
 * Readonly feature definitions used to render the realtime demo cards.
 */
⋮----
/**
 * Demonstration page showcasing all real-time Supabase integration features
 */
⋮----
{/* Header */}
⋮----
{/* Implementation Overview */}
⋮----
{/* Interactive Demos */}
⋮----
className=
⋮----
{/* Technical Implementation Details */}
⋮----
{/* Next Steps */}
````

## File: src/app/dashboard/profile/page.tsx
````typescript
/**
 * @fileoverview The profile page for the dashboard.
 */
⋮----
import { SettingsIcon, ShieldIcon, SlidersIcon, UserIcon } from "lucide-react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useEffect } from "react";
import { AccountSettingsSection } from "@/components/features/profile/account-settings-section";
import { PersonalInfoSection } from "@/components/features/profile/personal-info-section";
import { PreferencesSection } from "@/components/features/profile/preferences-section";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ROUTES } from "@/lib/routes";
import { useAuthCore } from "@/stores/auth/auth-core";
````

## File: src/app/dashboard/search/activities/activities-search-client.tsx
````typescript
/**
 * @fileoverview Client-side activity search experience (renders within RSC shell).
 */
⋮----
import type { Activity, ActivitySearchParams } from "@schemas/search";
import type { UiTrip } from "@schemas/trips";
import {
  AlertCircleIcon,
  CheckCircleIcon,
  SearchIcon,
  SparklesIcon,
  TicketIcon,
  XIcon,
} from "lucide-react";
import { useSearchParams } from "next/navigation";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { ActivityCard } from "@/components/features/search/cards/activity-card";
import { ActivitySearchForm } from "@/components/features/search/forms/activity-search-form";
import { ActivityComparisonModal } from "@/components/features/search/modals/activity-comparison-modal";
import { TripSelectionModal } from "@/components/features/search/modals/trip-selection-modal";
import { SearchLayout } from "@/components/layouts/search-layout";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { CardLoadingSkeleton } from "@/components/ui/query-states";
import { Separator } from "@/components/ui/separator";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useToast } from "@/components/ui/use-toast";
import { useSearchOrchestration } from "@/hooks/search/use-search-orchestration";
import { openActivityBooking } from "@/lib/activities/booking";
import { getErrorMessage } from "@/lib/api/error-types";
import { useComparisonStore } from "@/stores/comparison-store";
import { useSearchResultsStore } from "@/stores/search-results-store";
import { addActivityToTrip, getPlanningTrips } from "./actions";
⋮----
/** Maximum number of items allowed in comparison views. */
⋮----
/**
 * Activity search semantic colors aligned with statusVariants.
 * - Success indicator: green (active/success)
 * - AI suggestions: purple (distinct from verified results)
 */
⋮----
const isActivity = (data: unknown): data is Activity
⋮----
/** Activity search client component props. */
interface ActivitiesSearchClientProps {
  onSubmitServer: (params: ActivitySearchParams) => Promise<ActivitySearchParams>;
}
⋮----
/** Activity search client component. */
⋮----
// Initialize search type on mount
⋮----
// Initialize search with URL parameters
⋮----
const normalizedParams = await onSubmitServer(params); // server-side telemetry and validation
⋮----
await executeSearch(normalizedParams ?? params, controller.signal); // client fetch/store update
⋮----
// Pre-mutation count from selector; accurate since we early-return after remove
⋮----
// Pre-mutation count; subtract 1 since removeItem hasn't re-rendered yet
⋮----
const handleBookActivity = () =>
⋮----
{/* Search Form Section */}
⋮----
{/* Comparison Bar */}
⋮----
{/* Loading State */}
⋮----
{/* Error State */}
⋮----
{/* Mixed Results (Verified + AI) */}
⋮----
{/* Initial State */}
⋮----
{/* Floating Compare Button */}
⋮----
{/* Comparison Modal */}
⋮----
{/* Activity Selection Dialog */}
⋮----
{/* Trip Selection Modal */}
````

## File: src/app/dashboard/search/activities/loading.tsx
````typescript
/**
 * @fileoverview Loading UI for activity search page route.
 */
⋮----
import { SearchPageSkeleton } from "@/components/search/search-page-skeleton";
⋮----
/**
 * Route-level loading component shown during page transitions.
 */
export default function Loading()
````

## File: src/app/dashboard/search/activities/page.tsx
````typescript
/**
 * @fileoverview Server page for activity search (RSC shell).
 */
⋮----
import { submitActivitySearch } from "./actions";
import ActivitiesSearchClient from "./activities-search-client";
⋮----
/**
 * Activity search page that renders the client component and handles server submission.
 *
 * @returns {JSX.Element} The activity search page.
 */
export default function ActivitiesSearchPage()
````

## File: src/app/dashboard/search/destinations/actions.ts
````typescript
/**
 * @fileoverview Server actions for destination search.
 */
⋮----
import {
  type DestinationSearchParams,
  destinationSearchParamsSchema,
} from "@schemas/search";
import { normalizePlacesTextQuery } from "@/lib/google/places-utils";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Server action to validate and trace destination search submissions.
 *
 * @param params - Destination search parameters from the client.
 * @returns Validated destination search parameters.
 * @throws Error if validation fails.
 */
export async function submitDestinationSearch(
  params: DestinationSearchParams
): Promise<DestinationSearchParams>
````

## File: src/app/dashboard/search/destinations/destination-comparison-modal.tsx
````typescript
/**
 * @fileoverview DestinationComparisonModal component for comparing multiple destinations side-by-side.
 */
⋮----
import type { Destination } from "@schemas/search";
import {
  CalendarIcon,
  GlobeIcon,
  MapPinIcon,
  StarIcon,
  ThermometerIcon,
  XIcon,
} from "lucide-react";
import { useEffect } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { formatDestinationTypes } from "@/lib/google/places-format";
⋮----
const clampPopularity = (score: number): number =>
⋮----
/**
 * Props for the destination comparison modal component.
 *
 * @public
 */
export interface DestinationComparisonModalProps {
  /** Whether the modal dialog is currently open. */
  isOpen: boolean;
  /** Callback invoked when the modal should be closed. */
  onClose: () => void;
  /** Array of destinations to display in the comparison table. */
  destinations: Destination[];
  /**
   * Callback invoked when a destination should be removed from comparison.
   *
   * @param destinationId - The unique identifier of the destination to remove.
   */
  onRemove: (destinationId: string) => void;
  /**
   * Callback invoked when viewing detailed information for a destination.
   *
   * @param destination - The destination object to view details for.
   */
  onViewDetails: (destination: Destination) => void;
  /** Maximum number of destinations that can be compared simultaneously. */
  maxItems: number;
}
⋮----
/** Whether the modal dialog is currently open. */
⋮----
/** Callback invoked when the modal should be closed. */
⋮----
/** Array of destinations to display in the comparison table. */
⋮----
/**
   * Callback invoked when a destination should be removed from comparison.
   *
   * @param destinationId - The unique identifier of the destination to remove.
   */
⋮----
/**
   * Callback invoked when viewing detailed information for a destination.
   *
   * @param destination - The destination object to view details for.
   */
⋮----
/** Maximum number of destinations that can be compared simultaneously. */
⋮----
/**
 * Modal dialog component for comparing multiple destinations side-by-side.
 *
 * Displays a table comparing destinations across multiple attributes including:
 * type, location, rating, climate, best time to visit, and popularity score.
 * Each destination column includes a remove button and an action button to view
 * detailed information.
 *
 * The component renders nothing if the destinations array is empty.
 *
 * @param props - Component props.
 * @param props.isOpen - Whether the modal dialog is currently open.
 * @param props.onClose - Callback invoked when the modal should be closed.
 * @param props.destinations - Array of destinations to display in the comparison table.
 * @param props.onRemove - Callback invoked when a destination should be removed from comparison.
 * @param props.onViewDetails - Callback invoked when viewing detailed information for a destination.
 * @param props.maxItems - Maximum number of destinations that can be compared simultaneously.
 * @returns The modal dialog component, or null if no destinations are provided.
 */
⋮----
onClick=
````

## File: src/app/dashboard/search/destinations/destinations-search-client.tsx
````typescript
/**
 * @fileoverview Client-side destination search experience (renders within RSC shell).
 */
⋮----
import type { Destination, DestinationSearchParams } from "@schemas/search";
import {
  AlertCircleIcon,
  GlobeIcon,
  MapPinIcon,
  SearchIcon,
  XIcon,
} from "lucide-react";
import { useRouter } from "next/navigation";
import { useCallback, useEffect, useRef, useState } from "react";
import { DestinationCard } from "@/components/features/search/cards/destination-card";
import { DestinationSearchForm } from "@/components/features/search/forms/destination-search-form";
import { SearchLayout } from "@/components/layouts/search-layout";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { DestinationSkeleton } from "@/components/ui/travel-skeletons";
import { useToast } from "@/components/ui/use-toast";
import type { DestinationResult } from "@/hooks/search/use-destination-search";
import { useDestinationSearch } from "@/hooks/search/use-destination-search";
import { useSearchOrchestration } from "@/hooks/search/use-search-orchestration";
import { getErrorMessage } from "@/lib/api/error-types";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { DestinationComparisonModal } from "./destination-comparison-modal";
⋮----
/** The destinations search client component props. */
interface DestinationsSearchClientProps {
  onSubmitServer: (params: DestinationSearchParams) => Promise<DestinationSearchParams>;
}
⋮----
/** Maximum number of items allowed in comparison views. */
⋮----
/** The destinations search client component. */
⋮----
/** Handles the search for destinations. */
⋮----
await onSubmitServer(params); // server-side telemetry and validation
⋮----
await searchDestinations(params, controller.signal); // client fetch/store update
⋮----
/** Handles the selection of a destination. */
const handleDestinationSelect = (destination: Destination) =>
⋮----
/** Handles the comparison toggle for a destination. */
const handleDestinationCompare = (destination: Destination) =>
⋮----
/** Handles removing a destination from comparison. */
const handleRemoveFromComparison = (destinationId: string) =>
⋮----
/**
   * Opens destination details (placeholder until detail route/modal is wired).
   * Closes comparison modal when invoked from comparison.
   */
const openDestinationDetails = (
    destination: Destination,
    options?: { fromComparison?: boolean }
) =>
⋮----
/** Handles viewing details for a destination from comparison. */
const handleViewDetailsFromComparison = (destination: Destination) =>
⋮----
/** Handles the viewing of details for a destination. */
const handleViewDetails = (destination: Destination) =>
⋮----
/** Clears the comparison of destinations. */
const clearComparison = () =>
⋮----
/** The destinations to display. */
⋮----
{/* Search Form Card */}
⋮----
{/* Comparison Bar */}
⋮----
{/* Loading State */}
⋮----
{/* Error State */}
⋮----
{/* Empty State */}
⋮----
{/* Results Grid */}
⋮----
{/* Initial State */}
⋮----
{/* Floating Compare Button */}
⋮----
{/* Comparison Modal */}
````

## File: src/app/dashboard/search/destinations/loading.tsx
````typescript
/**
 * @fileoverview Loading UI for destination search page route.
 */
⋮----
import { SearchPageSkeleton } from "@/components/search/search-page-skeleton";
⋮----
/**
 * Route-level loading component shown during page transitions.
 */
export default function Loading()
````

## File: src/app/dashboard/search/destinations/page.tsx
````typescript
/**
 * @fileoverview Server page for destination search (RSC shell).
 */
⋮----
import { submitDestinationSearch } from "./actions";
import DestinationsSearchClient from "./destinations-search-client";
⋮----
/**
 * Destination search page that renders the client component and handles server submission.
 *
 * @returns {JSX.Element} The destination search page.
 */
export default function DestinationsSearchPage()
````

## File: src/app/dashboard/search/flights/results/page.tsx
````typescript
/**
 * @fileoverview Flight search results page with filters and CTA to book.
 */
⋮----
import { ArrowRightIcon, FilterIcon, PlaneIcon } from "lucide-react";
import { useSearchParams } from "next/navigation";
import { SearchLayout } from "@/components/layouts/search-layout";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { cn } from "@/lib/utils";
import { useSearchResultsStore } from "@/stores/search-results-store";
⋮----
/**
 * Flight results page semantic colors.
 * - Price display: green (indicates value/good deal)
 */
⋮----
// Mock flight results for demo
⋮----
{/* Search Summary */}
⋮----
{/* Search Status */}
⋮----
{/* Results */}
⋮----
{/* Filters Sidebar */}
⋮----
{/* Flight Results */}
⋮----
{/* Airline Info */}
⋮----
{/* Flight Route */}
⋮----
{/* Price and Book */}
⋮----
className=
⋮----
{/* Load More */}
````

## File: src/app/dashboard/search/flights/actions.ts
````typescript
/**
 * @fileoverview Server Actions for flight search.
 */
⋮----
import { type FlightSearchParams, flightSearchParamsSchema } from "@schemas/search";
import { normalizePlacesTextQuery } from "@/lib/google/places-utils";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Server action to validate and trace flight search submissions.
 *
 * @param params - Flight search parameters from the client.
 * @returns Validated flight search parameters.
 * @throws Error if validation fails.
 */
export async function submitFlightSearch(
  params: FlightSearchParams
): Promise<FlightSearchParams>
````

## File: src/app/dashboard/search/flights/flights-search-client.tsx
````typescript
/**
 * @fileoverview Client-side flight search experience (renders within RSC shell).
 */
⋮----
import type { FlightSearchParams } from "@schemas/search";
import { useQuery } from "@tanstack/react-query";
import {
  ArrowRightIcon,
  InfoIcon,
  LightbulbIcon,
  PlaneIcon,
  TrendingUpIcon,
} from "lucide-react";
⋮----
import { useRouter, useSearchParams } from "next/navigation";
import React from "react";
import { z } from "zod";
import { buildFlightApiPayload } from "@/components/features/search/filters/api-payload";
import { FilterPanel } from "@/components/features/search/filters/filter-panel";
import { FilterPresets } from "@/components/features/search/filters/filter-presets";
import { FlightSearchForm } from "@/components/features/search/forms/flight-search-form";
import { SearchLayout } from "@/components/layouts/search-layout";
import { Badge } from "@/components/ui/badge";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useToast } from "@/components/ui/use-toast";
import { useSearchOrchestration } from "@/hooks/search/use-search-orchestration";
import { getErrorMessage } from "@/lib/api/error-types";
import { ROUTES } from "@/lib/routes";
import { cn } from "@/lib/utils";
import { useSearchFiltersStore } from "@/stores/search-filters-store";
⋮----
/** Flight search client component props. */
interface FlightsSearchClientProps {
  onSubmitServer: (params: FlightSearchParams) => Promise<FlightSearchParams>;
}
⋮----
type PopularRoute = z.infer<typeof POPULAR_ROUTE_SCHEMA>;
⋮----
/** Flight search client component. */
⋮----
staleTime: 60 * 60 * 1000, // 1 hour
⋮----
// Initialize flight search type on mount
⋮----
// Check for search parameters in URL
⋮----
// Server-side telemetry then client execution
⋮----
const handleSearch = async (params: FlightSearchParams) =>
⋮----
// Merge form params with active filter payload
⋮----
const validatedParams = await onSubmitServer(searchWithFilters); // server-side telemetry and validation
⋮----
{/* Main content - 3 columns */}
⋮----
{/* Search Form */}
⋮----
{/* Popular Routes */}
⋮----
{/* Travel Tips */}
⋮----
{/* Sidebar - 1 column */}
⋮----
/** Card component for displaying a popular route. */
⋮----
className=
⋮----
onSelect();
⋮----
/**
 * Component for displaying a travel tip.
 */
````

## File: src/app/dashboard/search/flights/loading.tsx
````typescript
/**
 * @fileoverview Loading UI for flight search page route.
 */
⋮----
import { SearchPageSkeleton } from "@/components/search/search-page-skeleton";
⋮----
/**
 * Route-level loading component shown during page transitions.
 */
export default function Loading()
````

## File: src/app/dashboard/search/flights/page.tsx
````typescript
/**
 * @fileoverview Server page for flight search (RSC shell).
 */
⋮----
import { submitFlightSearch } from "./actions";
import FlightsSearchClient from "./flights-search-client";
⋮----
/** Flight search page that renders the client component and handles server submission. */
export default function FlightSearchPage()
````

## File: src/app/dashboard/search/hotels/actions.ts
````typescript
/**
 * @fileoverview Server Actions for hotel/accommodation search.
 */
⋮----
import {
  type SearchAccommodationParams,
  searchAccommodationParamsSchema,
} from "@schemas/search";
import { normalizePlacesTextQuery } from "@/lib/google/places-utils";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Server action to validate and trace hotel search submissions.
 *
 * @param params - Accommodation search parameters from the client.
 * @returns Validated accommodation search parameters.
 * @throws Error if validation fails.
 */
export async function submitHotelSearch(
  params: SearchAccommodationParams
): Promise<SearchAccommodationParams>
````

## File: src/app/dashboard/search/hotels/hotel-mapping.ts
````typescript
/**
 * @fileoverview Pure mapping utilities for hotel/accommodation search results.
 */
⋮----
import type { Accommodation, HotelResult } from "@schemas/search";
import { FALLBACK_HOTEL_IMAGE } from "@/lib/constants/images";
import { categorizeAmenities } from "@/lib/utils/amenity-categorization";
⋮----
type AccommodationLike = Accommodation & {
  category?: string;
  district?: string;
  reviewCount?: number;
  address?: (Accommodation["address"] & { district?: string }) | undefined;
};
⋮----
type AllowedCategory = (typeof ALLOWED_CATEGORIES)[number];
⋮----
type HotelVibe = "luxury" | "business" | "family" | "romantic" | "adventure";
⋮----
function toAllowedCategory(category?: string): AllowedCategory
⋮----
function deriveVibe(category: AllowedCategory, normalizedAmenities: string): HotelVibe
⋮----
// Returns a score on a 1–10 scale (default 5 = neutral); rating is mapped by
// Math.round(rating * 2) and clamped to [1,10].
function getRecommendationScore(rating: number | undefined): number
⋮----
function normalizeStarRating(starRating: number | undefined): number | undefined
⋮----
/**
 * Maps an accommodation search result into the unified `HotelResult` UI shape.
 *
 * Intentionally pure (no store reads, no network, no time-dependent logic) to
 * enable reuse and focused unit tests.
 */
export function mapAccommodationToHotelResult(
  accommodation: AccommodationLike
): HotelResult
````

## File: src/app/dashboard/search/hotels/loading.tsx
````typescript
/**
 * @fileoverview Loading UI for hotel search page route.
 */
⋮----
import { SearchPageSkeleton } from "@/components/search/search-page-skeleton";
⋮----
/**
 * Route-level loading component shown during page transitions.
 */
export default function Loading()
````

## File: src/app/dashboard/search/hotels/page.tsx
````typescript
/**
 * @fileoverview Server page for hotel/accommodation search (RSC shell).
 */
⋮----
import { submitHotelSearch } from "./actions";
import HotelsSearchClient from "./hotels-search-client";
⋮----
/**
 * Hotel search page that renders the client component and handles server submission.
 *
 * @returns {JSX.Element} The hotel search page.
 */
export default function HotelSearchPage()
````

## File: src/app/dashboard/search/unified/actions.ts
````typescript
/**
 * @fileoverview Server action for unified hotel search.
 */
⋮----
import { getAccommodationsService } from "@domain/accommodations/container";
import { accommodationListingSchema } from "@schemas/accommodations";
import {
  type HotelResult,
  type HotelSearchFormData,
  type SearchAccommodationParams,
  searchAccommodationParamsSchema,
} from "@schemas/search";
import { format } from "date-fns";
import { FALLBACK_HOTEL_IMAGE } from "@/lib/constants/images";
import { getGoogleMapsBrowserKey } from "@/lib/env/server";
import { secureUuid } from "@/lib/security/random";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/** Build photo URL. */
function buildPhotoUrl(photoName?: string): string | undefined
⋮----
// This URL is consumed by the client; use the public browser key (referrer-restricted),
// not a privileged server key.
⋮----
/**
 * Search hotels with schema validation.
 *
 * Maps component HotelSearchFormData to SearchAccommodationParams schema and validates.
 *
 * @param params - Hotel search parameters from component.
 * @returns Array of hotel results.
 * @throws Error if validation fails.
 */
export async function searchHotelsAction(
  params: HotelSearchFormData
): Promise<HotelResult[]>
⋮----
// Map component params to schema format
⋮----
/** Compute nights for the effective check-in/check-out window. */
const calculateNights = (): number =>
⋮----
/** Map search results to unified hotel results. */
⋮----
// Parse listing with Zod schema for type safety
⋮----
// Fallback to minimal hotel result if parsing fails
````

## File: src/app/dashboard/search/unified/loading.tsx
````typescript
/**
 * @fileoverview Loading UI for unified search page route.
 */
⋮----
import { SearchPageSkeleton } from "@/components/search/search-page-skeleton";
⋮----
/**
 * Route-level loading component shown during page transitions.
 */
export default function Loading()
````

## File: src/app/dashboard/search/unified/page.tsx
````typescript
/**
 * @fileoverview Server page for unified search experience (RSC shell).
 */
⋮----
import { searchHotelsAction } from "./actions";
import UnifiedSearchClient from "./unified-search-client";
⋮----
/** Server page for unified search experience (RSC shell). */
export default function UnifiedSearchPage()
````

## File: src/app/dashboard/search/unified/unified-search-client.tsx
````typescript
/**
 * @fileoverview Client-side unified search experience (renders within RSC shell).
 */
⋮----
import type {
  FlightResult,
  FlightSearchFormData,
  HotelResult,
  HotelSearchFormData,
} from "@schemas/search";
import { formatDistanceToNow } from "date-fns";
import {
  Building2Icon,
  ClockIcon,
  MapPinIcon,
  PlaneIcon,
  ShieldIcon,
  SparklesIcon,
  StarIcon,
  TrendingUpIcon,
  UsersIcon,
  ZapIcon,
} from "lucide-react";
import { useRouter } from "next/navigation";
import { type ReactNode, useEffect, useRef, useState } from "react";
import { FlightSearchForm } from "@/components/features/search/forms/flight-search-form";
import { HotelSearchForm } from "@/components/features/search/forms/hotel-search-form";
import { FlightResults } from "@/components/features/search/results/flight-results";
import { HotelResults } from "@/components/features/search/results/hotel-results";
import { SearchLayout } from "@/components/layouts/search-layout";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Separator } from "@/components/ui/separator";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useToast } from "@/components/ui/use-toast";
import { getErrorMessage } from "@/lib/api/error-types";
import { ROUTES } from "@/lib/routes";
import { statusVariants } from "@/lib/variants/status";
⋮----
interface UnifiedSearchClientProps {
  onSearchFlights?: (
    params: FlightSearchFormData,
    signal?: AbortSignal
  ) => Promise<FlightResult[]>;
  onSearchHotels: (
    params: HotelSearchFormData,
    signal?: AbortSignal
  ) => Promise<HotelResult[]>;
}
⋮----
// ignore
⋮----
const isAbortError = (error: unknown): boolean
⋮----
const handleFlightSearch = async (params: FlightSearchFormData): Promise<void> =>
⋮----
const handleLoadDemoResults = async () =>
⋮----
const handleHotelSearch = async (params: HotelSearchFormData): Promise<void> =>
⋮----
const handleFlightSelect = (flight: FlightResult): void =>
⋮----
const handleHotelSelect = (hotel: HotelResult): void =>
⋮----
const handleCompareFlights = (flights: FlightResult[]) =>
⋮----
const handleSaveToWishlist = (hotelId: string) =>
⋮----
// ignore
⋮----
{/* Hero Section */}
⋮----
<Badge className=
⋮----
{/* Search Interface */}
⋮----
{/* Implementation Notes */}
⋮----
/**
 * Feature card highlighting unified experience capabilities.
 */
````

## File: src/app/dashboard/search/page.tsx
````typescript
/**
 * @fileoverview Server page for search hub (RSC shell).
 */
⋮----
import SearchHubClient from "./search-hub-client";
⋮----
export default function SearchPage()
````

## File: src/app/dashboard/search/search-hub-client.tsx
````typescript
/**
 * @fileoverview Client-side search hub experience (renders within RSC shell).
 */
⋮----
import type { SearchType } from "@schemas/search";
import {
  ClockIcon,
  HistoryIcon,
  HotelIcon,
  MapPinIcon,
  PlaneIcon,
  RefreshCwIcon,
  SearchIcon,
  SparklesIcon,
} from "lucide-react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import type React from "react";
import { SearchAnalytics } from "@/components/features/search/search-analytics";
import { SearchCollections } from "@/components/features/search/search-collections";
import { SearchLayout } from "@/components/layouts/search-layout";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { ROUTES } from "@/lib/routes";
import { useSearchHistoryStore } from "@/stores/search-history/index";
⋮----
type RepeatSearchParams = Record<string, string | number | boolean | null | undefined>;
⋮----
/** Get the base path for a search type. */
function getSearchPath(searchType: SearchType): string
⋮----
/** Search hub client component. */
⋮----
// Get the 6 most recent searches
⋮----
/**
   * Navigate to search page with parameters.
   *
   * @param searchType - The type of search to repeat.
   * @param params - The parameters to repeat the search with.
   * @returns void
   */
const handleRepeatSearch = (
    searchType: SearchType,
    params: RepeatSearchParams
): void =>
⋮----
// Map params to query string based on search type
⋮----
{/* Main content - 2 columns */}
⋮----
{/* Sidebar - 1 column */}
⋮----
/** Get the title of a search based on its parameters. */
⋮----
/** Get the icon for a search type. */
⋮----
/** Quick option card for search types. */
⋮----
/** Recent search card. */
⋮----
````

## File: src/app/dashboard/settings/api-keys/actions.ts
````typescript
/**
 * @fileoverview Server Actions for user settings mutations.
 */
⋮----
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import type { Database } from "@/lib/supabase/database.types";
import { createServerSupabase, getCurrentUser } from "@/lib/supabase/server";
⋮----
/**
 * Updates the user's gateway fallback preference setting.
 *
 * @param allowGatewayFallback - Whether to allow gateway fallback.
 */
export async function updateGatewayFallbackPreference(
  allowGatewayFallback: boolean
): Promise<void>
⋮----
// Upsert row with owner RLS via SSR client
type UserSettingsInsert = Database["public"]["Tables"]["user_settings"]["Insert"];
// DB column names use snake_case by convention
⋮----
// biome-ignore lint/style/useNamingConvention: DB columns are snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: DB columns are snake_case
⋮----
// Revalidate the settings page to reflect the change
````

## File: src/app/dashboard/settings/api-keys/page.tsx
````typescript
/**
 * @fileoverview Dashboard API keys management page (route wrapper).
 *
 * Renders the shared API keys UI while allowing this route group to own its page
 * boundaries (metadata/layout) independently.
 */
⋮----
import { ApiKeysContent } from "@/components/settings/api-keys-content";
⋮----
export default function ApiKeysPage()
````

## File: src/app/dashboard/settings/page.tsx
````typescript
/**
 * @fileoverview Dashboard settings landing page.
 */
⋮----
import { ArrowRightIcon } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { ROUTES } from "@/lib/routes";
⋮----
export default function DashboardSettingsPage()
````

## File: src/app/dashboard/trips/[id]/collaborate/page.tsx
````typescript
/**
 * @fileoverview Trip collaboration page.
 *
 * Manages trip collaborators and real-time editing. Handles collaborator invitations,
 * permissions, sharing, and activity monitoring.
 */
⋮----
import {
  ClockIcon,
  CopyIcon,
  CrownIcon,
  EditIcon,
  EyeIcon,
  MailIcon,
  Share2Icon,
  Trash2Icon,
  UserPlusIcon,
  UsersIcon,
} from "lucide-react";
import { useParams } from "next/navigation";
import { useEffect, useId, useState } from "react";
import { z } from "zod";
import { ConnectionStatusMonitor } from "@/components/features/realtime/connection-status-monitor";
import {
  CollaborationIndicator,
  OptimisticTripUpdates,
} from "@/components/features/realtime/optimistic-trip-updates";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import { useToast } from "@/components/ui/use-toast";
import { useTrip } from "@/hooks/use-trips";
import { copyToClipboardWithToast } from "@/lib/client/clipboard";
import { getBrowserClient } from "@/lib/supabase";
import { statusVariants } from "@/lib/variants/status";
⋮----
/**
 * Consistent color palette aligned with statusVariants for roles
 */
⋮----
/**
 * Represents a collaborator on a trip with their permissions and status.
 */
interface Collaborator {
  /** Unique identifier for the collaborator record. */
  id: string;
  /** User ID of the collaborator. */
  userId: string;
  /** ID of the trip being collaborated on. */
  tripId: string;
  /** Email address of the collaborator. */
  email: string;
  /** Optional display name of the collaborator. */
  name?: string;
  /** Role determining permissions level. */
  role: "owner" | "editor" | "viewer";
  /** Current invitation/acceptance status. */
  status: "pending" | "accepted" | "declined";
  /** Detailed permission flags. */
  permissions: {
    /** Whether the collaborator can edit trip content. */
    canEdit: boolean;
    /** Whether the collaborator can invite others. */
    canInvite: boolean;
    /** Whether the collaborator can delete the trip. */
    canDelete: boolean;
  };
  /** Timestamp when the invitation was sent. */
  invitedAt: string;
  /** Timestamp when the invitation was accepted. */
  acceptedAt?: string;
}
⋮----
/** Unique identifier for the collaborator record. */
⋮----
/** User ID of the collaborator. */
⋮----
/** ID of the trip being collaborated on. */
⋮----
/** Email address of the collaborator. */
⋮----
/** Optional display name of the collaborator. */
⋮----
/** Role determining permissions level. */
⋮----
/** Current invitation/acceptance status. */
⋮----
/** Detailed permission flags. */
⋮----
/** Whether the collaborator can edit trip content. */
⋮----
/** Whether the collaborator can invite others. */
⋮----
/** Whether the collaborator can delete the trip. */
⋮----
/** Timestamp when the invitation was sent. */
⋮----
/** Timestamp when the invitation was accepted. */
⋮----
/**
 * Trip collaboration page component.
 *
 * Displays interface for managing collaborators, real-time editing, activity monitoring,
 * and sharing settings.
 *
 * @returns The trip collaboration page JSX element
 */
export default function TripCollaborationPage()
⋮----
// Pass null to useTrip when tripId is invalid to prevent requests to /api/trips/NaN
⋮----
// getBrowserClient() may return null during initial client-side initialization/hydration — skip auth check until client is available
⋮----
// Best-effort: keep UI consistent even if auth lookup fails
⋮----
// TODO: Replace with useCollaborators(tripId) hook when API endpoint is implemented.
⋮----
/**
   * Handles sending collaboration invitations to new users.
   */
const handleInviteCollaborator = async () =>
⋮----
// Prevent duplicate submissions while invite is in progress
⋮----
/**
   * Copies the trip share link to clipboard.
   */
const handleCopyShareLink = async (): Promise<void> =>
⋮----
/**
   * Returns the appropriate icon component for a collaborator role.
   *
   * @param role - The collaborator role
   * @returns Icon component for the role
   */
const getRoleIcon = (role: Collaborator["role"]) =>
⋮----
/**
   * Returns the appropriate status badge component for invitation status.
   *
   * @param status - The invitation status
   * @returns Badge component for the status
   */
⋮----
return <Badge className=
⋮----
{/* Header */}
⋮----
{/* Main Content */}
⋮----
onKeyDown=
⋮----

⋮----
{/* Sidebar */}
````

## File: src/app/dashboard/trips/loading.tsx
````typescript
/**
 * @fileoverview Loading skeleton for the trips dashboard page.
 */
⋮----
import { Skeleton } from "@/components/ui/skeleton";
⋮----
{/* Header */}
⋮----
{/* Filters bar */}
⋮----
{/* Trips grid */}
⋮----
{/* Trip image */}
⋮----
{/* Trip content */}
⋮----
{/* Trip dates */}
⋮----
{/* Trip details */}
⋮----
{/* Action buttons */}
⋮----
{/* Pagination */}
````

## File: src/app/dashboard/trips/page.tsx
````typescript
/**
 * @fileoverview Trips management page with filtering, sorting, and search.
 *
 * Provides comprehensive UI for managing user trips including status filtering,
 * search functionality, sorting options, and grid/list view modes.
 */
⋮----
import {
  FilterIcon,
  GridIcon,
  ListIcon,
  Loader2Icon,
  PlusIcon,
  SearchIcon,
} from "lucide-react";
import { useEffect, useMemo, useRef, useState } from "react";
import { ConnectionStatusIndicator } from "@/components/features/realtime/connection-status-monitor";
import { TripCard } from "@/components/features/trips/trip-card";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useToast } from "@/components/ui/use-toast";
import { type Trip, useCreateTrip, useDeleteTrip, useTrips } from "@/hooks/use-trips";
import { getErrorMessage } from "@/lib/api/error-types";
import { nowIso } from "@/lib/security/random";
import { parseTripDate } from "@/lib/trips/parse-trip-date";
⋮----
/**
 * Trip status count colors aligned with statusVariants.
 * Matches trip status semantic colors.
 */
⋮----
active: "text-green-700", // aligned with active status
completed: "text-gray-600", // neutral completed state
upcoming: "text-blue-700", // aligned with info status
⋮----
type ConnectionState = "connected" | "error" | "disconnected";
⋮----
const getConnectionStatusMessage = (state: ConnectionState): string =>
⋮----
const getConnectionState = (
  realtimeErrorCount: number,
  isConnected: boolean
): ConnectionState =>
⋮----
const isInvalidTripDateRange = (
  startDate: Date | null,
  endDate: Date | null
): boolean
⋮----
type TripStatus = "draft" | "upcoming" | "active" | "completed";
type SortOption = "name" | "date" | "budget" | "destinations";
type FilterOption = "all" | "draft" | "upcoming" | "active" | "completed";
⋮----
const getTripStatus = (trip: Trip, nowTs: number): TripStatus =>
⋮----
/**
 * Renders the trips management dashboard with filtering, sorting, and view
 * toggles backed by realtime queries.
 *
 * @returns Trips management layout with grid/list modes.
 */
⋮----
// Apply search filter
⋮----
// Apply status filter
⋮----
// Apply sorting
⋮----
const handleCreateTrip = async () =>
⋮----
const handleDeleteTrip = (tripId: string) =>
⋮----
const confirmDeleteTrip = async () =>
⋮----
// Handle error state
⋮----
// Show loading state
⋮----
{/* Header */}
⋮----
{/* Status Overview */}
⋮----
{/* Filters and Search */}
⋮----
{/* Trips Grid/List */}
⋮----
{/* Load More (if needed for pagination) */}
⋮----
setIsDeleteDialogOpen(open);
⋮----
onClick=
````

## File: src/app/dashboard/error.tsx
````typescript
/**
 * @fileoverview Dashboard-level error boundary for the dashboard directory.
 * This catches errors within the dashboard layout and pages.
 */
⋮----
import { useEffect } from "react";
import { ErrorFallback } from "@/components/error/error-fallback";
import { getSessionId } from "@/lib/client/session";
import { errorService } from "@/lib/error-service";
import { fireAndForget } from "@/lib/utils";
⋮----
interface ExtendedWindow extends Window {
  userStore?: { user?: { id?: string } };
}
⋮----
/**
 * Dashboard-level error boundary
 * Catches errors within the dashboard layout and pages
 */
export default function DashboardError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
reset: ()
⋮----
// Report the dashboard error
⋮----
// Log error in development
⋮----
/**
 * Gets the current user ID from the user store.
 *
 * @returns User ID or undefined if not available
 */
function getUserId(): string | undefined
````

## File: src/app/dashboard/layout.tsx
````typescript
/**
 * @fileoverview Dashboard root layout (RSC shell) enforcing auth and providing the
 * shared dashboard chrome.
 *
 * Caching is handled at the app level via `cacheComponents`; this layout intentionally
 * does not opt into per-file caching directives because it relies on authenticated
 * user context.
 */
⋮----
import { Suspense } from "react";
import { DashboardLayout } from "@/components/layouts/dashboard-layout";
import { requireUser } from "@/lib/auth/server";
import DashboardLoading from "./loading";
⋮----
export default async function Layout(
⋮----
// Enforce Supabase SSR auth for all dashboard routes.
````

## File: src/app/dashboard/loading.tsx
````typescript
/**
 * @fileoverview Dashboard loading skeleton.
 */
⋮----
import { CardSkeleton, LoadingContainer } from "@/components/ui/loading";
⋮----
/**
 * Dashboard loading component
 * Shows skeleton for dashboard layout while content loads
 */
⋮----
{/* Dashboard grid skeleton */}
````

## File: src/app/dashboard/page.tsx
````typescript
/**
 * @fileoverview Dashboard Page - Displays an overview of user travel data and metrics.
 *
 * Utilizes React Suspense for data fetching and loading states.
 * Composes multiple dashboard feature components.
 */
⋮----
import { Suspense } from "react";
import { DashboardMetrics } from "@/components/features/dashboard/dashboard-metrics";
import { QuickActions } from "@/components/features/dashboard/quick-actions";
import { RecentTrips } from "@/components/features/dashboard/recent-trips";
import { TripSuggestions } from "@/components/features/dashboard/trip-suggestions";
import { UpcomingFlights } from "@/components/features/dashboard/upcoming-flights";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
⋮----
{/* Quick Actions Skeleton */}
⋮----
{/* Main Content Grid Skeleton */}
⋮----
// Simulate API delay for demonstration of streaming
⋮----
{/* Top Row - Quick Actions */}
⋮----
{/* Dashboard Metrics */}
⋮----
{/* Main Content Grid */}
⋮----
{/* Recent Trips */}
⋮----
{/* Upcoming Flights */}
⋮----
{/* Trip Suggestions - Takes up remaining space */}
````

## File: src/app/global-error.tsx
````typescript
/**
 * @fileoverview Global error boundary for the app.
 * This catches errors in the root layout or template.
 */
⋮----
import { useEffect } from "react";
import { MinimalErrorFallback } from "@/components/error/error-fallback";
import { getSessionId } from "@/lib/client/session";
import { errorService } from "@/lib/error-service";
import { fireAndForget } from "@/lib/utils";
⋮----
/**
 * Global error boundary for the app.
 * Catches errors in the root layout or template.
 * This is a last resort fallback that replaces the entire root layout
 */
export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
reset: ()
⋮----
// Report the critical error
⋮----
// Log critical error
⋮----
/**
 * Gets the current user ID from the user store.
 *
 * @returns User ID or undefined if not available
 */
function getUserId(): string | undefined
````

## File: src/app/layout.tsx
````typescript
/**
 * @fileoverview Next.js root layout component with theme, query, and performance providers.
 *
 * Sets up providers for theming, data fetching, performance monitoring, and navigation.
 * Includes global font loading and metadata.
 */
⋮----
import { BotIdClient } from "botid/client";
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
⋮----
import { PerformanceMonitor } from "@/components/providers/performance-provider";
import { TanStackQueryProvider } from "@/components/providers/query-provider";
import { RealtimeAuthProvider } from "@/components/providers/realtime-auth-provider";
import { TelemetryProvider } from "@/components/providers/telemetry-provider";
import { ThemeProvider } from "@/components/providers/theme-provider";
import { Toaster } from "@/components/ui/toaster";
import { BOTID_PROTECT, SHOULD_ENABLE_BOT_ID } from "@/config/bot-protection";
⋮----
/**
 * Primary sans-serif font configuration.
 */
⋮----
/**
 * Monospace font configuration for code and technical content.
 */
⋮----
/**
 * Application metadata for SEO and social sharing.
 */
⋮----
/**
 * Viewport configuration for responsive design.
 */
⋮----
/**
 * Root layout component.
 *
 * Wraps the application with providers for theming, data fetching, performance monitoring,
 * notifications, and navigation.
 *
 * @param props - Component props
 * @param props.children - Child components to render in the main content area
 * @returns The root layout JSX element
 */
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>)
⋮----
{/* Initialize client-side OpenTelemetry tracing */}
⋮----
{/* Keep Supabase Realtime authorized with the current access token */}
````

## File: src/app/loading.tsx
````typescript
import { PageLoading } from "@/components/ui/loading";
⋮----
/**
 * Root loading component for Next.js App Router
 * Shown when navigating between pages or during Suspense boundaries
 */
export default function Loading()
````

## File: src/components/admin/configuration-actions.ts
````typescript
import {
  type AgentType,
  agentTypeSchema,
  versionIdSchema,
} from "@schemas/configuration";
import { resolveAgentConfig } from "@/lib/agents/config-resolver";
import { createServerSupabase } from "@/lib/supabase/server";
import { toAbsoluteUrl } from "@/lib/url/server-origin";
⋮----
export type AgentVersion = {
  id: string;
  createdAt: string;
  createdBy: string | null;
  summary: string | null;
};
⋮----
export type AgentMetrics = {
  versionCount: number;
  lastUpdatedAt: string | null;
};
⋮----
export async function fetchAgentBundle(agentTypeRaw: string)
⋮----
export async function updateAgentConfigAction(
  agentType: AgentType,
  payload: Record<string, unknown>
)
⋮----
// SSRF prevention: validate agentType against allow-list schema
⋮----
// Use absolute URL with trusted origin to prevent SSRF
⋮----
export async function rollbackAgentConfigAction(
  agentType: AgentType,
  versionId: string
)
⋮----
// SSRF prevention: validate agentType against allow-list schema
⋮----
// SSRF prevention: validate versionId format
⋮----
// Use absolute URL with trusted origin to prevent SSRF
````

## File: src/components/admin/configuration-manager.tsx
````typescript
/**
 * @fileoverview Admin UI for managing agent configuration with version history.
 * Uses server actions for data access; no client-side fetching side effects.
 */
⋮----
import type { AgentConfig, AgentType } from "@schemas/configuration";
import {
  AlertTriangleIcon,
  CheckCircleIcon,
  ClockIcon,
  HistoryIcon,
  RotateCcwIcon,
  SaveIcon,
  SettingsIcon,
} from "lucide-react";
import { useState, useTransition } from "react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useToast } from "@/components/ui/use-toast";
import {
  type AgentMetrics,
  type AgentVersion,
  fetchAgentBundle,
  rollbackAgentConfigAction,
  updateAgentConfigAction,
} from "./configuration-actions";
⋮----
export type ConfigurationManagerProps = {
  initialAgent: AgentType;
  initialConfig: AgentConfig;
  initialVersions: AgentVersion[];
  initialMetrics: AgentMetrics;
};
⋮----
const applyAgentData = (bundle: Awaited<ReturnType<typeof fetchAgentBundle>>) =>
⋮----
const handleAgentChange = (value: AgentType) =>
⋮----
const handleSave = () =>
⋮----
const handleRollback = (versionId: string) =>
⋮----
const onParamChange = (
    field: keyof AgentConfig["parameters"],
    value: number | string | null
) =>
````

## File: src/components/ai-elements/code-block.tsx
````typescript
/**
 * @fileoverview Small code/output block with optional copy control.
 */
⋮----
import { CheckIcon, CopyIcon } from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
⋮----
export type CodeBlockProps = {
  value: string;
  className?: string;
  isAnimating?: boolean;
  label?: string;
  maxHeightClassName?: string;
};
⋮----
<div className=
⋮----
className=
````

## File: src/components/ai-elements/conversation.tsx
````typescript
/**
 * @fileoverview Conversation component for displaying a conversation in a chat-like format.
 * Provides a styled conversation with various sizes and variants.
 */
⋮----
import { ArrowDownIcon } from "lucide-react";
import type { ComponentProps } from "react";
import { useCallback } from "react";
import { StickToBottom, useStickToBottomContext } from "use-stick-to-bottom";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
⋮----
/** Props for the Conversation container. */
export type ConversationProps = ComponentProps<typeof StickToBottom>;
⋮----
/**
 * Conversation container that auto-sticks to the bottom as content grows.
 *
 * @param className Optional extra classes.
 * @param props Additional StickToBottom props.
 * @returns A scrollable region with ARIA `role="log"`.
 */
⋮----
/** Props for the Conversation content region. */
⋮----
/**
 * The inner content region of the conversation.
 *
 * @param className Optional extra classes.
 * @param props Additional content props.
 * @returns A padded content wrapper.
 */
⋮----
<StickToBottom.Content className=
⋮----
/** Props for the empty state rendered when there are no messages. */
⋮----
/**
 * A simple empty state to display when no messages exist.
 *
 * @param title Optional title text.
 * @param description Optional message describing the state.
 * @param icon Optional icon React node.
 * @returns A centered placeholder UI.
 */
⋮----
className=
⋮----
/** Props for the floating scroll-to-bottom button. */
⋮----
/**
 * Renders a floating button that appears when scrolled away from bottom and
 * scrolls back to the latest message on click.
 *
 * @param className Optional extra classes.
 * @param props Additional button props.
 * @returns The scroll button when needed; otherwise `null`.
 */
````

## File: src/components/ai-elements/destination-card.tsx
````typescript
/**
 * @fileoverview Destination research card for AI Elements.
 */
⋮----
import type { DestinationResearchResult } from "@schemas/agents";
import type { ComponentProps } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Source, Sources, SourcesContent, SourcesTrigger } from "./sources";
⋮----
/**
 * Props for DestinationCard component.
 */
export type DestinationCardProps = ComponentProps<typeof Card> & {
  /** Destination research result to render. */
  result: DestinationResearchResult;
};
⋮----
/** Destination research result to render. */
⋮----
type DestinationItem = NonNullable<DestinationResearchResult["highlights"]>[number];
type SafetyScore = NonNullable<
  NonNullable<DestinationResearchResult["safety"]>["scores"]
>[number];
⋮----
/**
 * Render a destination research result with overview, highlights, and sources.
 */
⋮----
key=
````

## File: src/components/ai-elements/flight-card.tsx
````typescript
/**
 * @fileoverview Flight offer card for AI Elements.
 */
⋮----
import type { FlightSearchResult } from "@schemas/agents";
import type { ComponentProps } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Source, Sources, SourcesContent, SourcesTrigger } from "./sources";
⋮----
/**
 * Props for FlightOfferCard component.
 */
export type FlightOfferCardProps = ComponentProps<typeof Card> & {
  /** Search result containing itineraries to render. */
  result: FlightSearchResult;
};
⋮----
/** Search result containing itineraries to render. */
⋮----
type FlightItinerary = FlightSearchResult["itineraries"][number];
type FlightSegment = FlightItinerary["segments"][number];
type FlightSource = NonNullable<FlightSearchResult["sources"]>[number];
⋮----
/**
 * Render a compact flight search result with top itineraries and source links.
 */
````

## File: src/components/ai-elements/itinerary-timeline.tsx
````typescript
/**
 * @fileoverview Itinerary timeline component for AI Elements.
 */
⋮----
import type { ItineraryPlanResult } from "@schemas/agents";
import type { ComponentProps } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Source, Sources, SourcesContent, SourcesTrigger } from "./sources";
⋮----
/**
 * Props for ItineraryTimeline component.
 */
export type ItineraryTimelineProps = ComponentProps<typeof Card> & {
  /** Itinerary plan result to render. */
  result: ItineraryPlanResult;
};
⋮----
/** Itinerary plan result to render. */
⋮----
type ItineraryDay = ItineraryPlanResult["days"][number];
type ItineraryActivity = NonNullable<ItineraryDay["activities"]>[number];
type ItineraryRecommendation = NonNullable<
  ItineraryPlanResult["recommendations"]
>[number];
type ItinerarySource = NonNullable<ItineraryPlanResult["sources"]>[number];
⋮----
/**
 * Render an itinerary plan with day-by-day timeline.
 */
⋮----
key=
````

## File: src/components/ai-elements/message.tsx
````typescript
/**
 * @fileoverview Message primitives for chat UIs. Includes container, content,
 * and avatar components used within conversation lists.
 */
import type { UIMessage } from "ai";
import { cva, type VariantProps } from "class-variance-authority";
import type { ComponentProps, HTMLAttributes } from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { cn } from "@/lib/utils";
⋮----
/** Props for a single chat message container. */
export type MessageProps = HTMLAttributes<HTMLDivElement> & {
  from: UIMessage["role"];
};
⋮----
/**
 * Message container that aligns based on author role.
 *
 * @param from The role of the message author (user or assistant).
 * @returns A flex container with appropriate alignment.
 */
⋮----
className=
⋮----
/** Props for message content region. */
⋮----
/**
 * Content wrapper for message text and elements.
 *
 * @param variant Visual variant (contained or flat).
 * @returns A styled content container.
 */
⋮----
<div className=
⋮----
/** Props for the message avatar. */
⋮----
/**
 * Avatar for the message author.
 *
 * @param src Image URL.
 * @param name Optional display name for fallback initials.
 * @returns A sized avatar with border ring and fallback.
 */
````

## File: src/components/ai-elements/prompt-input.tsx
````typescript
/**
 * @fileoverview Prompt input primitives for chat UIs.
 *
 * This module intentionally stays small and composable. It exports a minimal set of
 * components used by the app (chat + demo pages) and avoids speculative/unused
 * features to keep maintenance cost low.
 */
⋮----
import type { ChatStatus } from "ai";
import { Loader2Icon, SendIcon, SquareIcon, XIcon } from "lucide-react";
import type {
  ComponentProps,
  FormEvent,
  FormEventHandler,
  HTMLAttributes,
  KeyboardEventHandler,
} from "react";
import { useState } from "react";
import {
  InputGroup,
  InputGroupAddon,
  InputGroupButton,
  InputGroupTextarea,
} from "@/components/ui/input-group";
import { cn } from "@/lib/utils";
⋮----
/**
 * Message data structure for prompt submissions.
 *
 * Keep this minimal; richer message shapes live at the chat transport layer.
 */
export type PromptInputMessage = {
  /** Optional text content of the message. */
  text?: string;
};
⋮----
/** Optional text content of the message. */
⋮----
/**
 * Props for the PromptInput form wrapper.
 */
export type PromptInputProps = Omit<HTMLAttributes<HTMLFormElement>, "onSubmit"> & {
  /** Submit handler for the prompt input. */
  onSubmit: (
    message: PromptInputMessage,
    event: FormEvent<HTMLFormElement>
  ) => void | Promise<void>;
  /** Optional error handler for submission failures or validation errors. */
  onError?: (error: Error) => void;
};
⋮----
/** Submit handler for the prompt input. */
⋮----
/** Optional error handler for submission failures or validation errors. */
⋮----
/**
 * Form wrapper that provides consistent layout via `InputGroup`.
 */
export const PromptInput = ({
  className,
  onSubmit,
  onError,
  children,
  ...props
}: PromptInputProps) =>
⋮----
const handleSubmit: FormEventHandler<HTMLFormElement> = (event) =>
⋮----
// Validate non-empty message before submission
⋮----
<form className=
⋮----
export type PromptInputBodyProps = HTMLAttributes<HTMLDivElement>;
⋮----
/**
 * Semantic container for the main content area of the prompt input.
 */
export const PromptInputBody = ({ className, ...props }: PromptInputBodyProps) => (
  <div className={cn("contents", className)} {...props} />
);
⋮----
<div className=
⋮----
/**
 * Layout component for header content above the input area.
 */
export const PromptInputHeader = ({ className, ...props }: PromptInputHeaderProps) => (
  <InputGroupAddon
    align="block-end"
    className={cn("order-first flex-wrap gap-1", className)}
    {...props}
  />
);
⋮----
className=
⋮----
export type PromptInputFooterProps = Omit<
  ComponentProps<typeof InputGroupAddon>,
  "align"
>;
⋮----
/**
 * Layout component for footer content below the input area.
 */
export const PromptInputFooter = ({ className, ...props }: PromptInputFooterProps) => (
  <InputGroupAddon
    align="block-end"
    className={cn("justify-between gap-1", className)}
    {...props}
  />
);
⋮----
export type PromptInputTextareaProps = ComponentProps<typeof InputGroupTextarea> & {
  /** Placeholder text for the textarea. */
  placeholder?: string;
};
⋮----
/** Placeholder text for the textarea. */
⋮----
/**
 * Textarea component with Enter-to-submit handling (Shift+Enter inserts a newline).
 */
export const PromptInputTextarea = ({
  className,
  placeholder = "What would you like to know?",
  ...props
}: PromptInputTextareaProps) =>
⋮----
const handleKeyDown: KeyboardEventHandler<HTMLTextAreaElement> = (event) =>
⋮----
export type PromptInputSubmitProps = ComponentProps<typeof InputGroupButton> & {
  /** Current chat status to determine icon display. */
  status?: ChatStatus;
};
⋮----
/** Current chat status to determine icon display. */
⋮----
/**
 * Status-aware submit button for prompt forms.
 */
export const PromptInputSubmit = ({
  className,
  variant = "default",
  size = "icon-sm",
  status,
  children,
  ...props
}: PromptInputSubmitProps) =>
````

## File: src/components/ai-elements/reasoning.tsx
````typescript
/**
 * @fileoverview Collapsible reasoning display for assistant messages.
 */
⋮----
import { ChevronDownIcon } from "lucide-react";
import { useState } from "react";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { cn } from "@/lib/utils";
import { Response } from "./response";
import { Shimmer } from "./shimmer";
⋮----
export type ReasoningProps = {
  text: string;
  className?: string;
  defaultOpen?: boolean;
  isAnimating?: boolean;
};
⋮----
className=
````

## File: src/components/ai-elements/response.tsx
````typescript
/**
 * @fileoverview AI Elements Response component.
 * Renders markdown content using Streamdown with sensible defaults.
 */
⋮----
import { type ComponentProps, memo } from "react";
import { Streamdown } from "streamdown";
import { cn } from "@/lib/utils";
import {
  streamdownControls,
  streamdownMermaid,
  streamdownRehypePlugins,
  streamdownRemarkPlugins,
  streamdownShikiTheme,
} from "./streamdown-config";
⋮----
/** Props for the Response component. */
export type ResponseProps = ComponentProps<typeof Streamdown> & {
  /**
   * When true, disables interactive controls during streaming.
   * Mode defaults to "streaming" when not explicitly provided.
   */
  isAnimating?: boolean;
};
⋮----
/**
   * When true, disables interactive controls during streaming.
   * Mode defaults to "streaming" when not explicitly provided.
   */
⋮----
/**
 * Response renders markdown content (with streaming-friendly parsing).
 *
 * Example:
 *   <Response>{"**Hello** world"}</Response>
 */
⋮----
className=
````

## File: src/components/ai-elements/shimmer.tsx
````typescript
import { motion } from "motion/react";
import { type CSSProperties, type ElementType, type JSX, memo, useMemo } from "react";
import { cn } from "@/lib/utils";
⋮----
export type TextShimmerProps = {
  children: string;
  as?: ElementType;
  className?: string;
  duration?: number;
  spread?: number;
};
⋮----
className=
````

## File: src/components/ai-elements/sources.tsx
````typescript
/**
 * @fileoverview AI Elements Sources components.
 * Minimal implementation using shadcn/ui Popover primitives.
 */
⋮----
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { safeHref } from "@/lib/url/safe-href";
import { cn } from "@/lib/utils";
⋮----
export type SourcesProps = React.ComponentPropsWithoutRef<typeof Popover>;
⋮----
/**
 * Sources is a container that groups a trigger and content listing citations.
 */
export function Sources(props: SourcesProps)
⋮----
export interface SourcesTriggerProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  /** Optional count to show in the trigger label. */
  count?: number;
}
⋮----
/** Optional count to show in the trigger label. */
⋮----
/**
 * SourcesTrigger renders a small button to open the sources popover.
 */
⋮----
/**
 * SourcesContent lists provided citations.
 */
⋮----
/**
 * Source renders a single source link item.
 */
⋮----
className=
````

## File: src/components/ai-elements/stay-card.tsx
````typescript
/**
 * @fileoverview Accommodation stay card for AI Elements.
 */
⋮----
import type { AccommodationSearchResult } from "@schemas/agents";
import type { ComponentProps } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Source, Sources, SourcesContent, SourcesTrigger } from "./sources";
⋮----
/**
 * Props for StayCard component.
 */
export type StayCardProps = ComponentProps<typeof Card> & {
  /** Accommodation search result */
  result: AccommodationSearchResult;
};
⋮----
/** Accommodation search result */
⋮----
type Stay = AccommodationSearchResult["stays"][number];
type StaySource = NonNullable<AccommodationSearchResult["sources"]>[number];
⋮----
/**
 * Render a compact list of stays with price and links.
 */
````

## File: src/components/ai-elements/streamdown-config.ts
````typescript
/**
 * @fileoverview Centralized Streamdown defaults for TripSage.
 *
 * Streamdown is used as the markdown renderer for AI Elements Response. We keep
 * the built-in remark/rehype pipeline (GFM, math, CJK-friendly parsing, Shiki,
 * Mermaid) but tighten link/image protocol handling for AI-generated content.
 */
⋮----
import type { MermaidConfig, MermaidOptions, StreamdownProps } from "streamdown";
import { defaultRehypePlugins, defaultRemarkPlugins } from "streamdown";
import type { Plugin } from "unified";
⋮----
type HardenOptions = {
  allowedImagePrefixes?: string[];
  allowedLinkPrefixes?: string[];
  allowedProtocols?: string[];
  defaultOrigin?: string | undefined;
  allowDataImages?: boolean;
};
⋮----
// Normalize dual plugin shapes (function or [function, options] tuple) and cast for streamdown's plugin type constraints.
````

## File: src/components/ai-elements/tool.tsx
````typescript
/**
 * @fileoverview Collapsible tool call/result display.
 */
⋮----
import { ChevronDownIcon } from "lucide-react";
import { useMemo, useState } from "react";
import { Badge } from "@/components/ui/badge";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { cn } from "@/lib/utils";
import { CodeBlock } from "./code-block";
⋮----
export type ToolProps = {
  name: string;
  status?: string;
  input?: unknown;
  output?: unknown;
  className?: string;
  defaultOpen?: boolean;
};
⋮----
function formatValue(value: unknown): string
⋮----
className=
⋮----
<CodeBlock label="Input" value=
````

## File: src/components/auth/login-form.tsx
````typescript
/**
 * @fileoverview The login form component.
 */
⋮----
import { SiGithub, SiGoogle } from "@icons-pack/react-simple-icons";
import { Loader2Icon, MailIcon } from "lucide-react";
import { useMemo, useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { resolveRedirectUrl } from "@/lib/auth/redirect";
import { useSupabaseRequired } from "@/lib/supabase/client";
⋮----
/** The login form props. */
type LoginFormProps = {
  redirectTo?: string;
};
⋮----
/**
 * The login form component.
 *
 * @param redirectTo - The redirect URL.
 * @returns The login form component.
 */
⋮----
/** Starts an MFA challenge for a verified factor (prefers TOTP). */
const startMfaChallenge = async () =>
⋮----
// Prefer TOTP for code-based verification; WebAuthn requires different handling
⋮----
/** Handles the password login. */
const handlePasswordLogin = async (event: React.FormEvent) =>
⋮----
/** Handles MFA code verification once a challenge is active. */
const handleMfaVerify = async (event: React.FormEvent) =>
⋮----
/** Handles the OAuth login. */
const handleOAuth = async (provider: "github" | "google") =>
````

## File: src/components/calendar/calendar-connect-client-wrapper.tsx
````typescript
/**
 * @fileoverview Calendar connection status card component.
 *
 * Client component that fetches calendar status via API route to avoid
 * server/client boundary violations. Displays connection status and list
 * of connected calendars.
 */
⋮----
import { CalendarCheckIcon, CalendarIcon, CalendarXIcon } from "lucide-react";
import { useEffect, useState } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { CalendarConnectClient } from "./calendar-connect-client";
⋮----
/**
 * Props for CalendarConnectionCard component.
 */
export interface CalendarConnectionCardProps {
  /** Optional className for styling */
  className?: string;
}
⋮----
/** Optional className for styling */
⋮----
/**
 * CalendarConnectionCard component.
 *
 * Client component that fetches calendar status via API and renders
 * the connection status UI.
 */
⋮----
const loadCalendarStatus = async () =>
````

## File: src/components/calendar/calendar-connect-client.tsx
````typescript
/**
 * @fileoverview Client component for initiating Google Calendar OAuth connection.
 */
⋮----
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
import { useToast } from "@/components/ui/use-toast";
import { useSupabaseRequired } from "@/lib/supabase";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
⋮----
/**
 * CalendarConnectClient component.
 *
 * Client component that initiates Google OAuth flow for calendar access.
 */
⋮----
const handleConnect = async () =>
⋮----
// If successful, user will be redirected to OAuth flow
````

## File: src/components/calendar/calendar-connection-card.tsx
````typescript
/**
 * @fileoverview Calendar connection status card component.
 *
 * Client component that fetches calendar status via API route to avoid
 * server/client boundary violations. Displays connection status and list
 * of connected calendars.
 */
⋮----
import type { CalendarStatusResponse } from "@schemas/calendar";
import {
  AlertCircleIcon,
  CalendarCheckIcon,
  CalendarIcon,
  CalendarXIcon,
} from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { CalendarConnectClient } from "./calendar-connect-client";
⋮----
/**
 * Props for CalendarConnectionCard component.
 */
export interface CalendarConnectionCardProps {
  /** Optional className for styling */
  className?: string;
}
⋮----
/** Optional className for styling */
⋮----
/**
 * CalendarConnectionCard component.
 *
 * Client component that fetches calendar status via API and renders
 * the connection status UI.
 */
⋮----
// Cancel any pending request
⋮----
// Create new AbortController for this request
⋮----
// Try to parse JSON error body, fallback to statusText
⋮----
// Not JSON, use statusText
⋮----
// Only update state if request wasn't aborted
⋮----
// Don't update state if request was aborted
⋮----
// Swallow telemetry errors to avoid breaking component
⋮----
// Cleanup: abort any pending request on unmount
⋮----
onClick=
````

## File: src/components/calendar/calendar-event-form.tsx
````typescript
/**
 * @fileoverview Client component for creating/editing calendar events.
 */
⋮----
import { createEventRequestSchema } from "@schemas/calendar";
import { useState } from "react";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/components/ui/use-toast";
import { useZodForm } from "@/hooks/use-zod-form";
⋮----
type EventFormData = z.infer<typeof EVENT_FORM_SCHEMA>;
⋮----
/**
 * Props for CalendarEventForm component.
 */
export interface CalendarEventFormProps {
  /** Optional initial event data for editing */
  initialData?: Partial<EventFormData>;
  /** Callback when event is created/updated */
  onSuccess?: (eventId: string) => void;
  /** Callback on error */
  onError?: (error: string) => void;
  /** Optional className */
  className?: string;
}
⋮----
/** Optional initial event data for editing */
⋮----
/** Callback when event is created/updated */
⋮----
/** Callback on error */
⋮----
/** Optional className */
⋮----
/**
 * CalendarEventForm component.
 *
 * Form for creating or editing calendar events.
 */
⋮----
dateTime: new Date(Date.now() + 60 * 60 * 1000), // Default 1 hour
⋮----
const onSubmit = async (data: EventFormData): Promise<void> =>
⋮----
// Reset form after successful submission
⋮----
// Only show toast if parent didn't provide onError callback
// Parent can handle error display (e.g., CalendarPage shows toast)
````

## File: src/components/calendar/calendar-event-list.tsx
````typescript
/**
 * @fileoverview Client Component for displaying calendar events list.
 *
 * Fetches events via API route to avoid server/client boundary violations.
 */
⋮----
import { useQuery } from "@tanstack/react-query";
import { CalendarIcon, ClockIcon, MapPinIcon } from "lucide-react";
import { z } from "zod";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { DateUtils } from "@/lib/dates/unified-date-utils";
⋮----
type CalendarEventListItem = z.infer<typeof CalendarEventListItemSchema>;
⋮----
/** Props for CalendarEventList component. */
export interface CalendarEventListProps {
  /** Calendar ID to fetch events from (default: "primary") */
  calendarId?: string;
  /** Start date for event query */
  timeMin?: Date;
  /** End date for event query */
  timeMax?: Date;
  /** Optional className */
  className?: string;
}
⋮----
/** Calendar ID to fetch events from (default: "primary") */
⋮----
/** Start date for event query */
⋮----
/** End date for event query */
⋮----
/** Optional className */
⋮----
/**
 * Fetches Calendar events via API and renders a summarized list in a card.
 *
 * @param props - Optional calendar id and time range plus styling hook.
 * @returns Client component output with event list.
 */
````

## File: src/components/error/error-fallback.tsx
````typescript
/**
 * @fileoverview Client error fallback boundary rendering telemetry-friendly UI.
 */
⋮----
import type { ErrorFallbackProps } from "@schemas/errors";
import { AlertTriangleIcon, BugIcon, HomeIcon, RefreshCwIcon } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
⋮----
/**
 * Default error fallback component for error boundaries
 */
⋮----
const handleGoHome = () =>
⋮----
const handleReload = () =>
⋮----
/**
 * Minimal error fallback for critical errors
 */
⋮----
/**
 * Page-level error fallback
 */
````

## File: src/components/features/agent-monitoring/communication/agent-collaboration-hub.tsx
````typescript
/**
 * @fileoverview Agent collaboration hub component for monitoring multi-agent coordination and handoffs.
 */
⋮----
import {
  ActivityIcon,
  AlertTriangleIcon,
  ArrowRightLeftIcon,
  BrainIcon,
  CheckCircle2Icon,
  ClockIcon,
  GitBranchIcon,
  NetworkIcon,
  TimerIcon,
  TrendingDownIcon,
  TrendingUpIcon,
  UsersIcon,
  WorkflowIcon,
} from "lucide-react";
import { AnimatePresence, motion } from "motion/react";
import type React from "react";
import { startTransition, useEffect, useOptimistic, useState } from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import {
  AGENT_STATUS_COLORS,
  DEFAULT_HANDOFF_STATUS_COLOR,
  HANDOFF_STATUS_COLORS,
  TREND_COLORS,
} from "@/lib/variants/status";
⋮----
/** Interface for an agent */
interface Agent {
  id: string;
  name: string;
  avatar?: string;
  status: "active" | "busy" | "idle" | "offline";
  specialization: string;
  currentTask?: string;
  performance: {
    accuracy: number;
    speed: number;
    efficiency: number;
  };
  workload: number; // 0-100
  lastActive: Date;
}
⋮----
workload: number; // 0-100
⋮----
/** Interface for an agent handoff */
interface AgentHandoff {
  id: string;
  fromAgent: string;
  toAgent: string;
  task: string;
  reason: string;
  timestamp: Date;
  status: "pending" | "completed" | "failed";
  confidence: number;
}
⋮----
/** Interface for a collaboration metric */
interface CollaborationMetric {
  metric: string;
  value: number;
  trend: "up" | "down" | "stable";
  description: string;
}
⋮----
/** Interface for the AgentCollaborationHub component props */
interface AgentCollaborationHubProps {
  agents: Agent[];
  handoffs: AgentHandoff[];
  onAgentSelect?: (agentId: string) => void;
  onHandoffApprove?: (handoffId: string) => void;
  onHandoffReject?: (handoffId: string) => void;
  className?: string;
}
⋮----
/** Mock agents for testing */
⋮----
/** Mock handoffs for testing */
⋮----
/** Mock collaboration metrics for testing */
⋮----
/** Function to get the status color for an agent */
const GetStatusColor = (status: Agent["status"] | "unknown") =>
⋮----
/** Function to get the status icon for an agent */
const GetStatusIcon = (status: Agent["status"] | "unknown") =>
⋮----
type AgentStatusIndicatorProps = {
  status?: Agent["status"];
};
⋮----
className=
⋮----
/** Component for an agent card */
⋮----
const getInitials = (name: string) =>
⋮----
/** Component for a handoff card */
⋮----
/** Get the status configuration for a handoff */
⋮----
/** Component for the AgentCollaborationHub */
⋮----
// Using React 19's useOptimistic for immediate UI updates
⋮----
// Simulate real-time updates
⋮----
// Update agent workloads and performance (deterministic - no randomness)
⋮----
// Performance metrics remain unchanged (deterministic behavior)
⋮----
const handleAgentSelect = (agentId: string) =>
⋮----
const handleHandoffApprove = (handoffId: string) =>
⋮----
const handleHandoffReject = (handoffId: string) =>
⋮----
// const averageWorkload = // Future implementation
//   optimisticAgents.reduce((sum, a) => sum + a.workload, 0) / optimisticAgents.length;
⋮----
<div className=
{/* Header */}
⋮----
{/* Metrics Overview */}
⋮----
{/* Agent Grid */}
⋮----
{/* Handoffs */}
⋮----
{/* Collaboration Flow Visualization */}
````

## File: src/components/features/agent-monitoring/dashboard/agent-status-dashboard-lazy.tsx
````typescript
import dynamic from "next/dynamic";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
⋮----
// Dynamically import the AgentStatusDashboard with loading fallback
⋮----
ssr: false, // Disable SSR for this heavy component
````

## File: src/components/features/agent-monitoring/dashboard/agent-status-dashboard.tsx
````typescript
/**
 * @fileoverview Deterministic agent monitoring dashboard backed by the
 * `useAgentStatusStore` + `useAgentStatusWebSocket` pair.
 */
⋮----
import type { AgentStatusType } from "@schemas/agent-status";
import {
  ActivityIcon,
  AlertTriangleIcon,
  CpuIcon,
  GaugeCircleIcon,
  PauseCircleIcon,
  PlayCircleIcon,
  RefreshCwIcon,
  UsersIcon,
} from "lucide-react";
import { useMemo } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import type { AgentStatusRealtimeControls } from "@/hooks/chat/use-agent-status-websocket";
import { statusVariants, type ToneVariant } from "@/lib/variants/status";
import { useAgentStatusStore } from "@/stores/agent-status-store";
import { ConnectionStatus } from "../../shared/connection-status";
⋮----
// Status colors aligned with statusVariants tone classes (static to avoid purge)
⋮----
/**
 * Realtime controls passed in by the parent so this dashboard stays
 * data-source-agnostic (tests can inject deterministic WebSocket state).
 */
export type AgentStatusDashboardProps = Pick<
  AgentStatusRealtimeControls,
  | "connectionStatus"
  | "connectionError"
  | "retryCount"
  | "resume"
  | "pause"
  | "reconnect"
>;
⋮----
function FormatTimestamp(timestamp: string | null)
⋮----
function DeriveConnectionBadge(status: string):
⋮----
/**
 * Renders the realtime agent status dashboard fed by Zustand + WebSocket data.
 *
 * @returns Monitoring layout with status cards and activity feed.
 */
⋮----
Live Supabase updates. Last event:
⋮----
{/* excludeRing: true suppresses the ring for compact badge rendering */}
````

## File: src/components/features/budget/budget-form.tsx
````typescript
/**
 * @fileoverview Trip budget form component with Zod validation and dynamic
 * category allocation.
 */
⋮----
import {
  budgetFormSchema,
  type ExpenseCategory,
  expenseCategorySchema,
} from "@schemas/budget";
import {
  AlertCircleIcon,
  CalculatorIcon,
  DollarSignIcon,
  Loader2Icon,
  PlusIcon,
  TrendingUpIcon,
  XIcon,
} from "lucide-react";
import React, { useCallback, useState } from "react";
import { z } from "zod";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Separator } from "@/components/ui/separator";
import { Switch } from "@/components/ui/switch";
import { Textarea } from "@/components/ui/textarea";
import { useZodForm } from "@/hooks/use-zod-form";
import { secureUuid } from "@/lib/security/random";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { cn } from "@/lib/utils";
⋮----
// Augmented form schema with UI-specific state fields
⋮----
type BudgetFormViewData = z.infer<typeof BudgetFormUiSchema>;
⋮----
interface BudgetFormProps {
  onSubmit: (data: BudgetFormViewData) => Promise<void>;
  onCancel?: () => void;
  initialData?: Partial<BudgetFormViewData>;
  currencies?: Array<{ code: string; name: string; symbol: string }>;
  tripId?: string;
  className?: string;
}
⋮----
// Default currency list (would typically come from API)
⋮----
// Remove UI-specific fields before submission
⋮----
const addCategory = () =>
⋮----
const removeCategory = (index: number) =>
⋮----
<Card className=
⋮----
{/* Basic Information */}
⋮----
{/* Budget Amount */}
⋮----
{/* Date Range */}
⋮----
{/* Budget Categories */}
⋮----
onChange=
⋮----
onClick=
⋮----
{/* Budget Summary */}
⋮----
className=
⋮----
{/* Budget Settings */}
⋮----
field.onChange(Number.parseInt(e.target.value, 10) || 80)
⋮----
{/* Notes */}
⋮----
{/* Form Validation Summary */}
⋮----
{/* Submit Actions */}
````

## File: src/components/features/dashboard/dashboard-metrics.tsx
````typescript
/**
 * @fileoverview Composite dashboard metrics component.
 *
 * Displays a grid of metric cards with a time window selector.
 * Fetches data using useDashboardMetrics hook with automatic polling.
 */
⋮----
import type { TimeWindow } from "@schemas/dashboard";
import { AlertCircleIcon } from "lucide-react";
import { useState } from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useDashboardMetrics } from "@/hooks/use-dashboard-metrics";
import { MetricsCard } from "./metrics-card";
⋮----
/**
 * Props for the DashboardMetrics component.
 */
export interface DashboardMetricsProps {
  /** Initial time window (default: "24h") */
  defaultWindow?: TimeWindow;
  /** Additional CSS classes */
  className?: string;
}
⋮----
/** Initial time window (default: "24h") */
⋮----
/** Additional CSS classes */
⋮----
/**
 * Composite component displaying dashboard metrics with time window selection.
 *
 * @param props - Component props
 * @returns The rendered dashboard metrics section
 *
 * @example
 * ```tsx
 * <DashboardMetrics defaultWindow="7d" />
 * ```
 */
export function DashboardMetrics({
  defaultWindow = "24h",
  className,
}: DashboardMetricsProps)
⋮----
<Tabs onValueChange=
⋮----
/**
 * Skeleton loading state for DashboardMetrics.
 */
function DashboardMetricsSkeleton()
````

## File: src/components/features/dashboard/metrics-card.tsx
````typescript
/**
 * @fileoverview Single metric card component with value, label, and optional trend.
 *
 * Displays a single metric in a card format with support for trend indicators,
 * units, and descriptions.
 */
⋮----
import { ArrowDownIcon, ArrowUpIcon, MinusIcon } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { cn } from "@/lib/utils";
⋮----
/**
 * Trend colors aligned with statusVariants urgency mapping.
 * Positive semantic: up=green (good), down=red (bad)
 * Negative semantic: up=red (bad), down=green (good)
 */
// biome-ignore lint/style/useNamingConvention: Review requested camelCase naming
⋮----
/**
 * Props for the MetricsCard component.
 */
export interface MetricsCardProps {
  /** Title label for the metric */
  title: string;
  /** The metric value to display */
  value: number | string;
  /** Optional unit suffix (e.g., "ms", "%") */
  unit?: string;
  /** Optional trend direction */
  trend?: "up" | "down" | "neutral";
  /** Optional trend value text (e.g., "+5%") */
  trendValue?: string;
  /** Optional description text */
  description?: string;
  /**
   * Semantic for interpreting trend direction.
   * Default treats "up" as negative (red) and "down" as positive (green).
   * Set to "positive" when increases are good (e.g., revenue).
   */
  trendSemantic?: "positive" | "negative";
  /** Additional CSS classes */
  className?: string;
}
⋮----
/** Title label for the metric */
⋮----
/** The metric value to display */
⋮----
/** Optional unit suffix (e.g., "ms", "%") */
⋮----
/** Optional trend direction */
⋮----
/** Optional trend value text (e.g., "+5%") */
⋮----
/** Optional description text */
⋮----
/**
   * Semantic for interpreting trend direction.
   * Default treats "up" as negative (red) and "down" as positive (green).
   * Set to "positive" when increases are good (e.g., revenue).
   */
⋮----
/** Additional CSS classes */
⋮----
/**
 * Displays a single metric in a card format.
 *
 * @param props - Component props
 * @returns The rendered metrics card
 *
 * @example
 * ```tsx
 * <MetricsCard title="Total Requests" value={1000} />
 * <MetricsCard title="Latency" value={150} unit="ms" />
 * <MetricsCard title="Error Rate" value={5} unit="%" trend="up" trendValue="+2%" />
 * ```
 */
⋮----
<Card className=
⋮----

⋮----
<span className=
````

## File: src/components/features/dashboard/metrics-chart.tsx
````typescript
/**
 * @fileoverview Recharts-based metrics visualization component.
 *
 * Displays time-series data as an area chart with gradient fill.
 * Uses ResponsiveContainer for fluid layouts.
 */
⋮----
import { useId } from "react";
import {
  Area,
  AreaChart,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { cn } from "@/lib/utils";
⋮----
/**
 * Data point for the metrics chart.
 */
export interface MetricsChartDataPoint {
  /** Label for the x-axis (e.g., time bucket name) */
  name: string;
  /** Numeric value for the y-axis */
  value: number;
}
⋮----
/** Label for the x-axis (e.g., time bucket name) */
⋮----
/** Numeric value for the y-axis */
⋮----
/**
 * Props for the MetricsChart component.
 */
export interface MetricsChartProps {
  /** Chart title */
  title: string;
  /** Array of data points to visualize */
  data: MetricsChartDataPoint[];
  /** Primary color for the chart (default: "#8884d8") */
  color?: string;
  /** Chart height in pixels (default: 200) */
  height?: number;
  /** Additional CSS classes */
  className?: string;
}
⋮----
/** Chart title */
⋮----
/** Array of data points to visualize */
⋮----
/** Primary color for the chart (default: "#8884d8") */
⋮----
/** Chart height in pixels (default: 200) */
⋮----
/** Additional CSS classes */
⋮----
/**
 * Displays time-series metrics data as an area chart.
 *
 * @param props - Component props
 * @returns The rendered chart card
 *
 * @example
 * ```tsx
 * <MetricsChart
 *   title="Request Volume"
 *   data={[
 *     { name: "Mon", value: 100 },
 *     { name: "Tue", value: 150 },
 *   ]}
 * />
 * ```
 */
⋮----
// Generate unique gradient ID per instance to avoid collisions between charts
⋮----
<Card className=
````

## File: src/components/features/dashboard/quick-actions.tsx
````typescript
/**
 * @fileoverview QuickActions component providing grid/list/compact layouts for
 * common travel planning tasks with icons, descriptions, and navigation links.
 */
⋮----
import {
  CalendarIcon,
  CompassIcon,
  MapPinIcon,
  MessageCircleIcon,
  PlaneIcon,
  PlusIcon,
  SearchIcon,
  SettingsIcon,
} from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { type ActionVariant, statusVariants } from "@/lib/variants/status";
⋮----
/**
 * Gets the tone class for an action variant, if provided.
 *
 * @param actionVariant - Optional action variant for status colors.
 * @returns The status variant class string or undefined.
 */
function GetActionToneClass(actionVariant?: ActionVariant): string | undefined
⋮----
/**
 * Interface defining a quick action item with metadata for display and navigation.
 */
interface QuickAction {
  /** Unique identifier for the action. */
  id: string;
  /** Display title of the action. */
  title: string;
  /** Descriptive text explaining the action. */
  description: string;
  /** React icon component to display. */
  icon: React.ReactNode;
  /** Navigation URL for the action. */
  href: string;
  /** Button variant styling. */
  variant?: "default" | "secondary" | "outline";
  /** Additional CSS classes for styling. */
  className?: string;
  /** Optional badge text (e.g., "AI"). */
  badge?: string;
  /** Action variant for status colors. */
  actionVariant?: ActionVariant;
}
⋮----
/** Unique identifier for the action. */
⋮----
/** Display title of the action. */
⋮----
/** Descriptive text explaining the action. */
⋮----
/** React icon component to display. */
⋮----
/** Navigation URL for the action. */
⋮----
/** Button variant styling. */
⋮----
/** Additional CSS classes for styling. */
⋮----
/** Optional badge text (e.g., "AI"). */
⋮----
/** Action variant for status colors. */
⋮----
/**
 * Props interface for the QuickActions component.
 */
interface QuickActionsProps {
  /** Layout style: "grid" or "list". */
  layout?: "grid" | "list";
  /** Whether to show action descriptions. */
  showDescription?: boolean;
  /** Whether to use compact mode with fewer actions. */
  compact?: boolean;
}
⋮----
/** Layout style: "grid" or "list". */
⋮----
/** Whether to show action descriptions. */
⋮----
/** Whether to use compact mode with fewer actions. */
⋮----
/**
 * Renders a single action button with icon, title, description, and navigation.
 *
 * @param action - The quick action data to render.
 * @param showDescription - Whether to display the action description.
 * @param compact - Whether to use compact styling.
 * @returns The action button component.
 */
⋮----
className=
⋮----
/**
 * Renders actions in a responsive grid layout.
 *
 * @param actions - Array of quick actions to display.
 * @param showDescription - Whether to show action descriptions.
 * @param compact - Whether to use compact grid sizing.
 * @returns The grid layout component.
 */
⋮----
/**
 * Renders actions in a vertical list layout.
 *
 * @param actions - Array of quick actions to display.
 * @param showDescription - Whether to show action descriptions.
 * @param compact - Whether to use compact list sizing.
 * @returns The list layout component.
 */
⋮----
<div className=
⋮----
/**
 * Main QuickActions component providing common travel planning shortcuts.
 *
 * Supports grid/list layouts and compact mode for different screen sizes.
 * Renders action buttons with icons, titles, descriptions, and navigation links.
 *
 * @param layout - Layout style ("grid" or "list").
 * @param showDescription - Whether to display action descriptions.
 * @param compact - Whether to use compact mode with fewer actions.
 * @returns The QuickActions component.
 */
⋮----
// Show different actions based on layout and space
⋮----
/**
 * Compact version of QuickActions for smaller spaces.
 *
 * Shows fewer actions in grid layout without descriptions.
 *
 * @returns The compact QuickActions component.
 */
⋮----
/**
 * List version of QuickActions for sidebar or narrow spaces.
 *
 * Shows all actions in vertical list layout with descriptions.
 *
 * @returns The list QuickActions component.
 */
````

## File: src/components/features/dashboard/trip-suggestions.tsx
````typescript
/**
 * @fileoverview TripSuggestions component displaying AI-powered travel recommendations
 * with personalized suggestions based on user memory and preferences, including
 * budget-aware filtering and interactive trip planning features.
 */
⋮----
import {
  BrainIcon,
  ClockIcon,
  MapPinIcon,
  SparklesIcon,
  StarIcon,
  TrendingUpIcon,
} from "lucide-react";
import Link from "next/link";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Skeleton } from "@/components/ui/skeleton";
import { useMemoryContext, useMemoryInsights } from "@/hooks/use-memory";
import { type TripSuggestion, useTripSuggestions } from "@/hooks/use-trips";
import { useBudgetStore } from "@/stores/budget-store";
⋮----
/**
 * Props interface for the TripSuggestions component.
 */
interface TripSuggestionsProps {
  /** Maximum number of suggestions to display. */
  limit?: number;
  /** Whether to show empty state when no suggestions available. */
  showEmpty?: boolean;
  /** User ID for personalized memory-based suggestions. */
  userId?: string;
  /** Whether to show AI memory-based personalized suggestions. */
  showMemoryBased?: boolean;
}
⋮----
/** Maximum number of suggestions to display. */
⋮----
/** Whether to show empty state when no suggestions available. */
⋮----
/** User ID for personalized memory-based suggestions. */
⋮----
/** Whether to show AI memory-based personalized suggestions. */
⋮----
/**
 * Skeleton loading component for trip suggestion cards.
 *
 * @returns The skeleton loading component.
 */
function SuggestionCardSkeleton()
⋮----
/**
 * Individual trip suggestion card component with detailed trip information.
 *
 * @param suggestion - The trip suggestion data to display.
 * @returns The suggestion card component.
 */
⋮----
/**
   * Get emoji icon for trip category.
   *
   * @param category - The trip category.
   * @returns The emoji icon for the category.
   */
const getCategoryIcon = (category: TripSuggestion["category"]) =>
⋮----
/**
   * Get CSS class for difficulty level text color.
   *
   * @param difficulty - The trip difficulty level.
   * @returns CSS class for text color.
   */
const getDifficultyColor = (difficulty?: TripSuggestion["difficulty"]) =>
⋮----
/**
   * Format price with proper currency formatting.
   *
   * @param price - The numeric price value.
   * @param currency - The currency code (e.g., "USD").
   * @returns Formatted price string.
   */
const formatPrice = (price: number, currency: string) =>
⋮----
/**
 * Empty state component shown when no trip suggestions are available.
 *
 * @returns The empty state component.
 */
⋮----
/**
 * Main TripSuggestions component displaying AI-powered travel recommendations.
 *
 * Combines API-based suggestions with personalized memory-based recommendations,
 * supports budget filtering, loading states, and interactive trip planning.
 *
 * @param limit - Maximum number of suggestions to display.
 * @param showEmpty - Whether to show empty state when no suggestions available.
 * @param userId - User ID for personalized memory-based suggestions.
 * @param showMemoryBased - Whether to show AI memory-based personalized suggestions.
 * @returns The TripSuggestions component.
 */
⋮----
// Use React Query hook to fetch trip suggestions
⋮----
limit: limit + 2, // Get extra in case we filter some out
⋮----
// Memory-based recommendations
⋮----
/**
   * Generate personalized trip suggestions based on user memory and preferences.
   *
   * @returns Array of memory-based trip suggestions.
   */
⋮----
// Add suggestions based on user preferences
⋮----
// Add suggestions based on AI recommendations
⋮----
// Combine memory-based and API suggestions
⋮----
// Limit the number of suggestions
⋮----
{/* Memory-based suggestions with special styling */}
⋮----
{/* Regular suggestions */}
````

## File: src/components/features/dashboard/upcoming-flights.tsx
````typescript
/**
 * @fileoverview Upcoming flights dashboard component.
 *
 * Displays a card-based list of upcoming flights with departure/arrival times,
 * flight status, duration, and pricing information. Integrates with trip data
 * and provides links to associated trips and flight search functionality.
 */
⋮----
import { ClockIcon, PlaneIcon } from "lucide-react";
import Link from "next/link";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { type UpcomingFlight, useUpcomingFlights } from "@/hooks/use-trips";
import { DateUtils } from "@/lib/dates/unified-date-utils";
⋮----
/**
 * Props for the UpcomingFlights component.
 *
 * @interface UpcomingFlightsProps
 */
interface UpcomingFlightsProps {
  /** Maximum number of flights to display. Defaults to 3. */
  limit?: number;
  /** Whether to show an empty state when no flights are available. Defaults to true. */
  showEmpty?: boolean;
}
⋮----
/** Maximum number of flights to display. Defaults to 3. */
⋮----
/** Whether to show an empty state when no flights are available. Defaults to true. */
⋮----
/**
 * Skeleton loading component for flight cards.
 *
 * Displays placeholder content while flight data is loading.
 *
 * @returns A skeleton flight card component.
 */
function FlightCardSkeleton()
⋮----
/**
 * Individual flight card component.
 *
 * Displays detailed information about a single upcoming flight including
 * departure/arrival times, status, duration, price, and associated trip links.
 *
 * @param props - Component props.
 * @param props.flight - The flight data to display.
 * @returns A formatted flight card component.
 */
⋮----
/**
   * Formats a time string to HH:mm format.
   *
   * @param timeString - ISO time string to format.
   * @returns Formatted time string.
   */
const formatTime = (timeString: string) =>
⋮----
/**
   * Formats a time string to MMM d format.
   *
   * @param timeString - ISO time string to format.
   * @returns Formatted date string.
   */
const formatDate = (timeString: string) =>
⋮----
/**
   * Returns the appropriate badge variant for a flight status.
   *
   * @param status - The flight status.
   * @returns Badge variant name.
   */
const getStatusColor = (status: UpcomingFlight["status"]) =>
⋮----
/**
   * Formats flight duration in minutes to "Xh Ym" format.
   *
   * @returns Formatted duration string.
   */
const getDuration = () =>
⋮----
<Badge variant=
⋮----

⋮----
/**
 * Empty state component for when no upcoming flights are available.
 *
 * Displays a message with a call-to-action to search for flights.
 *
 * @returns An empty state component with flight search CTA.
 */
⋮----
/**
 * Renders the upcoming flights dashboard widget with loading and empty states.
 *
 * @param props - Component configuration such as max flights and empty-state
 * preference.
 * @returns Card containing fetched flights or fallback UIs.
 */
````

## File: src/components/features/profile/account-settings-section.tsx
````typescript
/**
 * @fileoverview Account settings section: email update, verification, and
 * notification preferences.
 */
⋮----
import { type EmailUpdateFormData, emailUpdateFormSchema } from "@schemas/profile";
import { CheckIcon, MailIcon, Trash2Icon } from "lucide-react";
import { useEffect, useMemo, useState } from "react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { useToast } from "@/components/ui/use-toast";
import { useZodForm } from "@/hooks/use-zod-form";
import { getUnknownErrorMessage } from "@/lib/errors/get-unknown-error-message";
import { getBrowserClient } from "@/lib/supabase";
import { cn } from "@/lib/utils";
import { useAuthCore } from "@/stores/auth/auth-core";
⋮----
/**
 * Alert colors for account status indicators.
 * Deliberately distinct from statusVariants to keep lightweight, Tailwind-only tokens here.
 */
⋮----
/**
 * Account settings panel component.
 *
 * @returns A settings section with email and notification controls.
 */
⋮----
const resolveSupabaseClient = () =>
⋮----
const onEmailUpdate = async (data: EmailUpdateFormData) =>
⋮----
const handleEmailVerification = async () =>
⋮----
const handleAccountDeletion = async () =>
⋮----
const toggleNotificationSetting = async (
    setting: keyof typeof initialNotificationPrefs,
    enabled: boolean
) =>
⋮----
{/* Email Settings */}
⋮----
className=
⋮----
<h4 className=
⋮----
onSubmit=
⋮----
{/* Notification Settings */}
⋮----
{/* Danger Zone */}
````

## File: src/components/features/profile/personal-info-section.tsx
````typescript
/**
 * @fileoverview Personal info section: update profile picture and personal details.
 */
⋮----
import { type PersonalInfoFormData, personalInfoFormSchema } from "@schemas/profile";
import { CameraIcon, UploadIcon } from "lucide-react";
import { useEffect, useId, useMemo, useRef, useState } from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/components/ui/use-toast";
import { useZodForm } from "@/hooks/use-zod-form";
import { getUnknownErrorMessage } from "@/lib/errors/get-unknown-error-message";
import { getBrowserClient } from "@/lib/supabase";
import { useAuthCore } from "@/stores/auth/auth-core";
⋮----
type SupportedAvatarType = keyof typeof SUPPORTED_AVATAR_TYPES;
type SupportedAvatarExt = (typeof SUPPORTED_AVATAR_TYPES)[SupportedAvatarType];
⋮----
const resolveAvatarExt = (file: File): SupportedAvatarExt | null =>
⋮----
const resolveSupabaseClient = () =>
⋮----
const onSubmit = async (data: PersonalInfoFormData) =>
⋮----
const handleAvatarUpload = async (event: React.ChangeEvent<HTMLInputElement>) =>
⋮----
// Upload first to avoid losing existing avatar on failure
⋮----
// Only remove other format avatars after successful upload
⋮----
// Add cache-busting query parameter so clients fetch the updated image
⋮----
const getInitials = (firstName?: string, lastName?: string, displayName?: string) =>
⋮----
{/* Avatar Upload Section */}
⋮----
{/* Personal Information Form */}
⋮----
<form onSubmit=
````

## File: src/components/features/profile/personalization-insights.tsx
````typescript
/**
 * @fileoverview Personalization insights panel rendering memory summaries.
 */
⋮----
import type { MemoryContextResponse } from "@schemas/chat";
// import type { UserPreferences } from "@schemas/memory"; // Future implementation
import {
  BarChart3Icon,
  BrainIcon,
  CopyIcon,
  DollarSignIcon,
  InfoIcon,
  LightbulbIcon,
  MapPinIcon,
  RefreshCwIcon,
  SettingsIcon,
  StarIcon,
  TargetIcon,
  TrendingDownIcon,
  TrendingUpIcon,
  UserIcon,
} from "lucide-react";
import { useState } from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import {
  useMemoryContext,
  useMemoryInsights,
  useMemoryStats,
  // useUpdatePreferences, // Future implementation
} from "@/hooks/use-memory";
⋮----
// useUpdatePreferences, // Future implementation
⋮----
import { TREND_COLORS } from "@/lib/variants/status";
export type PersonalizationInsightsProps = {
  userId: string;
  className?: string;
  showRecommendations?: boolean;
  onPreferenceUpdate?: (preferences: unknown) => void;
};
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Spending trend colors with inverted semantic:
 * increasing=red (spending more is concerning), decreasing=green (spending less is good)
 * Uses 500 weight to align with TREND_COLORS for consistency across cards.
 */
⋮----
export function PersonalizationInsights({
  userId,
  className,
  showRecommendations = true,
  onPreferenceUpdate: _onPreferenceUpdate, // Future implementation
}: PersonalizationInsightsProps)
⋮----
onPreferenceUpdate: _onPreferenceUpdate, // Future implementation
⋮----
// const [isUpdating, setIsUpdating] = useState(false); // Future implementation
⋮----
// const updatePreferences = useUpdatePreferences(userId); // Future implementation
⋮----
const formatCurrency = (amount: number, currency = "USD") =>
⋮----
const formatTimestamp = (iso?: string) =>
⋮----
const truncateId = (id?: string) =>
⋮----
/**
   * Trend colors aligned with statusVariants urgency mapping.
   * For general trends: increasing=green, decreasing=red, stable=neutral
   */
const renderTrendIcon = (
    trend: "increasing" | "decreasing" | "stable",
    colorMap: typeof TREND_COLORS | typeof SPENDING_TREND_COLORS = TREND_COLORS
) =>
⋮----
// const handlePreferenceUpdate = async (preferences: Partial<UserPreferences>) => { // Future implementation
//   setIsUpdating(true);
//   try {
//     await updatePreferences.mutateAsync({
//       preferences,
//       merge_strategy: "merge",
//     });
//     onPreferenceUpdate?.(preferences);
//     await refetchInsights();
//   } catch (error) {
//     console.error("Failed to update preferences:", error);
//   } finally {
//     setIsUpdating(false);
//   }
// };
⋮----
{/* Travel Personality */}
⋮----
{/* Quick Stats */}
⋮----
{/* Top Destinations */}
⋮----
Last visit:
⋮----
<div className=
⋮----
{/* Header */}
⋮----
{/* Navigation Tabs */}
⋮----
{/* Content */}
⋮----
Updated:
````

## File: src/components/features/profile/preferences-section.tsx
````typescript
/**
 * @fileoverview Preferences section: update currency, language, timezone, and units.
 */
⋮----
import { CURRENCY_CODE_SCHEMA } from "@schemas/currency";
import { type PreferencesFormData, preferencesFormSchema } from "@schemas/profile";
import { GlobeIcon, ZapIcon } from "lucide-react";
import { useTheme } from "next-themes";
import { useEffect, useMemo, useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { useToast } from "@/components/ui/use-toast";
import { useZodForm } from "@/hooks/use-zod-form";
import { getUnknownErrorMessage } from "@/lib/errors/get-unknown-error-message";
import { getBrowserClient } from "@/lib/supabase";
import { useAuthCore } from "@/stores/auth/auth-core";
import { useCurrencyStore } from "@/stores/currency-store";
⋮----
type AdditionalSettingKey =
  | "analytics"
  | "autoSaveSearches"
  | "locationServices"
  | "smartSuggestions";
⋮----
// biome-ignore lint/correctness/useExhaustiveDependencies: form instance is stable from useZodForm
⋮----
const onSubmit = async (data: PreferencesFormData) =>
⋮----
// Update currency store if changed
⋮----
const toggleAdditionalSetting = async (
    setting: AdditionalSettingKey,
    enabled: boolean
) =>
⋮----
{/* Regional & Language Settings */}
⋮----
<form onSubmit=
⋮----
{/* Additional Settings */}
````

## File: src/components/features/realtime/connection-status-monitor.tsx
````typescript
/**
 * @fileoverview Connection status monitor component for real-time connections.
 */
⋮----
import {
  ActivityIcon,
  AlertTriangleIcon,
  CheckCircleIcon,
  RefreshCwIcon,
  WifiIcon,
  WifiOffIcon,
  XCircleIcon,
} from "lucide-react";
import { useState } from "react";
import { useShallow } from "zustand/react/shallow";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Separator } from "@/components/ui/separator";
import { useToast } from "@/components/ui/use-toast";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { cn } from "@/lib/utils";
import type { ToneVariant } from "@/lib/variants/status";
import { statusVariants } from "@/lib/variants/status";
import { useRealtimeConnectionStore } from "@/stores/realtime-connection-store";
⋮----
interface ConnectionStatus {
  isConnected: boolean;
  lastError: Error | null;
  connectedCount: number;
  totalCount: number;
  lastErrorAt: Date | null;
  reconnectAttempts: number;
  lastReconnectAt: Date | null;
}
⋮----
interface RealtimeConnection {
  id: string;
  table: string;
  status: "connected" | "disconnected" | "error" | "reconnecting" | "connecting";
  error?: Error;
  lastActivity: Date | null;
}
⋮----
function NormalizeTopic(topic: string): string
⋮----
function StatusIcon({
  isConnected,
  hasError,
  size = "h-4 w-4",
}: {
  isConnected: boolean;
  hasError: boolean;
  size?: string;
})
⋮----
/**
 * Component for monitoring real-time connection status
 * Shows overall connectivity, individual subscriptions, and provides reconnection controls
 */
⋮----
const handleReconnectAll = async () =>
⋮----
const getStatusBadge = (status: RealtimeConnection["status"]) =>
⋮----
// Disconnected uses "unknown" (neutral slate) to distinguish from actual errors.
⋮----
<Badge className=
⋮----
onClick=
⋮----
Connection Health:
⋮----
/**
 * Compact connection status indicator for navigation/header
 */
````

## File: src/components/features/realtime/optimistic-trip-updates.tsx
````typescript
/**
 * @fileoverview Optimistic trip updates component for realtime collaboration UI.
 */
⋮----
import type { UiTrip } from "@schemas/trips";
import { Badge } from "@/components/ui/badge";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/components/ui/use-toast";
import { type UpdateTripData, useTrip, useUpdateTrip } from "@/hooks/use-trips";
import { queryKeys } from "@/lib/query-keys";
import type { UpdateTables } from "@/lib/supabase/database.types";
import { statusVariants } from "@/lib/variants/status";
⋮----
type TripUpdate = UpdateTables<"trips">;
type TripUpdateKey = keyof TripUpdate;
⋮----
/**
 * Derive text/bg tone classes from the shared statusVariants map to avoid
 * hardcoded palette drift. Parsing is scoped here to keep icon/dot styling
 * lightweight while still anchored to the design tokens.
 */
function ToneClassFor(input: Parameters<typeof statusVariants>[0])
⋮----
function ExtractClass(classes: string, prefix: string)
⋮----
type ConnectionState = keyof typeof CONNECTION_BADGE_PROPS;
⋮----
function GetConnectionBadgeProps(state: ConnectionState)
⋮----
import { useQueryClient } from "@tanstack/react-query";
import {
  AlertCircleIcon,
  CalendarIcon,
  CheckCircleIcon,
  ClockIcon,
  DollarSignIcon,
  Loader2Icon,
  MapPinIcon,
  UsersIcon,
} from "lucide-react";
import { useEffect, useId, useRef, useState } from "react";
⋮----
/**
 * Interface for the optimistic trip updates props.
 */
interface OptimisticTripUpdatesProps {
  /** The ID of the trip to update. */
  tripId: number;
}
⋮----
/** The ID of the trip to update. */
⋮----
/**
 * Component demonstrating optimistic updates for trip editing
 * Shows real-time collaboration with instant UI feedback
 */
export function OptimisticTripUpdates(
⋮----
// Snapshots to support rollback when mutation fails and cache is missing
⋮----
/**
   * Handle optimistic update.
   *
   * @param field - The field to update.
   * @param value - The value to update the field to.
   * @returns A promise that resolves to the optimistic update.
   */
const handleOptimisticUpdate = async (
    field: TripUpdateKey,
    value: TripUpdate[TripUpdateKey]
) =>
⋮----
// Snapshot current state for rollback
⋮----
// Apply optimistic update to local state
⋮----
// Update local trip state optimistically
⋮----
// Perform actual update
⋮----
// Mark as successful and clear snapshots
⋮----
// Clear the optimistic update after a delay
⋮----
/**
       * Show a success toast.
       */
⋮----
// Revert optimistic update on error using cache or snapshots
⋮----
/**
       * Set the optimistic update to error.
       */
⋮----
/**
       * Show a failure toast.
       */
⋮----
/**
   * Handle input change.
   *
   * @param field - The field to update.
   * @param value - The value to update the field to.
   * @returns A promise that resolves to the input change.
   */
const handleInputChange = (
    field: TripUpdateKey,
    value: TripUpdate[TripUpdateKey]
) =>
⋮----
/**
   * Handle input blur.
   *
   * @param field - The field to update.
   * @returns A promise that resolves to the input blur.
   */
const handleInputBlur = (field: keyof TripUpdate) =>
⋮----
/**
   * Get the field status.
   *
   * @param field - The field to get the status of.
   * @returns The field status.
   */
const getFieldStatus = (field: string) =>
⋮----
/**
   * Get the connection status.
   *
   * @returns The connection status.
   */
const getConnectionStatus = () =>
⋮----
/**
   * Render the optimistic trip updates component.
   *
   * @returns The optimistic trip updates component.
   */
⋮----
onChange=
⋮----
onBlur=
⋮----
{/* Recent Activity Feed */}
⋮----
/**
 * Collaboration indicator showing who else is currently editing
 *
 * @param tripId - The ID of the trip to show the collaborators for.
 * @returns The collaboration indicator component.
 */
````

## File: src/components/features/search/cards/accommodation-card.tsx
````typescript
/**
 * @fileoverview Accommodation card component for displaying accommodation information.
 */
⋮----
import type { Accommodation } from "@schemas/search";
import { MapPinIcon, StarIcon } from "lucide-react";
import Image from "next/image";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { formatCurrency } from "../common/format";
import { GetAmenityIcon } from "./amenities";
⋮----
interface AccommodationCardProps {
  accommodation: Accommodation;
  onSelect?: (accommodation: Accommodation) => void;
  onCompare?: (accommodation: Accommodation) => void;
}
⋮----
/** Render amenity icon or fallback placeholder. */
const renderAmenityIcon = (amenity: string) =>
⋮----
Total:
⋮----
onClick=
````

## File: src/components/features/search/cards/activity-card.tsx
````typescript
/**
 * @fileoverview Activity card component for rendering search results with actions.
 */
⋮----
import type { Activity } from "@schemas/search";
import { ClockIcon, MapPinIcon } from "lucide-react";
import Image from "next/image";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardFooter } from "@/components/ui/card";
import { formatCurrency, formatDurationHours } from "../common/format";
import { RatingStars } from "./rating-stars";
⋮----
interface ActivityCardProps {
  activity: Activity;
  onSelect?: (activity: Activity) => void;
  onCompare?: (activity: Activity) => void;
  /** Optional source label to display (e.g., "Verified via Google Places" or "AI suggestion"). */
  sourceLabel?: string;
}
⋮----
/** Optional source label to display (e.g., "Verified via Google Places" or "AI suggestion"). */
⋮----
onClick=
````

## File: src/components/features/search/cards/amenities.tsx
````typescript
/**
 * @fileoverview Shared amenity icon map and renderer for search cards.
 */
⋮----
import {
  CarIcon,
  CoffeeIcon,
  DumbbellIcon,
  SparklesIcon,
  UtensilsIcon,
  WavesIcon,
  WifiIcon,
} from "lucide-react";
import type React from "react";
⋮----
/** Map of amenity IDs to their corresponding icon components. */
⋮----
/**
 * Retrieves the icon component for a given amenity ID.
 *
 * Supported amenity IDs: breakfast, gym, parking, pool, restaurant, spa, wifi
 *
 * @param id - The amenity identifier to look up
 * @returns The icon component for the amenity, or undefined if the ID is not recognized
 *
 * @example
 * const AmenityIcon = GetAmenityIcon("breakfast");
 * if (AmenityIcon) {
 *   return <AmenityIcon className="h-4 w-4" />;
 * }
 */
export function GetAmenityIcon(
  id: string
): React.ComponentType<
````

## File: src/components/features/search/cards/destination-card.tsx
````typescript
/**
 * @fileoverview DestinationCard component for displaying travel destination information
 * with ratings, climate data, attractions, and interactive selection actions.
 */
⋮----
import type { Destination } from "@schemas/search";
import {
  CalendarIcon,
  CloudRainIcon,
  GlobeIcon,
  MapPinIcon,
  StarIcon,
  ThermometerIcon,
} from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { formatDestinationTypes } from "@/lib/google/places-format";
⋮----
/**
 * Props interface for the DestinationCard component.
 */
interface DestinationCardProps {
  /** Destination data to display in the card. */
  destination: Destination;
  /** Callback when destination is selected. */
  onSelect?: (destination: Destination) => void;
  /** Callback when destination is added to comparison. */
  onCompare?: (destination: Destination) => void;
  /** Callback when destination details are requested. */
  onViewDetails?: (destination: Destination) => void;
}
⋮----
/** Destination data to display in the card. */
⋮----
/** Callback when destination is selected. */
⋮----
/** Callback when destination is added to comparison. */
⋮----
/** Callback when destination details are requested. */
⋮----
/**
 * DestinationCard component displaying comprehensive destination information.
 *
 * Shows destination name, address, rating, climate data, attractions, popularity,
 * and provides interactive buttons for selection, comparison, and details view.
 *
 * @param destination - The destination data to display.
 * @param onSelect - Callback fired when destination is selected.
 * @param onCompare - Callback fired when destination is added to comparison.
 * @param onViewDetails - Callback fired when details are requested.
 * @returns The DestinationCard component.
 */
⋮----
/**
   * Get appropriate icon component based on destination types.
   *
   * @param types - Array of destination type identifiers.
   * @returns React icon component for the destination type.
   */
const getDestinationIcon = (types: string[]) =>
⋮----
/**
   * Format best time to visit months into a readable string.
   *
   * @param months - Array of month identifiers.
   * @returns Formatted string of best visit months.
   */
const formatBestTimeToVisit = (months: string[]) =>
⋮----
// const monthNames = [ // Future implementation
//   "Jan",
//   "Feb",
//   "Mar",
//   "Apr",
//   "May",
//   "Jun",
//   "Jul",
//   "Aug",
//   "Sep",
//   "Oct",
//   "Nov",
//   "Dec",
// ];
⋮----
{/* Description */}
⋮----
{/* Climate Info */}
⋮----
{/* Best Time to Visit */}
⋮----
{/* Top Attractions */}
⋮----
{/* Popularity Score */}
⋮----
{/* Action Buttons */}
````

## File: src/components/features/search/cards/flight-card.tsx
````typescript
/**
 * @fileoverview Reusable flight card component for flight results display.
 */
⋮----
import type { FlightResult } from "@schemas/search";
import {
  HeartIcon,
  MonitorIcon,
  PlaneIcon,
  ShieldIcon,
  StarIcon,
  TrendingUpIcon,
  UtensilsIcon,
  WifiIcon,
  ZapIcon,
} from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { formatCurrency, formatDurationMinutes } from "../common/format";
⋮----
/**
 * Flight-specific semantic colors aligned with statusVariants.
 * - Price trends: green (down/good), red (up/bad)
 * - Deal indicators: green (success/active)
 * - Emissions: green (low), amber (average), red (high)
 * - UI accents: blue (info), red (urgent)
 */
⋮----
/** Price change icon component */
export function PriceChangeIcon(
⋮----
/** Prediction badge for flight booking recommendation */
export function PredictionBadge({
  prediction,
}: {
  prediction: FlightResult["prediction"];
})
⋮----
<Badge variant="outline" className=
⋮----
/** Flight card component props */
export interface FlightCardProps {
  flight: FlightResult;
  viewMode: "list" | "grid";
  isSelected: boolean;
  isOptimisticSelecting: boolean;
  isPending: boolean;
  onSelect: () => void;
  onToggleComparison: () => void;
}
⋮----
/** Individual flight card for results display */
⋮----
{/* Promotions Banner */}
⋮----
{/* Airline Info */}
⋮----
className=
⋮----
{/* Route & Times */}
⋮----
{/* Additional Info for List View */}
⋮----
{/* Price & Actions */}
⋮----
{/* Comparison Checkbox */}
⋮----
{/* AI Prediction Details */}
````

## File: src/components/features/search/cards/hotel-card.tsx
````typescript
/**
 * @fileoverview Reusable hotel card component for hotel results display.
 */
⋮----
import type { HotelResult } from "@schemas/search";
import {
  Building2Icon,
  CalendarIcon,
  HeartIcon,
  ImageIcon,
  MapPinIcon,
  ShieldIcon,
  SparklesIcon,
  StarIcon,
  TrendingUpIcon,
  ZapIcon,
} from "lucide-react";
import Image from "next/image";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { statusVariants } from "@/lib/variants/status";
import { formatCurrency } from "../common/format";
import { GetAmenityIcon } from "./amenities";
import { RatingStars } from "./rating-stars";
⋮----
/** Get price history icon based on trend */
export function PriceHistoryIcon(
⋮----
/** Hotel card component props */
export interface HotelCardProps {
  hotel: HotelResult;
  viewMode: "list" | "grid" | "map";
  isSaved: boolean;
  isOptimisticSelecting: boolean;
  isPending: boolean;
  onSelect: () => void;
  onToggleWishlist: () => void;
}
⋮----
/** Individual hotel card for results display */
⋮----
className=
⋮----
{/* AI Recommendation Badge */}
⋮----
{/* Wishlist Button */}
⋮----
{/* Hotel Image */}
⋮----
{/* Image Count Badge */}
⋮----
{/* Deals Banner */}
⋮----
{/* Hotel Details */}
⋮----
{/* Header */}
⋮----
{/* Amenities */}
⋮----
{/* Special Features */}
⋮----
{/* Availability & Urgency */}
⋮----
{/* Pricing */}
⋮----
{/* AI Recommendation */}
⋮----
{/* Action Buttons */}
````

## File: src/components/features/search/cards/rating-stars.tsx
````typescript
/**
 * @fileoverview Rating stars component for displaying activity ratings.
 */
⋮----
import { StarIcon } from "lucide-react";
⋮----
/**
 * Rating stars component for displaying activity ratings.
 *
 * @param value - The rating value to display.
 * @param max - The maximum number of stars to display.
 * @returns The rating stars component.
 */
export function RatingStars(
````

## File: src/components/features/search/common/format.ts
````typescript
/**
 * @fileoverview Shared formatting utilities for search feature.
 */
⋮----
/**
 * Format a number as USD currency with no fractional digits.
 *
 * @param value - The number to format.
 * @returns The formatted currency string.
 */
export function formatCurrency(
  value: number,
  currency = "USD",
  locale = "en-US"
): string
⋮----
/**
 * Convert duration in hours to human-friendly text matching search UI tests.
 *
 * Rules:
 * - < 1 hour: round to minutes, e.g., 0.5 -> "30 mins"
 * - = 1 hour: "1 hour"
 * - < 24 hours: show one decimal at most, e.g., 2.5 -> "2.5 hours"
 * - >= 24 hours:
 *     * exact days => "N days"
 *     * otherwise => "Xd Yh" where Y is whole hours remainder
 */
export function formatDurationHours(hours: number): string
⋮----
/**
 * Convert minutes to `Xh Ym` representation.
 *
 * @param minutes - The duration in minutes to format.
 * @returns The formatted duration string.
 */
export function formatDurationMinutes(minutes: number): string
````

## File: src/components/features/search/common/number-input-field.tsx
````typescript
/**
 * @fileoverview Reusable number input field component for forms.
 * Integrates with React Hook Form and provides proper number parsing.
 */
⋮----
import type { Control, FieldValues, Path, PathValue } from "react-hook-form";
import {
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
⋮----
/**
 * Props for the NumberInputField component.
 *
 * @template T The form data type extending FieldValues.
 */
interface NumberInputFieldProps<T extends FieldValues> {
  /** React Hook Form control instance. */
  control: Control<T>;
  /** Field name path in the form data. */
  name: Path<T>;
  /** Label text displayed above the input. */
  label: string;
  /** Minimum allowed value (optional). */
  min?: number;
  /** Maximum allowed value (optional). */
  max?: number;
  /** Step increment for the input (optional). */
  step?: number | string;
  /** Default value for the input (optional). */
  defaultValue?: PathValue<T, Path<T>>;
  /** Placeholder text (optional). */
  placeholder?: string;
  /** Whether the field is required (optional). */
  required?: boolean;
  /** Whether the input should be disabled (optional). */
  disabled?: boolean;
}
⋮----
/** React Hook Form control instance. */
⋮----
/** Field name path in the form data. */
⋮----
/** Label text displayed above the input. */
⋮----
/** Minimum allowed value (optional). */
⋮----
/** Maximum allowed value (optional). */
⋮----
/** Step increment for the input (optional). */
⋮----
/** Default value for the input (optional). */
⋮----
/** Placeholder text (optional). */
⋮----
/** Whether the field is required (optional). */
⋮----
/** Whether the input should be disabled (optional). */
⋮----
/**
 * Reusable number input field component for React Hook Form.
 *
 * Handles proper number parsing, converting string input to number values
 * for the form state. Integrates with shadcn/ui form components.
 *
 * Note: HTML `min`/`max` attributes only provide browser-level guarding; callers
 * should mirror these constraints in their validation schema (e.g., Zod or
 * React Hook Form rules) to ensure consistent client/server enforcement.
 *
 * @template T The form data type extending FieldValues.
 * @param props Component props.
 * @returns A form field with number input.
 *
 * @example
 * ```tsx
 * <NumberInputField
 *   control={form.control}
 *   name="passengers"
 *   label="Number of Passengers"
 *   min={1}
 *   max={9}
 *   defaultValue={1}
 *   placeholder="Enter number of passengers"
 * />
 * ```
 */
⋮----
onChange=
⋮----
// Only commit finite numbers to form state; otherwise clear value
````

## File: src/components/features/search/common/search-form-shell.tsx
````typescript
/**
 * @fileoverview Reusable search form shell component.
 *
 * Provides a consistent wrapper for search forms with form state management,
 * validation, loading states, and error handling.
 */
⋮----
import { zodResolver } from "@hookform/resolvers/zod";
import { AlertCircleIcon, Loader2Icon, SearchIcon } from "lucide-react";
import { useState, useTransition } from "react";
import type { DefaultValues, FieldValues, Path, UseFormReturn } from "react-hook-form";
import { useForm } from "react-hook-form";
import type { z } from "zod";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Form } from "@/components/ui/form";
import { withClientTelemetrySpan } from "@/lib/telemetry/client";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { cn } from "@/lib/utils";
⋮----
/** Popular item for quick selection */
export interface PopularItem<TParams> {
  id: string;
  label: string;
  params: Partial<TParams>;
  icon?: React.ReactNode;
}
⋮----
/** Props for the SearchFormShell component */
export interface SearchFormShellProps<TSchema extends z.ZodType<FieldValues>> {
  /** Zod schema for form validation */
  schema: TSchema;
  /** Default form values */
  defaultValues: DefaultValues<z.infer<TSchema>>;
  /** Handler called on form submission */
  onSubmit: (params: z.infer<TSchema>) => Promise<void>;
  /** Telemetry span name for tracking submissions */
  telemetrySpanName?: string;
  /** Error message to display */
  error?: string | null;
  /** Custom submit button text */
  submitLabel?: string;
  /** Custom loading button text */
  loadingLabel?: string;
  /** Whether the form is disabled */
  disabled?: boolean;
  /** Additional className for the form */
  className?: string;
  /** Render function for form fields */
  children: (form: UseFormReturn<z.infer<TSchema>>) => React.ReactNode;
  /** Popular items for quick selection */
  popularItems?: PopularItem<z.infer<TSchema>>[];
  /** Handler for popular item selection */
  onPopularItemSelect?: (
    item: PopularItem<z.infer<TSchema>>,
    form: UseFormReturn<z.infer<TSchema>>
  ) => void;
}
⋮----
/** Zod schema for form validation */
⋮----
/** Default form values */
⋮----
/** Handler called on form submission */
⋮----
/** Telemetry span name for tracking submissions */
⋮----
/** Error message to display */
⋮----
/** Custom submit button text */
⋮----
/** Custom loading button text */
⋮----
/** Whether the form is disabled */
⋮----
/** Additional className for the form */
⋮----
/** Render function for form fields */
⋮----
/** Popular items for quick selection */
⋮----
/** Handler for popular item selection */
⋮----
/**
 * Shared search form shell with consistent validation, loading, and error states.
 *
 * @example
 * ```tsx
 * <SearchFormShell
 *   schema={flightSearchSchema}
 *   defaultValues={{ origin: "", destination: "" }}
 *   onSubmit={handleSearch}
 *   telemetrySpanName="flight.search"
 * >
 *   {(form) => (
 *     <>
 *       <FormField name="origin" control={form.control} ... />
 *       <FormField name="destination" control={form.control} ... />
 *     </>
 *   )}
 * </SearchFormShell>
 * ```
 */
⋮----
// biome-ignore lint/suspicious/noExplicitAny: zodResolver requires flexible schema typing for Zod v4 compatibility
⋮----
const handlePopularItemClick = (item: PopularItem<z.infer<TSchema>>) =>
⋮----
// Default behavior: update provided fields while preserving metadata
⋮----
onClick=
````

## File: src/components/features/search/common/use-search-form.ts
````typescript
/**
 * @fileoverview Shared React Hook Form setup for search feature forms.
 *
 * Provides a thin, typed wrapper around react-hook-form with Zod v4 resolver.
 * Keeps configuration consistent across search forms.
 */
⋮----
import { zodResolver } from "@hookform/resolvers/zod";
import type {
  DefaultValues,
  FieldValues,
  UseFormProps,
  UseFormReturn,
} from "react-hook-form";
import { useForm } from "react-hook-form";
import type { z } from "zod";
⋮----
/**
 * Shared React Hook Form setup for search feature forms.
 *
 * @param schema - The Zod schema to use for validation.
 * @param defaultValues - The default values to use for the form.
 * @param options - The options to use for the form.
 * @returns A React Hook Form instance.
 */
// biome-ignore lint/style/useNamingConvention: Hook name follows existing app conventions.
export function useSearchForm<TSchema extends z.ZodType<FieldValues>>(
  schema: TSchema,
  defaultValues: DefaultValues<z.infer<TSchema>>,
  options: Omit<UseFormProps<z.infer<TSchema>>, "resolver" | "defaultValues"> = {}
): UseFormReturn<z.infer<TSchema>>
⋮----
// biome-ignore lint/suspicious/noExplicitAny: zodResolver requires flexible schema typing for Zod v4 compatibility
````

## File: src/components/features/search/filters/api-payload.ts
````typescript
/**
 * @fileoverview API payload builders for search filters.
 *
 * Transforms Zustand filter state into API request parameters.
 * Bridges the UI filter state to backend search APIs.
 */
⋮----
import type { FilterValue } from "@schemas/stores";
import { FILTER_IDS } from "./constants";
import { isRangeObject, isStringArray, isStringValue } from "./utils";
⋮----
/** Active filter record from the store. */
export type ActiveFilters = Record<string, { value: FilterValue }>;
⋮----
/** Flight API filter parameters. */
export interface FlightApiFilters {
  /** Maximum number of stops (0 = direct only). */
  maxStops?: number;
  /** Airlines to exclude from results. */
  excludedAirlines?: string[];
  /** Maximum price in currency units. */
  maxPrice?: number;
  /** Direct flights only flag. */
  directOnly?: boolean;
}
⋮----
/** Maximum number of stops (0 = direct only). */
⋮----
/** Airlines to exclude from results. */
⋮----
/** Maximum price in currency units. */
⋮----
/** Direct flights only flag. */
⋮----
/** Hotel API filter parameters. */
export interface HotelApiFilters {
  /** Price range for hotels. */
  priceRange?: { min: number; max: number };
  /** Minimum star rating (1-5). */
  minRating?: number;
  /** Required amenities. */
  amenities?: string[];
}
⋮----
/** Price range for hotels. */
⋮----
/** Minimum star rating (1-5). */
⋮----
/** Required amenities. */
⋮----
/** Activity API filter parameters. */
export interface ActivityApiFilters {
  /** Price range for activities. */
  priceRange?: { min: number; max: number };
  /** Activity categories to include. */
  categories?: string[];
  /** Maximum duration in minutes. */
  maxDuration?: number;
}
⋮----
/** Price range for activities. */
⋮----
/** Activity categories to include. */
⋮----
/** Maximum duration in minutes. */
⋮----
/**
 * Convert stops filter value to maxStops API parameter.
 * Maps "any" -> undefined, "direct" -> 0, "one" -> 1, "two+" -> 2
 */
function stopsToMaxStops(value: string | undefined): number | undefined
⋮----
/**
 * Build flight API filter parameters from active filters.
 *
 * @param filters - Active filters from the search-filters store
 * @returns Flight API filter object ready for API request
 *
 * @example
 * ```ts
 * const { activeFilters } = useSearchFiltersStore();
 * const apiFilters = buildFlightApiPayload(activeFilters);
 * // Pass to flight search API: { maxStops: 1, maxPrice: 500 }
 * ```
 */
export function buildFlightApiPayload(filters: ActiveFilters): FlightApiFilters
⋮----
// Stops filter
⋮----
// Airlines filter (multi-select)
⋮----
// Price range filter
⋮----
/**
 * Build hotel API filter parameters from active filters.
 *
 * @param filters - Active filters from the search-filters store
 * @returns Hotel API filter object ready for API request
 */
export function buildHotelApiPayload(filters: ActiveFilters): HotelApiFilters
⋮----
// Price range filter
⋮----
/**
 * Build activity API filter parameters from active filters.
 *
 * @param filters - Active filters from the search-filters store
 * @returns Activity API filter object ready for API request
 */
export function buildActivityApiPayload(filters: ActiveFilters): ActivityApiFilters
⋮----
// Price range filter
⋮----
// Duration filter
````

## File: src/components/features/search/filters/constants.ts
````typescript
/**
 * @fileoverview Filter constants and typed IDs for search filter components.
 *
 * Provides type-safe filter identifiers and option definitions used across
 * filter-panel and filter components.
 */
⋮----
/**
 * Typed filter IDs with const assertion for compile-time safety.
 * Use these instead of magic strings throughout filter components.
 */
⋮----
/** Type representing valid filter ID values. */
export type FilterId = (typeof FILTER_IDS)[keyof typeof FILTER_IDS];
⋮----
/** Option type for filter selections. */
export interface FilterOption {
  readonly label: string;
  readonly value: string;
  readonly disabled?: boolean;
  readonly icon?: React.ReactNode;
}
⋮----
/** Flight stops options. */
⋮----
/** Departure time options. */
⋮----
/** Airlines options (typical major carriers). */
⋮----
/** Default price range bounds. */
⋮----
/** Default duration range bounds (in minutes). */
````

## File: src/components/features/search/filters/filter-checkbox-group.tsx
````typescript
/**
 * @fileoverview Multi-select checkbox group filter component.
 *
 * Uses shadcn/ui Checkbox for multi-select filters like airlines, amenities.
 */
⋮----
import { useCallback, useMemo } from "react";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";
import { ScrollArea } from "@/components/ui/scroll-area";
⋮----
export interface FilterOption {
  /** Unique value for the option */
  value: string;
  /** Display label */
  label: string;
  /** Optional count to display */
  count?: number;
  /** Whether the option is disabled */
  disabled?: boolean;
}
⋮----
/** Unique value for the option */
⋮----
/** Display label */
⋮----
/** Optional count to display */
⋮----
/** Whether the option is disabled */
⋮----
export interface FilterCheckboxGroupProps {
  /** Unique identifier for the filter */
  filterId: string;
  /** Display label for the filter */
  label: string;
  /** Available options */
  options: readonly FilterOption[];
  /** Currently selected values */
  value?: string[];
  /** Callback when selection changes */
  onChange: (filterId: string, value: string[]) => void;
  /** Maximum height before scrolling */
  maxHeight?: number;
  /** Show select all / none buttons */
  showSelectAll?: boolean;
  /** Whether the filter is disabled */
  disabled?: boolean;
}
⋮----
/** Unique identifier for the filter */
⋮----
/** Display label for the filter */
⋮----
/** Available options */
⋮----
/** Currently selected values */
⋮----
/** Callback when selection changes */
⋮----
/** Maximum height before scrolling */
⋮----
/** Show select all / none buttons */
⋮----
/** Whether the filter is disabled */
⋮----
/**
 * Multi-select checkbox group filter.
 *
 * @example
 * ```tsx
 * <FilterCheckboxGroup
 *   filterId="airlines"
 *   label="Airlines"
 *   options={[
 *     { value: "AA", label: "American Airlines", count: 12 },
 *     { value: "UA", label: "United Airlines", count: 8 },
 *   ]}
 *   value={["AA"]}
 *   onChange={(id, val) => setFilter(id, val)}
 * />
 * ```
 */
⋮----
checked=
````

## File: src/components/features/search/filters/filter-panel.tsx
````typescript
/**
 * @fileoverview Main filter panel component for search pages.
 *
 * Integrates with Zustand search-filters-store and uses shadcn/ui
 * Accordion for collapsible filter sections.
 *
 * @see ADR-0057 for architecture decisions
 */
⋮----
import type { FilterValue, ValidatedFilterOption } from "@schemas/stores";
import { SlidersHorizontalIcon, XIcon } from "lucide-react";
import { useCallback, useMemo } from "react";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { useSearchFiltersStore } from "@/stores/search-filters-store";
import { formatCurrency, formatDurationMinutes } from "../common/format";
import { AIRLINES_OPTIONS, FILTER_IDS, STOPS_OPTIONS, TIME_OPTIONS } from "./constants";
import { FilterCheckboxGroup } from "./filter-checkbox-group";
import { FilterRange } from "./filter-range";
import { FilterToggleOptions } from "./filter-toggle-options";
import { isRangeObject, isStringArray, isStringValue } from "./utils";
⋮----
/** Props for the FilterPanel component */
interface FilterPanelProps {
  /** Optional CSS class name */
  className?: string;
  /** Default open accordion sections */
  defaultOpenSections?: string[];
}
⋮----
/** Optional CSS class name */
⋮----
/** Default open accordion sections */
⋮----
/** Get typed filter value from active filters map. */
export function GetFilterValue<T extends FilterValue>(
  activeFilters: Record<string, { value: FilterValue }>,
  filterId: string,
  guard: (value: FilterValue) => value is T
): T | undefined
⋮----
/** Get display label for an active filter. */
export function GetFilterLabel(
  filterId: string,
  value: FilterValue,
  currentFilters: ValidatedFilterOption[]
): string
⋮----
// Try to find option label
⋮----
/**
 * Main filter panel component.
 *
 * Displays filter controls organized in collapsible accordion sections.
 * Integrates with Zustand store for state management.
 */
⋮----
// Group filters by category
⋮----
// Get active filter entries for display
⋮----
// Handle filter value change
⋮----
// Handle range filter change (converts to FilterValue format)
⋮----
// Handle remove filter badge
⋮----
// Handle clear category
⋮----
// Don't render if no search type is selected
⋮----
{/* Active filter badges */}
⋮----
{/* Filter sections */}
⋮----
{/* Price Range */}
⋮----
e.stopPropagation();
handleClearCategory("pricing");
⋮----
value=
⋮----
{/* Stops */}
⋮----
{/* Airlines */}
⋮----
handleClearCategory("airline");
⋮----
{/* Empty state */}
````

## File: src/components/features/search/filters/filter-presets.tsx
````typescript
/**
 * @fileoverview Filter presets component for saving and loading filter configurations.
 */
⋮----
import type { FilterPreset } from "@schemas/stores";
import { BookmarkIcon, CheckIcon, PencilIcon, PlusIcon, TrashIcon } from "lucide-react";
import { useState } from "react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { useSearchFiltersStore } from "@/stores/search-filters-store";
⋮----
/** Props for the filter presets component */
interface FilterPresetsProps {
  className?: string;
}
⋮----
/** Filter presets component for saving and loading filter configurations. */
⋮----
// Filter presets for current search type
⋮----
/** Save a new filter preset */
const handleSavePreset = () =>
⋮----
/** Load a filter preset */
const handleLoadPreset = (presetId: string) =>
⋮----
/** Delete a filter preset */
const handleDeletePreset = (presetId: string) =>
⋮----
/** Update a filter preset */
const handleUpdatePreset = () =>
⋮----
/** Duplicate a filter preset */
const handleDuplicatePreset = (presetId: string, originalName: string) =>
⋮----
/** Start editing a filter preset */
const startEditing = (preset: FilterPreset) =>
⋮----
onClick=
⋮----
{/* Edit Dialog */}
````

## File: src/components/features/search/filters/filter-range.tsx
````typescript
/**
 * @fileoverview Reusable range filter component with dual-thumb slider.
 *
 * Uses shadcn/ui Slider for price range, duration, and similar filters.
 */
⋮----
import { useCallback, useEffect, useState } from "react";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
⋮----
export interface FilterRangeProps {
  /** Unique identifier for the filter */
  filterId: string;
  /** Display label for the filter */
  label: string;
  /** Minimum allowed value */
  min: number;
  /** Maximum allowed value */
  max: number;
  /** Step increment */
  step?: number;
  /** Current value as [min, max] tuple */
  value?: [number, number] | { min: number; max: number };
  /** Callback when value changes */
  onChange: (filterId: string, value: { min: number; max: number }) => void;
  /** Format function for displaying values */
  formatValue?: (value: number) => string;
  /** Optional description */
  description?: string;
  /** Whether the filter is disabled */
  disabled?: boolean;
}
⋮----
/** Unique identifier for the filter */
⋮----
/** Display label for the filter */
⋮----
/** Minimum allowed value */
⋮----
/** Maximum allowed value */
⋮----
/** Step increment */
⋮----
/** Current value as [min, max] tuple */
⋮----
/** Callback when value changes */
⋮----
/** Format function for displaying values */
⋮----
/** Optional description */
⋮----
/** Whether the filter is disabled */
⋮----
/** Default value formatter */
const DEFAULT_FORMAT_VALUE = (value: number)
⋮----
/**
 * Range filter component with dual-thumb slider.
 *
 * @example
 * ```tsx
 * <FilterRange
 *   filterId="price_range"
 *   label="Price"
 *   min={0}
 *   max={2000}
 *   value={[100, 500]}
 *   onChange={(id, val) => setFilter(id, val)}
 *   formatValue={(v) => `$${v}`}
 * />
 * ```
 */
export function FilterRange({
  filterId,
  label,
  min,
  max,
  step = 1,
  value,
  onChange,
  formatValue = DEFAULT_FORMAT_VALUE,
  description,
  disabled = false,
}: FilterRangeProps)
⋮----
// Internal state for smooth slider interaction
⋮----
// Sync with external value
⋮----
````

## File: src/components/features/search/filters/filter-toggle-options.tsx
````typescript
/**
 * @fileoverview Toggle options filter component using shadcn/ui ToggleGroup.
 *
 * Used for filters like stops (Any/Nonstop/1/2+), time of day, etc.
 */
⋮----
import { useCallback } from "react";
import { Label } from "@/components/ui/label";
import { ToggleGroup, ToggleGroupItem } from "@/components/ui/toggle-group";
⋮----
export interface ToggleOption {
  /** Unique value for the option */
  value: string;
  /** Display label */
  label: string;
  /** Optional icon to display */
  icon?: React.ReactNode;
  /** Whether the option is disabled */
  disabled?: boolean;
}
⋮----
/** Unique value for the option */
⋮----
/** Display label */
⋮----
/** Optional icon to display */
⋮----
/** Whether the option is disabled */
⋮----
export interface FilterToggleOptionsProps {
  /** Unique identifier for the filter */
  filterId: string;
  /** Display label for the filter */
  label: string;
  /** Available options */
  options: readonly ToggleOption[];
  /** Current value (single for single-select, array for multi-select) */
  value?: string | string[];
  /** Callback when selection changes */
  onChange: (filterId: string, value: string | string[]) => void;
  /** Whether multiple options can be selected */
  multiple?: boolean;
  /** Whether the filter is disabled */
  disabled?: boolean;
  /** Optional description */
  description?: string;
}
⋮----
/** Unique identifier for the filter */
⋮----
/** Display label for the filter */
⋮----
/** Available options */
⋮----
/** Current value (single for single-select, array for multi-select) */
⋮----
/** Callback when selection changes */
⋮----
/** Whether multiple options can be selected */
⋮----
/** Whether the filter is disabled */
⋮----
/** Optional description */
⋮----
/**
 * Toggle options filter using ToggleGroup.
 *
 * @example
 * ```tsx
 * // Single select
 * <FilterToggleOptions
 *   filterId="stops"
 *   label="Stops"
 *   options={[
 *     { value: "any", label: "Any" },
 *     { value: "0", label: "Nonstop" },
 *     { value: "1", label: "1 Stop" },
 *     { value: "2+", label: "2+" },
 *   ]}
 *   value="any"
 *   onChange={(id, val) => setFilter(id, val)}
 * />
 *
 * // Multi select
 * <FilterToggleOptions
 *   filterId="departure_time"
 *   label="Departure Time"
 *   multiple
 *   options={[
 *     { value: "morning", label: "Morning" },
 *     { value: "afternoon", label: "Afternoon" },
 *     { value: "evening", label: "Evening" },
 *   ]}
 *   value={["morning", "afternoon"]}
 *   onChange={(id, val) => setFilter(id, val)}
 * />
 * ```
 */
⋮----
// For single select, ToggleGroup returns empty string when deselected
// For multi select, it returns empty array
⋮----
// Only update if a value is selected (don't allow deselection in single mode)
⋮----
onValueChange=
````

## File: src/components/features/search/filters/utils.ts
````typescript
/**
 * @fileoverview Filter utility functions and type guards.
 *
 * Provides type-safe guards for filter value inspection and
 * reusable helpers for filter components.
 */
⋮----
import type { FilterValue } from "@schemas/stores";
⋮----
/**
 * Type guard for range filter values.
 * Validates that value is an object with numeric min and max properties.
 */
export function isRangeObject(
  value: FilterValue
): value is
⋮----
/**
 * Type guard for single string filter values.
 */
export function isStringValue(value: FilterValue): value is string
⋮----
/**
 * Type guard for string array filter values (multi-select).
 */
export function isStringArray(value: FilterValue): value is string[]
⋮----
/**
 * Type guard for numeric filter values.
 */
export function isNumberValue(value: FilterValue): value is number
⋮----
/**
 * Type guard for boolean filter values.
 */
export function isBooleanValue(value: FilterValue): value is boolean
````

## File: src/components/features/search/forms/activity-search-form.tsx
````typescript
/**
 * @fileoverview Activity search form component for searching activities.
 */
⋮----
import {
  type ActivitySearchFormData,
  type ActivitySearchParams,
  activitySearchFormSchema,
} from "@schemas/search";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { withClientTelemetrySpan } from "@/lib/telemetry/client";
import { useSearchForm } from "../common/use-search-form";
⋮----
interface ActivitySearchFormProps {
  onSearch?: (data: ActivitySearchParams) => Promise<void>;
  initialValues?: Partial<ActivitySearchFormData>;
}
⋮----
const onSubmit = (data: ActivitySearchFormData)
⋮----
<form onSubmit=
⋮----
onChange=
````

## File: src/components/features/search/forms/destination-search-form.tsx
````typescript
/**
 * @fileoverview Destination search form component for searching destinations.
 */
⋮----
import {
  type DestinationSearchFormData,
  type DestinationSearchParams,
  destinationSearchFormSchema,
} from "@schemas/search";
import { ClockIcon, MapPinIcon, StarIcon, TrendingUpIcon } from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { useToast } from "@/components/ui/use-toast";
import { useMemoryContext } from "@/hooks/use-memory";
import { initTelemetry, withClientTelemetrySpan } from "@/lib/telemetry/client";
import { useSearchForm } from "../common/use-search-form";
⋮----
/** Type for destination search form values. */
export type DestinationSearchFormValues = DestinationSearchFormData;
⋮----
/** Interface for destination suggestions. */
interface DestinationSuggestion {
  placeId: string;
  description: string;
  mainText: string;
  secondaryText: string;
  types: string[];
}
⋮----
type PlacesApiPlace = {
  id: string;
  displayName?: { text: string };
  formattedAddress?: string;
  types?: string[];
};
⋮----
/** Interface for destination search form props. */
interface DestinationSearchFormProps {
  onSearch?: (data: DestinationSearchParams) => void | Promise<void>;
  initialValues?: Partial<DestinationSearchFormValues>;
  userId?: string;
  showMemoryRecommendations?: boolean;
}
⋮----
/** Array of destination types. */
⋮----
/** Array of popular destinations. */
⋮----
/**
 * Destination search form with debounced autocomplete and optional
 * memory suggestions.
 *
 * @param onSearch - Callback function to handle search submissions.
 * @param initialValues - Initial values for the form.
 * @param userId - User ID for memory-based recommendations.
 * @param showMemoryRecommendations - Whether to show memory-based recommendations.
 * @returns Destination search form component.
 */
⋮----
// Memory-based recommendations
⋮----
/**
   * Fetches autocomplete suggestions from `/api/places/search` with abort support.
   *
   * @param searchQuery - The query to search for.
   * @returns Promise resolving to an array of destination suggestions.
   * @throws Error if the search fails.
   */
⋮----
// Debounced autocomplete suggestions
⋮----
/** Applies a selected suggestion to the form and hides the dropdown. */
const handleSuggestionSelect = (suggestion: DestinationSuggestion) =>
⋮----
/** Prefills the query with a popular destination and focuses the input. */
const handlePopularDestinationClick = (destination: string) =>
⋮----
/** Submits the search values to the parent callback. */
const handleSubmit = (data: DestinationSearchFormValues)
⋮----
<form onSubmit=
⋮----
ref(el);
⋮----
// Delay hiding suggestions to allow for clicks
⋮----
{/* Autocomplete Suggestions Dropdown */}
⋮----
{/* Memory-based Recommendations */}
⋮----
{/* Trending from Travel Patterns */}
⋮----
{/* Recent Memories */}
⋮----
// Extract destination names from memory content
⋮----
{/* Popular Destinations Quick Select */}
⋮----
{/* Destination Types Filter */}
⋮----
{/* Options */}
⋮----
// biome-ignore lint/style/useNamingConvention: Utility function name is intentionally camelCase
````

## File: src/components/features/search/forms/flight-search-form.tsx
````typescript
/**
 * @fileoverview Flight search form component for searching flights.
 */
⋮----
import { type FlightSearchFormData, flightSearchFormSchema } from "@schemas/search";
import { useQuery } from "@tanstack/react-query";
import {
  AlertCircleIcon,
  ArrowRightIcon,
  CalendarIcon,
  ClockIcon,
  Loader2Icon,
  MapPinIcon,
  PlaneIcon,
  SearchIcon,
  SparklesIcon,
  TrendingDownIcon,
  UsersIcon,
} from "lucide-react";
import React, { useOptimistic, useState, useTransition } from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Progress } from "@/components/ui/progress";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Separator } from "@/components/ui/separator";
import { withClientTelemetrySpan } from "@/lib/telemetry/client";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { cn } from "@/lib/utils";
import { useSearchForm } from "../common/use-search-form";
⋮----
// Flight search params type
export type FlightSearchParams = FlightSearchFormData;
⋮----
interface SearchSuggestion {
  id: string;
  type: "city" | "airport";
  name: string;
  code: string;
  country: string;
  popular?: boolean;
}
⋮----
interface PopularDestination {
  code: string;
  name: string;
  savings?: string;
  country?: string;
}
⋮----
interface FlightSearchFormProps {
  onSearch: (params: FlightSearchParams) => Promise<void>;
  suggestions?: SearchSuggestion[];
  className?: string;
  showSmartBundles?: boolean;
  initialParams?: Partial<FlightSearchParams>;
}
⋮----
/** Flight search form with validation and popular destination shortcuts. */
⋮----
// React Hook Form with Zod validation
⋮----
// Watch form values for dynamic behavior
⋮----
// Optimistic search state
⋮----
gcTime: 2 * 60 * 60 * 1000, // 2 hours
⋮----
staleTime: 60 * 60 * 1000, // 1 hour
⋮----
const handleSwapAirports = () =>
⋮----
const handleQuickFill = (destination:
⋮----
// Clear form error when form changes
⋮----
<Card className=
⋮----
{/* Form Error Alert */}
⋮----
{/* Trip Type Selector */}
⋮----
{/* Main Search Form */}
⋮----
{/* From/To Section */}
⋮----
{/* Swap Button */}
⋮----
{/* Dates Section */}
⋮----
{/* Passengers & Class */}
⋮----
{/* Passengers */}
⋮----
{/* Children */}
⋮----
{/* Cabin Class */}
⋮----
{/* Popular Destinations */}
⋮----
onClick=
⋮----
{/* Smart Bundle Preview */}
⋮----
{/* Search Button */}
⋮----
{/* Progress indicator for optimistic updates */}
````

## File: src/components/features/search/forms/hotel-search-form.tsx
````typescript
/**
 * @fileoverview Hotel search form component for searching hotels.
 */
⋮----
import { type HotelSearchFormData, hotelSearchFormSchema } from "@schemas/search";
import {
  BedIcon,
  Building2Icon,
  CalendarIcon,
  CarIcon,
  CoffeeIcon,
  DumbbellIcon,
  Loader2Icon,
  MapPinIcon,
  SearchIcon,
  SparklesIcon,
  StarIcon,
  TrendingUpIcon,
  UsersIcon,
  UtensilsIcon,
  WavesIcon,
  WifiIcon,
  WindIcon,
} from "lucide-react";
import { useId, useOptimistic, useState, useTransition } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Progress } from "@/components/ui/progress";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Separator } from "@/components/ui/separator";
import { withClientTelemetrySpan } from "@/lib/telemetry/client";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { cn } from "@/lib/utils";
import { useSearchForm } from "../common/use-search-form";
⋮----
// React 19 optimistic update types for hotel search
export type HotelSearchParams = HotelSearchFormData;
⋮----
/** Location suggestion interface. */
interface LocationSuggestion {
  id: string;
  name: string;
  type: "city" | "hotel" | "landmark";
  country: string;
  deals?: number;
}
⋮----
/** Hotel search form props. */
interface HotelSearchFormProps {
  onSearch: (params: HotelSearchParams) => Promise<void>;
  suggestions?: LocationSuggestion[];
  className?: string;
  showRecommendations?: boolean;
}
⋮----
/** Amenities array. */
⋮----
/** Hotel search form component. */
⋮----
const calculateNights = () =>
⋮----
const handleAmenityToggle = (amenityId: string) =>
⋮----
const handleQuickLocation = (location: string) =>
⋮----
<Card className=
⋮----
{/* Location Search */}
⋮----
{/* Dates Section */}
⋮----
{/* Guests and Rooms */}
⋮----
{/* Star Rating */}
⋮----
className=
⋮----
{/* Amenities */}
⋮----
onClick=
⋮----
{/* Trending Destinations */}
⋮----
{/* All-Inclusive Preview */}
⋮----
{/* Search Button */}
⋮----
{/* Progress indicator for optimistic updates */}
````

## File: src/components/features/search/modals/activity-comparison-modal.tsx
````typescript
/**
 * @fileoverview Modal component for comparing selected activities side-by-side.
 */
⋮----
import type { Activity } from "@schemas/search";
import { MapPinIcon, StarIcon, XIcon } from "lucide-react";
import Image from "next/image";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
⋮----
interface ActivityComparisonModalProps {
  isOpen: boolean;
  onClose: () => void;
  activities: Activity[];
  onRemove: (activityId: string) => void;
  onAddToTrip: (activity: Activity) => void;
}
⋮----
/**
 * Modal dialog for comparing activities.
 *
 * Displays a side-by-side comparison of selected activities including
 * details like price, rating, location, and type.
 *
 * @param props - Component props.
 * @param props.isOpen - Whether the modal is open.
 * @param props.onClose - Callback to close the modal.
 * @param props.activities - List of activities to compare.
 * @param props.onRemove - Callback to remove an activity from comparison.
 * @param props.onAddToTrip - Callback to initiate adding an activity to a trip.
 */
⋮----
{/* Image Row */}
⋮----
{/* Price Row */}
⋮----
currency: "USD", // Assuming USD for now, ideally from activity
⋮----
{/* Rating Row */}
⋮----
{/* Location Row */}
⋮----
{/* Type/Category Row */}
⋮----
{/* Actions Row */}
````

## File: src/components/features/search/modals/trip-selection-modal.tsx
````typescript
/**
 * @fileoverview Modal component for selecting a trip to add an activity to.
 */
⋮----
import type { Activity } from "@schemas/search";
import type { UiTrip } from "@schemas/trips";
import { CalendarIcon, MapPinIcon } from "lucide-react";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { ScrollArea } from "@/components/ui/scroll-area";
⋮----
interface TripSelectionModalProps {
  isOpen: boolean;
  onClose: () => void;
  activity: Activity;
  trips: UiTrip[];
  onAddToTrip: (tripId: string) => Promise<void>;
  isAdding: boolean;
}
⋮----
/**
 * Modal dialog for selecting a trip from a list.
 *
 * Displays a list of user trips and allows selecting one to add an activity to.
 * Handles empty states and loading states.
 *
 * @param props - Component props.
 * @param props.isOpen - Whether the modal is open.
 * @param props.onClose - Callback to close the modal.
 * @param props.activity - The activity being added.
 * @param props.trips - List of available trips.
 * @param props.onAddToTrip - Callback when a trip is selected and confirmed.
 * @param props.isAdding - Whether the add operation is in progress.
 */
⋮----
const handleClose = () =>
⋮----
const handleConfirm = async () =>
⋮----
// biome-ignore lint/correctness/useExhaustiveDependencies: reset selection when modal or activity changes
````

## File: src/components/features/search/results/shared/results-controls-bar.tsx
````typescript
/**
 * @fileoverview Controls bar component for search results.
 *
 * Provides sort, filter, and view mode controls with optional
 * comparison selection UI.
 */
⋮----
import {
  ArrowUpDownIcon,
  FilterIcon,
  Grid3X3Icon,
  ListIcon,
  MapIcon,
} from "lucide-react";
import type { ReactNode } from "react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Separator } from "@/components/ui/separator";
import type { SortDirection, ViewMode } from "./use-results-list";
⋮----
/** Sort option configuration. */
export interface SortOption<S extends string> {
  /** Sort field value. */
  value: S;
  /** Display label. */
  label: string;
}
⋮----
/** Sort field value. */
⋮----
/** Display label. */
⋮----
/** Props for the ResultsControlsBar component. */
export interface ResultsControlsBarProps<S extends string> {
  /** Number of results found. */
  resultCount: number;
  /** Label for the result type (e.g., "flights", "hotels"). */
  resultLabel: string;
  /** Current sort field. */
  sortBy: S;
  /** Available sort options. */
  sortOptions: SortOption<S>[];
  /** Current sort direction. */
  sortDirection: SortDirection;
  /** Current view mode. */
  viewMode: ViewMode;
  /** Whether to show the map view option. */
  showMapView?: boolean;
  /** Callback when sort field changes. */
  onSortChange: (field: S) => void;
  /** Callback when sort direction toggles. */
  onDirectionToggle: () => void;
  /** Callback when view mode changes. */
  onViewModeChange: (mode: ViewMode) => void;
  /** Callback when filter button is clicked. */
  onOpenFilters?: () => void;
  /** Number of items selected for comparison. */
  selectedCount?: number;
  /** Maximum items that can be compared. */
  maxCompare?: number;
  /** Callback to clear comparison selection. */
  onClearSelection?: () => void;
  /** Callback to trigger comparison. */
  onCompare?: () => void;
  /** Additional content to render in the controls bar. */
  children?: ReactNode;
  /** Test ID for the component. */
  testId?: string;
}
⋮----
/** Number of results found. */
⋮----
/** Label for the result type (e.g., "flights", "hotels"). */
⋮----
/** Current sort field. */
⋮----
/** Available sort options. */
⋮----
/** Current sort direction. */
⋮----
/** Current view mode. */
⋮----
/** Whether to show the map view option. */
⋮----
/** Callback when sort field changes. */
⋮----
/** Callback when sort direction toggles. */
⋮----
/** Callback when view mode changes. */
⋮----
/** Callback when filter button is clicked. */
⋮----
/** Number of items selected for comparison. */
⋮----
/** Maximum items that can be compared. */
⋮----
/** Callback to clear comparison selection. */
⋮----
/** Callback to trigger comparison. */
⋮----
/** Additional content to render in the controls bar. */
⋮----
/** Test ID for the component. */
⋮----
/**
 * Controls bar component for search results.
 *
 * Provides a consistent UI for sorting, filtering, and view mode
 * selection across different result types.
 *
 * @example
 * ```tsx
 * <ResultsControlsBar
 *   resultCount={flights.length}
 *   resultLabel="flights"
 *   sortBy={sortBy}
 *   sortOptions={[
 *     { value: "price", label: "Price" },
 *     { value: "duration", label: "Duration" },
 *   ]}
 *   sortDirection={sortDirection}
 *   viewMode={viewMode}
 *   onSortChange={setSortBy}
 *   onDirectionToggle={toggleSortDirection}
 *   onViewModeChange={setViewMode}
 *   onOpenFilters={handleOpenFilters}
 * />
 * ```
 */
⋮----
{/* Comparison selection bar */}
⋮----
{/* Additional content */}
````

## File: src/components/features/search/results/shared/results-empty-state.tsx
````typescript
/**
 * @fileoverview Empty state component for search results.
 *
 * Displays a consistent "no results found" UI across flight, hotel,
 * and activity search result views.
 */
⋮----
import type { LucideIcon } from "lucide-react";
import { RefreshCwIcon } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
⋮----
/** Props for the ResultsEmptyState component. */
export interface ResultsEmptyStateProps {
  /** Icon to display above the message. */
  icon: LucideIcon;
  /** Main heading text. */
  title: string;
  /** Description text below the heading. */
  description: string;
  /** Label for the action button. */
  actionLabel?: string;
  /** Callback when action button is clicked. */
  onAction?: () => void;
}
⋮----
/** Icon to display above the message. */
⋮----
/** Main heading text. */
⋮----
/** Description text below the heading. */
⋮----
/** Label for the action button. */
⋮----
/** Callback when action button is clicked. */
⋮----
/**
 * Empty state component for search results.
 *
 * Provides a consistent UI when no results are found, with customizable
 * icon, messaging, and action button.
 *
 * @example
 * ```tsx
 * <ResultsEmptyState
 *   icon={PlaneIcon}
 *   title="No flights found"
 *   description="Try adjusting your search dates or filters"
 *   actionLabel="Modify Search"
 *   onAction={handleModifySearch}
 * />
 * ```
 */
export function ResultsEmptyState({
  icon: Icon,
  title,
  description,
  actionLabel = "Modify Search",
  onAction,
}: ResultsEmptyStateProps)
````

## File: src/components/features/search/results/shared/results-loading-skeleton.tsx
````typescript
/**
 * @fileoverview Loading skeleton component for search results.
 *
 * Provides consistent loading states across flight, hotel, and activity
 * result views with configurable skeleton layouts.
 */
⋮----
import type { ReactNode } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { cn } from "@/lib/utils";
⋮----
/** Skeleton variant for different result types. */
export type SkeletonVariant = "flight" | "hotel" | "activity";
⋮----
/** Props for the ResultsLoadingSkeleton component. */
export interface ResultsLoadingSkeletonProps {
  /** Number of skeleton items to display. */
  count?: number;
  /** Skeleton layout variant. */
  variant: SkeletonVariant;
  /** Additional CSS classes. */
  className?: string;
  /** Test ID for the container. */
  testId?: string;
}
⋮----
/** Number of skeleton items to display. */
⋮----
/** Skeleton layout variant. */
⋮----
/** Additional CSS classes. */
⋮----
/** Test ID for the container. */
⋮----
/** Flight skeleton layout. */
function FlightSkeleton()
⋮----
/** Hotel skeleton layout. */
function HotelSkeleton()
⋮----
/** Activity skeleton layout. */
function ActivitySkeleton()
⋮----
/** Map of variant to skeleton component. */
⋮----
/**
 * Loading skeleton component for search results.
 *
 * Displays placeholder skeletons while results are loading,
 * with variant-specific layouts for flights, hotels, and activities.
 *
 * @example
 * ```tsx
 * <ResultsLoadingSkeleton
 *   variant="flight"
 *   count={3}
 *   testId="flight-results-loading"
 * />
 * ```
 */
export function ResultsLoadingSkeleton({
  count = 3,
  variant,
  className,
  testId,
}: ResultsLoadingSkeletonProps)
⋮----
className=
````

## File: src/components/features/search/results/shared/use-results-list.ts
````typescript
/**
 * @fileoverview Shared hook for results list state management.
 *
 * Encapsulates common patterns across flight/hotel/activity results:
 * - Sorting with configurable fields and direction
 * - View mode toggling (list/grid)
 * - Selection set for comparison or wishlist
 * - Optimistic selection with transition
 */
⋮----
import { useCallback, useMemo, useOptimistic, useState, useTransition } from "react";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
⋮----
/** View mode options for results display. */
export type ViewMode = "list" | "grid" | "map";
⋮----
/** Sort direction options. */
export type SortDirection = "asc" | "desc";
⋮----
/** Configuration for the useResultsList hook. */
export interface UseResultsListOptions<T, S extends string> {
  /** Array of results to manage. */
  results: T[];
  /** Function to extract unique ID from an item. */
  getId: (item: T) => string;
  /** Default sort field. */
  defaultSort: S;
  /** Default sort direction. */
  defaultDirection?: SortDirection;
  /** Default view mode. */
  defaultViewMode?: ViewMode;
  /** Comparator function for sorting. */
  compare: (a: T, b: T, sortBy: S, direction: SortDirection) => number;
  /** Maximum items that can be selected for comparison. */
  maxSelections?: number;
  /** Context name for error logging. */
  errorContext?: string;
}
⋮----
/** Array of results to manage. */
⋮----
/** Function to extract unique ID from an item. */
⋮----
/** Default sort field. */
⋮----
/** Default sort direction. */
⋮----
/** Default view mode. */
⋮----
/** Comparator function for sorting. */
⋮----
/** Maximum items that can be selected for comparison. */
⋮----
/** Context name for error logging. */
⋮----
/** Return type for the useResultsList hook. */
export interface UseResultsListReturn<T, S extends string> {
  /** Sorted results array. */
  sortedResults: T[];
  /** Current sort field. */
  sortBy: S;
  /** Current sort direction. */
  sortDirection: SortDirection;
  /** Current view mode. */
  viewMode: ViewMode;
  /** Whether a transition is pending. */
  isPending: boolean;
  /** Set of selected item IDs. */
  selectedIds: Set<string>;
  /** ID of item currently being optimistically selected. */
  optimisticSelectingId: string;

  /** Set the sort field. */
  setSortBy: (field: S) => void;
  /** Toggle sort direction between asc and desc. */
  toggleSortDirection: () => void;
  /** Set sort direction explicitly. */
  setSortDirection: (direction: SortDirection) => void;
  /** Set view mode. */
  setViewMode: (mode: ViewMode) => void;
  /** Toggle an item in the selection set. */
  toggleSelection: (id: string) => void;
  /** Clear all selections. */
  clearSelection: () => void;
  /** Check if an item is selected. */
  isSelected: (id: string) => boolean;
  /** Get selected items from the results. */
  getSelectedItems: () => T[];
  /**
   * Handle item selection with optimistic UI and error handling.
   * Wraps the async callback in a transition.
   */
  handleSelect: (item: T, onSelect: (item: T) => Promise<void> | void) => void;
}
⋮----
/** Sorted results array. */
⋮----
/** Current sort field. */
⋮----
/** Current sort direction. */
⋮----
/** Current view mode. */
⋮----
/** Whether a transition is pending. */
⋮----
/** Set of selected item IDs. */
⋮----
/** ID of item currently being optimistically selected. */
⋮----
/** Set the sort field. */
⋮----
/** Toggle sort direction between asc and desc. */
⋮----
/** Set sort direction explicitly. */
⋮----
/** Set view mode. */
⋮----
/** Toggle an item in the selection set. */
⋮----
/** Clear all selections. */
⋮----
/** Check if an item is selected. */
⋮----
/** Get selected items from the results. */
⋮----
/**
   * Handle item selection with optimistic UI and error handling.
   * Wraps the async callback in a transition.
   */
⋮----
/**
 * Hook for managing results list state.
 *
 * Consolidates common patterns from flight/hotel/activity results:
 * - Sorting logic with configurable comparator
 * - View mode toggling
 * - Selection management for comparison features
 * - Optimistic selection with React transitions
 *
 * @example
 * ```tsx
 * const {
 *   sortedResults,
 *   sortBy,
 *   setSortBy,
 *   viewMode,
 *   setViewMode,
 *   handleSelect,
 * } = useResultsList({
 *   results: flights,
 *   getId: (f) => f.id,
 *   defaultSort: "price",
 *   compare: (a, b, sortBy, dir) => {
 *     const mul = dir === "asc" ? 1 : -1;
 *     return mul * (a.price - b.price);
 *   },
 *   errorContext: "FlightResults",
 * });
 * ```
 */
export function useResultsList<T, S extends string>({
  results,
  getId,
  defaultSort,
  defaultDirection = "asc",
  defaultViewMode = "list",
  compare,
  maxSelections = 3,
  errorContext = "ResultsList",
}: UseResultsListOptions<T, S>): UseResultsListReturn<T, S>
⋮----
// Optimistic selection state
⋮----
// Memoized sorted results
⋮----
// Toggle sort direction
⋮----
// Toggle selection for comparison/wishlist
⋮----
// Clear all selections
⋮----
// Check if item is selected
⋮----
// Get selected items
⋮----
// Handle item selection with optimistic UI
````

## File: src/components/features/search/results/activity-results.tsx
````typescript
/**
 * @fileoverview Activity results grid with filters, sorting controls, and view modes.
 */
⋮----
import type { Activity } from "@schemas/search";
import {
  ArrowUpDownIcon,
  FilterIcon,
  Grid3X3Icon,
  ListIcon,
  MapPinIcon,
  RefreshCwIcon,
} from "lucide-react";
import { useState, useTransition } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { useToast } from "@/components/ui/use-toast";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { cn } from "@/lib/utils";
import { ActivityCard } from "../cards/activity-card";
⋮----
interface ActivityResultsProps {
  results: Activity[];
  loading?: boolean;
  onSelect: (activity: Activity) => Promise<void> | void;
  onCompare?: (activities: Activity[]) => void;
  onOpenFilters?: () => void;
  onLoadMore?: () => Promise<void>;
  hasMore?: boolean;
  className?: string;
}
⋮----
/** Activity results component */
⋮----
// Optimistic selection state (handles concurrent selections safely)
⋮----
/** Handle activity selection */
const handleActivitySelect = (activity: Activity) =>
⋮----
/** Handle activity comparison */
const handleCompare = (activity: Activity) =>
⋮----
/** Sort activities by price, rating, or duration */
const handleSort = (field: "price" | "rating" | "duration") =>
⋮----
/** Load more activities */
const handleLoadMore = async () =>
⋮----
/** Sort activities by price, rating, or duration */
⋮----
/** Render loading state */
⋮----
className=
⋮----
/** Render no activities found state */
⋮----
/** Render activity results */
⋮----
<div className=
{/* Search Controls */}
⋮----
{/* Activity Results */}
⋮----
onCompare=
⋮----
{/* Load More */}
````

## File: src/components/features/search/results/flight-results.tsx
````typescript
/**
 * @fileoverview Flight results grid with filters, tags, and sorting controls.
 */
⋮----
import type { FlightResult } from "@schemas/search";
import { PlaneIcon } from "lucide-react";
import { useCallback } from "react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { cn } from "@/lib/utils";
import { FlightCard } from "../cards/flight-card";
import { ResultsControlsBar } from "./shared/results-controls-bar";
import { ResultsEmptyState } from "./shared/results-empty-state";
import { ResultsLoadingSkeleton } from "./shared/results-loading-skeleton";
import type { SortDirection, ViewMode } from "./shared/use-results-list";
import { useResultsList } from "./shared/use-results-list";
⋮----
/** Narrow ViewMode to flight-compatible modes (no map view). */
function ToFlightViewMode(mode: ViewMode): "list" | "grid"
⋮----
type FlightSortField = "price" | "duration" | "departure" | "emissions";
⋮----
/** Sort options for flight results. */
⋮----
/** Flight results component props */
interface FlightResultsProps {
  results: FlightResult[];
  loading?: boolean;
  onSelect: (flight: FlightResult) => Promise<void> | void;
  onCompare: (flights: FlightResult[]) => void;
  onModifySearch?: () => void;
  className?: string;
}
⋮----
/** Flight comparator for sorting. */
function CompareFlights(
  first: FlightResult,
  second: FlightResult,
  sortBy: FlightSortField,
  sortDirection: SortDirection
): number
⋮----
/** Flight results grid with filters, tags, and sorting controls. */
⋮----
/** Handle flight selection. */
⋮----
/** Handle comparison. */
⋮----
className=
⋮----
{/* Flight Results */}
⋮----
isSelected=
````

## File: src/components/features/search/results/hotel-results.tsx
````typescript
/**
 * @fileoverview Hotel results grid with filters, badges, and sorting controls.
 */
⋮----
import type { HotelResult } from "@schemas/search";
import {
  ArrowUpDownIcon,
  Building2Icon,
  FilterIcon,
  Grid3X3Icon,
  ListIcon,
  MapIcon,
  RefreshCwIcon,
} from "lucide-react";
import { useMemo, useOptimistic, useState, useTransition } from "react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { type Coordinates, calculateDistanceKm } from "@/lib/geo";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { cn } from "@/lib/utils";
import { HotelCard } from "../cards/hotel-card";
⋮----
/** Hotel results props */
interface HotelResultsProps {
  results: HotelResult[];
  loading?: boolean;
  onSelect: (hotel: HotelResult) => Promise<void> | void;
  onSaveToWishlist: (hotelId: string) => Promise<void> | void;
  className?: string;
  showMap?: boolean;
  /** Optional controlled wishlist state passed from a parent component. */
  wishlistHotelIds?: ReadonlySet<string>;
  /** Search center coordinates for distance calculation. */
  searchCenter?: Coordinates;
}
⋮----
/** Optional controlled wishlist state passed from a parent component. */
⋮----
/** Search center coordinates for distance calculation. */
⋮----
/** Hotel results component */
⋮----
// Optimistic selection state
⋮----
/** Handle hotel selection */
const handleHotelSelect = (hotel: HotelResult) =>
⋮----
/** Toggle hotel wishlist state. */
const toggleWishlist = (hotelId: string) =>
⋮----
// Revert optimistic toggle if the parent callback throws.
⋮----
/** Check if distance sorting is available. */
⋮----
/** Calculate distance from search center for a hotel. */
const getDistance = (hotel: HotelResult): number
⋮----
const comparator = (first: HotelResult, second: HotelResult) =>
⋮----
const cycleSort = () =>
⋮----
const toggleDirection = () =>
⋮----
const formatSortLabel = (sort: typeof sortBy) =>
⋮----
const formatDirectionLabel = (direction: typeof sortDirection)
⋮----
<div className=
{/* Search Controls */}
⋮----
Sort:
⋮----
{/* Hotel Results */}
⋮----
onSelect=
⋮----
{/* Load More */}
````

## File: src/components/features/search/search-collections.tsx
````typescript
/**
 * @fileoverview Search collections component for organizing saved searches into groups.
 */
⋮----
import type { SearchCollection, ValidatedSavedSearch } from "@schemas/stores";
import {
  FolderIcon,
  FolderPlusIcon,
  MoreHorizontalIcon,
  PencilIcon,
  PlusIcon,
  TrashIcon,
} from "lucide-react";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { useSearchHistoryStore } from "@/stores/search-history";
⋮----
/** Props for the search collections component */
interface SearchCollectionsProps {
  className?: string;
  onSelectSearch?: (search: ValidatedSavedSearch) => void;
}
⋮----
/** Search collections component for organizing saved searches into groups. */
⋮----
/** Get saved searches for a collection */
const getCollectionSearches = (collection: SearchCollection) =>
⋮----
/** Handle create collection */
const handleCreateCollection = async () =>
⋮----
/** Handle update collection */
const handleUpdateCollection = async () =>
⋮----
/** Handle delete collection */
const handleDeleteCollection = async (collectionId: string) =>
⋮----
/** Handle remove from collection */
const handleRemoveFromCollection = (collectionId: string, searchId: string) =>
⋮----
/** Handle start editing */
const startEditing = (collection: SearchCollection) =>
⋮----
/** Toggle expand */
const toggleExpand = (collectionId: string) =>
⋮----
<DropdownMenuItem onClick=
⋮----
{/* Edit Dialog */}
⋮----
/** Dropdown component to add a search to a collection. */
⋮----
/** Dropdown component to add a search to a collection. */
⋮----
const handleAddToCollection = (collectionId: string) =>
⋮----
const handleCreateAndAdd = async () =>
````

## File: src/components/features/security/mfa-panel.tsx
````typescript
/**
 * @fileoverview MFA management panel showing factors, status, and actions.
 */
⋮----
import type { MfaFactor } from "@schemas/mfa";
import { AlertCircleIcon, CheckCircle2Icon, ShieldIcon } from "lucide-react";
import Image from "next/image";
import { useId, useState, useTransition } from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import {
  refreshMfaFactors,
  regenerateMfaBackups,
  resendMfaChallenge,
  revokeOtherSessions as revokeOtherSessionsAction,
  startMfaEnrollment,
  verifyMfaBackup,
  verifyMfaTotp,
} from "@/lib/security/mfa-client";
import { secureId } from "@/lib/security/random";
import { cn } from "@/lib/utils";
⋮----
/** The UI message. */
type UIMessage = {
  id: string;
  text: string;
  type: "info" | "error" | "success";
};
⋮----
/** The MFA panel props. */
type MfaPanelProps = {
  userEmail: string;
  initialAal: "aal1" | "aal2";
  factors: MfaFactor[];
  loadError?: string | null;
};
⋮----
/**
 * The MFA panel component.
 *
 * @param userEmail - The user email.
 * @param initialAal - The initial AAL.
 * @param factors - The factors.
 * @param loadError - The load error.
 * @returns The MFA panel component.
 */
⋮----
/** Pushes a message to the messages state. */
const pushMessage = (msg: Omit<UIMessage, "id">) =>
⋮----
/** Refreshes the factors. */
const refreshFactors = async () =>
⋮----
/** Handles refreshing factors with feedback. */
const handleRefreshFactors = () =>
⋮----
/** Begins the enrollment. */
const beginEnrollment = () =>
⋮----
/** Resends the challenge. */
const resendChallenge = () =>
⋮----
/** Verifies the code. */
const verifyCode = () =>
⋮----
/** Verifies the backup code. */
const verifyBackup = () =>
⋮----
/** Regenerates the backups. */
const regenerateBackups = () =>
⋮----
/** Revokes the other sessions. */
const revokeOtherSessions = () =>
⋮----
onChange=
````

## File: src/components/features/security/security-dashboard-client.tsx
````typescript
/**
 * @fileoverview Client-side helpers for the security dashboard: local time rendering
 * and interactive session controls.
 */
⋮----
import type { ActiveSession, SecurityEvent, SecurityMetrics } from "@schemas/security";
import {
  CheckCircle2Icon,
  MonitorIcon,
  ShieldCheckIcon,
  ShieldIcon,
  SmartphoneIcon,
} from "lucide-react";
import { useEffect, useMemo, useState } from "react";
import { Button } from "@/components/ui/button";
import { useToast } from "@/components/ui/use-toast";
import { cn } from "@/lib/utils";
⋮----
// Local status colors; consider lifting to shared tokens if reused elsewhere
⋮----
/** Local time props. */
type LocalTimeProps = {
  isoString: string;
  className?: string;
};
⋮----
/**
 * Render an ISO timestamp in the viewer's locale/timezone.
 *
 * @param isoString - The ISO timestamp to render.
 * @param className - The class name to apply to the rendered timestamp.
 * @returns The rendered timestamp.
 */
export function LocalTime(
⋮----
/** Security events list props. */
type SecurityEventsListProps = {
  events: SecurityEvent[];
  riskColor: Record<SecurityEvent["riskLevel"], string>;
};
⋮----
/**
 * Display recent security events with risk coloring and client-local timestamps.
 *
 * @param events - The security events to render.
 * @param riskColor - The risk color for each security event risk level.
 * @returns The rendered security events list.
 */
⋮----
/** Active sessions list props. */
⋮----
/**
 * Interactive list of active sessions with terminate controls for non-current entries.
 *
 * @param sessions - The active sessions to render.
 * @returns The rendered active sessions list.
 */
⋮----
/**
   * Handle the termination of a session.
   *
   * @param sessionId - The ID of the session to terminate.
   */
const handleTerminate = async (sessionId: string) =>
⋮----
className=
⋮----
/** Connections summary props. */
⋮----
/**
 * Present connection metadata with client-local timestamp formatting.
 *
 * @param metrics - The security metrics to render.
 * @returns The rendered connections summary.
 */
````

## File: src/components/features/trips/budget-tracker.tsx
````typescript
/**
 * @fileoverview Budget tracker component summarizing spend and savings.
 */
⋮----
import type { BudgetSummary } from "@schemas/budget";
import {
  AlertTriangleIcon,
  DollarSignIcon,
  PlusIcon,
  TargetIcon,
  TrendingUpIcon,
} from "lucide-react";
import { useMemo } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { useBudgetStore } from "@/stores/budget-store";
import { useCurrencyStore } from "@/stores/currency-store";
⋮----
/**
 * Budget status colors aligned with statusVariants.
 * Maps budget health to consistent text colors.
 */
⋮----
caution: "text-yellow-600", // intermediate warning state
ok: "text-green-700", // aligned with active/low urgency
over: "text-red-700", // aligned with error/high urgency
warning: "text-amber-700", // aligned with pending/medium urgency
⋮----
interface BudgetTrackerProps {
  tripId?: string;
  budgetId?: string;
  className?: string;
  showActions?: boolean;
  onAddExpense?: () => void;
  onCreateBudget?: () => void;
}
⋮----
// If this is the active budget, use the computed summary
⋮----
// Otherwise, manually compute for this specific budget
// This is a simplified version - in production you'd want to
// fetch expenses for this specific budget
⋮----
const totalSpent = 0; // Would be calculated from expenses
⋮----
const formatCurrency = (amount: number) =>
⋮----
const getStatusColor = (percentage: number) =>
⋮----
// const getProgressColor = (percentage: number) => { // Future implementation
//   if (percentage >= 100) return "bg-destructive";
//   if (percentage >= 80) return "bg-orange-500";
//   if (percentage >= 60) return "bg-yellow-500";
//   return "bg-primary";
// };
⋮----
{/* Main Budget Overview */}
⋮----
<span className=
⋮----
{/* Daily Metrics */}
⋮----
{/* Projected Total */}
````

## File: src/components/features/trips/itinerary-builder.tsx
````typescript
/**
 * @fileoverview Client-side itinerary builder with drag-and-drop scheduling.
 */
⋮----
import {
  DragDropContext,
  Draggable,
  Droppable,
  type DropResult,
} from "@hello-pangea/dnd";
import type { TripDestination, UiTrip } from "@schemas/trips";
import {
  CalendarIcon,
  CarIcon,
  Edit2Icon,
  GripVerticalIcon,
  HotelIcon,
  MapPinIcon,
  PlaneIcon,
  PlusIcon,
  TrainIcon,
  Trash2Icon,
} from "lucide-react";
import type { Dispatch, SetStateAction } from "react";
import { useCallback, useId, useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { secureUuid } from "@/lib/security/random";
import { useTripItineraryStore } from "@/stores/trip-itinerary-store";
⋮----
interface ItineraryBuilderProps {
  trip: UiTrip;
  onUpdateTrip?: (trip: UiTrip) => void;
  className?: string;
}
⋮----
interface DestinationFormData {
  name: string;
  country: string;
  startDate: string;
  endDate: string;
  activities: string[];
  accommodation: {
    type: string;
    name: string;
    price?: number;
  };
  transportation: {
    type: string;
    details: string;
    price?: number;
  };
  estimatedCost?: number;
  notes?: string;
}
⋮----
interface DestinationDialogProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  formData: DestinationFormData;
  setFormData: Dispatch<SetStateAction<DestinationFormData>>;
  addActivity: () => void;
  updateActivity: (index: number, value: string) => void;
  removeActivity: (index: number) => void;
  onSave: () => void | Promise<void>;
  isEditing: boolean;
}
⋮----
// biome-ignore lint/suspicious/noArrayIndexKey: Activities are simple strings without stable IDs; index key avoids remount on input change
⋮----
onClick=
⋮----
const resetForm = () =>
⋮----
const openAddDialog = () =>
⋮----
const openEditDialog = (destination: TripDestination) =>
⋮----
const handleSaveDestination = () =>
⋮----
const handleDeleteDestination = (destinationId: string) =>
⋮----
const addActivity = () =>
⋮----
const updateActivity = (index: number, value: string) =>
⋮----
const removeActivity = (index: number) =>
⋮----
const getTransportationIcon = (type?: string) =>
⋮----
{/* Add Destination Dialog */}
⋮----
{/* Edit Destination Dialog */}
````

## File: src/components/features/trips/trip-card.tsx
````typescript
/**
 * @fileoverview Trip card component for displaying trip information.
 *
 * Shows trip details including dates, duration, budget, destinations, and status
 * with edit/delete actions and navigation to trip details.
 */
⋮----
import type { UiTrip } from "@schemas/trips";
import { CalendarIcon, DollarSignIcon, MapPinIcon } from "lucide-react";
import Link from "next/link";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { DateUtils } from "@/lib/dates/unified-date-utils";
import { cn } from "@/lib/utils";
import { statusVariants } from "@/lib/variants/status";
import { useBudgetStore } from "@/stores/budget-store";
⋮----
type Trip = UiTrip;
⋮----
/**
 * Props for the TripCard component.
 *
 * @interface TripCardProps
 */
interface TripCardProps {
  /** The trip data to display. */
  trip: Trip;
  /** Optional callback for edit action. */
  onEdit?: (trip: Trip) => void;
  /** Optional callback for delete action. */
  onDelete?: (tripId: string) => void;
  /** Optional additional CSS classes. */
  className?: string;
}
⋮----
/** The trip data to display. */
⋮----
/** Optional callback for edit action. */
⋮----
/** Optional callback for delete action. */
⋮----
/** Optional additional CSS classes. */
⋮----
/**
 * Renders a trip summary card with metadata, actions, and derived values.
 *
 * @param props - Component inputs including callbacks and trip data.
 * @returns Styled card with trip details and actions.
 */
⋮----
/**
   * Formats a date string for display.
   *
   * @param dateString - The date string to format.
   * @returns Formatted date string or "Not set" placeholder.
   */
const formatDate = (dateString?: string) =>
⋮----
/**
   * Determines the current status of the trip.
   *
   * @returns The trip status: "draft", "upcoming", "active", or "completed".
   */
const getTripStatus = () =>
⋮----
/**
   * Maps trip status to statusVariants.
   * All statuses use statusVariants for consistent styling.
   */
const getStatusClassName = (status: string) =>
⋮----
<Badge className=
⋮----
````

## File: src/components/features/trips/trip-timeline.tsx
````typescript
/**
 * @fileoverview Trip timeline component for visualizing trip itinerary.
 *
 * Displays chronological timeline of destinations, activities, and events
 * with interactive editing capabilities and status indicators.
 */
⋮----
import type { TripDestination, UiTrip } from "@schemas/trips";
import {
  CalendarIcon,
  CarIcon,
  ClockIcon,
  Edit2Icon,
  MapPinIcon,
  PlaneIcon,
  PlusIcon,
  TrainIcon,
} from "lucide-react";
import { useMemo } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { DateUtils } from "@/lib/dates/unified-date-utils";
⋮----
type Trip = UiTrip;
type Destination = TripDestination;
⋮----
/**
 * Props for the TripTimeline component.
 *
 * @interface TripTimelineProps
 */
interface TripTimelineProps {
  /** The trip data to visualize in timeline format. */
  trip: Trip;
  /** Optional callback for editing destination details. */
  onEditDestination?: (destination: Destination) => void;
  /** Optional callback for adding new destinations. */
  onAddDestination?: () => void;
  /** Optional additional CSS classes. */
  className?: string;
  /** Whether to show action buttons. Defaults to true. */
  showActions?: boolean;
}
⋮----
/** The trip data to visualize in timeline format. */
⋮----
/** Optional callback for editing destination details. */
⋮----
/** Optional callback for adding new destinations. */
⋮----
/** Optional additional CSS classes. */
⋮----
/** Whether to show action buttons. Defaults to true. */
⋮----
/**
 * Represents a single event in the trip timeline.
 *
 * @interface TimelineEvent
 */
interface TimelineEvent {
  /** Unique identifier for the event. */
  id: string;
  /** Type of event determining icon and styling. */
  type: "arrival" | "departure" | "activity" | "accommodation";
  /** Date and time of the event. */
  date: Date;
  /** Event title or name. */
  title: string;
  /** Optional event description. */
  description?: string;
  /** Location where the event takes place. */
  location: string;
  /** Associated destination object. */
  destination: Destination;
  /** Icon type to display for the event. */
  iconType: "flight" | "car" | "train" | "calendar" | "location";
}
⋮----
/** Unique identifier for the event. */
⋮----
/** Type of event determining icon and styling. */
⋮----
/** Date and time of the event. */
⋮----
/** Event title or name. */
⋮----
/** Optional event description. */
⋮----
/** Location where the event takes place. */
⋮----
/** Associated destination object. */
⋮----
/** Icon type to display for the event. */
⋮----
/**
 * Renders a chronological visualization of trip destinations and events with
 * optional editing controls.
 *
 * @param props - Component properties including trip data and callbacks.
 * @returns Timeline component summarizing the itinerary.
 */
⋮----
// Arrival event
⋮----
// Activities
⋮----
// For activities without specific dates, distribute them across the stay
⋮----
// Departure event
⋮----
const formatEventDate = (date: Date) =>
⋮----
// const formatEventTime = (date: Date) => { // Future implementation
//   return format(date, "h:mm a");
// };
⋮----
const getEventColor = (type: TimelineEvent["type"]) =>
⋮----
const getEventIcon = (iconType: TimelineEvent["iconType"]) =>
⋮----
const getDuration = () =>
⋮----
{/* Timeline line */}
⋮----
{/* Timeline dot */}
⋮----
{/* Event content */}
⋮----
{/* Destination details */}
⋮----
{/* Actions */}
⋮----
{/* Add destination button */}
````

## File: src/components/layouts/auth-layout.tsx
````typescript
import Link from "next/link";
⋮----
export function AuthLayout(
````

## File: src/components/layouts/dashboard-layout.tsx
````typescript
/**
 * @fileoverview DashboardLayout components providing the main application layout
 * with sidebar navigation, header, and user account management for the dashboard
 * experience.
 */
⋮----
import type { AuthUser } from "@schemas/stores";
import Link from "next/link";
import { ThemeToggle } from "@/components/ui/theme-toggle";
import { mapSupabaseUserToAuthUser, requireUser } from "@/lib/auth/server";
import { ROUTES } from "@/lib/routes";
import { SidebarNav } from "./sidebar-nav";
import { UserNav } from "./user-nav";
⋮----
/** Dashboard navigation link metadata used by the layout. */
export interface DashboardNavItem {
  href: string;
  title: string;
  icon?: React.ReactNode;
}
⋮----
export interface DashboardLayoutData {
  navItems: ReadonlyArray<DashboardNavItem>;
  user: AuthUser;
}
⋮----
// Chat is intentionally outside the dashboard namespace; keep `/chat` public.
⋮----
/**
 * Fetches authenticated user and navigation data required by the dashboard layout.
 *
 * Isolated from the Server Component to enable focused unit tests without RSC rendering.
 */
// biome-ignore lint/style/useNamingConvention: helper function is not a React component
export async function fetchDashboardLayoutData(): Promise<DashboardLayoutData>
⋮----
interface DashboardLayoutViewProps {
  children: React.ReactNode;
  navItems?: ReadonlyArray<DashboardNavItem>;
  user: AuthUser;
}
⋮----
/**
 * Pure presentational layout for the dashboard shell; expects resolved data.
 */
export function DashboardLayoutView({
  children,
  navItems = DASHBOARD_NAV_ITEMS,
  user,
}: DashboardLayoutViewProps)
⋮----
/**
 * Server Component wrapper that resolves auth/navigation data then renders the
 * presentational dashboard shell.
 *
 * @param children - Content to render in the main content area.
 */
export async function DashboardLayout(
````

## File: src/components/layouts/navbar.tsx
````typescript
/**
 * @fileoverview App navbar with navigation links and mobile drawer toggle.
 */
⋮----
import { CalendarIcon, MapPinIcon, MenuIcon, XIcon } from "lucide-react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { ThemeToggle } from "@/components/ui/theme-toggle";
import { ROUTES } from "@/lib/routes";
import { cn } from "@/lib/utils";
⋮----
{/* Desktop navigation */}
⋮----
className=
⋮----
{/* User section */}
⋮----
{/* Mobile menu button */}
⋮----
{/* Mobile navigation */}
````

## File: src/components/layouts/search-layout.tsx
````typescript
import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
⋮----
interface SearchNavProps extends React.HTMLAttributes<HTMLElement> {
  items: {
    href: string;
    title: string;
    icon?: React.ReactNode;
  }[];
}
⋮----
<nav className=
⋮----
className=
````

## File: src/components/layouts/sidebar-nav.tsx
````typescript
/**
 * @fileoverview Sidebar navigation component.
 */
⋮----
import Link from "next/link";
import { usePathname } from "next/navigation";
import { ROUTES } from "@/lib/routes";
import { cn } from "@/lib/utils";
⋮----
/**
 * Props interface for the SidebarNav component.
 */
interface SidebarNavProps extends React.HTMLAttributes<HTMLElement> {
  /** Array of navigation items with href, title, and optional icon. */
  items: ReadonlyArray<{
    href: string;
    title: string;
    icon?: React.ReactNode;
  }>;
}
⋮----
/** Array of navigation items with href, title, and optional icon. */
⋮----
/**
 * Navigation component for sidebar with active route highlighting.
 *
 * @param className - Additional CSS classes to apply.
 * @param items - Array of navigation items to display.
 * @param props - Additional HTML attributes.
 * @returns The SidebarNav component.
 */
export function SidebarNav(
⋮----
className=
````

## File: src/components/layouts/user-nav.tsx
````typescript
/**
 * @fileoverview User navigation component.
 */
⋮----
import type { AuthUser } from "@schemas/stores";
import {
  ChevronDownIcon,
  LogOutIcon,
  SettingsIcon,
  ShieldIcon,
  UserIcon,
} from "lucide-react";
import Link from "next/link";
import { useState, useTransition } from "react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { logoutAction } from "@/lib/auth/actions";
import { ROUTES } from "@/lib/routes";
⋮----
interface UserNavProps {
  user: AuthUser;
}
⋮----
/**
 * User navigation component with profile dropdown and logout functionality.
 *
 * Displays user avatar and provides access to profile, settings, and logout
 * options via a popover menu.
 *
 * @param user - The authenticated user.
 * @returns The UserNav component.
 */
export function UserNav(
⋮----
const handleLogout = () =>
⋮----
// Get initials for avatar fallback
````

## File: src/components/providers/performance-provider.tsx
````typescript
/**
 * @fileoverview Wrapper for performance monitoring provider.
 */
⋮----
import type { ReactNode } from "react";
import { useWebVitals } from "@/hooks/use-performance";
⋮----
/** Props for the PerformanceMonitor component. */
interface PerformanceMonitorProps {
  children: ReactNode;
}
⋮----
/**
 * PerformanceMonitor component.
 *
 * Initializes Web Vitals monitoring and returns the children.
 *
 * @param children - React children to wrap.
 * @returns The children wrapped in a PerformanceMonitor component.
 */
export function PerformanceMonitor(
⋮----
// Initialize Web Vitals monitoring
````

## File: src/components/providers/query-provider.tsx
````typescript
/**
 * @fileoverview TanStack Query provider with OTEL-backed telemetry.
 * Refer to docs/development/observability.md for tracing and alerting standards.
 */
⋮----
import { QueryClient, QueryClientProvider, type QueryKey } from "@tanstack/react-query";
import dynamic from "next/dynamic";
import { type ReactNode, useState } from "react";
⋮----
import { shouldRetryError } from "@/lib/api/error-types";
import { cacheTimes, staleTimes } from "@/lib/query/config";
⋮----
type QueryDefault = {
  gcTime: number;
  queryKey: QueryKey;
  staleTime: number;
};
⋮----
/**
 * Create a new QueryClient with default options.
 *
 * @returns QueryClient instance with default options.
 */
function CreateQueryClient()
⋮----
// Global fallback for queries without per-key staleTime defaults.
⋮----
/**
 * TanStack Query provider component.
 *
 * @param children - React children to wrap with QueryProvider.
 * @returns QueryProvider component wrapping the children.
 */
export function TanStackQueryProvider(
````

## File: src/components/providers/realtime-auth-provider.tsx
````typescript
/**
 * @fileoverview React provider that synchronizes Supabase Realtime authentication
 * with the current Supabase session token.
 */
⋮----
import { useEffect } from "react";
import { getBrowserClient } from "@/lib/supabase";
⋮----
/**
 * Keeps Supabase Realtime authorized with the latest access token, reacting to
 * authentication lifecycle events and cleaning up on unmount.
 *
 * @returns This component renders nothing; it purely manages side effects.
 */
export function RealtimeAuthProvider(): null
⋮----
// During SSR, supabase is null - skip auth setup
⋮----
// Capture non-null reference for use in nested functions
⋮----
// biome-ignore lint/style/useNamingConvention: Not a React hook
async function initializeRealtimeAuthHandler(): Promise<void>
⋮----
// Allow UI to operate; realtime auth will refresh when a valid token exists.
````

## File: src/components/providers/telemetry-provider.tsx
````typescript
/**
 * @fileoverview React provider that initializes client-side OpenTelemetry tracing.
 *
 * This component initializes the WebTracerProvider and FetchInstrumentation
 * when mounted in the browser. It renders nothing and is purely for side effects.
 */
⋮----
import { useEffect } from "react";
import { initTelemetry } from "@/lib/telemetry/client";
⋮----
/**
 * TelemetryProvider component.
 *
 * Initializes client-side OpenTelemetry tracing on mount. Uses useEffect to
 * ensure initialization only happens in the browser (not during SSR).
 *
 * This component renders nothing and is purely for side effects.
 *
 * @returns null (renders nothing)
 */
export function TelemetryProvider(): null
⋮----
// Initialize telemetry only in browser environment
````

## File: src/components/providers/theme-provider.tsx
````typescript
/**
 * @fileoverview Wrapper for Next.js ThemeProvider component.
 */
⋮----
import { ThemeProvider as NextThemesProvider } from "next-themes";
import type { ComponentProps } from "react";
⋮----
/**
 * ThemeProvider component.
 *
 * @param children - React children to wrap with ThemeProvider.
 * @param props - Component props aligned with Next.js ThemeProvider.
 * @returns ThemeProvider component wrapping the children.
 */
export function ThemeProvider({
  children,
  ...props
}: ComponentProps<typeof NextThemesProvider>)
````

## File: src/components/search/search-page-skeleton.tsx
````typescript
/**
 * @fileoverview Shared loading skeleton for search result pages.
 */
⋮----
import { Skeleton } from "@/components/ui/skeleton";
⋮----
/**
 * Skeleton UI for search pages.
 *
 * @returns {JSX.Element} Placeholder content while search pages load.
 */
export function SearchPageSkeleton()
⋮----
// biome-ignore lint/a11y/useSemanticElements: Loading skeleton uses role="status" live region; no semantic element fits this container.
````

## File: src/components/settings/api-keys-content.tsx
````typescript
/**
 * @fileoverview BYOK API keys management UI. Provides provider selection and secured
 * key storage operations via authenticated API. IDs are generated with `useId` to
 * avoid duplicate DOM identifiers when multiple instances are rendered.
 */
⋮----
import {
  useActionState,
  useCallback,
  useEffect,
  useId,
  useMemo,
  useRef,
  useState,
} from "react";
import { z } from "zod";
import { updateGatewayFallbackPreference } from "@/app/dashboard/settings/api-keys/actions";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Separator } from "@/components/ui/separator";
import { Skeleton } from "@/components/ui/skeleton";
import { Switch } from "@/components/ui/switch";
import { useToast } from "@/components/ui/use-toast";
import { useAuthenticatedApi } from "@/hooks/use-authenticated-api";
import { useZodForm } from "@/hooks/use-zod-form";
import { ApiError } from "@/lib/api/error-types";
import { getUnknownErrorMessage } from "@/lib/errors/get-unknown-error-message";
import { validateApiKeyInput } from "@/lib/security/api-key-validation";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
⋮----
type AllowedService = (typeof SUPPORTED)[number];
⋮----
type ApiKeyFormValues = z.infer<typeof API_KEY_FORM_SCHEMA>;
⋮----
function IsAllowedService(value: string): value is AllowedService
⋮----
function ToTitleCaseIdentifier(value: string): string
⋮----
function GetProviderDisplayName(providerId: string): string
⋮----
type ApiKeySummary = {
  service: AllowedService;
  createdAt: string;
  lastUsed?: string | null;
  hasKey: boolean;
  isValid: boolean;
};
⋮----
/**
 * Render the API Keys management UI.
 *
 * @returns The BYOK management UI component.
 */
⋮----
const onDelete = async (svc: AllowedService) =>
⋮----
const onToggleFallback = (next: boolean) =>
⋮----
// Generate unique ids for form controls to satisfy accessibility and lint rules
````

## File: src/components/ui/__mocks__/use-toast.ts
````typescript
/**
 * @fileoverview Vitest mocks for the use-toast module. Provides mocked
 * implementations for testing toast functionality in isolation.
 */
⋮----
import { vi } from "vitest";
import type { Toast } from "../use-toast";
⋮----
/**
 * Mock implementation of the toast function. Creates a mock toast object
 * with jest mock functions for testing purposes.
 *
 * @param _props - Toast properties (ignored in mock).
 * @returns A mock toast object with dismiss, id, and update properties.
 */
⋮----
/**
 * Mock implementation of the useToast hook. Returns a mock object
 * with the expected hook interface for testing.
 *
 * @returns A mock useToast hook result with dismiss function, toast function, and empty toasts array.
 */
````

## File: src/components/ui/accordion.tsx
````typescript
import { ChevronDownIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
````

## File: src/components/ui/alert-dialog.tsx
````typescript
import { cn } from "@/lib/utils";
⋮----
className=
⋮----
export function AlertDialogHeader({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>)
⋮----
export function AlertDialogFooter({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>)
````

## File: src/components/ui/alert.tsx
````typescript
/**
 * @fileoverview Alert component for displaying content in an alert-like format.
 * Provides a styled alert with various sizes and variants.
 */
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Variants for alert components.
 *
 * @returns A string of classes for the alert.
 */
⋮----
/**
 * Alert component for displaying content in an alert-like format.
 *
 * @param className Optional extra classes.
 * @param variant Variant of the alert.
 * @returns A div with alert styling and ARIA role.
 */
⋮----
className=
⋮----
/**
 * Alert title component for displaying content in an alert-like format.
 *
 * @param className Optional extra classes.
 * @returns A h5 with alert title styling and ARIA role.
 */
⋮----
/**
 * Alert description component for displaying content in an alert-like format.
 *
 * @param className Optional extra classes.
 * @returns A div with alert description styling and ARIA role.
 */
````

## File: src/components/ui/avatar.tsx
````typescript
import { cn } from "@/lib/utils";
⋮----
function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>)
⋮----
className=
⋮----
function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>)
````

## File: src/components/ui/badge.tsx
````typescript
/**
 * @fileoverview Badge component for displaying content in a badge-like format.
 * Provides a styled badge with various sizes and variants.
 */
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Variants for badge components.
 *
 * @returns A string of classes for the badge.
 */
⋮----
/**
 * Props for the Badge component.
 *
 * @param className Optional extra classes.
 * @param variant Variant of the badge.
 * @returns A div with badge styling and ARIA role.
 */
export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof BadgeVariants> {}
⋮----
/**
 * Badge component for displaying content in a badge-like format.
 *
 * @param className Optional extra classes.
 * @param variant Variant of the badge.
 * @returns A div with badge styling and ARIA role.
 */
function Badge(
⋮----
return <div className=
⋮----
/**
 * Export the Badge component and variants.
 *
 * @returns An object containing the Badge component and variants.
 */
````

## File: src/components/ui/button.tsx
````typescript
/**
 * @fileoverview Button component for triggering actions.
 * Provides a styled button with various sizes and variants.
 */
⋮----
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Variants for button components.
 *
 * @param className Optional extra classes.
 * @param size Size of the button.
 * @param variant Variant of the button.
 * @returns A string of classes for the button.
 */
⋮----
/**
 * Button component for triggering actions.
 *
 * @param className Optional extra classes.
 * @param variant Variant of the button.
 * @param size Size of the button.
 * @param asChild Whether the button is a child of another component.
 * @returns A button with styling and accessibility features.
 */
⋮----
/**
 * Export the button component and variants.
 *
 * @returns An object containing the button component and variants.
 */
````

## File: src/components/ui/card.tsx
````typescript
/**
 * @fileoverview Card component for displaying content in a card-like format.
 * Provides a styled card with header, title, description, content, and footer.
 */
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Card component for displaying content in a card-like format.
 *
 * @param className Optional extra classes.
 * @returns A div with card styling and ARIA role.
 */
⋮----
/**
 * Card header component for displaying content in a card-like format.
 *
 * @param className Optional extra classes.
 * @returns A div with card header styling and ARIA role.
 */
⋮----
/**
 * Card description component for displaying content in a card-like format.
 *
 * @param className Optional extra classes.
 * @returns A p with card description styling and ARIA role.
 */
⋮----
/**
 * Card content component for displaying content in a card-like format.
 *
 * @param className Optional extra classes.
 * @returns A div with card content styling and ARIA role.
 */
⋮----
/**
 * Card footer component for displaying content in a card-like format.
 *
 * @param className Optional extra classes.
 * @returns A div with card footer styling and ARIA role.
 */
````

## File: src/components/ui/checkbox.tsx
````typescript
/**
 * @fileoverview Accessible checkbox component built on Radix primitives.
 */
⋮----
import { CheckIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
export interface CheckboxProps
  extends React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root> {
  ref?: React.Ref<React.ComponentRef<typeof CheckboxPrimitive.Root>>;
}
````

## File: src/components/ui/collapsible.tsx
````typescript
function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>)
⋮----
function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>)
````

## File: src/components/ui/command.tsx
````typescript
import { Command as CommandPrimitive } from "cmdk";
import { SearchIcon } from "lucide-react";
⋮----
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { cn } from "@/lib/utils";
⋮----
className=
````

## File: src/components/ui/current-year.tsx
````typescript
/**
 * Displays the current year on the client to avoid server prerender time coupling.
 */
export function CurrentYear()
⋮----
return <>
````

## File: src/components/ui/dialog.tsx
````typescript
import { XIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
className=
⋮----
function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>)
````

## File: src/components/ui/drawer.tsx
````typescript
import { Drawer as DrawerPrimitive } from "vaul";
⋮----
import { cn } from "@/lib/utils";
⋮----
function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>)
⋮----
className=
⋮----
function DrawerHeader(
````

## File: src/components/ui/dropdown-menu.tsx
````typescript
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>)
⋮----
function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>)
⋮----
function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>)
⋮----
function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>)
⋮----
function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
})
⋮----
className=
⋮----
function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>)
⋮----
function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>)
⋮----
function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
})
````

## File: src/components/ui/form.tsx
````typescript
import { Slot } from "@radix-ui/react-slot";
⋮----
import {
  Controller,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form";
⋮----
import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";
⋮----
type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};
⋮----
const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) =>
⋮----
// biome-ignore lint/style/useNamingConvention: This is a React hook
const useFormField = () =>
⋮----
type FormItemContextValue = {
  id: string;
};
⋮----
className=
````

## File: src/components/ui/hover-card.tsx
````typescript
import { cn } from "@/lib/utils";
⋮----
function HoverCardTrigger({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Trigger>)
⋮----
function HoverCardContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Content>)
````

## File: src/components/ui/input-group.tsx
````typescript
/**
 * @fileoverview Input group primitives used by AI Elements prompt inputs.
 * Provides grouped controls, add-ons, and text/textarea fields with consistent
 * styling and focus/invalid states.
 */
⋮----
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";
⋮----
/**
 * Group wrapper for input controls.
 *
 * @param className Optional extra classes.
 * @returns A div with input-group styling and ARIA role.
 */
⋮----
className=
⋮----
// Variants based on alignment.
⋮----
// Focus state.
⋮----
// Error state.
⋮----
/**
 * Variants for input group addons.
 *
 * @param align Alignment of the addon within the group.
 * @returns A string of classes for the addon.
 */
⋮----
/**
 * Addon region placed inline or in block areas of the input group.
 *
 * @param className Optional extra classes.
 * @param align Alignment of the addon within the group.
 * @returns A div that forwards clicks to focus the input.
 */
⋮----
/**
 * Button component for input group.
 *
 * @param className Optional extra classes.
 * @param type Type of the button.
 * @param variant Variant of the button.
 * @param size Size of the button.
 * @returns A button with input group styling.
 */
⋮----
/**
 * Text component for input group.
 *
 * @param className Optional extra classes.
 * @returns A span with input group styling.
 */
⋮----
/**
 * Input component for input group.
 *
 * @param className Optional extra classes.
 * @returns An input with input group styling.
 */
⋮----
/**
 * Textarea component for input group.
 *
 * @param className Optional extra classes.
 * @returns A textarea with input group styling.
 */
⋮----
/**
 * Export the input group components.
 *
 * @returns An object containing the input group components.
 */
````

## File: src/components/ui/input.tsx
````typescript
/**
 * @fileoverview Input component for form fields.
 * Provides a styled input field with consistent styling and accessibility features.
 */
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Input component for form fields.
 *
 * @param className Optional extra classes.
 * @param type Type of the input.
 * @returns An input with styling and accessibility features.
 */
function Input(
⋮----
className=
````

## File: src/components/ui/label.tsx
````typescript
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
⋮----
export interface LabelProps
  extends React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>,
    VariantProps<typeof LabelVariants> {
  ref?: React.Ref<React.ComponentRef<typeof LabelPrimitive.Root>>;
}
⋮----
export function Label(
````

## File: src/components/ui/loading-skeletons.tsx
````typescript
/**
 * @fileoverview Loading skeleton components for various UI elements.
 * Provides placeholder components that mimic the layout of actual content
 * during loading states.
 */
⋮----
import { cn } from "@/lib/utils";
import { Skeleton } from "./skeleton";
⋮----
/**
 * Props for the AvatarSkeleton component.
 */
export interface AvatarSkeletonProps {
  /** Size variant for the avatar skeleton. */
  size?: "sm" | "md" | "lg" | "xl";
  /** Optional additional CSS classes. */
  className?: string;
}
⋮----
/** Size variant for the avatar skeleton. */
⋮----
/** Optional additional CSS classes. */
⋮----
/**
 * Avatar skeleton component that displays a circular placeholder for profile images.
 *
 * @param size - Size variant for the avatar skeleton. Defaults to "md".
 * @param className - Optional additional CSS classes.
 * @param props - Additional HTML div element props.
 * @returns A skeleton component styled as a circular avatar placeholder.
 */
⋮----
className=
⋮----
/**
 * Props for the CardSkeleton component.
 */
export interface CardSkeletonProps {
  /** Whether to include an image placeholder at the top of the card. */
  hasImage?: boolean;
  /** Whether to include an avatar in the header section. */
  hasAvatar?: boolean;
  /** Number of title lines to display. Defaults to 1. */
  titleLines?: number;
  /** Number of body content lines to display. Defaults to 3. */
  bodyLines?: number;
  /** Optional additional CSS classes. */
  className?: string;
}
⋮----
/** Whether to include an image placeholder at the top of the card. */
⋮----
/** Whether to include an avatar in the header section. */
⋮----
/** Number of title lines to display. Defaults to 1. */
⋮----
/** Number of body content lines to display. Defaults to 3. */
⋮----
/** Optional additional CSS classes. */
⋮----
/**
 * Card skeleton component that displays a placeholder for card-based content.
 *
 * @param hasImage - Whether to include an image placeholder. Defaults to false.
 * @param hasAvatar - Whether to include an avatar. Defaults to false.
 * @param titleLines - Number of title lines. Defaults to 1.
 * @param bodyLines - Number of body lines. Defaults to 3.
 * @param className - Optional additional CSS classes.
 * @param props - Additional HTML div element props.
 * @returns A skeleton component mimicking a content card layout.
 */
⋮----
{/* Image placeholder */}
⋮----
{/* Header with optional avatar */}
⋮----
{/* Body content */}
⋮----
/**
 * Props for the ListItemSkeleton component.
 */
⋮----
/** Whether to include an avatar at the start of the list item. */
⋮----
/** Whether to include an action button at the end of the list item. */
⋮----
/** Number of title lines to display. Defaults to 1. */
⋮----
/** Number of subtitle lines to display. Defaults to 1. */
⋮----
/** Optional additional CSS classes. */
⋮----
/**
 * List item skeleton component that displays a placeholder for list item content.
 *
 * @param hasAvatar - Whether to include an avatar. Defaults to false.
 * @param hasAction - Whether to include an action button. Defaults to false.
 * @param titleLines - Number of title lines. Defaults to 1.
 * @param subtitleLines - Number of subtitle lines. Defaults to 1.
 * @param className - Optional additional CSS classes.
 * @param props - Additional HTML div element props.
 * @returns A skeleton component mimicking a list item layout.
 */
⋮----
/**
 * Props for the TableSkeleton component.
 */
⋮----
/** Number of data rows to display. Defaults to 5. */
⋮----
/** Number of columns to display. Defaults to 4. */
⋮----
/** Whether to include a header row. Defaults to true. */
⋮----
/** Optional additional CSS classes. */
⋮----
/**
 * Table skeleton component that displays a placeholder for tabular data.
 *
 * @param rows - Number of data rows. Defaults to 5.
 * @param columns - Number of columns. Defaults to 4.
 * @param hasHeader - Whether to show header row. Defaults to true.
 * @param className - Optional additional CSS classes.
 * @param props - Additional HTML table element props.
 * @returns A skeleton component mimicking a table layout.
 */
⋮----
<div className=
⋮----
/**
 * Props for the FormSkeleton component.
 */
⋮----
/** Number of form fields to display. Defaults to 3. */
⋮----
/** Whether to include a submit button at the end. Defaults to true. */
⋮----
/** Optional additional CSS classes. */
⋮----
/**
 * Form skeleton component that displays a placeholder for form layouts.
 *
 * @param fields - Number of form fields. Defaults to 3.
 * @param hasSubmitButton - Whether to show submit button. Defaults to true.
 * @param className - Optional additional CSS classes.
 * @param props - Additional HTML div element props.
 * @returns A skeleton component mimicking a form layout.
 */
⋮----
/**
 * Props for the ChartSkeleton component.
 */
⋮----
/** Type of chart to display skeleton for. Defaults to "bar". */
⋮----
/** Optional additional CSS classes. */
⋮----
/**
 * Chart skeleton component that displays a placeholder for chart/graph visualizations.
 *
 * @param type - Chart type variant. Defaults to "bar".
 * @param className - Optional additional CSS classes.
 * @param props - Additional HTML div element props.
 * @returns A skeleton component mimicking a chart layout.
 */
⋮----
{/* Chart title */}
⋮----
{/* Chart area */}
⋮----
{/* Chart legend */}
````

## File: src/components/ui/loading-spinner.tsx
````typescript
/**
 * @fileoverview Loading spinner components with multiple visual variants including
 * default spinning circle, animated dots, bars, and pulsing circle styles,
 * supporting different sizes and colors with accessibility features.
 */
⋮----
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Loading spinner variants for different styles and sizes using class-variance-authority.
 * Colors aligned with statusVariants semantics:
 * - info: blue-700 (matches statusVariants info)
 * - success: green-700 (matches statusVariants active/success)
 * - warning: amber-700 (matches statusVariants pending/medium)
 * - destructive: red-700 (matches statusVariants error)
 */
⋮----
/**
 * Props interface for the LoadingSpinner component.
 */
export interface LoadingSpinnerProps
  extends Omit<React.HTMLAttributes<HTMLDivElement>, "color">,
    VariantProps<typeof SpinnerVariants> {
  /** Visual variant of the spinner. */
  variant?: "default" | "dots" | "bars" | "pulse";
}
⋮----
/** Visual variant of the spinner. */
⋮----
/**
 * Props interface for SVG-based spinner components.
 */
export interface SVGSpinnerProps
  extends Omit<React.SVGAttributes<SVGSVGElement>, "color">,
    VariantProps<typeof SpinnerVariants> {
  /** Visual variant of the spinner. */
  variant?: "default" | "dots" | "bars" | "pulse";
}
⋮----
/** Visual variant of the spinner. */
⋮----
/**
 * Default spinning circle loader component with animated SVG path.
 *
 * @param props - Component props including size, color, and HTML attributes.
 * @param ref - Forwarded ref to the spinner container div.
 * @returns The default spinner component.
 */
⋮----
/**
 * Animated dots loader component with staggered pulse animations.
 *
 * @param props - Component props including size, color, and HTML attributes.
 * @param ref - Forwarded ref to the spinner container div.
 * @returns The dots spinner component.
 */
⋮----
className=
⋮----
/**
 * Animated bars loader component with sequential pulse animations.
 *
 * @param props - Component props including size, color, and HTML attributes.
 * @param ref - Forwarded ref to the spinner container div.
 * @returns The bars spinner component.
 */
⋮----
/**
 * Pulsing circle loader component with continuous ping animation.
 *
 * @param props - Component props including size, color, and HTML attributes.
 * @param ref - Forwarded ref to the spinner container div.
 * @returns The pulse spinner component.
 */
⋮----
/**
 * Main Loading Spinner component that renders different spinner variants.
 *
 * Supports multiple visual styles: default (spinning circle), dots, bars, and pulse.
 * All variants include accessibility features and support size/color customization.
 *
 * @param variant - The visual variant of the spinner to render.
 * @param props - Additional props passed to the specific spinner variant.
 * @param ref - Forwarded ref to the spinner component.
 * @returns The appropriate spinner component based on variant.
 */
````

## File: src/components/ui/loading.tsx
````typescript
/**
 * @fileoverview Loading components index
 * Exports all loading-related components for easy importing
 */
⋮----
// Hooks
⋮----
// Generic skeletons
⋮----
// Types re-exported from concrete component modules
⋮----
// Loading states
⋮----
// Base components
⋮----
// Travel-specific skeletons
````

## File: src/components/ui/menubar.tsx
````typescript
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>)
⋮----
function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>)
⋮----
className=
⋮----
function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>)
⋮----
function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean;
})
⋮----
function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean;
})
⋮----
function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>)
````

## File: src/components/ui/popover.tsx
````typescript
import { cn } from "@/lib/utils";
⋮----
export interface PopoverContentProps
  extends React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content> {
  ref?: React.Ref<React.ComponentRef<typeof PopoverPrimitive.Content>>;
}
⋮----
export function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ref,
  ...props
}: PopoverContentProps)
````

## File: src/components/ui/progress.tsx
````typescript
/**
 * @fileoverview Progress bar component built on Radix UI primitives, providing
 * accessible progress indicators with customizable styling and smooth animations.
 */
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Progress bar component for displaying completion status.
 *
 * Built on Radix UI Progress primitive with accessibility features including
 * ARIA attributes and screen reader support. Supports custom styling and smooth transitions.
 *
 * @param className - Additional CSS classes to apply.
 * @param value - Current progress value (0-100).
 * @param props - Additional props passed to the Radix Progress component.
 * @param ref - Forwarded ref to the progress root element.
 * @returns The Progress component.
 */
````

## File: src/components/ui/query-states.tsx
````typescript
/**
 * @fileoverview React Query state management components.
 * Provides reusable components for handling loading, error, and empty states
 * in React Query operations.
 */
⋮----
import type {
  UseInfiniteQueryResult,
  UseMutationResult,
  UseQueryResult,
} from "@tanstack/react-query";
import { AlertCircleIcon, Loader2Icon } from "lucide-react";
import type { ReactNode } from "react";
import { InlineQueryError } from "@/components/providers/query-error-boundary";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
⋮----
/**
 * Aligned query state colors matching statusVariants semantics.
 * - loading/processing: blue (info)
 * - success: green (active/success)
 * - error: red (error)
 * - empty: gray (neutral)
 */
⋮----
/**
 * Props for the QueryStateHandler component.
 */
interface QueryStateHandlerProps<TData = unknown, TError = Error> {
  /** The React Query result object to handle. */
  query: UseQueryResult<TData, TError>;
  /** Render function that receives the query data when available. */
  children: (data: TData) => ReactNode;
  /** Optional fallback component to show during loading state. */
  loadingFallback?: ReactNode;
  /** Optional error fallback that receives error and retry function. */
  errorFallback?: (error: TError, retry: () => void) => ReactNode;
  /** Optional fallback component to show when data is empty. */
  emptyFallback?: ReactNode;
  /** Optional function to determine if data should be considered empty. */
  isEmpty?: (data: TData) => boolean;
}
⋮----
/** The React Query result object to handle. */
⋮----
/** Render function that receives the query data when available. */
⋮----
/** Optional fallback component to show during loading state. */
⋮----
/** Optional error fallback that receives error and retry function. */
⋮----
/** Optional fallback component to show when data is empty. */
⋮----
/** Optional function to determine if data should be considered empty. */
⋮----
/**
 * Query state handler component that manages loading, error, and empty states.
 *
 * @param query - The React Query result object to handle.
 * @param children - Render function for successful data state.
 * @param loadingFallback - Optional loading state fallback.
 * @param errorFallback - Optional error state fallback.
 * @param emptyFallback - Optional empty state fallback.
 * @param isEmpty - Optional function to check if data is empty.
 * @returns The appropriate component based on query state.
 */
export function QueryStateHandler<TData = unknown, TError = Error>({
  query,
  children,
  loadingFallback,
  errorFallback,
  emptyFallback,
  isEmpty,
}: QueryStateHandlerProps<TData, TError>)
⋮----
// Loading state
⋮----
// Error state
⋮----
return <>
⋮----
// Convert error to Error type for InlineQueryError
⋮----
// Empty state
⋮----
// Success state
⋮----
// Fallback
⋮----
/**
 * Props for the MutationStateHandler component.
 */
interface MutationStateHandlerProps<
  TData = unknown,
  TError = Error,
  TVariables = unknown,
> {
  /** The React Query mutation result object to handle. */
  mutation: UseMutationResult<TData, TError, TVariables>;
  /** Child components to render alongside mutation state indicators. */
  children: ReactNode;
  /** Whether to show success message after successful mutation. */
  showSuccess?: boolean;
  /** Success message to display. Defaults to "Success!". */
  successMessage?: string;
  /** Duration in milliseconds to show success message. Defaults to 3000. */
  successDuration?: number;
}
⋮----
/** The React Query mutation result object to handle. */
⋮----
/** Child components to render alongside mutation state indicators. */
⋮----
/** Whether to show success message after successful mutation. */
⋮----
/** Success message to display. Defaults to "Success!". */
⋮----
/** Duration in milliseconds to show success message. Defaults to 3000. */
⋮----
/**
 * Mutation state handler component for form submissions and actions.
 *
 * @param mutation - The React Query mutation result object to handle.
 * @param children - Child components to render.
 * @param showSuccess - Whether to show success message. Defaults to false.
 * @param successMessage - Success message text. Defaults to "Success!".
 * @param successDuration - How long to show success message. Defaults to 3000.
 * @returns Component with mutation state indicators.
 */
⋮----
{/* Loading state */}
⋮----
{/* Error state */}
⋮----
/**
 * Default loading skeleton component.
 *
 * @returns A simple skeleton with three lines of varying widths.
 */
⋮----
/**
 * Default empty state component.
 *
 * @returns A centered empty state with icon and message.
 */
⋮----
/**
 * Card-based loading skeleton for lists.
 *
 * @param count - Number of skeleton cards to display. Defaults to 3.
 * @returns A list of skeleton cards mimicking content cards.
 */
⋮----
/**
 * Table loading skeleton component.
 *
 * @param rows - Number of skeleton rows to display. Defaults to 5.
 * @param columns - Number of skeleton columns to display. Defaults to 4.
 * @returns A skeleton component mimicking a table layout.
 */
⋮----
{/* Header */}
⋮----
{/* Rows */}
⋮----
/**
 * Props for the SuspenseQuery component.
 */
⋮----
/** The React Query result object to handle. */
⋮----
/** Render function that receives the query data. */
⋮----
/** Optional fallback component to show during loading. */
⋮----
/** Optional placeholder data to show while loading. */
⋮----
/**
 * Suspense-like query wrapper with enhanced loading states.
 *
 * @param query - The React Query result object to handle.
 * @param children - Render function for the data.
 * @param fallback - Optional loading fallback component.
 * @param placeholderData - Optional placeholder data for loading state.
 * @returns Component that handles query states with placeholder support.
 */
⋮----
// Show placeholder data while loading if available
⋮----
throw error; // Let error boundary handle this
⋮----
/**
 * Props for the InfiniteQueryStateHandler component.
 */
interface InfiniteQueryStateHandlerProps<TData = unknown> {
  /** The React Query infinite result object to handle. */
  query: UseInfiniteQueryResult<TData, Error>;
  /** Render function that receives flattened array of all pages data. */
  children: (data: TData[]) => ReactNode;
  /** Optional fallback component to show during loading. */
  loadingFallback?: ReactNode;
  /** Optional fallback component to show when no data is available. */
  emptyFallback?: ReactNode;
  /** Optional custom load more button component. */
  loadMoreButton?: ReactNode;
}
⋮----
/** The React Query infinite result object to handle. */
⋮----
/** Render function that receives flattened array of all pages data. */
⋮----
/** Optional fallback component to show during loading. */
⋮----
/** Optional fallback component to show when no data is available. */
⋮----
/** Optional custom load more button component. */
⋮----
/**
 * Infinite query state handler component.
 *
 * @param query - The React Query infinite result object to handle.
 * @param children - Render function for the flattened data array.
 * @param loadingFallback - Optional loading state fallback.
 * @param emptyFallback - Optional empty state fallback.
 * @param loadMoreButton - Optional custom load more button.
 * @returns Component that handles infinite query states with load more functionality.
 */
⋮----
// Type assertion for infinite query data structure
⋮----
// Convert error to Error type for InlineQueryError
⋮----
// Extract data from infinite query pages structure
⋮----

⋮----
{/* Load more button */}
⋮----
onClick=
⋮----
{/* Loading indicator for next page */}
````

## File: src/components/ui/radio-group.tsx
````typescript
import { CircleIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
className=
````

## File: src/components/ui/scroll-area.tsx
````typescript
import { cn } from "@/lib/utils";
⋮----
function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>)
⋮----
function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>)
````

## File: src/components/ui/select.tsx
````typescript
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default";
})
⋮----
className=
⋮----
function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>)
⋮----
function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>)
⋮----
function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>)
⋮----
function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>)
⋮----
function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>)
````

## File: src/components/ui/separator.tsx
````typescript
import { cn } from "@/lib/utils";
````

## File: src/components/ui/sheet.tsx
````typescript
import { XIcon } from "lucide-react";
⋮----
import { cn } from "@/lib/utils";
⋮----
function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>)
⋮----
className=
⋮----
function SheetHeader(
````

## File: src/components/ui/skeleton.tsx
````typescript
/**
 * @fileoverview Skeleton component with accessibility support and customizable variants.
 */
⋮----
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Skeleton component variants for consistent styling
 */
⋮----
export interface SkeletonProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof SkeletonVariants> {
  width?: string | number;
  height?: string | number;
  lines?: number;
  animate?: boolean;
}
⋮----
/**
 * Basic skeleton component with accessibility support
 */
⋮----
// Calculate final animation variant
⋮----
// Build inline styles
⋮----
// Single line skeleton
⋮----
// Multi-line skeleton
⋮----
// Vary the width of lines to look more natural
⋮----
className=
````

## File: src/components/ui/slider.tsx
````typescript
import { cn } from "@/lib/utils";
````

## File: src/components/ui/switch.tsx
````typescript
import { cn } from "@/lib/utils";
⋮----
className=
````

## File: src/components/ui/table.tsx
````typescript
import { cn } from "@/lib/utils";
````

## File: src/components/ui/tabs.tsx
````typescript
import { cn } from "@/lib/utils";
⋮----
export interface TabsListProps
  extends React.ComponentPropsWithoutRef<typeof TabsPrimitive.List> {
  ref?: React.Ref<React.ComponentRef<typeof TabsPrimitive.List>>;
}
export function TabsList(
⋮----
export interface TabsTriggerProps
  extends React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger> {
  ref?: React.Ref<React.ComponentRef<typeof TabsPrimitive.Trigger>>;
}
export function TabsTrigger(
⋮----
export interface TabsContentProps
  extends React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content> {
  ref?: React.Ref<React.ComponentRef<typeof TabsPrimitive.Content>>;
}
export function TabsContent(
````

## File: src/components/ui/textarea.tsx
````typescript
/**
 * @fileoverview Textarea component for form fields.
 * Provides a styled textarea field with consistent styling and accessibility features.
 */
⋮----
import { cn } from "@/lib/utils";
⋮----
/**
 * Textarea component for form fields.
 *
 * @param className Optional extra classes.
 * @returns A textarea with styling and accessibility features.
 */
⋮----
className=
````

## File: src/components/ui/theme-toggle.tsx
````typescript
/**
 * @fileoverview Theme toggle switch supporting light/system/dark preferences.
 */
⋮----
import { MonitorIcon, MoonIcon, SunIcon } from "lucide-react";
import { useTheme } from "next-themes";
⋮----
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
⋮----
export function ThemeToggle()
⋮----
// useEffect only runs on the client, so now we can safely show the UI
⋮----
// Alternative compact toggle for simpler use cases
export function CompactThemeToggle()
````

## File: src/components/ui/toaster.tsx
````typescript
import { useTheme } from "next-themes";
import { Toaster as SonnerToaster } from "sonner";
⋮----
/**
 * Toast notification container using Sonner.
 *
 * Integrates with next-themes for automatic light/dark theme support.
 * Renders at bottom-right on desktop, top on mobile.
 */
````

## File: src/components/ui/toggle-group.tsx
````typescript
import type { VariantProps } from "class-variance-authority";
⋮----
import { ToggleVariants } from "@/components/ui/toggle";
import { cn } from "@/lib/utils";
⋮----
className=
````

## File: src/components/ui/toggle.tsx
````typescript
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "@/lib/utils";
````

## File: src/components/ui/tooltip.tsx
````typescript
import { cn } from "@/lib/utils";
⋮----
function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>)
````

## File: src/components/ui/travel-skeletons.tsx
````typescript
/**
 * @fileoverview Travel-specific skeleton components for flight, hotel, trip, and
 * destination search results.
 */
⋮----
import { cn } from "@/lib/utils";
import { AvatarSkeleton, CardSkeleton, ListItemSkeleton } from "./loading-skeletons";
import { Skeleton } from "./skeleton";
⋮----
/**
 * Flight search result skeleton
 */
export interface FlightSkeletonProps {
  className?: string;
}
⋮----
{/* Flight route and times */}
⋮----
{/* Departure */}
⋮----
{/* Flight path */}
⋮----
{/* Arrival */}
⋮----
{/* Price */}
⋮----
{/* Flight details */}
⋮----
/**
 * Hotel/accommodation search result skeleton
 */
export interface HotelSkeletonProps {
  className?: string;
}
⋮----
{/* Hotel rating */}
⋮----
{/* Location */}
⋮----
{/* Amenities */}
⋮----
{/* Price and booking */}
⋮----
/**
 * Trip card skeleton
 */
⋮----
{/* Trip dates */}
⋮----
{/* Trip destination */}
⋮----
{/* Trip status and budget */}
⋮----
/**
 * Destination card skeleton
 */
⋮----
{/* Destination image with overlay */}
⋮----
{/* Destination name and description */}
⋮----
{/* Weather and best time */}
⋮----
{/* Tags */}
⋮----
/**
 * Itinerary item skeleton
 */
⋮----
{/* Time indicator */}
⋮----
{/* Content */}
⋮----
/**
 * Chat message skeleton
 */
⋮----
className=
⋮----
<div className=
⋮----
/**
 * Search filter skeleton
 */
⋮----
{/* Use FormSkeleton as base for overall structure */}
⋮----
{/* Section title */}
⋮----
{/* Section options using ListItemSkeleton pattern */}
````

## File: src/components/ui/use-toast.ts
````typescript
/**
 * @fileoverview Toast notification wrapper providing backward-compatible API
 * over Sonner. Maintains the same interface as the previous Radix-based toast.
 */
⋮----
import { toast as sonnerToast } from "sonner";
⋮----
type ToastVariant = "default" | "destructive";
⋮----
/**
 * Props for creating a toast notification.
 */
interface ToastProps {
  /** Primary toast title (must be a string for Sonner compatibility) */
  title?: string;
  /** Secondary description text (must be a string for Sonner compatibility) */
  description?: string;
  /** Visual variant - "destructive" renders as error toast */
  variant?: ToastVariant;
  /** Optional action button */
  action?: {
    label: string;
    onClick: () => void;
  };
}
⋮----
/** Primary toast title (must be a string for Sonner compatibility) */
⋮----
/** Secondary description text (must be a string for Sonner compatibility) */
⋮----
/** Visual variant - "destructive" renders as error toast */
⋮----
/** Optional action button */
⋮----
/**
 * Return value from toast() for controlling the notification.
 */
interface ToastReturn {
  /** Unique toast identifier */
  id: string | number;
  /** Dismiss this specific toast */
  dismiss: () => void;
  /** Update this toast with new props; returns new toast with updated ID */
  update: (props: ToastProps) => ToastReturn;
}
⋮----
/** Unique toast identifier */
⋮----
/** Dismiss this specific toast */
⋮----
/** Update this toast with new props; returns new toast with updated ID */
⋮----
/**
 * Display a toast notification.
 *
 * Maps variant "destructive" to Sonner's error toast, otherwise uses default.
 *
 * @param props - Toast configuration
 * @returns Object with id, dismiss, and update functions
 *
 * @example
 * ```ts
 * // Success toast
 * toast({ title: "Saved", description: "Changes saved successfully" });
 *
 * // Error toast
 * toast({ title: "Error", description: "Failed to save", variant: "destructive" });
 * ```
 */
function toast(props: ToastProps): ToastReturn
⋮----
/**
 * Hook providing toast state and control functions.
 *
 * Maintains backward compatibility with previous Radix-based implementation.
 * Note: Sonner manages its own internal state, so `toasts` array is always empty.
 * This hook exists for API compatibility. To render toasts, use `<Toaster />` from sonner.
 *
 * @returns Object with toast function, dismiss function, and toasts array (always empty)
 */
function useToast()
⋮----
toasts: [] as const, // Sonner manages its own state
````

## File: src/components/Map.tsx
````typescript
/**
 * @fileoverview Google Maps component with Advanced Markers.
 *
 * Client-side map component using Maps JavaScript API with Map ID, Advanced
 * Markers, and Places integration. Loads Maps JS via importLibrary.
 */
⋮----
import { useEffect, useRef, useState } from "react";
import { getGoogleMapsBrowserKey } from "@/lib/env/client";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
⋮----
interface Window {
    google?: typeof google;
    initMap?: () => void;
  }
⋮----
interface MapProps {
  center: { lat: number; lng: number };
  zoom?: number;
  mapId?: string;
  markers?: Array<{
    placeId?: string;
    lat: number;
    lng: number;
    title?: string;
    photoName?: string;
  }>;
  onMarkerClick?: (marker: {
    placeId?: string;
    lat: number;
    lng: number;
    title?: string;
  }) => void;
}
⋮----
/**
 * Google Maps component with Advanced Markers.
 *
 * @param props Map configuration props.
 */
export function GoogleMap({
  center,
  zoom = 10,
  mapId,
  markers = [],
  onMarkerClick,
}: MapProps)
⋮----
// Load Maps JS API script if not already loaded
⋮----
const initMap = async () =>
⋮----
mapId: mapId ?? "DEMO_MAP_ID", // Replace with your Map ID
⋮----
// Clear existing markers
⋮----
// Create Advanced Markers
⋮----
// Silently ignore telemetry failures to prevent error handler from breaking
````

## File: src/components/PlacesAutocomplete.tsx
````typescript
/**
 * @fileoverview Google Places Autocomplete component with session tokens.
 *
 * Client-side autocomplete component using Places Autocomplete Data API with
 * session token lifecycle management and debounced input handling.
 */
⋮----
import { useEffect, useRef, useState } from "react";
import { getGoogleMapsBrowserKey } from "@/lib/env/client";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
⋮----
type AutocompleteSuggestion = google.maps.places.AutocompleteSuggestion;
type AutocompleteRequest = google.maps.places.AutocompleteRequest;
type PlacePrediction = google.maps.places.PlacePrediction;
⋮----
interface Window {
    google?: typeof google;
  }
⋮----
interface PlacesAutocompleteProps {
  onPlaceSelect: (place: {
    placeId: string;
    displayName: string;
    formattedAddress?: string;
    location?: { lat: number; lng: number };
  }) => void;
  placeholder?: string;
  locationBias?: {
    lat: number;
    lng: number;
    radiusMeters: number;
  };
  includedTypes?: string[];
  className?: string;
}
⋮----
/**
 * Google Places Autocomplete component with session tokens.
 *
 * @param props Autocomplete configuration props.
 */
⋮----
// Load Maps JS API script if not already loaded
⋮----
const initAutocomplete = async () =>
⋮----
const handleInputChange = (value: string) =>
⋮----
}, 300); // 300ms debounce
⋮----
const handlePlaceSelect = async (placePrediction: PlacePrediction | null) =>
⋮----
// Terminate session and create new token
⋮----
const getOptionId = (
    suggestion: (typeof selectableSuggestions)[number],
    index: number
) => suggestion.placePrediction.placeId ?? `places-option-$
⋮----
const handleClickOutside = (event: MouseEvent) =>
⋮----
onKeyDown=
⋮----
onMouseLeave=
⋮----
const selectSuggestion = () =>
⋮----
if (event.key === " ")
````

## File: src/config/bot-protection.ts
````typescript
/**
 * @fileoverview Bot protection routes for BotId.
 */
⋮----
import { getRuntimeEnv } from "@/lib/env/runtime-env";
⋮----
export type HttpMethod =
  | "GET"
  | "POST"
  | "PUT"
  | "PATCH"
  | "DELETE"
  | "OPTIONS"
  | "HEAD";
⋮----
export type BotIdProtectRule = { method: HttpMethod; path: string };
⋮----
// Default `BOTID_ENABLE` intentionally excludes "development" and "test" so BotId is disabled
// locally and in tests unless overridden.
⋮----
// Treat empty `BOTID_ENABLE` the same as undefined (fall back to defaults).
````

## File: src/domain/accommodations/providers/types.ts
````typescript
/**
 * @fileoverview Provider-agnostic accommodation adapter types.
 *
 * Replaces Expedia-specific DTOs with neutral contracts used by Amadeus + Google Places stack.
 */
⋮----
import type { ProviderError } from "@domain/accommodations/errors";
import type {
  AccommodationBookingRequest,
  AccommodationCheckAvailabilityParams,
  AccommodationDetailsParams,
  AccommodationSearchParams,
} from "@schemas/accommodations";
⋮----
/** Supported accommodation provider names. */
export type ProviderName = "amadeus";
⋮----
/** Context information passed to provider operations. */
export type ProviderContext = {
  userId?: string;
  sessionId?: string;
  userAgent?: string;
  clientIp?: string;
  testScenario?: string;
};
⋮----
/** Result of a provider operation with success/failure states and retry tracking. */
export type ProviderResult<T> =
  | { ok: true; value: T; retries: number }
  | { ok: false; error: ProviderError; retries: number };
⋮----
/** Result of a provider search operation. */
export type ProviderSearchResult = {
  listings: Array<Record<string, unknown>>;
  total?: number;
  currency?: string;
};
⋮----
/** Result of a provider details operation. */
export type ProviderDetailsResult = {
  listing: Record<string, unknown>;
};
⋮----
/** Result of a provider availability operation. */
export type ProviderAvailabilityResult = {
  bookingToken: string;
  expiresAt: string;
  price: {
    currency: string;
    total: string;
    breakdown?: {
      base?: string;
      fees?: string;
      taxes?: string;
    };
  };
  propertyId: string;
  rateId: string;
};
⋮----
/** Payload for a provider booking operation. */
export type ProviderBookingPayload = Record<string, unknown>;
⋮----
/** Result of a provider booking operation. */
export type ProviderBookingResult = {
  itineraryId?: string;
  confirmationNumber?: string;
  providerBookingId?: string;
  message?: string;
};
⋮----
/**
 * Abstraction for any accommodation supply provider.
 *
 * Implementations must wrap provider-specific errors into {@link ProviderError}
 * and surface retry counts for telemetry.
 */
export interface AccommodationProviderAdapter {
  /** Provider identifier for telemetry and error tracking. */
  readonly name: ProviderName;

  /**
   * Search for available accommodations matching criteria.
   */
  search(
    params: AccommodationSearchParams,
    ctx?: ProviderContext
  ): Promise<ProviderResult<ProviderSearchResult>>;

  /**
   * Get detailed information for a specific property.
   */
  getDetails(
    params: AccommodationDetailsParams,
    ctx?: ProviderContext
  ): Promise<ProviderResult<ProviderDetailsResult>>;

  /**
   * Verify room availability and get booking token.
   */
  checkAvailability(
    params: AccommodationCheckAvailabilityParams,
    ctx?: ProviderContext
  ): Promise<ProviderResult<ProviderAvailabilityResult>>;

  /**
   * Create a booking reservation.
   */
  createBooking(
    payload: ProviderBookingPayload,
    ctx?: ProviderContext
  ): Promise<ProviderResult<ProviderBookingResult>>;

  /**
   * Build provider-specific booking payload from normalized request.
   */
  buildBookingPayload(
    params: AccommodationBookingRequest,
    options?: {
      paymentIntentId?: string;
      currency?: string;
      totalCents?: number;
    }
  ): ProviderBookingPayload;
}
⋮----
/** Provider identifier for telemetry and error tracking. */
⋮----
/**
   * Search for available accommodations matching criteria.
   */
search(
    params: AccommodationSearchParams,
    ctx?: ProviderContext
  ): Promise<ProviderResult<ProviderSearchResult>>;
⋮----
/**
   * Get detailed information for a specific property.
   */
getDetails(
    params: AccommodationDetailsParams,
    ctx?: ProviderContext
  ): Promise<ProviderResult<ProviderDetailsResult>>;
⋮----
/**
   * Verify room availability and get booking token.
   */
checkAvailability(
    params: AccommodationCheckAvailabilityParams,
    ctx?: ProviderContext
  ): Promise<ProviderResult<ProviderAvailabilityResult>>;
⋮----
/**
   * Create a booking reservation.
   */
createBooking(
    payload: ProviderBookingPayload,
    ctx?: ProviderContext
  ): Promise<ProviderResult<ProviderBookingResult>>;
⋮----
/**
   * Build provider-specific booking payload from normalized request.
   */
buildBookingPayload(
    params: AccommodationBookingRequest,
    options?: {
      paymentIntentId?: string;
      currency?: string;
      totalCents?: number;
    }
  ): ProviderBookingPayload;
````

## File: src/domain/accommodations/booking-orchestrator.ts
````typescript
/**
 * @fileoverview Booking orchestrator with compensation.
 *
 * Executes booking workflow: approval -> payment -> provider booking -> persistence.
 * Handles refunds and alerts on failure paths.
 */
⋮----
import type {
  AccommodationProviderAdapter,
  ProviderResult,
} from "@domain/accommodations/providers/types";
import type { AccommodationBookingResult } from "@schemas/accommodations";
import {
  type ProcessedPayment,
  refundBookingPayment,
} from "@/lib/payments/booking-payment";
import { secureUuid } from "@/lib/security/random";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/** Command object for booking transaction execution. */
export type BookingCommand = {
  approvalKey: string;
  userId: string;
  sessionId: string;
  idempotencyKey: string;
  bookingToken: string;
  amount: number;
  currency: string;
  paymentMethodId: string;
  guest: {
    name: string;
    email: string;
    phone?: string;
  };
  stay: {
    listingId: string;
    checkin: string;
    checkout: string;
    guests: number;
    specialRequests?: string;
    tripId?: string;
  };
  providerPayload: ProviderPayloadBuilder;
  processPayment: () => Promise<ProcessedPayment>;
  persistBooking: (payload: PersistPayload) => Promise<void>;
  requestApproval: () => Promise<void>;
};
⋮----
/** Provider payload builder function or static object. */
type ProviderPayloadBuilder =
  | Record<string, unknown>
  | ((payment: ProcessedPayment) => Record<string, unknown>);
⋮----
/** Payload for persisting booking transaction to database. */
type PersistPayload = {
  bookingId: string;
  providerBookingId?: string;
  stripePaymentIntentId: string;
  confirmationNumber: string;
  command: BookingCommand;
};
⋮----
/** Dependencies for booking orchestrator. */
export type BookingOrchestratorDeps = {
  provider: AccommodationProviderAdapter;
  supabase: TypedServerSupabase;
};
⋮----
/**
 * Executes booking workflow with telemetry and compensation.
 *
 * @param deps - Provider adapter and Supabase client.
 * @param command - Booking command with approval and payment hooks.
 * @returns Confirmed booking result or throws provider/payment error.
 */
export function runBookingOrchestrator(
  deps: BookingOrchestratorDeps,
  command: BookingCommand
): Promise<AccommodationBookingResult>
⋮----
/**
 * Refunds booking payment if payment intent ID is available.
 *
 * @param payment - Processed payment to refund.
 */
async function refundOnFailure(payment?: ProcessedPayment): Promise<void>
````

## File: src/domain/accommodations/constants.ts
````typescript
/**
 * @fileoverview Shared accommodations domain constants.
 */
⋮----
/** Cache TTL for accommodation search results (seconds). */
````

## File: src/domain/accommodations/container.ts
````typescript
/**
 * @fileoverview Dependency container for accommodations domain.
 *
 * Centralizes construction of the accommodations service so callers (AI tools, routes)
 * do not hard-wire provider/configuration at import time.
 */
⋮----
import { ACCOM_SEARCH_CACHE_TTL_SECONDS } from "@domain/accommodations/constants";
import { AmadeusProviderAdapter } from "@domain/accommodations/providers/amadeus-adapter";
import { AccommodationsService } from "@domain/accommodations/service";
import { Ratelimit } from "@upstash/ratelimit";
import { getRedis } from "@/lib/redis";
import { createServerSupabase } from "@/lib/supabase/server";
⋮----
/**
 * Returns a singleton AccommodationsService configured with Amadeus adapter,
 * cache TTL, rate limit, and Supabase factory.
 */
export function getAccommodationsService(): AccommodationsService
````

## File: src/domain/accommodations/errors.ts
````typescript
/**
 * @fileoverview Domain-level errors for accommodation providers and services.
 */
⋮----
/** Canonical provider error categories used across adapters and services. */
export type ProviderErrorCode =
  | "not_found"
  | "rate_limited"
  | "unauthorized"
  | "provider_failed"
  | "provider_timeout"
  | "validation_failed"
  | "circuit_open";
⋮----
/** Optional metadata that helps diagnose provider failures. */
export type ProviderErrorMeta = {
  statusCode?: number;
  retryAfterMs?: number;
  provider?: string;
  operation?: string;
};
⋮----
/**
 * Normalized error surface for accommodation provider failures.
 *
 * Adapters convert downstream errors into this type so callers can map to
 * tool or domain-specific failures without inspecting raw provider responses.
 */
export class ProviderError extends Error
⋮----
constructor(code: ProviderErrorCode, message: string, meta?: ProviderErrorMeta)
⋮----
export function isProviderError(error: unknown): error is ProviderError
````

## File: src/domain/accommodations/service.ts
````typescript
/**
 * @fileoverview Accommodations domain service orchestrating provider calls, caching, and booking.
 *
 * Provider-neutral implementation for Amadeus + Google Places hybrid stack.
 */
⋮----
import { runBookingOrchestrator } from "@domain/accommodations/booking-orchestrator";
import { ProviderError } from "@domain/accommodations/errors";
import type {
  AccommodationProviderAdapter,
  ProviderContext,
  ProviderResult,
} from "@domain/accommodations/providers/types";
import {
  type AccommodationBookingRequest,
  type AccommodationBookingResult,
  type AccommodationCheckAvailabilityParams,
  type AccommodationCheckAvailabilityResult,
  type AccommodationDetailsParams,
  type AccommodationDetailsResult,
  type AccommodationSearchParams,
  type AccommodationSearchResult,
  accommodationBookingOutputSchema,
  accommodationCheckAvailabilityOutputSchema,
  accommodationDetailsOutputSchema,
  accommodationSearchOutputSchema,
} from "@schemas/accommodations";
import type { Ratelimit } from "@upstash/ratelimit";
import { canonicalizeParamsForCache } from "@/lib/cache/keys";
import { bumpTag, versionedKey } from "@/lib/cache/tags";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import { enrichHotelListingWithPlaces } from "@/lib/google/places-enrichment";
import { resolveLocationToLatLng } from "@/lib/google/places-geocoding";
import { retryWithBackoff } from "@/lib/http/retry";
import type { ProcessedPayment } from "@/lib/payments/booking-payment";
import { secureUuid } from "@/lib/security/random";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
// Extract Span type from withTelemetrySpan signature to avoid direct @opentelemetry/api import
type TelemetrySpan = Parameters<Parameters<typeof withTelemetrySpan>[2]>[0];
⋮----
/** Dependencies for the accommodations service. */
export type AccommodationsServiceDeps = {
  provider: AccommodationProviderAdapter;
  supabase: () => Promise<TypedServerSupabase>;
  rateLimiter?: Ratelimit;
  cacheTtlSeconds: number;
};
⋮----
/**
 * Context for the accommodations service.
 *
 * @property rateLimitKey - Optional explicit rate limit key. If not provided, falls back to `userId` from ProviderContext.
 * @property processPayment - Optional payment processing function for bookings.
 * @property requestApproval - Optional approval request function for bookings.
 */
export type ServiceContext = ProviderContext & {
  rateLimitKey?: string;
  processPayment?: (params: {
    amountCents: number;
    currency: string;
  }) => Promise<ProcessedPayment>;
  requestApproval?: () => Promise<void>;
};
⋮----
/** Cached booking price data structure. */
type CachedBookingPrice = {
  bookingToken: string;
  price: { currency: string; total: string };
  propertyId: string;
  rateId: string;
  sessionId?: string;
  userId?: string;
};
⋮----
/** Accommodations service class. */
export class AccommodationsService
⋮----
constructor(private readonly deps: AccommodationsServiceDeps)
⋮----
/** Executes an availability search with cache-aside. */
async search(
    params: AccommodationSearchParams,
    ctx?: ServiceContext
): Promise<AccommodationSearchResult>
⋮----
/** Retrieve details for a specific accommodation property. */
async details(
    params: AccommodationDetailsParams,
    ctx?: ServiceContext
): Promise<AccommodationDetailsResult>
⋮----
/** Check final availability and pricing. */
async checkAvailability(
    params: AccommodationCheckAvailabilityParams,
    ctx: ServiceContext
): Promise<AccommodationCheckAvailabilityResult>
⋮----
/** Complete an accommodation booking. */
async book(
    params: AccommodationBookingRequest,
    ctx: ServiceContext & { userId: string }
): Promise<AccommodationBookingResult>
⋮----
const providerPayloadBuilder = (payment: ProcessedPayment)
⋮----
const persist = async ()
⋮----
// Invalidate search cache using tag-based invalidation
// Bumping the tag invalidates all search cache entries for this tag
⋮----
/** Call a provider function and return the result. */
private async callProvider<T>(
    fn: (ctx?: ProviderContext) => Promise<ProviderResult<T>>,
    ctx?: ServiceContext
): Promise<
⋮----
/** Build a cache key for a search parameters object. */
private buildCacheKey(params: AccommodationSearchParams): string | undefined
⋮----
/**
   * Validates booking context including payment/approval handlers and rate limiting.
   *
   * @param ctx - Service context with payment and approval handlers
   * @param span - Telemetry span for event recording
   * @throws Error if handlers are missing
   * @throws ProviderError if rate limit exceeded
   */
private async validateBookingContext(
    ctx: ServiceContext & { userId: string },
    span: TelemetrySpan,
    listingId: string
): Promise<void>
⋮----
/**
   * Validates that a trip exists and belongs to the user.
   *
   * @param supabase - Supabase client instance
   * @param tripId - Trip ID string to validate
   * @param userId - User ID to verify ownership
   * @throws ProviderError if trip ID is invalid or trip not found/not owned
   */
private async validateTripOwnership(
    supabase: TypedServerSupabase,
    tripId: string | undefined,
    userId: string
): Promise<void>
⋮----
/**
   * Validates cached booking price and context.
   *
   * @param cachedPrice - Cached price data from booking cache (must not be null)
   * @param params - Booking request parameters
   * @param ctx - Service context with user/session info
   * @returns Validated amount in cents
   * @throws Error if validation fails
   */
private validateCachedPrice(
    cachedPrice: CachedBookingPrice,
    params: AccommodationBookingRequest,
    ctx: ServiceContext & { userId: string }
):
⋮----
/**
   * Builds a database row for booking persistence.
   *
   * @param params - Booking request parameters
   * @param payload - Booking orchestrator payload with booking ID
   * @param userId - User ID for the booking
   * @returns Database row object ready for insertion
   */
private buildBookingRow(
    params: AccommodationBookingRequest,
    payload: {
      bookingId: string;
      providerBookingId?: string;
      stripePaymentIntentId?: string | null;
    },
    userId: string
): Record<string, unknown>
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database columns use snake_case
⋮----
/** Internal type for price extraction from provider listings. */
type ProviderListingWithPrices = {
  rooms?: Array<{
    rates?: Array<{
      price?: {
        numeric?: number;
        total?: string;
      };
    }>;
  }>;
};
⋮----
/**
 * Extracts numeric price values from accommodation listings.
 *
 * @param listings - Array of accommodation listing objects with nested rooms and rates.
 * @returns Array of numeric price values found in the listings.
 */
function collectPrices(listings: Array<ProviderListingWithPrices>): number[]
⋮----
/**
 * Filters listings to those whose price range overlaps with the provided bounds.
 *
 * @param listings - Unfiltered provider listings.
 * @param minPrice - Optional minimum total price.
 * @param maxPrice - Optional maximum total price.
 * @returns Listings constrained to the requested price band.
 */
function filterListingsByPrice(
  listings: Array<ProviderListingWithPrices>,
  minPrice?: number,
  maxPrice?: number
): Array<ProviderListingWithPrices>
````

## File: src/domain/activities/container.ts
````typescript
/**
 * @fileoverview Dependency container for activities domain.
 *
 * Centralizes construction of the activities service so callers (AI tools, routes)
 * do not hard-wire dependencies at import time.
 */
⋮----
import { ActivitiesService } from "@domain/activities/service";
import { createServerSupabase } from "@/lib/supabase/server";
⋮----
/**
 * Returns a singleton ActivitiesService configured with Supabase factory.
 */
export function getActivitiesService(): ActivitiesService
````

## File: src/domain/activities/errors.ts
````typescript
/**
 * @fileoverview Domain-level errors for activities service.
 */
⋮----
/**
 * Error thrown when an activity cannot be found.
 */
export class NotFoundError extends Error
⋮----
constructor(message: string)
⋮----
/**
 * Type guard to check if an error is a NotFoundError.
 *
 * @param error - Error to check.
 * @returns True if error is a NotFoundError.
 */
export function isNotFoundError(error: unknown): error is NotFoundError
````

## File: src/domain/activities/service.ts
````typescript
/**
 * @fileoverview Activities domain service orchestrating Google Places search,
 * caching, and optional AI/web fallback.
 *
 * Uses Supabase search_activities table as durable cache per SPEC-0030.
 */
⋮----
import { webSearch } from "@ai/tools/server/web-search";
import { NotFoundError } from "@domain/activities/errors";
import type { ActivitySearchResult, ServiceContext } from "@domain/activities/types";
import type { Activity, ActivitySearchParams } from "@schemas/search";
import { activitySearchParamsSchema } from "@schemas/search";
import type { ToolCallOptions } from "ai";
import { hashInputForCache } from "@/lib/cache/hash";
import {
  buildActivitySearchQuery,
  getActivityDetailsFromPlaces,
  searchActivitiesWithPlaces,
} from "@/lib/google/places-activities";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Cache TTL for Google Places results (24 hours).
 */
⋮----
/**
 * Cache TTL for AI fallback results (6 hours).
 */
⋮----
/**
 * Dependencies for the activities service.
 */
export interface ActivitiesServiceDeps {
  /** Supabase client factory. */
  supabase: () => Promise<TypedServerSupabase>;
}
⋮----
/** Supabase client factory. */
⋮----
/**
 * Activities service class.
 */
export class ActivitiesService
⋮----
constructor(private readonly deps: ActivitiesServiceDeps)
⋮----
/**
   * Computes a normalized query hash for cache lookups.
   *
   * @param params - Activity search parameters.
   * @returns Normalized hash string.
   */
private computeQueryHash(params: ActivitySearchParams): string
⋮----
// Normalize params for consistent hashing
⋮----
/**
   * Searches for activities with caching and optional AI fallback.
   *
   * @param params - Activity search parameters.
   * @param ctx - Service context (userId, locale, ip, etc.).
   * @returns Activity search result with metadata.
   */
async search(
    params: ActivitySearchParams,
    ctx?: ServiceContext
): Promise<ActivitySearchResult>
⋮----
// Check Supabase cache (authenticated users only)
// Note: Database column names use snake_case (user_id, query_hash, activity_type, expires_at, created_at)
⋮----
// Perform Google Places search
⋮----
// Heuristic: trigger AI fallback if zero or very few results
⋮----
// Call webSearch tool server-side
⋮----
// Handle both direct result and async iterable
⋮----
// Normalize web search results into Activity[] (best-effort)
⋮----
// Persist fallback results separately with shorter TTL (authenticated users only)
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// Continue without caching - fallback results still returned
⋮----
// Continue with Places results only
⋮----
// Persist to Supabase cache (authenticated users only)
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// Continue without caching - results still returned
⋮----
/**
   * Retrieves detailed activity information by Place ID.
   *
   * @param placeId - Google Place ID.
   * @param ctx - Service context.
   * @returns Activity object with full details.
   */
async details(placeId: string, ctx?: ServiceContext): Promise<Activity>
⋮----
// Check cache for details (could be in search results)
⋮----
// Try to find in recent search results (authenticated users only)
// Note: Database column names use snake_case (user_id, expires_at, created_at)
⋮----
// Fetch from Places API
⋮----
/**
   * Simple heuristic to determine if a destination is "popular".
   *
   * Used to decide whether low Places result count should trigger AI fallback.
   * This is a basic implementation; can be enhanced with a whitelist or
   * external data source.
   *
   * @param destination - Destination string.
   * @returns True if destination is considered popular.
   */
private isPopularDestination(destination: string): boolean
⋮----
/**
   * Normalizes web search results into Activity objects (best-effort).
   *
   * Extracts activity-like information from web search snippets and URLs.
   * This is a heuristic mapping and may not always produce high-quality results.
   *
   * @param webResults - Web search results from Firecrawl.
   * @param destination - Destination location.
   * @param date - Optional date string.
   * @returns Array of Activity objects (may be empty if normalization fails).
   */
private normalizeWebResultsToActivities(
    webResults: Array<{
      url: string;
      title?: string;
      snippet?: string;
      publishedAt?: string;
    }>,
    destination: string,
    date?: string
): Activity[]
⋮----
// Skip if no title or snippet
⋮----
// Extract activity type from title/snippet (heuristic)
⋮----
// Default values for AI fallback activities
⋮----
duration: 120, // Default 2 hours
⋮----
price: 2, // Default moderate price
rating: 0, // No rating available
````

## File: src/domain/activities/types.ts
````typescript
/**
 * @fileoverview Type definitions for activities domain.
 *
 * Reuses Zod schemas from @schemas/search.ts to avoid duplication.
 */
⋮----
import type { Activity, ActivitySearchParams } from "@schemas/search";
⋮----
/**
 * Service context for activities operations.
 */
export interface ServiceContext {
  /** User ID for cache lookups and RLS. */
  userId?: string;
  /** Locale for internationalization. */
  locale?: string;
  /** IP address for rate limiting. */
  ip?: string;
  /** Feature flags. */
  featureFlags?: Record<string, boolean>;
}
⋮----
/** User ID for cache lookups and RLS. */
⋮----
/** Locale for internationalization. */
⋮----
/** IP address for rate limiting. */
⋮----
/** Feature flags. */
⋮----
/**
 * Activity search result metadata.
 */
export interface ActivitySearchMetadata {
  /** Total number of activities found. */
  total: number;
  /** Whether results came from cache. */
  cached: boolean;
  /** Primary source of results. */
  primarySource: "googleplaces" | "ai_fallback" | "mixed";
  /** All sources present in results. */
  sources: Array<"googleplaces" | "ai_fallback" | "cached">;
  /** Optional notes for UI/chat (e.g., caveats about AI suggestions). */
  notes?: string[];
}
⋮----
/** Total number of activities found. */
⋮----
/** Whether results came from cache. */
⋮----
/** Primary source of results. */
⋮----
/** All sources present in results. */
⋮----
/** Optional notes for UI/chat (e.g., caveats about AI suggestions). */
⋮----
/**
 * Activity search result.
 */
export interface ActivitySearchResult {
  /** Array of activities. */
  activities: Activity[];
  /** Search metadata. */
  metadata: ActivitySearchMetadata;
}
⋮----
/** Array of activities. */
⋮----
/** Search metadata. */
````

## File: src/domain/amadeus/amadeus.d.ts
````typescript
/**
 * @fileoverview TypeScript declarations for the amadeus npm package.
 *
 * The amadeus package does not include TypeScript definitions, so we provide
 * minimal type declarations based on the actual API usage patterns.
 *
 * Note: API response validation is handled separately via Zod schemas in
 * `schemas.ts`. This declaration file only provides types for the SDK client
 * methods themselves.
 */
⋮----
/** Configuration for the Amadeus client. */
interface AmadeusConfig {
    clientId: string;
    clientSecret: string;
    hostname?: string;
  }
⋮----
/** Response from the Amadeus API. */
interface AmadeusResponse<T = unknown> {
    data?: T;
    result?: T;
    [key: string]: unknown;
  }
⋮----
/** Amadeus client interface. */
interface AmadeusClient {
    referenceData: {
      locations: {
        hotels: {
          byGeocode: {
            get(params: {
              latitude: number;
              longitude: number;
              radius?: number;
              radiusUnit?: string;
            }): Promise<AmadeusResponse>;
          };
        };
      };
    };
    shopping: {
      hotelOffersSearch: {
        get(params: {
          adults: number;
          checkInDate: string;
          checkOutDate: string;
          currency?: string;
          hotelIds: string;
          includeClosed?: boolean;
        }): Promise<AmadeusResponse>;
      };
    };
    booking: {
      hotelBookings: {
        post(payload: string): Promise<AmadeusResponse>;
      };
    };
  }
⋮----
get(params: {
              latitude: number;
              longitude: number;
              radius?: number;
              radiusUnit?: string;
            }): Promise<AmadeusResponse>;
⋮----
get(params: {
          adults: number;
          checkInDate: string;
          checkOutDate: string;
          currency?: string;
          hotelIds: string;
          includeClosed?: boolean;
        }): Promise<AmadeusResponse>;
⋮----
post(payload: string): Promise<AmadeusResponse>;
⋮----
/** Amadeus client class. */
class Amadeus implements AmadeusClient
⋮----
constructor(config: AmadeusConfig);
⋮----
/** Export the Amadeus client class. */
````

## File: src/domain/amadeus/chain-codes.ts
````typescript
/**
 * @fileoverview Hotel chain code mappings from Amadeus to brand names and categories.
 *
 * Amadeus uses 2-character chain codes to identify hotel brands.
 * This mapping enables UI display of brand names and automatic category classification.
 *
 * @see https://amadeus.com/en/resources/amadeus-property-codes
 */
⋮----
/** Hotel category classification */
export type HotelCategory = "hotel" | "resort" | "boutique" | "apartment" | "villa";
⋮----
/** Hotel tier classification */
export type HotelTier = "budget" | "midscale" | "upscale" | "luxury";
⋮----
/** Chain info including brand name and category */
export interface ChainInfo {
  brand: string;
  category: HotelCategory;
  tier: HotelTier;
}
⋮----
/**
 * Create chain info helper.
 */
function chain(brand: string, category: HotelCategory, tier: HotelTier): ChainInfo
⋮----
/**
 * Amadeus chain code to brand info mapping.
 * Uses Map for O(1) lookup and to avoid naming convention issues with uppercase keys.
 */
⋮----
// Marriott International
⋮----
// Hilton Worldwide
⋮----
// IHG Hotels & Resorts
⋮----
// Hyatt Hotels
⋮----
// Accor
⋮----
// Wyndham Hotels
⋮----
// Best Western
⋮----
// Radisson Hotel Group
⋮----
// Choice Hotels
⋮----
// Independent luxury
⋮----
/**
 * Get chain info from Amadeus chain code.
 *
 * @param chainCode - Amadeus 2-character chain code
 * @returns Chain info with brand name and category, or undefined if not found
 */
export function getChainInfo(chainCode: string | undefined): ChainInfo | undefined
⋮----
/**
 * Get brand name from Amadeus chain code.
 *
 * @param chainCode - Amadeus 2-character chain code
 * @returns Brand name or undefined if not found
 */
export function getBrandName(chainCode: string | undefined): string | undefined
⋮----
/**
 * Get hotel category from Amadeus chain code.
 * Falls back to "hotel" if chain code is unknown.
 *
 * @param chainCode - Amadeus 2-character chain code
 * @returns Hotel category (hotel, resort, boutique, apartment, villa)
 */
export function getCategoryFromChainCode(chainCode: string | undefined): HotelCategory
⋮----
/**
 * Check if a chain is in the luxury tier.
 *
 * @param chainCode - Amadeus 2-character chain code
 * @returns True if the chain is luxury tier
 */
export function isLuxuryChain(chainCode: string | undefined): boolean
````

## File: src/domain/amadeus/client.ts
````typescript
/**
 * @fileoverview Thin wrapper around the official Amadeus Node SDK.
 *
 * Provides lazy singleton construction and typed helper methods for the
 * accommodations workload (hotel geocode search, offers search, booking).
 */
⋮----
import Amadeus from "amadeus";
⋮----
type AmadeusClient = InstanceType<typeof Amadeus>;
⋮----
/**
 * Test-only setter to inject a mock Amadeus client and reset the singleton.
 */
export function setAmadeusClientForTests(client: AmadeusClient | null): void
⋮----
/**
 * Retrieves a required environment variable value.
 *
 * @param name - Environment variable name
 * @returns Environment variable value
 * @throws {Error} When environment variable is missing
 */
function getEnv(name: string): string
⋮----
/**
 * Returns a singleton Amadeus client instance.
 *
 * Initializes the client on first call using AMADEUS_CLIENT_ID,
 * AMADEUS_CLIENT_SECRET, and AMADEUS_ENV environment variables.
 * Subsequent calls return the same instance.
 *
 * @returns Configured Amadeus client instance
 * @throws {Error} When required environment variables are missing
 */
export function getAmadeusClient(): AmadeusClient
⋮----
/**
 * Searches for hotels by geographic coordinates.
 *
 * @param params - Search parameters
 * @param params.latitude - Latitude coordinate (-90 to 90)
 * @param params.longitude - Longitude coordinate (-180 to 180)
 * @param params.radiusKm - Search radius in kilometers (default: 5)
 * @returns Promise resolving to Amadeus API response with hotel data
 */
export function listHotelsByGeocode(params: {
  latitude: number;
  longitude: number;
  radiusKm?: number;
})
⋮----
/**
 * Searches for hotel offers by hotel IDs and stay dates.
 *
 * @param params - Search parameters
 * @param params.hotelIds - Array of Amadeus hotel IDs to search
 * @param params.checkInDate - Check-in date in YYYY-MM-DD format
 * @param params.checkOutDate - Check-out date in YYYY-MM-DD format
 * @param params.adults - Number of adult guests
 * @param params.currency - ISO currency code (default: "USD")
 * @returns Promise resolving to Amadeus API response with hotel offers
 */
export function searchHotelOffers(params: {
  hotelIds: string[];
  checkInDate: string;
  checkOutDate: string;
  adults: number;
  currency?: string;
})
⋮----
/**
 * Books a hotel offer using the provided booking payload.
 *
 * @param payload - Booking payload containing guest details, hotel offer ID, and payment information
 * @returns Promise resolving to Amadeus API response with booking confirmation
 */
export function bookHotelOffer(payload: Record<string, unknown>)
````

## File: src/domain/amadeus/mappers.ts
````typescript
/**
 * @fileoverview Mapping functions from Amadeus SDK responses to TripSage accommodation domain structures.
 */
⋮----
import type { AccommodationSearchResult } from "@schemas/accommodations";
import type { AmadeusHotel, AmadeusHotelOffer } from "./schemas";
⋮----
/**
 * Extract cancellation policy info from Amadeus policies object.
 */
function extractCancellationPolicy(policies: Record<string, unknown> | undefined):
  | {
      deadline?: string;
      description?: string;
      partialRefundable?: boolean;
      refundable?: boolean;
    }
  | undefined {
  if (!policies || typeof policies !== "object") return undefined;
⋮----
/**
 * Sum taxes from Amadeus price taxes array.
 */
function projectTaxes(
  taxes:
    | Array<{ amount: string; code?: string; currency?: string; included?: boolean }>
    | undefined
): Array<
⋮----
/**
 * Map Amadeus hotels and offers to TripSage accommodation listings.
 *
 * @param hotels - Amadeus hotels.
 * @param offersByHotel - Amadeus offers by hotel.
 * @param meta - Meta data.
 * @returns TripSage accommodation listings.
 */
export function mapHotelsToListings(
  hotels: AmadeusHotel[],
  offersByHotel: Record<string, AmadeusHotelOffer[]>,
  meta: Record<string, unknown>
): AccommodationSearchResult["listings"]
⋮----
// Choose most restrictive cancellation policy among offers (refundability false wins)
⋮----
// prefer non-refundable
⋮----
// otherwise earliest deadline is more restrictive
⋮----
/**
 * Collect prices from Amadeus offers.
 *
 * @param offers - Amadeus offers.
 * @returns Prices.
 */
export function collectPricesFromOffers(offers: AmadeusHotelOffer[]): number[]
````

## File: src/domain/amadeus/schemas.ts
````typescript
/**
 * @fileoverview Zod schemas for Amadeus hotel search, offers, and booking responses.
 */
⋮----
import { primitiveSchemas } from "@schemas/registry";
import { z } from "zod";
⋮----
/** Schema for Amadeus address. */
⋮----
/** Schema for Amadeus geo. */
⋮----
/** Schema for Amadeus hotel. */
⋮----
/** Type for Amadeus hotel. */
export type AmadeusHotel = z.infer<typeof amadeusHotelSchema>;
⋮----
/** Schema for Amadeus offer price. */
⋮----
/** Schema for Amadeus hotel offer. */
⋮----
/** Type for Amadeus hotel offer. */
export type AmadeusHotelOffer = z.infer<typeof amadeusHotelOfferSchema>;
⋮----
/** Schema for Amadeus hotel offer container. */
⋮----
/** Type for Amadeus hotel offer container. */
export type AmadeusHotelOfferContainer = z.infer<
  typeof amadeusHotelOfferContainerSchema
>;
⋮----
/** Schema for Amadeus hotel booking. */
⋮----
/** Type for Amadeus hotel booking. */
export type AmadeusHotelBooking = z.infer<typeof amadeusHotelBookingSchema>;
````

## File: src/domain/flights/providers/duffel.ts
````typescript
/**
 * @fileoverview Duffel provider client for flight offer requests.
 */
⋮----
import { type FlightSearchRequest, flightSearchRequestSchema } from "@schemas/flights";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
⋮----
/** The type of the Duffel offer response. */
type DuffelOfferResponse = unknown;
⋮----
/**
 * Get the Duffel API key from the environment variables.
 *
 * @returns The Duffel API key.
 */
function getDuffelKey(): string | undefined
⋮----
/**
 * Convert a camelCase object to a snake_case object.
 *
 * @param value - The object to convert.
 * @returns The converted object.
 */
function toSnakeCase(value: unknown): unknown
⋮----
/**
 * Error thrown when Duffel configuration is missing or invalid.
 */
class DuffelConfigError extends Error
⋮----
constructor(message = "Duffel API key is not configured")
⋮----
/**
 * Execute a Duffel offer request.
 *
 * @param params - The flight search request parameters.
 * @returns The Duffel offer response.
 * @throws an Error with a structured message on HTTP failure.
 */
export async function fetchDuffelOffers(
  params: FlightSearchRequest
): Promise<DuffelOfferResponse>
⋮----
type CamelSlice = {
    origin: string;
    destination: string;
    departureDate: string;
  };
⋮----
// The response from the Duffel API.
````

## File: src/domain/flights/mappers.ts
````typescript
/**
 * @fileoverview Provider mappers for flights.
 * Converts provider payloads to normalized FlightOffer DTOs.
 */
⋮----
import { FLIGHT_OFFER_SCHEMA, type FlightOffer } from "@schemas/flights";
⋮----
/** The type of the Duffel money. */
type DuffelMoney = {
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  total_amount?: string;
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  total_currency?: string;
};
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
/** The type of the Duffel location. */
type DuffelLocation = {
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  iata_code?: string;
  name?: string;
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  city_name?: string;
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  country_name?: string;
  terminal?: string;
};
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
/** The type of the Duffel segment. */
type DuffelSegment = {
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  arriving_at?: string;
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  departing_at?: string;
  destination?: DuffelLocation;
  origin?: DuffelLocation;
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  marketing_carrier?: { iata_code?: string; name?: string; id?: string };
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  operating_carrier?: { iata_code?: string; name?: string; id?: string };
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  marketing_carrier_flight_number?: string;
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  operating_carrier_flight_number?: string;
  distance?: number;
  duration?: string;
};
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
/** The type of the Duffel slice. */
type DuffelSlice = {
  // biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
  cabin_class?: string;
  duration?: string;
  segments?: DuffelSegment[];
};
⋮----
// biome-ignore lint/style/useNamingConvention: external provider payloads use snake_case
⋮----
/** The type of the Duffel offer. */
type DuffelOffer = DuffelMoney & {
  id?: string;
  slices?: DuffelSlice[];
};
⋮----
/**
 * Parse a Duffel ISO-8601 duration (PnDTnHnM) to minutes.
 *
 * @param value - The ISO-8601 duration.
 * @returns The duration in minutes or undefined on parse errors.
 */
function parseIsoDurationToMinutes(value?: string): number | undefined
⋮----
/**
 * Normalize one Duffel offer into the shared FlightOffer shape.
 *
 * @param offer - The Duffel offer.
 * @returns The normalized FlightOffer or null on parse errors.
 */
export function mapDuffelOffer(offer: DuffelOffer): FlightOffer | null
⋮----
/**
 * Normalize Duffel response JSON into a FlightOffer array and resolved currency.
 */
export function mapDuffelOffersList(
  payload: unknown,
  fallbackCurrency: string
):
````

## File: src/domain/flights/service.ts
````typescript
/**
 * @fileoverview Flights service orchestrating provider calls and normalization.
 */
⋮----
import {
  type FlightSearchRequest,
  type FlightSearchResult,
  flightSearchRequestSchema,
  flightSearchResultSchema,
} from "@schemas/flights";
import { mapDuffelOffersList } from "./mappers";
import { fetchDuffelOffers } from "./providers/duffel";
⋮----
/**
 * Search flights via Duffel and return normalized offers.
 *
 * @param params - The flight search request parameters.
 * @returns The flight search result.
 * @throws an Error with a structured message on HTTP failure.
 */
export async function searchFlightsService(
  params: FlightSearchRequest
): Promise<FlightSearchResult>
````

## File: src/domain/schemas/shared/media.ts
````typescript
/**
 * @fileoverview Shared media/attachment primitives.
 */
⋮----
import { z } from "zod";
⋮----
export type Attachment = z.infer<typeof ATTACHMENT_SCHEMA>;
````

## File: src/domain/schemas/shared/money.ts
````typescript
/**
 * @fileoverview Shared money/currency primitives.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "../registry";
⋮----
export type CurrencyCode = z.infer<typeof CURRENCY_CODE_SCHEMA>;
export type Price = z.infer<typeof PRICE_SCHEMA>;
````

## File: src/domain/schemas/shared/person.ts
````typescript
/**
 * @fileoverview Shared person/contact primitives (names, email, phone, password).
 */
⋮----
import { z } from "zod";
import { primitiveSchemas, refinedSchemas } from "../registry";
⋮----
export type PersonName = z.infer<typeof NAME_SCHEMA>;
export type EmailAddress = z.infer<typeof EMAIL_SCHEMA>;
export type PhoneNumber = z.infer<typeof PHONE_SCHEMA>;
````

## File: src/domain/schemas/shared/time.ts
````typescript
/**
 * @fileoverview Shared time/date primitives for reuse across domains.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "../registry";
⋮----
export type IsoDateString = z.infer<typeof ISO_DATE_STRING>;
export type IsoDateTimeString = z.infer<typeof ISO_DATETIME_STRING>;
````

## File: src/domain/schemas/ui/error-boundary.ts
````typescript
/**
 * @fileoverview Error boundary component and loading state schemas (UI only).
 */
⋮----
import { z } from "zod";
⋮----
export type ErrorBoundaryPropsType = z.infer<typeof errorBoundarySchema>;
⋮----
export type ErrorState = z.infer<typeof errorStateSchema>;
⋮----
export type GlobalErrorProps = z.infer<typeof globalErrorPropsSchema>;
⋮----
export type RouteErrorProps = z.infer<typeof routeErrorPropsSchema>;
⋮----
export type ErrorLoadingState = z.infer<typeof errorLoadingStateSchema>;
⋮----
export type ErrorSkeletonProps = z.infer<typeof errorSkeletonPropsSchema>;
````

## File: src/domain/schemas/ui/loading.ts
````typescript
/**
 * @fileoverview Loading states and skeleton UI props schemas (UI only).
 */
⋮----
import { z } from "zod";
⋮----
export type LoadingState = z.infer<typeof loadingStateSchema>;
⋮----
export type SkeletonProps = z.infer<typeof skeletonPropsSchema>;
````

## File: src/domain/schemas/accommodations.ts
````typescript
/**
 * @fileoverview Accommodation tool schemas with validation.
 * Includes search parameters, results, details, availability checks, and booking schemas for accommodation tools.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for accommodation management
⋮----
/**
 * Zod schema for supported property types in accommodation search.
 * Defines available accommodation categories.
 */
⋮----
/** TypeScript type for property types. */
export type PropertyType = z.infer<typeof propertyTypeSchema>;
⋮----
/**
 * Zod schema for accommodation search sort criteria.
 * Defines available sorting options for search results.
 */
⋮----
/** TypeScript type for sort criteria. */
export type SortBy = z.infer<typeof sortBySchema>;
⋮----
/**
 * Zod schema for accommodation search sort order directions.
 * Defines ascending and descending sort options.
 */
⋮----
/** TypeScript type for sort order directions. */
export type SortOrder = z.infer<typeof sortOrderSchema>;
⋮----
// ===== TOOL INPUT SCHEMAS =====
// Schemas for accommodation tool input validation and processing
⋮----
/**
 * Zod schema for accommodation search input parameters.
 * Validates all search criteria including dates, location, guest counts, and filters.
 * Used for AI tool input validation.
 */
⋮----
semanticQuery: z.string().optional(), // For RAG semantic search
⋮----
/** TypeScript type for accommodation search parameters. */
export type AccommodationSearchParams = z.infer<typeof accommodationSearchInputSchema>;
⋮----
/**
 * Zod schema for individual accommodation listing structure.
 * Represents a single listing from search results, including provider data
 * and Google Places enrichment (place, placeDetails).
 */
⋮----
/** TypeScript type for accommodation listing. */
export type AccommodationListing = z.infer<typeof accommodationListingSchema>;
⋮----
/**
 * Zod schema for accommodation search result data.
 * Contains search results, pricing info, and metadata from providers.
 */
⋮----
/** TypeScript type for accommodation search results. */
export type AccommodationSearchResult = z.infer<typeof accommodationSearchOutputSchema>;
⋮----
/**
 * Zod schema for accommodation details request parameters.
 * Used to fetch detailed information about a specific listing.
 */
⋮----
/** TypeScript type for accommodation details parameters. */
export type AccommodationDetailsParams = z.infer<
  typeof accommodationDetailsInputSchema
>;
⋮----
/**
 * Zod schema for accommodation details output parameters.
 * Contains detailed listing information from providers.
 */
⋮----
/** TypeScript type for accommodation details results. */
export type AccommodationDetailsResult = z.infer<
  typeof accommodationDetailsOutputSchema
>;
⋮----
/**
 * Zod schema for accommodation availability check input parameters.
 * Validates parameters for checking property availability and pricing.
 */
⋮----
/** TypeScript type for accommodation availability check parameters. */
export type AccommodationCheckAvailabilityParams = z.infer<
  typeof accommodationCheckAvailabilityInputSchema
>;
⋮----
/**
 * Zod schema for accommodation availability check output parameters.
 * Contains booking token, pricing breakdown, and expiration information.
 */
⋮----
expiresAt: primitiveSchemas.isoDateTime, // ISO 8601 timestamp
⋮----
/** TypeScript type for accommodation availability check results. */
export type AccommodationCheckAvailabilityResult = z.infer<
  typeof accommodationCheckAvailabilityOutputSchema
>;
⋮----
/**
 * Zod schema for accommodation booking input parameters.
 * Validates booking parameters including guest information, dates, and payment details.
 */
⋮----
amount: z.number().positive(), // Total amount in cents from checkAvailability
bookingToken: z.string().min(1), // From checkAvailability
⋮----
currency: primitiveSchemas.isoCurrency, // Currency code from checkAvailability
⋮----
listingId: z.string().min(1), // Property ID for reference
paymentMethodId: z.string().min(1), // Stripe payment method ID
⋮----
/** TypeScript type for accommodation booking requests. */
export type AccommodationBookingRequest = z.infer<
  typeof accommodationBookingInputSchema
>;
⋮----
/**
 * Zod schema for accommodation booking output parameters.
 * Contains booking confirmation details including booking ID, status, and payment information.
 */
⋮----
providerBookingId: z.string().optional(), // Provider booking confirmation ID
⋮----
stripePaymentIntentId: z.string().optional(), // Stripe payment intent ID
⋮----
/** TypeScript type for accommodation booking results. */
export type AccommodationBookingResult = z.infer<
  typeof accommodationBookingOutputSchema
>;
````

## File: src/domain/schemas/agent-status.ts
````typescript
/**
 * @fileoverview Agent status tracking and validation schemas.
 * Includes agent entities, tasks, workflows, metrics, and real-time update schemas.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
⋮----
// Core business logic schemas for agent management
⋮----
/**
 * Zod schema for agent status type enumeration.
 * Defines possible states for agent execution lifecycle.
 */
⋮----
/** TypeScript type for agent status types. */
export type AgentStatusType = z.infer<typeof agentStatusTypeSchema>;
⋮----
/**
 * Zod schema for task status enumeration.
 * Defines possible states for agent task execution.
 */
⋮----
/** TypeScript type for task status. */
export type TaskStatus = z.infer<typeof taskStatusSchema>;
⋮----
/**
 * Zod schema for session status enumeration.
 * Defines possible states for agent sessions.
 */
⋮----
/** TypeScript type for session status. */
export type SessionStatus = z.infer<typeof sessionStatusSchema>;
⋮----
/**
 * Zod schema for agent task entities.
 * Validates task details including status, progress, and error information.
 */
⋮----
/** TypeScript type for agent tasks. */
export type AgentTask = z.infer<typeof agentTaskSchema>;
⋮----
/**
 * Zod schema for agent entities.
 * Validates agent configuration, status, and associated tasks.
 */
⋮----
/** TypeScript type for agents. */
export type Agent = z.infer<typeof agentSchema>;
⋮----
/**
 * Zod schema for agent activity records.
 * Validates activity logs with timestamps and metadata.
 */
⋮----
/** TypeScript type for agent activities. */
export type AgentActivity = z.infer<typeof agentActivitySchema>;
⋮----
/**
 * Zod schema for resource usage metrics.
 * Tracks CPU, memory, and network usage for agents.
 */
⋮----
/** TypeScript type for resource usage. */
export type ResourceUsage = z.infer<typeof resourceUsageSchema>;
⋮----
/**
 * Zod schema for agent session entities.
 * Groups agents, activities, and resource usage for a session.
 */
⋮----
/** TypeScript type for agent sessions. */
export type AgentSession = z.infer<typeof agentSessionSchema>;
⋮----
/**
 * Zod schema for workflow connections between agents.
 * Defines conditional connections in agent workflows.
 */
⋮----
/** TypeScript type for workflow connections. */
export type WorkflowConnection = z.infer<typeof workflowConnectionSchema>;
⋮----
/**
 * Zod schema for agent workflow entities.
 * Validates workflow configuration including agents and connections.
 */
⋮----
/** TypeScript type for agent workflows. */
export type AgentWorkflowEntity = z.infer<typeof agentWorkflowEntitySchema>;
⋮----
/**
 * Zod schema for agent runtime configuration.
 * Validates runtime settings including concurrency limits and timeouts.
 */
⋮----
timeoutMs: z.number().int().positive().max(300000), // 5 minutes max
⋮----
/** TypeScript type for agent runtime configuration. */
export type AgentRuntimeConfig = z.infer<typeof agentRuntimeConfigSchema>;
⋮----
/**
 * Zod schema for agent performance metrics.
 * Tracks execution times, success rates, and task completion statistics.
 */
⋮----
/** TypeScript type for agent metrics. */
export type AgentMetrics = z.infer<typeof agentMetricsSchema>;
⋮----
// ===== STATE SCHEMAS =====
// Schemas for client-side state management
⋮----
/**
 * Zod schema for agent state management in Zustand stores.
 * Organizes agents, sessions, workflows, and metrics for UI state.
 */
⋮----
/** TypeScript type for agent state. */
export type AgentState = z.infer<typeof agentStateSchema>;
⋮----
// ===== API SCHEMAS =====
// Request/response schemas for agent API endpoints
⋮----
/**
 * API request schema for creating agent tasks.
 * Validates task parameters including priority and metadata.
 */
⋮----
/** TypeScript type for agent task creation requests. */
export type CreateAgentTaskRequest = z.infer<typeof createAgentTaskRequestSchema>;
⋮----
/**
 * API request schema for updating existing agent tasks.
 * Allows partial updates of task properties.
 */
⋮----
/** TypeScript type for agent task update requests. */
export type UpdateAgentTaskRequest = z.infer<typeof updateAgentTaskRequestSchema>;
⋮----
/**
 * API request schema for creating new agents.
 * Validates agent configuration including type, name, and runtime settings.
 */
⋮----
/** TypeScript type for agent creation requests. */
export type CreateAgentRequest = z.infer<typeof createAgentRequestSchema>;
⋮----
/**
 * API request schema for updating existing agents.
 * Allows partial updates of agent properties.
 */
⋮----
/** TypeScript type for agent update requests. */
export type UpdateAgentRequest = z.infer<typeof updateAgentRequestSchema>;
⋮----
/**
 * API request schema for creating agent workflows.
 * Validates workflow configuration including agents and connections.
 */
⋮----
/** TypeScript type for workflow creation requests. */
export type CreateWorkflowRequest = z.infer<typeof createWorkflowRequestSchema>;
⋮----
/**
 * API request schema for updating existing workflows.
 * Allows partial updates of workflow properties.
 */
⋮----
/** TypeScript type for workflow update requests. */
export type UpdateWorkflowRequest = z.infer<typeof updateWorkflowRequestSchema>;
⋮----
// ===== REALTIME SCHEMAS =====
// WebSocket message schemas for real-time updates
⋮----
/**
 * Zod schema for agent status update WebSocket messages.
 * Broadcasts agent status changes in real-time.
 */
⋮----
/** TypeScript type for agent status updates. */
export type AgentStatusUpdate = z.infer<typeof agentStatusUpdateSchema>;
⋮----
/**
 * Zod schema for task status update WebSocket messages.
 * Broadcasts task status changes in real-time.
 */
⋮----
/** TypeScript type for task status updates. */
export type TaskStatusUpdate = z.infer<typeof taskStatusUpdateSchema>;
⋮----
/**
 * Zod schema for resource usage update WebSocket messages.
 * Broadcasts resource usage metrics in real-time.
 */
⋮----
/** TypeScript type for resource usage updates. */
export type ResourceUsageUpdate = z.infer<typeof resourceUsageUpdateSchema>;
⋮----
/**
 * Zod schema for mutually exclusive agent WebSocket message types.
 * Exactly one of: status update, task update, or resource usage update.
 * Uses z.xor() to enforce mutual exclusivity (Zod v4.2.0+).
 */
⋮----
/** TypeScript type for agent WebSocket messages. */
export type AgentWebSocketMessage = z.infer<typeof agentWebSocketMessageSchema>;
⋮----
// ===== FORM SCHEMAS =====
// UI form validation schemas with user-friendly error messages
⋮----
/**
 * Form schema for creating and editing agents.
 * Includes validation for agent configuration and runtime settings.
 */
⋮----
/** TypeScript type for agent form data. */
export type AgentFormData = z.infer<typeof agentFormSchema>;
⋮----
/**
 * Form schema for creating and editing agent tasks.
 * Includes validation for task details and priority.
 */
⋮----
/** TypeScript type for task form data. */
export type TaskFormData = z.infer<typeof taskFormSchema>;
⋮----
/**
 * Form schema for creating and editing agent workflows.
 * Includes validation for workflow configuration and connections.
 */
⋮----
/** TypeScript type for workflow form data. */
export type WorkflowFormData = z.infer<typeof workflowFormSchema>;
⋮----
// ===== UTILITY FUNCTIONS =====
// Validation helpers and business logic functions
⋮----
/**
 * Validates agent data from external sources.
 * Performs comprehensive validation of agent entities.
 *
 * @param data - Raw agent data to validate
 * @returns Parsed and validated agent data
 * @throws {ZodError} When validation fails with detailed error information
 */
export const validateAgentData = (data: unknown): Agent =>
⋮----
/**
 * Validates agent task data from external sources.
 * Ensures task details meet business requirements.
 *
 * @param data - Raw task data to validate
 * @returns Parsed and validated task data
 * @throws {ZodError} When validation fails with detailed error information
 */
export const validateAgentTask = (data: unknown): AgentTask =>
⋮----
/**
 * Validates workflow data from external sources.
 * Ensures workflow configuration is valid.
 *
 * @param data - Raw workflow data to validate
 * @returns Parsed and validated workflow data
 * @throws {ZodError} When validation fails with detailed error information
 */
export const validateWorkflow = (data: unknown): AgentWorkflowEntity =>
⋮----
/**
 * Safely validates agent data with error handling.
 *
 * @param data - Raw agent data to validate
 * @returns Validation result with success/error information
 */
export const safeValidateAgent = (data: unknown) =>
⋮----
/**
 * Safely validates task data with error handling.
 *
 * @param data - Raw task data to validate
 * @returns Validation result with success/error information
 */
export const safeValidateTask = (data: unknown) =>
⋮----
/**
 * Safely validates workflow data with error handling.
 *
 * @param data - Raw workflow data to validate
 * @returns Validation result with success/error information
 */
export const safeValidateWorkflow = (data: unknown) =>
⋮----
/**
 * Calculates agent success rate from metrics.
 * Computes the ratio of completed tasks to total tasks.
 *
 * @param metrics - Agent metrics containing task completion data
 * @returns Success rate as a number between 0 and 1
 */
export const calculateSuccessRate = (metrics: AgentMetrics): number =>
⋮----
/**
 * Checks if an agent is currently active.
 * Determines if agent is in an active execution state.
 *
 * @param agent - Agent entity to check
 * @returns True if agent is active, false otherwise
 */
export const isAgentActive = (agent: Agent): boolean =>
⋮----
/**
 * Gets the current load (active tasks) for an agent.
 * Counts tasks that are currently in progress.
 *
 * @param agent - Agent entity to analyze
 * @returns Number of active tasks
 */
export const getAgentLoad = (agent: Agent): number =>
⋮----
/**
 * Determines if an agent can accept a new task.
 * Checks agent status and concurrency limits.
 *
 * @param agent - Agent entity to check
 * @param config - Optional runtime configuration for concurrency limits
 * @returns True if agent can accept new tasks, false otherwise
 */
export const canAcceptNewTask = (
  agent: Agent,
  config?: AgentRuntimeConfig
): boolean =>
````

## File: src/domain/schemas/agents.ts
````typescript
/**
 * @fileoverview Canonical Zod v4 schemas for Agent workflows (single source of truth).
 *
 * Defines request/response schemas for destination research, itinerary planning,
 * flight search, accommodation search, budget planning, memory updates, and
 * router classification workflows.
 */
⋮----
import { z } from "zod";
import {
  type FlightSearchRequest,
  type FlightSearchResult,
  flightSearchRequestSchema,
  flightSearchResultSchema,
} from "./flights";
⋮----
/** Zod schema for supported agent workflow types (routing-level kinds). */
⋮----
/** TypeScript type for agent workflow kinds. */
export type AgentWorkflowKind = z.infer<typeof agentWorkflowKindSchema>;
⋮----
/** Zod schema for source citations in agent research results. */
⋮----
/** TypeScript type for agent source citations. */
export type AgentSource = z.infer<typeof agentSourceSchema>;
⋮----
// Destination item schema
⋮----
/** Zod schema for destination research requests. */
⋮----
/** Zod schema for destination research results. */
⋮----
/** TypeScript type for destination research requests. */
export type DestinationResearchRequest = z.infer<
  typeof destinationResearchRequestSchema
>;
⋮----
/** TypeScript type for destination research results. */
export type DestinationResearchResult = z.infer<typeof destinationResearchResultSchema>;
⋮----
// Itinerary planning
⋮----
/** Zod schema for itinerary planning requests. */
⋮----
/** Zod schema for itinerary planning results. */
⋮----
/** TypeScript type for itinerary planning requests. */
export type ItineraryPlanRequest = z.infer<typeof itineraryPlanRequestSchema>;
⋮----
/** TypeScript type for itinerary planning results. */
export type ItineraryPlanResult = z.infer<typeof itineraryPlanResultSchema>;
⋮----
// Flight search (delegated to domain/schemas/flights)
⋮----
// Accommodation search
⋮----
/** Zod schema for accommodation search requests. */
⋮----
/** Zod schema for accommodation search results. */
⋮----
/** TypeScript type for accommodation search requests. */
export type AccommodationSearchRequest = z.infer<
  typeof accommodationSearchRequestSchema
>;
⋮----
/** TypeScript type for accommodation search results. */
export type AccommodationSearchResult = z.infer<typeof accommodationSearchResultSchema>;
⋮----
/** Zod schema for budget planning requests. */
⋮----
/** Zod schema for budget planning results. */
⋮----
/** TypeScript type for budget planning requests. */
export type BudgetPlanRequest = z.infer<typeof budgetPlanRequestSchema>;
⋮----
/** TypeScript type for budget planning results. */
export type BudgetPlanResult = z.infer<typeof budgetPlanResultSchema>;
⋮----
/** Zod schema for memory record entries. */
⋮----
/** TypeScript type for memory records. */
export type MemoryRecord = z.infer<typeof memoryRecordSchema>;
⋮----
/** Zod schema for memory update requests. */
⋮----
/** TypeScript type for memory update requests. */
export type MemoryUpdateRequest = z.infer<typeof memoryUpdateRequestSchema>;
⋮----
/** Zod schema for router classification requests. */
⋮----
/** TypeScript type for router requests. */
export type RouterRequest = z.infer<typeof routerRequestSchema>;
⋮----
/** Zod schema for router workflow classification results. */
⋮----
/** TypeScript type for router classifications. */
export type RouterClassification = z.infer<typeof routerClassificationSchema>;
⋮----
/** Collection of all agent workflow schemas. */
⋮----
/** TypeScript type for the agent schemas collection. */
export type AgentSchemas = typeof agentSchemas;
````

## File: src/domain/schemas/api.ts
````typescript
/**
 * @fileoverview API request/response validation schemas.
 * Includes authentication, user profiles, chat, trips, API keys, Google Maps/Places, and WebSocket schemas.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
import { apiResponseSchema, paginatedResponseSchema } from "./validation";
⋮----
/** TypeScript type for generic API responses. */
export type ApiResponse<T = unknown> = z.infer<
  ReturnType<typeof apiResponseSchema<z.ZodSchema<T>>>
>;
⋮----
/** TypeScript type for paginated API responses. */
export type PaginatedResponse<T = unknown> = z.infer<
  ReturnType<typeof paginatedResponseSchema<z.ZodSchema<T>>>
>;
⋮----
// ===== AUTHENTICATION API SCHEMAS =====
// Request/response schemas for authentication endpoints
⋮----
/**
 * Zod schema for login API requests.
 * Validates email and password credentials.
 */
⋮----
/** TypeScript type for login requests. */
export type LoginRequest = z.infer<typeof loginRequestSchema>;
⋮----
/**
 * Zod schema for user registration API requests.
 * Validates registration data including terms acceptance and password strength.
 */
⋮----
/** TypeScript type for registration requests. */
export type RegisterRequest = z.infer<typeof registerRequestSchema>;
⋮----
/**
 * Zod schema for authentication API responses.
 * Includes access token, refresh token, and user information.
 */
⋮----
/** TypeScript type for authentication responses. */
export type AuthResponse = z.infer<typeof authResponseSchema>;
⋮----
/**
 * Zod schema for refresh token API requests.
 * Validates refresh token for token renewal.
 */
⋮----
/** TypeScript type for refresh token requests. */
export type RefreshTokenRequest = z.infer<typeof refreshTokenRequestSchema>;
⋮----
/**
 * Zod schema for password reset API requests.
 * Validates email for password reset initiation.
 */
⋮----
/** TypeScript type for password reset requests. */
export type ResetPasswordRequest = z.infer<typeof resetPasswordRequestSchema>;
⋮----
/**
 * Zod schema for password reset confirmation API requests.
 * Validates new password and reset token.
 */
⋮----
/** TypeScript type for password reset confirmation requests. */
export type ConfirmResetPasswordRequest = z.infer<
  typeof confirmResetPasswordRequestSchema
>;
⋮----
// ===== USER PROFILE API SCHEMAS =====
// Request/response schemas for user profile endpoints
⋮----
/**
 * Zod schema for user profile data.
 * Validates complete user profile including preferences and settings.
 */
⋮----
/** TypeScript type for user profiles. */
export type UserProfile = z.infer<typeof userProfileSchema>;
⋮----
/**
 * Zod schema for updating user profile API requests.
 * Allows partial updates of profile properties.
 */
⋮----
/** TypeScript type for user profile update requests. */
export type UpdateUserProfileRequest = z.infer<typeof updateUserProfileRequestSchema>;
⋮----
// ===== CHAT API SCHEMAS =====
// Request/response schemas for chat endpoints
⋮----
/**
 * Zod schema for chat message entities.
 * Validates message content, attachments, and metadata.
 */
⋮----
/** TypeScript type for chat messages. */
export type ChatMessage = z.infer<typeof chatMessageSchema>;
⋮----
/**
 * Zod schema for conversation entities.
 * Validates conversation structure including messages and metadata.
 */
⋮----
/** TypeScript type for conversations. */
export type Conversation = z.infer<typeof conversationSchema>;
⋮----
/**
 * Zod schema for sending message API requests.
 * Validates message content, attachments, and context.
 */
⋮----
data: z.string().min(1), // Base64 encoded data
⋮----
/** TypeScript type for send message requests. */
export type SendMessageRequest = z.infer<typeof sendMessageRequestSchema>;
⋮----
// ===== TRIP API SCHEMAS =====
// Trip schemas moved to @schemas/trips for consolidation
// Import trip schemas from @schemas/trips instead
⋮----
// ===== API KEY MANAGEMENT SCHEMAS =====
// Request/response schemas for API key endpoints
⋮----
/**
 * Zod schema for API key entities.
 * Validates API key data including service, usage, and rate limits.
 */
⋮----
/** TypeScript type for API keys. */
export type ApiKey = z.infer<typeof apiKeySchema>;
⋮----
/**
 * Zod schema for creating API key API requests.
 * Validates API key creation parameters.
 */
⋮----
/** TypeScript type for API key creation requests. */
export type CreateApiKeyRequest = z.infer<typeof createApiKeyRequestSchema>;
⋮----
/**
 * Zod schema for updating API key API requests.
 * Allows partial updates of API key properties.
 */
⋮----
/** TypeScript type for API key update requests. */
export type UpdateApiKeyRequest = z.infer<typeof updateApiKeyRequestSchema>;
⋮----
/**
 * Zod schema for POST /api/keys request body.
 * Validates service name and API key with length constraints and trimming.
 * Used for BYOK (Bring Your Own Key) provider key storage.
 */
⋮----
// Optional base URL for per-user Gateway. Must be https when provided.
⋮----
/** TypeScript type for POST /api/keys request body. */
export type PostKeyBody = z.infer<typeof postKeyBodySchema>;
⋮----
// ===== GOOGLE MAPS/PLACES API SCHEMAS =====
// Request schemas for Google Maps and Places API endpoints
⋮----
/**
 * Zod schema for POST /api/routes request body.
 * Validates Google Maps Routes API computeRoutes request parameters.
 */
⋮----
/** TypeScript type for compute routes requests. */
export type ComputeRoutesRequest = z.infer<typeof computeRoutesRequestSchema>;
⋮----
/**
 * Zod schema for POST /api/route-matrix request body.
 * Validates Google Maps Routes API computeRouteMatrix request parameters.
 */
⋮----
/** TypeScript type for route matrix requests. */
export type RouteMatrixRequest = z.infer<typeof routeMatrixRequestSchema>;
⋮----
/**
 * Zod schema for POST /api/geocode request body.
 * Validates geocoding request parameters.
 * Uses xor to enforce exactly one geocoding mode:
 * - Forward: address string
 * - Reverse: lat AND lng coordinates
 */
⋮----
/** TypeScript type for geocode requests. */
export type GeocodeRequest = z.infer<typeof geocodeRequestSchema>;
⋮----
/**
 * Zod schema for GET /api/timezone query parameters.
 * Validates timezone lookup request parameters.
 */
⋮----
/** TypeScript type for timezone requests. */
export type TimezoneRequest = z.infer<typeof timezoneRequestSchema>;
⋮----
/**
 * Zod schema for POST /api/places/search request body.
 * Validates Google Places API (New) Text Search request parameters.
 */
⋮----
/** TypeScript type for places search requests. */
export type PlacesSearchRequest = z.infer<typeof placesSearchRequestSchema>;
⋮----
/**
 * Zod schema for GET /api/places/details/[id] query parameters.
 * Validates Google Places API (New) Place Details request parameters.
 */
⋮----
/** TypeScript type for places details requests. */
export type PlacesDetailsRequest = z.infer<typeof placesDetailsRequestSchema>;
⋮----
/**
 * Zod schema for GET /api/places/photo query parameters.
 * Validates Google Places API (New) Photo Media request parameters.
 */
⋮----
/** TypeScript type for places photo requests. */
export type PlacesPhotoRequest = z.infer<typeof placesPhotoRequestSchema>;
⋮----
/**
 * Zod schema for POST /api/places/nearby request body.
 * Validates Google Places API (New) Nearby Search request parameters.
 */
⋮----
/** TypeScript type for places nearby requests. */
export type PlacesNearbyRequest = z.infer<typeof placesNearbyRequestSchema>;
⋮----
// ===== Upstream Google Places API v1 Response Schemas =====
⋮----
/**
 * Zod schema for Google Places API place object.
 * Validates upstream place data from Text Search, Nearby Search, Place Details.
 * Uses looseObject to accept additional fields from Google API.
 */
⋮----
/** TypeScript type for upstream Google Place. */
export type UpstreamPlace = z.infer<typeof upstreamPlaceSchema>;
⋮----
/**
 * Zod schema for Google Places API search response.
 * Validates upstream response from Text Search and Nearby Search endpoints.
 */
⋮----
/** TypeScript type for upstream Places search response. */
export type UpstreamPlacesSearchResponse = z.infer<
  typeof upstreamPlacesSearchResponseSchema
>;
⋮----
// ===== Upstream Google Routes API v2 Response Schemas =====
⋮----
/**
 * Zod schema for Google Routes API route object.
 * Validates upstream route data returned from computeRoutes.
 */
⋮----
/** TypeScript type for upstream Route. */
export type UpstreamRoute = z.infer<typeof upstreamRouteSchema>;
⋮----
/**
 * Zod schema for Google Routes API computeRoutes response.
 * Validates upstream response from computeRoutes endpoint.
 */
⋮----
/** TypeScript type for upstream Routes response. */
export type UpstreamRoutesResponse = z.infer<typeof upstreamRoutesResponseSchema>;
⋮----
/**
 * Zod schema for Google Routes API route matrix entry.
 * Validates upstream matrix entry data returned from computeRouteMatrix.
 * The condition field indicates route availability per Google Routes API v2.
 */
⋮----
/** TypeScript type for upstream Route matrix entry. */
export type UpstreamRouteMatrixEntry = z.infer<typeof upstreamRouteMatrixEntrySchema>;
⋮----
/**
 * Zod schema for Google Routes API computeRouteMatrix response.
 * Validates upstream response from computeRouteMatrix endpoint (array of entries).
 */
⋮----
/** TypeScript type for upstream Route matrix response. */
export type UpstreamRouteMatrixResponse = z.infer<
  typeof upstreamRouteMatrixResponseSchema
>;
⋮----
// ===== Upstream Google Geocoding API Response Schemas =====
⋮----
/**
 * Zod schema for Google Geocoding API result object.
 * Validates upstream geocoding result data.
 */
⋮----
/** TypeScript type for upstream Geocode result. */
export type UpstreamGeocodeResult = z.infer<typeof upstreamGeocodeResultSchema>;
⋮----
/**
 * Zod schema for Google Geocoding API response.
 * Validates upstream response from Geocoding endpoint.
 */
⋮----
/** TypeScript type for upstream Geocode response. */
export type UpstreamGeocodeResponse = z.infer<typeof upstreamGeocodeResponseSchema>;
⋮----
// ===== Upstream Google Timezone API Response Schemas =====
⋮----
/**
 * Zod schema for Google Timezone API response.
 * Validates upstream response from Timezone endpoint.
 * Note: dstOffset, rawOffset, timeZoneId, and timeZoneName are optional
 * because error responses (e.g., ZERO_RESULTS) only include the status field.
 */
⋮----
/** TypeScript type for upstream Timezone response. */
export type UpstreamTimezoneResponse = z.infer<typeof upstreamTimezoneResponseSchema>;
⋮----
/**
 * Zod schema for POST /api/accommodations/personalize request body.
 * Validates hotel personalization request parameters.
 */
⋮----
/**
         * Aggregated user review score normalized to 0–5.
         */
⋮----
/**
         * Official property classification (stars), not derived from user ratings.
         */
⋮----
/** TypeScript type for hotel personalization requests. */
export type HotelPersonalizeRequest = z.infer<typeof hotelPersonalizeRequestSchema>;
⋮----
// ===== ERROR SCHEMAS =====
// Schemas for API error responses
⋮----
/**
 * Zod schema for API error responses.
 * Validates error structure including code, message, and optional details.
 */
⋮----
/** TypeScript type for API errors. */
export type ApiError = z.infer<typeof apiErrorSchema>;
⋮----
/**
 * Zod schema for validation error responses.
 * Validates validation error structure with constraint and field information.
 */
⋮----
/** TypeScript type for validation errors. */
export type ValidationError = z.infer<typeof validationErrorSchema>;
⋮----
// ===== WEBSOCKET SCHEMAS =====
// Schemas for WebSocket message handling
⋮----
/**
 * Zod schema for WebSocket messages.
 * Validates WebSocket message structure including type, data, and error fields.
 */
⋮----
/** TypeScript type for WebSocket messages. */
export type WebSocketMessage = z.infer<typeof websocketMessageSchema>;
⋮----
/**
 * Zod schema for WebSocket subscription requests.
 * Validates subscription parameters including channel and optional filters.
 */
⋮----
/** TypeScript type for WebSocket subscriptions. */
export type WebSocketSubscription = z.infer<typeof websocketSubscriptionSchema>;
⋮----
// ===== UTILITY FUNCTIONS =====
// Validation helpers for API responses
⋮----
/**
 * Validates API response data against a schema.
 * Throws an error with detailed validation messages if validation fails.
 *
 * @param schema - Zod schema to validate against
 * @param data - API response data to validate
 * @returns Validated response data
 * @throws {Error} When validation fails with detailed error information
 */
export const validateApiResponse = <T>(schema: z.ZodSchema<T>, data: unknown): T =>
⋮----
/**
 * Safely validates API response data with error handling.
 * Returns a result object with success/error information instead of throwing.
 *
 * @param schema - Zod schema to validate against
 * @param data - API response data to validate
 * @returns Validation result with success/error information
 */
export const safeValidateApiResponse = <T>(schema: z.ZodSchema<T>, data: unknown) =>
⋮----
// ===== MULTIPART VALIDATION SCHEMAS =====
// Schemas for multipart form data file validation
⋮----
/** Maximum file size constants (in bytes). */
⋮----
/** 50MB - Large attachments */
⋮----
/** 5MB - Profile pictures, small attachments */
⋮----
/** 10MB - Standard file uploads */
⋮----
/** Maximum number of files constants. */
⋮----
/** Large batch upload */
⋮----
/** Single file upload */
⋮----
/** Standard batch upload */
⋮----
/**
 * Zod schema for multipart file validation options.
 * Validates file size limits, count limits, and allowed MIME types.
 */
⋮----
/** Allowed MIME types (optional) */
⋮----
/** Maximum number of files allowed */
⋮----
/** Maximum file size in bytes */
⋮----
/** TypeScript type for multipart validation options. */
export type MultipartValidationOptions = z.infer<
  typeof multipartValidationOptionsSchema
>;
````

## File: src/domain/schemas/attachments.ts
````typescript
/**
 * @fileoverview Attachment schemas for Supabase Storage.
 *
 * Defines Zod v4 schemas for attachment uploads, listings, and responses.
 */
⋮----
import { z } from "zod";
⋮----
// ===== CONSTANTS =====
⋮----
/**
 * Allowed MIME types for attachment uploads.
 *
 * Note: SVG intentionally excluded due to XSS risk (can contain JavaScript).
 */
⋮----
/** Maximum file size in bytes (10MB). */
⋮----
/** Maximum number of files per upload request. */
⋮----
/** Maximum total payload size in bytes (50MB). */
⋮----
// ===== UPLOAD SCHEMAS =====
⋮----
/** Schema for validating upload options (trip/message context). */
⋮----
export type AttachmentUploadOptions = z.infer<typeof attachmentUploadOptionsSchema>;
⋮----
// ===== LIST QUERY SCHEMAS =====
⋮----
/** Schema for attachment listing query parameters. */
⋮----
export type AttachmentListQuery = z.infer<typeof attachmentListQuerySchema>;
⋮----
// ===== RESPONSE SCHEMAS =====
⋮----
/** Schema for a single uploaded file response. */
⋮----
export type UploadedFile = z.infer<typeof uploadedFileSchema>;
⋮----
/** Schema for the upload response payload. */
⋮----
export type UploadResponse = z.infer<typeof uploadResponseSchema>;
⋮----
/** Schema for an attachment file in listings. */
⋮----
export type AttachmentFile = z.infer<typeof attachmentFileSchema>;
⋮----
/** Schema for pagination metadata. */
⋮----
export type Pagination = z.infer<typeof paginationSchema>;
⋮----
/** Schema for the attachment list response. */
⋮----
export type AttachmentListResponse = z.infer<typeof attachmentListResponseSchema>;
⋮----
// ===== HELPER FUNCTIONS =====
⋮----
/**
 * Check if a MIME type is allowed for uploads.
 *
 * @param mimeType - MIME type to check.
 * @returns True if the MIME type is allowed.
 */
export function isAllowedMimeType(mimeType: string): boolean
⋮----
/**
 * Sanitize a filename for safe storage.
 *
 * Removes path components, limits length, and replaces special characters.
 *
 * @param filename - Original filename.
 * @returns Sanitized filename.
 */
export function sanitizeFilename(filename: string): string
⋮----
// Remove path components
⋮----
// Replace special characters with underscores
⋮----
// biome-ignore lint/suspicious/noControlCharactersInRegex: intentional - filter out control chars for security
⋮----
// Limit length (preserve extension)
````

## File: src/domain/schemas/budget.ts
````typescript
/**
 * @fileoverview Budget and expense management schemas with validation.
 * Includes budget allocation, expense tracking, currency conversion, and financial reporting.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for budget and expense management
⋮----
/** Zod schema for expense categories with predefined budget allocation types. */
⋮----
/** TypeScript type for expense categories. */
export type ExpenseCategory = z.infer<typeof expenseCategorySchema>;
⋮----
/** Zod schema for budget category allocations with spending tracking. */
⋮----
remaining: z.number(), // Can be negative if overspent
⋮----
/** TypeScript type for budget categories. */
export type BudgetCategory = z.infer<typeof budgetCategorySchema>;
⋮----
/** Zod schema for expense sharing details between participants. */
⋮----
/** TypeScript type for share details. */
export type ShareDetails = z.infer<typeof shareDetailsSchema>;
⋮----
/**
 * Zod schema for budget data with category allocations and validation.
 * Ensures date ranges are valid and category allocations don't exceed total budget.
 * Used for budget creation, updates, and financial planning.
 */
⋮----
// Validate that category amounts don't exceed total budget
⋮----
/** TypeScript type for budget data. */
export type Budget = z.infer<typeof budgetSchema>;
⋮----
/**
 * Zod schema for expense records with attachment support and sharing.
 * Validates expense details, amounts, and participant sharing arrangements.
 */
⋮----
/** TypeScript type for expense data. */
export type Expense = z.infer<typeof expenseSchema>;
⋮----
/** Zod schema for currency exchange rates with update tracking. */
⋮----
/** TypeScript type for currency rates. */
export type CurrencyRate = z.infer<typeof currencyRateSchema>;
⋮----
// ===== REPORTING SCHEMAS =====
// Schemas for budget analysis and financial reporting
⋮----
/** Zod schema for budget summary with spending analysis and projections. */
⋮----
percentageSpent: z.number().min(0), // Can be over 100%
⋮----
totalRemaining: z.number(), // Can be negative
⋮----
/** TypeScript type for budget summaries. */
export type BudgetSummary = z.infer<typeof budgetSummarySchema>;
⋮----
/** Zod schema for budget alerts with notification thresholds. */
⋮----
/** TypeScript type for budget alerts. */
export type BudgetAlert = z.infer<typeof budgetAlertSchema>;
⋮----
// ===== API SCHEMAS =====
// Request/response schemas for budget API endpoints
⋮----
/**
 * API request schema for creating budgets with category allocations.
 * Validates budget parameters and ensures category amounts don't exceed total.
 */
⋮----
/** TypeScript type for budget creation requests. */
export type CreateBudgetRequest = z.infer<typeof createBudgetRequestSchema>;
⋮----
/**
 * API request schema for updating existing budgets.
 * Allows partial updates while maintaining validation constraints.
 */
⋮----
/** TypeScript type for budget update requests. */
export type UpdateBudgetRequest = z.infer<typeof updateBudgetRequestSchema>;
⋮----
/**
 * API request schema for adding expenses with sharing support.
 * Validates expense details and participant sharing arrangements.
 */
⋮----
/** TypeScript type for expense creation requests. */
export type AddExpenseRequest = z.infer<typeof addExpenseRequestSchema>;
⋮----
/**
 * API request schema for updating existing expenses.
 * Allows partial updates of expense properties.
 */
⋮----
/** TypeScript type for expense update requests. */
export type UpdateExpenseRequest = z.infer<typeof updateExpenseRequestSchema>;
⋮----
/** API request schema for creating budget alerts with notification settings. */
⋮----
/** TypeScript type for budget alert creation requests. */
export type CreateBudgetAlertRequest = z.infer<typeof createBudgetAlertRequestSchema>;
⋮----
// ===== FORM SCHEMAS =====
// UI form validation schemas with user-friendly error messages
⋮----
/**
 * Form schema for creating and editing budgets.
 * Includes user-friendly validation messages and category allocation checks.
 */
⋮----
/** TypeScript type for budget form data. */
export type BudgetFormData = z.infer<typeof budgetFormSchema>;
⋮----
/**
 * Form schema for creating and editing expenses.
 * Includes attachment validation, sharing details, and user-friendly error messages.
 */
⋮----
/** TypeScript type for expense form data. */
export type ExpenseFormData = z.infer<typeof expenseFormSchema>;
⋮----
// ===== STATE SCHEMAS =====
// Schemas for client-side state management
⋮----
/** Zod schema for budget state management in Zustand stores. */
⋮----
/** TypeScript type for budget state. */
export type BudgetState = z.infer<typeof budgetStateSchema>;
⋮----
// ===== UTILITY FUNCTIONS =====
// Validation helpers and business logic functions
⋮----
/**
 * Validates budget data from external sources.
 * Performs comprehensive validation including category allocation checks.
 *
 * @param data - Raw budget data to validate
 * @returns Parsed and validated budget data
 * @throws {ZodError} When validation fails with detailed error information
 *
 * @example
 * ```typescript
 * const rawData = { name: "Trip Budget", totalAmount: 1000 };
 * const budget = validateBudgetData(rawData);
 * ```
 */
export const validateBudgetData = (data: unknown): Budget =>
⋮----
/**
 * Validates expense data from external sources.
 * Ensures expense details meet business requirements.
 *
 * @param data - Raw expense data to validate
 * @returns Parsed and validated expense data
 * @throws {ZodError} When validation fails with detailed error information
 */
export const validateExpenseData = (data: unknown): Expense =>
⋮----
/**
 * Safely validates budget data with error handling.
 *
 * @param data - Raw budget data to validate
 * @returns Validation result with success/error information
 */
export const safeValidateBudget = (data: unknown) =>
⋮----
/**
 * Safely validates expense data with error handling.
 *
 * @param data - Raw expense data to validate
 * @returns Validation result with success/error information
 */
export const safeValidateExpense = (data: unknown) =>
⋮----
/**
 * Calculates comprehensive budget summary including spending analysis and projections.
 * Analyzes spending patterns, calculates daily averages, and provides financial insights.
 *
 * @param budget - Budget to analyze
 * @param expenses - Associated expenses for calculation
 * @returns Comprehensive budget summary with percentages and projections
 *
 * @example
 * ```typescript
 * const summary = calculateBudgetSummary(budget, expenses);
 * if (summary.isOverBudget) {
 *   alert(`Budget exceeded by ${summary.totalRemaining}`);
 * }
 * ```
 */
export const calculateBudgetSummary = (
  budget: Budget,
  expenses: Expense[]
): BudgetSummary =>
⋮----
// Calculate daily averages if dates are available
⋮----
/**
 * Form schema for budget category configuration.
 * Includes visual customization options and allocation validation.
 */
⋮----
/** TypeScript type for budget category form data. */
export type BudgetCategoryFormData = z.infer<typeof budgetCategoryFormSchema>;
````

## File: src/domain/schemas/chat.ts
````typescript
/**
 * @fileoverview Chat messaging and conversation schemas with validation.
 * Includes message structure, tool calls, attachments, and conversation management.
 */
⋮----
import { z } from "zod";
import { AGENT_STATUS_BROADCAST_PAYLOAD_SCHEMA } from "./realtime";
import { primitiveSchemas } from "./registry";
import { ATTACHMENT_SCHEMA } from "./shared/media";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for chat functionality
⋮----
/** Zod schema for message roles in chat conversations (system, user, assistant, tool). */
⋮----
/** TypeScript type for message roles. */
export type MessageRole = z.infer<typeof messageRoleSchema>;
⋮----
/** Zod schema for tool call execution states during conversation flow. */
⋮----
/** TypeScript type for tool call states. */
export type ToolCallState = z.infer<typeof toolCallStateSchema>;
⋮----
/** Zod schema for tool call execution status with lifecycle tracking. */
⋮----
/** TypeScript type for tool call status. */
export type ToolCallStatus = z.infer<typeof toolCallStatusSchema>;
⋮----
/** Zod schema for tool call metadata and execution tracking. */
⋮----
/** TypeScript type for tool calls. */
export type ToolCall = z.infer<typeof toolCallSchema>;
⋮----
/** Zod schema for tool execution results with success/error status. */
⋮----
/** TypeScript type for tool results. */
export type ToolResult = z.infer<typeof toolResultSchema>;
⋮----
/** Zod schema for text content parts within messages. */
⋮----
/** TypeScript type for text parts. */
export type TextPart = z.infer<typeof textPartSchema>;
⋮----
/** Zod schema for discriminated union of message content parts. */
⋮----
/** TypeScript type for message parts. */
export type MessagePart = z.infer<typeof messagePartSchema>;
⋮----
/** Zod schema for file attachments in messages with metadata. */
⋮----
/** TypeScript type for attachments. */
export type Attachment = z.infer<typeof attachmentSchema>;
⋮----
/**
 * Zod schema for chat messages with tool calls, attachments, and metadata.
 * Validates message structure, content requirements, and attachment constraints.
 * Used for both API communication and client-side state management.
 */
⋮----
/** TypeScript type for chat messages. */
export type Message = z.infer<typeof messageSchema>;
⋮----
/**
 * Zod schema for chat session metadata and message history.
 * Manages conversation state, agent status, and temporal tracking.
 */
⋮----
/** TypeScript type for chat sessions. */
export type ChatSession = z.infer<typeof chatSessionSchema>;
⋮----
/** Zod schema for chat store state management with loading states. */
⋮----
/** TypeScript type for chat store state. */
export type ChatStoreState = z.infer<typeof chatStoreStateSchema>;
⋮----
/**
 * Zod schema for conversation messages with agent status and flexible content.
 * Supports both structured message parts and legacy content formats.
 */
⋮----
/** TypeScript type for conversation messages. */
export type ConversationMessage = z.infer<typeof conversationMessageSchema>;
⋮----
/** Zod schema for memory context responses with relevance scoring. */
⋮----
/** TypeScript type for memory context responses. */
export type MemoryContextResponse = z.infer<typeof memoryContextResponseSchema>;
⋮----
// ===== API SCHEMAS =====
// Request/response schemas for chat API endpoints
⋮----
/** Zod schema for chat completion API requests with message arrays. */
⋮----
/** TypeScript type for chat completion requests. */
export type ChatCompletionRequest = z.infer<typeof chatCompletionRequestSchema>;
⋮----
/**
 * Zod schema for creating a chat message in a session.
 * Validates request body for POST /api/chat/sessions/[id]/messages endpoint.
 * Ensures content is a non-empty string and role is a valid optional message role.
 */
⋮----
/** TypeScript type for create message requests. */
export type CreateMessageRequest = z.infer<typeof createMessageRequestSchema>;
⋮----
/** Zod schema for chat completion API responses with choice arrays. */
⋮----
/** TypeScript type for chat completion responses. */
export type ChatCompletionResponse = z.infer<typeof chatCompletionResponseSchema>;
⋮----
/** Zod schema for send message options with AI parameters and attachments. */
⋮----
/** TypeScript type for send message options. */
export type SendMessageOptions = z.infer<typeof sendMessageOptionsSchema>;
⋮----
// ===== FORM SCHEMAS =====
// UI form validation schemas with user-friendly error messages
⋮----
/**
 * Form schema for sending messages with attachment validation.
 * Includes file type, size, and quantity constraints for user experience.
 */
⋮----
.max(50 * 1024 * 1024), // 50MB max
⋮----
/** TypeScript type for send message form data. */
export type SendMessageFormData = z.infer<typeof sendMessageFormSchema>;
⋮----
/**
 * Form schema for creating new chat conversations.
 * Validates conversation title, privacy settings, and participant constraints.
 */
⋮----
/** TypeScript type for conversation creation form data. */
export type CreateConversationFormData = z.infer<typeof createConversationFormSchema>;
````

## File: src/domain/schemas/configuration.ts
````typescript
/**
 * @fileoverview Configuration management schemas with validation.
 * Includes agent configurations, model names, version identifiers, and configuration scopes.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for configuration management
⋮----
/**
 * Zod schema for agent type classifications.
 * Defines available agent types in the system.
 */
⋮----
/** TypeScript type for agent types. */
export type AgentType = z.infer<typeof agentTypeSchema>;
⋮----
/**
 * Zod schema for configuration scope levels.
 * Defines hierarchy of configuration scopes from global to user-specific.
 */
⋮----
/** TypeScript type for configuration scopes. */
export type ConfigurationScope = z.infer<typeof configurationScopeSchema>;
⋮----
/**
 * Zod schema for supported AI model names.
 * Defines available AI models for agent configuration.
 */
⋮----
/** TypeScript type for model names. */
export type ModelName = z.infer<typeof modelNameSchema>;
⋮----
/**
 * Zod schema for version identifiers with validation.
 * Validates version ID format: v{timestamp}_{hash}.
 */
⋮----
/** TypeScript type for version IDs. */
export type VersionId = z.infer<typeof versionIdSchema>;
⋮----
/**
 * Zod schema for agent configuration requests.
 * Validates model parameters and generation settings with business rules.
 */
⋮----
/** TypeScript type for agent config requests. */
export type AgentConfigRequest = z.infer<typeof agentConfigRequestSchema>;
⋮----
/**
 * Zod schema for complete agent configuration records.
 * Validates agent configuration including model, parameters, scope, and timestamps.
 */
⋮----
/** TypeScript type for agent configurations. */
export type AgentConfig = z.infer<typeof configurationAgentConfigSchema>;
````

## File: src/domain/schemas/contact.ts
````typescript
/**
 * @fileoverview Contact and feedback form validation schemas.
 * Includes contact forms, feedback forms, and newsletter subscription schemas.
 */
⋮----
import { z } from "zod";
import { EMAIL_SCHEMA, NAME_SCHEMA } from "./shared/person";
⋮----
// ===== FORM SCHEMAS =====
// UI form validation schemas with user-friendly error messages
⋮----
/**
 * Zod schema for contact form validation.
 * Validates contact form data including category, message, and urgency.
 */
⋮----
/** TypeScript type for contact form data. */
export type ContactFormData = z.infer<typeof contactFormSchema>;
⋮----
/**
 * Zod schema for feedback form validation.
 * Validates feedback data including rating, category, and description.
 */
⋮----
/** TypeScript type for feedback form data. */
export type FeedbackFormData = z.infer<typeof feedbackFormSchema>;
⋮----
/**
 * Zod schema for newsletter subscription form validation.
 * Validates subscription preferences including frequency and content preferences.
 */
⋮----
/** TypeScript type for newsletter subscription form data. */
export type NewsletterSubscriptionFormData = z.infer<
  typeof newsletterSubscriptionFormSchema
>;
````

## File: src/domain/schemas/currency.ts
````typescript
/**
 * @fileoverview Currency management and exchange rate schemas.
 * Includes currency codes, metadata, exchange rates, conversion results, and store state.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for currency management
⋮----
/**
 * Zod schema for ISO 4217 currency codes (3-letter uppercase).
 * Validates currency code format and structure.
 */
⋮----
/** TypeScript type for currency codes. */
export type CurrencyCode = z.infer<typeof CURRENCY_CODE_SCHEMA>;
⋮----
/**
 * Zod schema for currency metadata and display information.
 * Validates currency details including code, name, symbol, and decimal places.
 */
⋮----
/** TypeScript type for currency metadata. */
export type Currency = z.infer<typeof CURRENCY_SCHEMA>;
⋮----
/**
 * Zod schema for currency exchange rate data.
 * Validates exchange rate information including base currency, target currency, rate, and timestamp.
 */
⋮----
/** TypeScript type for exchange rates. */
export type ExchangeRate = z.infer<typeof EXCHANGE_RATE_SCHEMA>;
⋮----
/**
 * Zod schema for currency conversion pairs.
 * Validates currency pair structure for conversion operations.
 */
⋮----
/** TypeScript type for currency pairs. */
export type CurrencyPair = z.infer<typeof CURRENCY_PAIR_SCHEMA>;
⋮----
/**
 * Zod schema for currency conversion results.
 * Validates conversion result including amounts, currencies, rate, and timestamp.
 */
⋮----
/** TypeScript type for conversion results. */
export type ConversionResult = z.infer<typeof CONVERSION_RESULT_SCHEMA>;
⋮----
// ===== STATE SCHEMAS =====
// Schemas for client-side state management
⋮----
/**
 * Zod schema for currency store state management.
 * Organizes currencies, exchange rates, favorites, and base currency for UI state.
 */
⋮----
/** TypeScript type for currency store state. */
export type CurrencyState = z.infer<typeof CURRENCY_STATE_SCHEMA>;
⋮----
// ===== API SCHEMAS =====
// Request/response schemas for currency API endpoints
⋮----
/**
 * Zod schema for exchange rates fetch requests.
 * Validates parameters for fetching exchange rates including base currency and target currencies.
 */
⋮----
/** TypeScript type for exchange rates fetch requests. */
export type FetchExchangeRatesRequest = z.infer<
  typeof FETCH_EXCHANGE_RATES_REQUEST_SCHEMA
>;
⋮----
/**
 * Zod schema for exchange rates update responses.
 * Includes updated rates, base currency, and timestamp.
 */
⋮----
/** TypeScript type for exchange rates update responses. */
export type UpdateExchangeRatesResponse = z.infer<
  typeof UPDATE_EXCHANGE_RATES_RESPONSE_SCHEMA
>;
````

## File: src/domain/schemas/dashboard.ts
````typescript
/**
 * @fileoverview Dashboard metrics schemas with validation.
 * Includes API response types and time window configuration.
 */
⋮----
import { z } from "zod";
⋮----
// ===== CORE SCHEMAS =====
⋮----
/**
 * Time window options for metrics aggregation.
 */
⋮----
/** TypeScript type for time window options. */
export type TimeWindow = z.infer<typeof timeWindowSchema>;
⋮----
/**
 * Dashboard metrics response schema.
 * Validates aggregated metrics from the /api/dashboard endpoint.
 */
⋮----
/** Number of trips in planning/booked status */
⋮----
/** Average request latency in milliseconds */
⋮----
/** Number of completed trips */
⋮----
/** Error rate as percentage (0-100) */
⋮----
/** Total API requests in window */
⋮----
/** Total number of trips */
⋮----
/** TypeScript type for dashboard metrics. */
export type DashboardMetrics = z.infer<typeof dashboardMetricsSchema>;
⋮----
// ===== TOOL INPUT SCHEMAS =====
⋮----
/**
 * Query parameters schema for dashboard API.
 */
⋮----
/** TypeScript type for dashboard query parameters. */
export type DashboardQuery = z.infer<typeof dashboardQuerySchema>;
⋮----
/**
 * Converts time window to hours.
 *
 * @param window - Time window string
 * @returns Hours (0 for 'all')
 */
export function windowToHours(window: TimeWindow): number
````

## File: src/domain/schemas/deals.ts
````typescript
/**
 * @fileoverview Travel deals schemas with validation.
 * Includes deal entities, alerts, filters, store state, and statistics.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for travel deals
⋮----
/**
 * Zod schema for deal category types.
 * Defines available deal categories including flights, accommodations, and packages.
 */
⋮----
/** TypeScript type for deal types. */
export type DealType = z.infer<typeof DEAL_TYPE_SCHEMA>;
⋮----
/**
 * Zod schema for deal entities.
 * Represents travel deals with pricing, dates, and metadata.
 */
⋮----
/** TypeScript type for deal entities. */
export type Deal = z.infer<typeof DEAL_SCHEMA>;
⋮----
/**
 * Zod schema for deal alert subscriptions.
 * Validates deal alert configuration including filters and notification preferences.
 */
⋮----
/** TypeScript type for deal alerts. */
export type DealAlert = z.infer<typeof DEAL_ALERT_SCHEMA>;
⋮----
/**
 * Zod schema for deal filter criteria.
 * Validates filter parameters for searching and filtering deals.
 */
⋮----
/** TypeScript type for deal filters. */
export type DealFilters = z.infer<typeof DEAL_FILTERS_SCHEMA>;
⋮----
// ===== STATE SCHEMAS =====
// Schemas for client-side state management
⋮----
/**
 * Zod schema for deal store state.
 * Organizes deals, alerts, filters, and user preferences for UI state.
 */
⋮----
/** TypeScript type for deal store state. */
export type DealState = z.infer<typeof DEAL_STATE_SCHEMA>;
⋮----
/**
 * TypeScript type for computed deal statistics.
 * Includes aggregated statistics about deals including averages and counts by category.
 */
export type DealStats = {
  avgDiscount: number;
  avgSavings: number;
  byDestination: Record<string, number>;
  byType: Record<DealType, number>;
  totalCount: number;
};
````

## File: src/domain/schemas/errors.ts
````typescript
/**
 * @fileoverview Error reporting schemas and related types.
 * Includes error boundary information, error details, error reports, and component props.
 */
⋮----
import type React from "react";
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for error reporting
⋮----
/**
 * Zod schema for React error boundary information.
 * Validates error boundary context including component stack and error boundary details.
 */
⋮----
/** TypeScript type for error boundary information. */
export type ErrorInfo = z.infer<typeof errorInfoSchema>;
⋮----
/**
 * Zod schema for error details and stack traces.
 * Validates error structure including message, name, stack, and digest.
 */
⋮----
/** TypeScript type for error details. */
export type ErrorDetails = z.infer<typeof errorDetailsSchema>;
⋮----
/**
 * Zod schema for complete error reports sent to monitoring services.
 * Validates error report structure including error details, context, and metadata.
 */
⋮----
/** TypeScript type for error reports. */
export type ErrorReport = z.infer<typeof errorReportSchema>;
⋮----
// ===== COMPONENT PROPS =====
// TypeScript interfaces for error boundary component props
⋮----
/**
 * Props for error fallback UI components.
 * Defines error display and recovery action props.
 */
export interface ErrorFallbackProps {
  error: Error & { digest?: string };
  reset?: () => void;
  retry?: () => void;
}
⋮----
/**
 * Props for error boundary wrapper components.
 * Defines error boundary configuration including fallback and error handlers.
 */
export interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<ErrorFallbackProps>;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
  level?: "page" | "component" | "global";
}
⋮----
/**
 * Configuration for error reporting and monitoring services.
 * Defines error service settings including endpoint, API key, and retry configuration.
 */
export interface ErrorServiceConfig {
  enabled: boolean;
  endpoint?: string;
  apiKey?: string;
  maxRetries?: number;
  enableLocalStorage?: boolean;
}
````

## File: src/domain/schemas/flights.ts
````typescript
/**
 * @fileoverview Canonical Zod v4 schemas for flights.
 * Defines domain entities, tool inputs/outputs, and normalized offers.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
⋮----
export type CabinClass = z.infer<typeof CABIN_CLASS_ENUM>;
⋮----
export type FlightLocation = z.infer<typeof FLIGHT_LOCATION_SCHEMA>;
⋮----
export type FlightSegment = z.infer<typeof FLIGHT_SEGMENT_SCHEMA>;
⋮----
export type FlightSlice = z.infer<typeof FLIGHT_SLICE_SCHEMA>;
⋮----
export type Pricing = z.infer<typeof PRICING_SCHEMA>;
⋮----
export type FlightOffer = z.infer<typeof FLIGHT_OFFER_SCHEMA>;
⋮----
// ===== TOOL INPUT / OUTPUT SCHEMAS =====
⋮----
export type FlightSearchRequest = z.infer<typeof flightSearchRequestSchema>;
⋮----
export type FlightSearchResult = z.infer<typeof flightSearchResultSchema>;
````

## File: src/domain/schemas/mfa.ts
````typescript
/**
 * @fileoverview MFA domain schemas for enrollment, verification, and backup codes.
 */
⋮----
import { primitiveSchemas } from "@schemas/registry";
import { z } from "zod";
⋮----
// ===== CORE SCHEMAS =====
⋮----
/** The MFA factor schema. */
⋮----
/** The MFA factor type. */
export type MfaFactor = z.infer<typeof mfaFactorSchema>;
⋮----
/** The MFA enrollment schema. */
⋮----
/** The MFA enrollment type. */
export type MfaEnrollment = z.infer<typeof mfaEnrollmentSchema>;
⋮----
/** The MFA verification input schema. */
⋮----
/** The MFA verification input type. */
export type MfaVerificationInput = z.infer<typeof mfaVerificationInputSchema>;
⋮----
/** The backup code schema. */
⋮----
/** The backup code type. */
export type BackupCode = z.infer<typeof backupCodeSchema>;
⋮----
/** The backup code list schema. */
⋮----
/** The backup code list type. */
export type BackupCodeList = z.infer<typeof backupCodeListSchema>;
⋮----
// ===== TOOL INPUT SCHEMAS =====
⋮----
/** The backup code verify input schema. */
⋮----
/** The backup code verify input type. */
export type BackupCodeVerifyInput = z.infer<typeof backupCodeVerifyInputSchema>;
⋮----
/** The MFA challenge input schema. */
⋮----
/** The MFA challenge input type. */
export type MfaChallengeInput = z.infer<typeof mfaChallengeInputSchema>;
⋮----
/** The backup code regenerate input schema. */
⋮----
/** The backup code regenerate input type. */
export type BackupCodeRegenerateInput = z.infer<typeof backupCodeRegenerateInputSchema>;
⋮----
/** The MFA session revoke input schema. */
⋮----
/** The MFA session revoke input type. */
export type MfaSessionRevokeInput = z.infer<typeof mfaSessionRevokeInputSchema>;
````

## File: src/domain/schemas/profile.ts
````typescript
/**
 * @fileoverview User profile and settings form validation schemas.
 * Includes personal info, preferences, security settings, and email update forms.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
import { EMAIL_SCHEMA, NAME_SCHEMA, PHONE_SCHEMA } from "./shared/person";
⋮----
// ===== FORM SCHEMAS =====
// UI form validation schemas with user-friendly error messages
⋮----
/**
 * Zod schema for personal information form validation.
 * Validates user profile data including name, bio, location, and contact information.
 */
⋮----
/** TypeScript type for personal information form data. */
export type PersonalInfoFormData = z.infer<typeof personalInfoFormSchema>;
⋮----
/**
 * Zod schema for user preferences form validation.
 * Validates user preferences including currency, language, theme, and notification settings.
 */
⋮----
/** TypeScript type for preferences form data. */
export type PreferencesFormData = z.infer<typeof preferencesFormSchema>;
⋮----
/**
 * Zod schema for security settings form validation.
 * Validates security configuration including two-factor authentication and session settings.
 */
⋮----
/** TypeScript type for security settings form data. */
export type SecuritySettingsFormData = z.infer<typeof securitySettingsFormSchema>;
⋮----
/**
 * Zod schema for email update form validation.
 * Validates new email address for account updates.
 */
⋮----
/** TypeScript type for email update form data. */
export type EmailUpdateFormData = z.infer<typeof emailUpdateFormSchema>;
````

## File: src/domain/schemas/providers.ts
````typescript
/**
 * @fileoverview AI provider registry and model resolution schemas.
 * Includes provider identifiers, resolution results, and model mapper types.
 */
⋮----
import type { LanguageModel } from "ai";
import { z } from "zod";
⋮----
// ===== CORE SCHEMAS =====
⋮----
/**
 * Zod schema for provider identifiers.
 * Defines supported AI providers in the system.
 */
⋮----
/** TypeScript type for provider identifiers. */
export type ProviderId = z.infer<typeof providerIdSchema>;
⋮----
/**
 * Zod schema for provider resolution result (serializable fields only).
 * The `model` field is excluded as LanguageModel is not serializable.
 */
⋮----
/**
 * TypeScript type for provider resolution result.
 * Extends schema with runtime-only `model` field.
 */
export type ProviderResolution = z.infer<typeof providerResolutionSchema> & {
  model: LanguageModel;
};
⋮----
/** Map a generic model hint to a provider-specific model id. */
export type ModelMapper = (provider: ProviderId, modelHint?: string) => string;
````

## File: src/domain/schemas/realtime.ts
````typescript
/**
 * @fileoverview Realtime connection and backoff configuration schemas.
 * Includes connection status, backoff configuration, and broadcast payload schemas.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for realtime connections
⋮----
/**
 * Zod schema for exponential backoff configuration.
 * Validates retry configuration including factor, initial delay, and maximum delay.
 */
⋮----
/** Exponential factor (e.g., 2 for doubling, 1.5 for 50% increase). */
⋮----
/** Initial delay in milliseconds before the first retry. */
⋮----
/** Maximum delay in milliseconds (caps exponential growth). */
⋮----
/** TypeScript type for backoff configuration. */
export type BackoffConfig = z.infer<typeof backoffConfigSchema>;
⋮----
/**
 * Zod schema for connection status enumeration.
 * Defines possible states for realtime connections.
 */
⋮----
/** TypeScript type for connection status. */
export type ConnectionStatus = z.infer<typeof CONNECTION_STATUS_SCHEMA>;
⋮----
/**
 * Zod schema for chat message broadcast payload.
 * Validates chat message data for realtime broadcasting.
 */
⋮----
/** TypeScript type for chat message broadcast payload. */
export type ChatMessageBroadcastPayload = z.infer<
  typeof CHAT_MESSAGE_BROADCAST_PAYLOAD_SCHEMA
>;
⋮----
/**
 * Zod schema for chat typing broadcast payload.
 * Validates typing indicator data for realtime broadcasting.
 */
⋮----
/** TypeScript type for chat typing broadcast payload. */
export type ChatTypingBroadcastPayload = z.infer<
  typeof CHAT_TYPING_BROADCAST_PAYLOAD_SCHEMA
>;
⋮----
/**
 * Zod schema for agent status broadcast payload.
 * Validates agent status data for realtime broadcasting.
 */
⋮----
/** TypeScript type for agent status broadcast payload. */
export type AgentStatusBroadcastPayload = z.infer<
  typeof AGENT_STATUS_BROADCAST_PAYLOAD_SCHEMA
>;
````

## File: src/domain/schemas/registry.ts
````typescript
/**
 * @fileoverview Centralized schema registry for TripSage AI
 * Leverages Zod v4 advanced features: recursive schemas, template literals, refined generics
 * Provides shared schemas, transforms, and validation patterns
 */
⋮----
import { z } from "zod";
⋮----
/**
 * Base primitive schemas with enhanced validation (Zod v4 patterns)
 * Uses top-level helpers: z.email(), z.uuid(), z.url(), z.iso.datetime()
 * Uses unified error option: { error: "..." }
 */
⋮----
// Travel-specific template literals
⋮----
// Array schemas with Zod v4 improved generics
⋮----
// Enhanced string schemas
⋮----
// Number schemas
⋮----
/**
 * Transform schemas for data normalization
 * Uses Zod v4 .transform() with proper patterns
 */
⋮----
/**
 * Refinement schemas for complex validation
 * Uses Zod v4 .refine() with unified error option
 */
⋮----
/**
 * Standardized API route error response schema.
 * All route handlers should return errors in this shape for consistency.
 * Matches the format used by errorResponse(), notFoundResponse(),
 * unauthorizedResponse(), and forbiddenResponse() helpers.
 */
⋮----
/** TypeScript type for standardized route error responses. */
export type RouteError = z.infer<typeof routeErrorSchema>;
⋮----
/**
 * Schema registry combining all schema groups
 */
⋮----
// Export types
export type Uuid = z.infer<typeof primitiveSchemas.uuid>;
export type Email = z.infer<typeof primitiveSchemas.email>;
export type Url = z.infer<typeof primitiveSchemas.url>;
export type IsoDateTime = z.infer<typeof primitiveSchemas.isoDateTime>;
export type Timestamp = z.infer<typeof primitiveSchemas.timestamp>;
````

## File: src/domain/schemas/search.ts
````typescript
/**
 * @fileoverview Search functionality schemas with validation.
 * Includes search parameters, results, filters, and form validation for flights, accommodations, activities, and destinations.
 */
⋮----
import { z } from "zod";
import { propertyTypeSchema } from "./accommodations";
import { CABIN_CLASS_ENUM } from "./flights";
import { primitiveSchemas } from "./registry";
import { CURRENCY_CODE_SCHEMA } from "./shared/money";
import { ISO_DATE_STRING } from "./shared/time";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for search functionality
⋮----
// Base validation helpers
⋮----
/**
 * Zod schema for base search parameters shared across search types.
 * Includes common fields like dates, destination, and passenger counts.
 */
⋮----
/** TypeScript type for base search parameters. */
export type BaseSearchParams = z.infer<typeof baseSearchParamsSchema>;
⋮----
/**
 * Zod schema for flight-specific search parameters.
 * Includes cabin class, airline preferences, and routing options.
 */
⋮----
/** TypeScript type for flight search parameters. */
export type FlightSearchParams = z.infer<typeof flightSearchParamsSchema>;
⋮----
/**
 * Zod schema for accommodation-specific search parameters.
 * Includes property type, amenities, price range, and rating filters.
 */
⋮----
/** TypeScript type for accommodation search parameters. */
export type SearchAccommodationParams = z.infer<typeof searchAccommodationParamsSchema>;
⋮----
/**
 * Zod schema for activity-specific search parameters.
 * Includes difficulty level, duration range, and category filters.
 */
⋮----
/** TypeScript type for activity search parameters. */
export type ActivitySearchParams = z.infer<typeof activitySearchParamsSchema>;
⋮----
/**
 * Zod schema for destination-specific search parameters.
 * Includes location components, language, and result type filters.
 */
⋮----
/** TypeScript type for destination search parameters. */
export type DestinationSearchParams = z.infer<typeof destinationSearchParamsSchema>;
⋮----
/**
 * Zod schema for union of all search parameter types.
 * Supports flight, accommodation, activity, and destination searches.
 */
⋮----
/** TypeScript type for search parameters. */
export type SearchParams = z.infer<typeof searchParamsSchema>;
⋮----
/**
 * Zod schema for search type enumeration.
 * Defines supported search categories.
 */
⋮----
/** TypeScript type for search types. */
export type SearchType = z.infer<typeof searchTypeSchema>;
⋮----
/**
 * Zod schema for flight search results.
 * Includes airline, timing, pricing, and routing information.
 */
⋮----
/** TypeScript type for flight search results. */
export type Flight = z.infer<typeof flightSchema>;
⋮----
/**
 * Zod schema for accommodation availability info.
 * Tracks room availability and booking urgency.
 */
⋮----
/**
 * Zod schema for accommodation search results.
 * Includes property details, pricing, amenities, and location information.
 * Extended to preserve provider data for UI enrichment.
 */
⋮----
/** TypeScript type for accommodation search results. */
export type Accommodation = z.infer<typeof accommodationSchema>;
⋮----
/** TypeScript type for accommodation availability. */
export type AccommodationAvailability = z.infer<typeof accommodationAvailabilitySchema>;
⋮----
/**
 * Zod schema for activity search results.
 * Includes activity details, pricing, duration, and location information.
 */
⋮----
/** TypeScript type for activity search results. */
export type Activity = z.infer<typeof activitySchema>;
⋮----
/**
 * Zod schema for destination search results.
 * Includes location details, attractions, climate, and metadata.
 */
⋮----
/** TypeScript type for destination search results. */
export type Destination = z.infer<typeof destinationSchema>;
⋮----
/**
 * Zod schema for union of all search result types.
 * Supports flights, accommodations, activities, and destinations.
 */
⋮----
/** TypeScript type for search results. */
export type SearchResult = z.infer<typeof searchResultSchema>;
⋮----
/**
 * Zod schema for search results grouped by type.
 * Organizes results into separate arrays for each search category.
 */
⋮----
/** TypeScript type for grouped search results. */
export type SearchResults = z.infer<typeof searchResultsSchema>;
⋮----
/**
 * Zod schema for saved search configurations.
 * Stores search parameters and metadata for reuse.
 */
⋮----
/** TypeScript type for saved searches. */
export type SavedSearch = z.infer<typeof savedSearchSchema>;
⋮----
/**
 * Zod schema for filter values used in search filtering.
 * Supports strings, numbers, booleans, and arrays.
 */
⋮----
/** TypeScript type for filter values. */
export type FilterValue = z.infer<typeof filterValueSchema>;
⋮----
/**
 * Zod schema for metadata values in search responses.
 * Supports various data types including nested objects.
 */
⋮----
/** TypeScript type for metadata values. */
export type MetadataValue = z.infer<typeof metadataValueSchema>;
⋮----
/**
 * Zod schema for search API response structure.
 * Includes results, filters, metadata, and pagination information.
 */
⋮----
/** TypeScript type for search API responses. */
export type SearchResponse = z.infer<typeof searchResponseSchema>;
⋮----
/**
 * Zod schema for filter options in search UI.
 * Defines filter configuration with options and counts.
 */
⋮----
/** TypeScript type for filter options. */
export type FilterOption = z.infer<typeof filterOptionSchema>;
⋮----
/**
 * Zod schema for sort options in search UI.
 * Defines sorting configuration with direction and field.
 */
⋮----
/** TypeScript type for sort options. */
export type SortOption = z.infer<typeof sortOptionSchema>;
⋮----
// ===== FORM SCHEMAS =====
// UI form validation schemas with user-friendly error messages
⋮----
// Common form validation patterns
⋮----
/** Optional future date schema that treats empty strings as undefined for optional form fields. */
⋮----
/** Optional difficulty schema that allows empty strings to be treated as undefined. */
⋮----
/**
 * Form schema for flight search with validation.
 * Includes passenger details, routing preferences, and date validation.
 */
⋮----
/** TypeScript type for flight search form data. */
export type FlightSearchFormData = z.infer<typeof flightSearchFormSchema>;
⋮----
/**
 * Form schema for accommodation search with validation.
 * Includes guest details, dates, price range, and property filters.
 */
⋮----
/** TypeScript type for accommodation search form data. */
export type AccommodationSearchFormData = z.infer<typeof accommodationSearchFormSchema>;
⋮----
/**
 * Form schema for activity search with validation.
 * Includes participant details, date ranges, difficulty, and price filters.
 */
⋮----
// Only validate if both dates are present
⋮----
/** TypeScript type for activity search form data. */
export type ActivitySearchFormData = z.infer<typeof activitySearchFormSchema>;
⋮----
/**
 * Form schema for hotel search with validation.
 * Includes guest details, dates, price range, amenities, and rating filters.
 * Date fields use FUTURE_DATE_SCHEMA to match database DATE type (YYYY-MM-DD).
 */
⋮----
/** TypeScript type for hotel search form data. */
export type HotelSearchFormData = z.infer<typeof hotelSearchFormSchema>;
⋮----
/**
 * Form schema for destination search with validation.
 * Includes query, types, language, region, and limit filters.
 */
⋮----
/** TypeScript type for destination search form data. */
export type DestinationSearchFormData = z.infer<typeof destinationSearchFormSchema>;
⋮----
// ===== UI RESULT SCHEMAS =====
// UI-specific result schemas for component display
⋮----
/**
 * Zod schema for hotel search results displayed in UI.
 * Includes detailed hotel information, pricing, amenities, and AI recommendations.
 */
⋮----
/** TypeScript type for hotel search results. */
export type HotelResult = z.infer<typeof hotelResultSchema>;
⋮----
/**
 * Zod schema for flight search results displayed in UI.
 * Includes detailed flight information, pricing, emissions, and AI predictions.
 */
⋮----
duration: z.number().int().positive(), // minutes
⋮----
/** TypeScript type for flight search results. */
export type FlightResult = z.infer<typeof flightResultSchema>;
⋮----
// ===== DATABASE ROW SCHEMAS =====
// Schemas for database table rows matching Supabase structure
⋮----
/**
 * Zod schema for search_hotels table row.
 * Matches database structure with snake_case column names.
 */
⋮----
/** TypeScript type for search_hotels table row. */
export type SearchHotelsRow = z.infer<typeof searchHotelsRowSchema>;
⋮----
/**
 * Zod schema for search_flights table row.
 * Matches database structure with snake_case column names.
 */
⋮----
/** TypeScript type for search_flights table row. */
export type SearchFlightsRow = z.infer<typeof searchFlightsRowSchema>;
⋮----
/**
 * Zod schema for search_activities table row.
 * Matches database structure with snake_case column names.
 */
⋮----
/** TypeScript type for search_activities table row. */
export type SearchActivitiesRow = z.infer<typeof searchActivitiesRowSchema>;
⋮----
/**
 * Zod schema for search_destinations table row.
 * Matches database structure with snake_case column names.
 */
⋮----
/** TypeScript type for search_destinations table row. */
export type SearchDestinationsRow = z.infer<typeof searchDestinationsRowSchema>;
⋮----
// ===== UTILITY FUNCTIONS =====
// Validation helpers and business logic functions
⋮----
/**
 * Validates search parameters based on search type.
 * Performs type-specific validation and returns parsed parameters.
 *
 * @param data - Raw search parameters to validate
 * @param searchType - Type of search (flight, accommodation, activity, destination)
 * @returns Parsed and validated search parameters
 * @throws {Error} When validation fails or search type is unknown
 */
export const validateSearchParams = (data: unknown, searchType: string) =>
⋮----
/**
 * Safely validates search parameters with error handling.
 * Returns a result object with success/error information instead of throwing.
 *
 * @param data - Raw search parameters to validate
 * @param searchType - Type of search (flight, accommodation, activity, destination)
 * @returns Validation result with success/error information
 */
export const safeValidateSearchParams = (data: unknown, searchType: string) =>
````

## File: src/domain/schemas/stores.ts
````typescript
/**
 * @fileoverview Zustand store state validation schemas.
 * Runtime validation for all store state mutations and data across auth, user, search, trip, chat, UI, budget, and API key stores.
 */
⋮----
import { z } from "zod";
import { messageRoleSchema } from "./chat";
import { primitiveSchemas } from "./registry";
import { searchTypeSchema as baseSearchTypeSchema } from "./search";
import { storeTripSchema } from "./trips";
⋮----
type SchemaLogDetails = Record<string, unknown>;
⋮----
interface SchemaLogger {
  error: (message: string, details?: SchemaLogDetails) => void;
  warn: (message: string, details?: SchemaLogDetails) => void;
  info: (message: string, details?: SchemaLogDetails) => void;
}
⋮----
// noop
⋮----
// noop
⋮----
// noop
⋮----
function getSchemaLogger(): Promise<SchemaLogger>
⋮----
function ignorePromise(promise: Promise<unknown>): void
⋮----
// noop
⋮----
function logSchemaError(message: string, details?: SchemaLogDetails): void
⋮----
function logSchemaWarn(message: string, details?: SchemaLogDetails): void
⋮----
// ===== CORE SCHEMAS =====
// Core store state patterns and reusable schemas
⋮----
// Common validation patterns using registry primitives
⋮----
// ===== SEARCH PARAMS STORE SCHEMAS =====
⋮----
export type SearchType = z.infer<typeof searchTypeSchema>;
⋮----
export type ValidatedFlightParams = z.infer<typeof flightSearchParamsStoreSchema>;
⋮----
export type ValidatedAccommodationParams = z.infer<
  typeof accommodationSearchParamsStoreSchema
>;
⋮----
export type ValidatedActivityParams = z.infer<typeof activitySearchParamsStoreSchema>;
⋮----
export type ValidatedDestinationParams = z.infer<
  typeof destinationSearchParamsStoreSchema
>;
⋮----
// ===== SEARCH FILTERS STORE SCHEMAS =====
⋮----
export type FilterValue = z.infer<typeof filterValueSchema>;
⋮----
export type ValidatedFilterOption = z.infer<typeof filterOptionSchema>;
⋮----
export type ValidatedSortOption = z.infer<typeof sortOptionSchema>;
⋮----
export type ActiveFilter = z.infer<typeof activeFilterSchema>;
⋮----
export type FilterPreset = z.infer<typeof filterPresetSchema>;
export type SortDirection = z.infer<typeof sortDirectionSchema>;
⋮----
// ===== UI STORE SUPPORT SCHEMAS =====
⋮----
export type Theme = z.infer<typeof themeSchema>;
⋮----
export type NotificationType = z.infer<typeof notificationTypeSchema>;
⋮----
export type LoadingState = z.infer<typeof loadingStateSchema>;
⋮----
export type Notification = z.infer<typeof notificationSchema>;
⋮----
export type LoadingStates = z.infer<typeof loadingStatesSchema>;
⋮----
// ===== SEARCH HISTORY STORE SCHEMAS =====
⋮----
export type SearchHistoryItem = z.infer<typeof searchHistoryItemSchema>;
⋮----
export type ValidatedSavedSearch = z.infer<typeof savedSearchSchema>;
⋮----
export type SearchCollection = z.infer<typeof searchCollectionSchema>;
⋮----
export type QuickSearch = z.infer<typeof quickSearchSchema>;
⋮----
// ===== SEARCH RESULTS STORE SCHEMAS =====
⋮----
export type SearchStatus = z.infer<typeof searchStatusSchema>;
⋮----
export type SearchMetrics = z.infer<typeof searchMetricsSchema>;
⋮----
export type SearchContext = z.infer<typeof searchContextSchema>;
⋮----
export type ErrorDetails = z.infer<typeof errorDetailsSchema>;
⋮----
/**
 * Base loading state schema for store state.
 * Includes error handling and loading indicators.
 */
⋮----
/**
 * Base pagination state schema for store state.
 * Includes pagination metadata for list views.
 */
⋮----
/**
 * Zod schema for auth-specific user preferences (UI settings).
 * Note: Distinct from memory.ts USER_PREFERENCES_SCHEMA which is for travel preferences.
 */
⋮----
/** TypeScript type for auth user preferences. */
export type AuthUserPreferences = z.infer<typeof AUTH_USER_PREFERENCES_SCHEMA>;
⋮----
/**
 * Zod schema for auth user security settings.
 * Includes two-factor authentication and security questions.
 */
⋮----
answer: z.string(), // This would be hashed in real implementation
⋮----
/** TypeScript type for auth user security. */
export type AuthUserSecurity = z.infer<typeof AUTH_USER_SECURITY_SCHEMA>;
⋮----
/**
 * Zod schema for auth user entities.
 * Validates user data including profile, preferences, and security settings.
 */
⋮----
/** TypeScript type for auth users. */
export type AuthUser = z.infer<typeof AUTH_USER_SCHEMA>;
⋮----
/**
 * Zod schema for authentication token information.
 * Validates access and refresh tokens with expiration.
 */
⋮----
/** TypeScript type for auth token information. */
export type AuthTokenInfo = z.infer<typeof AUTH_TOKEN_INFO_SCHEMA>;
⋮----
/**
 * Zod schema for authentication session entities.
 * Validates session data including device information and expiration.
 */
⋮----
/** TypeScript type for auth sessions. */
export type AuthSession = z.infer<typeof AUTH_SESSION_SCHEMA>;
⋮----
// ===== STATE SCHEMAS =====
// Schemas for Zustand store state management
⋮----
/**
 * Zod schema for auth store state.
 * Manages authentication state including user, session, and loading indicators.
 */
⋮----
/** TypeScript type for auth store state. */
export type AuthStoreState = z.infer<typeof authStoreStateSchema>;
⋮----
/**
 * Zod schema for auth store actions.
 * Validates action function signatures for auth store.
 */
⋮----
/** TypeScript type for auth store actions. */
export type AuthStoreActions = z.infer<typeof authStoreActionsSchema>;
⋮----
/**
 * Zod schema for search store state.
 * Manages search parameters, results, filters, and saved searches.
 */
⋮----
/** TypeScript type for search store state. */
export type SearchStoreState = z.infer<typeof searchStoreStateSchema>;
⋮----
/**
 * Zod schema for search store actions.
 * Validates action function signatures for search store.
 */
⋮----
/** TypeScript type for search store actions. */
export type SearchStoreActions = z.infer<typeof searchStoreActionsSchema>;
⋮----
/**
 * Zod schema for trip store state.
 * Manages trip data, filters, pagination, and current trip selection.
 */
⋮----
/** TypeScript type for trip store state. */
export type TripStoreState = z.infer<typeof tripStoreStateSchema>;
⋮----
/**
 * Zod schema for trip store actions.
 * Validates action function signatures for trip store.
 */
⋮----
/** TypeScript type for trip store actions. */
export type TripStoreActions = z.infer<typeof tripStoreActionsSchema>;
⋮----
/**
 * Zod schema for chat store state.
 * Manages conversations, messages, typing indicators, and connection status.
 */
⋮----
/** TypeScript type for chat store state. */
export type ChatStoreState = z.infer<typeof chatStoreStateSchema>;
⋮----
/**
 * Zod schema for chat store actions.
 * Validates action function signatures for chat store.
 */
⋮----
/** TypeScript type for chat store actions. */
export type ChatStoreActions = z.infer<typeof chatStoreActionsSchema>;
⋮----
/**
 * Zod schema for UI store state.
 * Manages UI state including modals, notifications, toasts, sidebar, and theme.
 */
⋮----
/** TypeScript type for UI store state. */
export type UiStoreState = z.infer<typeof uiStoreStateSchema>;
⋮----
/**
 * Zod schema for UI store actions.
 * Validates action function signatures for UI store.
 */
⋮----
/** TypeScript type for UI store actions. */
export type UiStoreActions = z.infer<typeof uiStoreActionsSchema>;
⋮----
/**
 * Zod schema for budget store state.
 * Manages budgets, expenses, exchange rates, and current budget selection.
 */
⋮----
/** TypeScript type for budget store state. */
export type BudgetStoreState = z.infer<typeof budgetStoreStateSchema>;
⋮----
/**
 * Zod schema for budget store actions.
 * Validates action function signatures for budget store.
 */
⋮----
/** TypeScript type for budget store actions. */
export type BudgetStoreActions = z.infer<typeof budgetStoreActionsSchema>;
⋮----
/**
 * Zod schema for API key store state.
 * Manages API keys, service status, and usage tracking.
 */
⋮----
/** TypeScript type for API key store state. */
export type ApiKeyStoreState = z.infer<typeof apiKeyStoreStateSchema>;
⋮----
/**
 * Zod schema for API key store actions.
 * Validates action function signatures for API key store.
 */
⋮----
/** TypeScript type for API key store actions. */
export type ApiKeyStoreActions = z.infer<typeof apiKeyStoreActionsSchema>;
⋮----
// ===== UTILITY FUNCTIONS =====
// Validation helpers and middleware for store state
⋮----
/**
 * Validates store state against a schema.
 * Throws an error with detailed validation messages if validation fails.
 *
 * @param schema - Zod schema to validate against
 * @param state - Store state to validate
 * @param storeName - Optional store name for error messages
 * @returns Validated store state
 * @throws {Error} When validation fails with detailed error information
 */
export const validateStoreState = <T>(
  schema: z.ZodSchema<T>,
  state: unknown,
  storeName?: string
): T =>
⋮----
/**
 * Safely validates store state with error handling.
 * Returns a result object with success/error information instead of throwing.
 *
 * @param schema - Zod schema to validate against
 * @param state - Store state to validate
 * @param storeName - Optional store name for error messages
 * @returns Validation result with success/error information
 */
export const safeValidateStoreState = <T>(
  schema: z.ZodSchema<T>,
  state: unknown,
  storeName?: string
) =>
⋮----
/**
 * Middleware for Zustand store validation.
 * Wraps store configuration with development-time state validation.
 *
 * @param schema - Zod schema to validate state against
 * @param storeName - Optional store name for error messages
 * @returns Middleware function for Zustand store configuration
 */
export const storeValidationMiddleware =
<T>(schema: z.ZodSchema<T>, storeName?: string)
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Zustand store API requires flexible typing
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Zustand store API requires flexible typing
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Zustand partial state can be any shape
⋮----
// Validate initial state
````

## File: src/domain/schemas/temporal.ts
````typescript
/**
 * @fileoverview Temporal schemas for date/time, duration, ranges, and recurrence.
 * Includes date ranges, time ranges, durations, recurrence rules, and business hours.
 */
⋮----
import { z } from "zod";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for temporal data
⋮----
/**
 * Zod schema for date ranges with validation.
 * Ensures end date is on or after start date.
 */
⋮----
/** TypeScript type for date ranges. */
export type DateRange = z.infer<typeof dateRangeSchema>;
⋮----
/**
 * Zod schema for time ranges with validation.
 * Validates time format and ensures end time is after start time.
 */
⋮----
/** TypeScript type for time ranges. */
export type TimeRange = z.infer<typeof timeRangeSchema>;
⋮----
/**
 * Zod schema for time durations.
 * Validates duration components including days, hours, and minutes.
 */
⋮----
/** TypeScript type for durations. */
export type Duration = z.infer<typeof durationSchema>;
⋮----
/**
 * Zod schema for datetime ranges with timezone support.
 * Validates datetime range and ensures end datetime is after start datetime.
 */
⋮----
/** TypeScript type for datetime ranges. */
export type DateTimeRange = z.infer<typeof dateTimeRangeSchema>;
⋮----
/**
 * Zod schema for recurrence rules (RFC 5545 compliant).
 * Validates recurrence configuration with business rules.
 */
⋮----
/** TypeScript type for recurrence rules. */
export type RecurrenceRule = z.infer<typeof recurrenceRuleSchema>;
⋮----
/**
 * Zod schema for weekly business hours.
 * Defines business hours for each day of the week with optional timezone.
 */
⋮----
/** TypeScript type for business hours. */
export type BusinessHours = z.infer<typeof businessHoursSchema>;
⋮----
/**
 * Zod schema for availability information with capacity and restrictions.
 * Validates availability data including datetime ranges and capacity limits.
 */
⋮----
/** TypeScript type for availability. */
export type Availability = z.infer<typeof availabilitySchema>;
⋮----
/**
 * Zod schema for recurrence frequency (lowercase format for internal use).
 * Defines available recurrence frequencies.
 */
⋮----
/** TypeScript type for recurrence frequency. */
export type RecurrenceFrequency = z.infer<typeof recurrenceFrequencySchema>;
⋮----
/**
 * Zod schema for recurring rule configuration (internal format with numeric day-of-week).
 * This format is used by RecurringDateGenerator and can be converted to/from RFC 5545.
 */
⋮----
/** Optional maximum number of occurrences. */
⋮----
/** Day of month for monthly recurrence (1-31). */
⋮----
/** Days of week for weekly recurrence (0=Sunday, 6=Saturday). */
⋮----
/** Optional end date for the recurrence. */
⋮----
/** How often the event repeats (daily, weekly, monthly, yearly). */
⋮----
/** The interval between occurrences (e.g., 2 for every 2 weeks). */
⋮----
/** Week of month for monthly recurrence (1-5). */
⋮----
/** TypeScript type for recurring rule. */
export type RecurringRule = z.infer<typeof recurringRuleSchema>;
````

## File: src/domain/schemas/tokens.ts
````typescript
/**
 * @fileoverview Token counting, budgeting, and model limits schemas.
 * Includes chat message roles, token counting messages, clamp results, and model limits.
 */
⋮----
import { z } from "zod";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for token management
⋮----
/**
 * Zod schema for chat message roles.
 * Defines available roles for chat messages in token counting.
 */
⋮----
/** TypeScript type for chat message roles. */
export type ChatMessageRole = z.infer<typeof chatMessageRoleSchema>;
⋮----
/**
 * Zod schema for chat messages used in token counting.
 * Validates message structure including content and role.
 */
⋮----
/** TypeScript type for chat messages used in token counting. */
export type TokenChatMessage = z.infer<typeof tokenChatMessageSchema>;
⋮----
/**
 * Zod schema for token clamp result.
 * Validates token clamping result including final max tokens and reasons.
 */
⋮----
/** Final safe max tokens for the model/context. */
⋮----
/** Reasons describing why clamping occurred. */
⋮----
/** TypeScript type for clamp result. */
export type ClampResult = z.infer<typeof clampResultSchema>;
⋮----
/**
 * Zod schema for model limits table (key-value mapping of model names to context limits).
 * Validates model name to context limit mappings.
 */
⋮----
/** TypeScript type for model limits table. */
export type ModelLimitsTable = z.infer<typeof modelLimitsTableSchema>;
````

## File: src/domain/schemas/trips.ts
````typescript
/**
 * @fileoverview Trip-related Zod schemas for runtime validation.
 * Includes trip creation, updates, filtering, suggestions, and itinerary items.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
import { EMAIL_SCHEMA, NAME_SCHEMA } from "./shared/person";
import { tripStatusSchema, tripTypeSchema } from "./supabase";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for trip management
⋮----
/** Zod schema for trip visibility levels. */
⋮----
/** TypeScript type for trip visibility levels. */
export type TripVisibility = z.infer<typeof visibilitySchema>;
⋮----
/**
 * Zod schema for trip destinations (UI/store representation).
 * Represents a destination within a trip with activities, accommodation, and transportation.
 */
⋮----
/** TypeScript type for trip destinations. */
export type TripDestination = z.infer<typeof tripDestinationSchema>;
⋮----
/**
 * Zod schema for trip preferences (UI/store representation).
 * Includes budget breakdown, accommodation preferences, transportation, activities, etc.
 */
⋮----
.catchall(z.unknown()); // Allow additional preferences
⋮----
/** TypeScript type for trip preferences. */
export type TripPreferences = z.infer<typeof tripPreferencesSchema>;
⋮----
/**
 * Zod schema for UI Trip representation.
 * Maps database trips to UI-friendly format with camelCase fields and flat budget.
 * This is the canonical schema for the trip store and UI components.
 */
⋮----
/** TypeScript type for UI Trip representation. */
export type UiTrip = z.infer<typeof storeTripSchema>;
⋮----
/**
 * Zod schema for filtering trips based on various criteria.
 * Supports filtering by destination, date range, and status.
 */
⋮----
/** TypeScript type for trip filter criteria. */
export type TripFilters = z.infer<typeof tripFiltersSchema>;
⋮----
/**
 * Zod schema for creating new trips with required and optional fields.
 * Validates trip parameters including dates, budget, travelers, and preferences.
 */
⋮----
/** TypeScript type for trip creation input. */
export type TripCreateInput = z.infer<typeof tripCreateSchema>;
⋮----
/**
 * Zod schema for updating existing trips.
 * Allows partial updates while maintaining validation constraints.
 */
⋮----
/** TypeScript type for trip update input. */
export type TripUpdateInput = z.infer<typeof tripUpdateSchema>;
⋮----
/**
 * Zod schema for AI-generated trip suggestions with ratings and metadata.
 * Includes destination details, pricing, difficulty, and recommendation scores.
 */
⋮----
/** TypeScript type for AI-generated trip suggestions. */
export type TripSuggestion = z.infer<typeof tripSuggestionSchema>;
⋮----
/**
 * Zod schema for creating itinerary items like activities, meals, and transportation.
 * Validates item details including booking status, timing, and pricing.
 */
⋮----
/** TypeScript type for itinerary item creation input. */
export type ItineraryItemCreateInput = z.infer<typeof itineraryItemCreateSchema>;
⋮----
/**
 * Zod schema for updating existing itinerary items.
 * Allows partial updates of itinerary item properties.
 */
⋮----
/** TypeScript type for itinerary item update input. */
export type ItineraryItemUpdateInput = z.infer<typeof itineraryItemUpdateSchema>;
⋮----
// ===== FORM SCHEMAS =====
// UI form validation schemas with user-friendly error messages
⋮----
// Common form validation patterns
⋮----
/**
 * Form schema for creating new trips.
 * Includes validation for dates, travelers, budget, and collaboration settings.
 */
⋮----
/** TypeScript type for trip creation form data. */
export type CreateTripFormData = z.infer<typeof createTripFormSchema>;
⋮----
/**
 * Form schema for updating existing trips.
 * Allows partial updates of trip properties with validation.
 */
⋮----
/** TypeScript type for trip update form data. */
export type UpdateTripFormData = z.infer<typeof updateTripFormSchema>;
⋮----
/**
 * Form schema for adding travelers to trips.
 * Validates traveler details and invitation settings.
 */
⋮----
/** TypeScript type for add traveler form data. */
export type AddTravelerFormData = z.infer<typeof addTravelerFormSchema>;
````

## File: src/domain/schemas/validation.ts
````typescript
/**
 * @fileoverview Validation error handling and result schemas.
 * Includes validation context, error structures, and form validation utilities.
 */
⋮----
import { z } from "zod";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for validation
⋮----
/**
 * Zod schema for validation context enumeration.
 * Defines contexts where validation can occur.
 */
⋮----
/** TypeScript type for validation context. */
export type ValidationContext = z.infer<typeof validationContextSchema>;
⋮----
/**
 * Zod schema for validation error entities.
 * Validates error structure including code, context, field, and message.
 */
⋮----
/** TypeScript type for validation errors. */
export type ValidationErrorDetail = z.infer<typeof validationErrorDetailSchema>;
⋮----
/**
 * Generic validation result schema factory.
 * Creates a standardized result schema with data, errors, and success status.
 *
 * @param dataSchema - Schema for the validated data payload
 * @returns Zod schema for validation result structure
 */
export const validationResultSchema = <T extends z.ZodTypeAny>(dataSchema: T)
⋮----
/**
 * Generic API response wrapper schema.
 * Standardizes success + optional data/error/metadata.
 */
export const apiResponseSchema = <T extends z.ZodTypeAny>(dataSchema: T)
⋮----
/** Paginated response wrapper schema. */
export const paginatedResponseSchema = <T extends z.ZodTypeAny>(itemSchema: T)
⋮----
/** TypeScript type for validation results. */
export type ValidationResult<T = unknown> = {
  data?: T;
  errors?: ValidationErrorDetail[];
  success: boolean;
  warnings?: string[];
};
⋮----
// ===== UTILITY FUNCTIONS =====
// Validation helpers for form data
⋮----
/**
 * Validates form data against a schema.
 * Throws an error with detailed validation messages if validation fails.
 *
 * @param schema - Zod schema to validate against
 * @param data - Form data to validate
 * @returns Validated form data
 * @throws {Error} When validation fails with detailed error information
 */
export const validateFormData = <T>(schema: z.ZodSchema<T>, data: unknown): T =>
⋮----
/**
 * Safely validates form data with error handling.
 * Returns a result object with success/error information instead of throwing.
 *
 * @param schema - Zod schema to validate against
 * @param data - Form data to validate
 * @returns Validation result with success/error information
 */
export const safeValidateFormData = <T>(schema: z.ZodSchema<T>, data: unknown) =>
⋮----
/**
 * Extracts form errors from a Zod error into a record format.
 * Maps error paths to error messages for form field display.
 *
 * @param error - Zod validation error
 * @returns Record mapping field paths to error messages
 */
export const getFormErrors = (error: z.ZodError) =>
````

## File: src/domain/schemas/webhooks.ts
````typescript
/**
 * @fileoverview Webhook payload and job schemas with validation.
 * Includes webhook payloads, notification jobs, and memory sync jobs.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for webhook handling
⋮----
/**
 * Zod schema for webhook payload validation.
 * Validates Supabase webhook payload structure including record changes and event type.
 */
⋮----
/** TypeScript type for webhook payloads. */
export type WebhookPayload = z.infer<typeof webhookPayloadSchema>;
⋮----
/**
 * Zod schema for collaborator notification job validation.
 * Validates notification job structure including event key and payload.
 */
⋮----
/** TypeScript type for notification jobs. */
export type NotifyJob = z.infer<typeof notifyJobSchema>;
⋮----
/**
 * Zod schema for memory sync job validation.
 * Validates memory synchronization job structure including conversation messages and sync type.
 */
⋮----
/** TypeScript type for memory sync jobs. */
export type MemorySyncJob = z.infer<typeof memorySyncJobSchema>;
````

## File: src/hooks/chat/use-agent-status-websocket.ts
````typescript
/**
 * @fileoverview Hook that wires Supabase realtime agent status events into the agent
 * status store via the shared `useRealtimeChannel` helper. All direct channel
 * management has been deleted per FINAL-ONLY policy.
 */
⋮----
import type { AgentStatusType, AgentTask } from "@schemas/agent-status";
import { useCallback, useEffect, useRef } from "react";
import type { BackoffConfig } from "@/lib/realtime/backoff";
import { type AgentTaskUpdate, useAgentStatusStore } from "@/stores/agent-status-store";
import { useAuthCore } from "@/stores/auth/auth-core";
import {
  type RealtimeConnectionStatus,
  useRealtimeChannel,
} from "../supabase/use-realtime-channel";
⋮----
interface AgentStatusUpdatePayload {
  agentId: string;
  status?: AgentStatusType;
  progress?: number;
  name?: string;
  description?: string;
  metadata?: Record<string, unknown>;
  type?: string;
}
⋮----
interface AgentTaskStartPayload {
  agentId: string;
  task?: Pick<AgentTask, "id" | "title" | "description">;
}
⋮----
interface AgentTaskProgressPayload {
  agentId: string;
  taskId: string;
  progress?: number;
  status?: AgentTask["status"];
}
⋮----
interface AgentTaskCompletePayload {
  agentId: string;
  taskId: string;
  error?: string;
}
⋮----
interface AgentErrorPayload {
  agentId: string;
  error?: unknown;
}
⋮----
interface AgentResourceUsagePayload {
  agentId: string;
  cpu: number;
  memory: number;
  tokens: number;
}
⋮----
type AgentRealtimePayload =
  | AgentStatusUpdatePayload
  | AgentTaskStartPayload
  | AgentTaskProgressPayload
  | AgentTaskCompletePayload
  | AgentErrorPayload
  | AgentResourceUsagePayload;
⋮----
export interface AgentStatusRealtimeControls {
  /** Raw realtime connection status from `useRealtimeChannel`. */
  connectionStatus: RealtimeConnectionStatus;
  /** Last connection error, if any. */
  connectionError: string | null;
  /** Number of consecutive retries triggered by backoff. */
  retryCount: number;
  /** Current user topic (e.g., `user:123`). */
  topic: string | null;
  /** Resume realtime monitoring (re-subscribes). */
  resume: () => void;
  /** Pause realtime monitoring (unsubscribes). */
  pause: () => void;
  /** Force a reconnect cycle using backoff helper. */
  reconnect: () => void;
  /** Report local resource usage sample back to Supabase (best effort). */
  reportResourceUsage: (input: {
    agentId: string;
    cpu: number;
    memory: number;
    tokens: number;
  }) => Promise<void>;
}
⋮----
/** Raw realtime connection status from `useRealtimeChannel`. */
⋮----
/** Last connection error, if any. */
⋮----
/** Number of consecutive retries triggered by backoff. */
⋮----
/** Current user topic (e.g., `user:123`). */
⋮----
/** Resume realtime monitoring (re-subscribes). */
⋮----
/** Pause realtime monitoring (unsubscribes). */
⋮----
/** Force a reconnect cycle using backoff helper. */
⋮----
/** Report local resource usage sample back to Supabase (best effort). */
⋮----
/**
 * Subscribes the current user to their Supabase agent-status channel and keeps
 * the Zustand store in sync while exposing connection controls.
 *
 * @returns Connection control surface with monitoring helpers.
 */
export function useAgentStatusWebSocket(): AgentStatusRealtimeControls
⋮----
// Ignore send failures; local store already recorded usage.
````

## File: src/hooks/chat/use-optimistic-chat.ts
````typescript
/**
 * @fileoverview React hook for optimistic chat updates.
 *
 * Provides optimistic UI updates for chat messages, showing messages
 * immediately while sending in the background.
 */
⋮----
import { useCallback, useOptimistic, useState } from "react";
import { secureUuid } from "@/lib/security/random";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import type { ChatMessage } from "./use-websocket-chat";
⋮----
export interface OptimisticChatMessage extends ChatMessage {
  isOptimistic?: boolean;
}
⋮----
export interface UseOptimisticChatOptions {
  messages: ChatMessage[];
  sendMessage: (content: string) => Promise<void>;
  currentUser: {
    id: string;
    name: string;
    avatar?: string;
  };
}
⋮----
export interface UseOptimisticChatReturn {
  optimisticMessages: OptimisticChatMessage[];
  sendOptimisticMessage: (content: string) => Promise<void>;
  isPending: boolean;
  error: string | null;
}
⋮----
/**
 * Hook for optimistic chat message updates.
 *
 * Shows messages immediately in UI while sending in background.
 *
 * @param options - Hook configuration options
 * @param options.messages - Current chat messages
 * @param options.sendMessage - Function to send messages
 * @param options.currentUser - Current user information
 * @returns Object with optimistic messages and send function
 */
export function useOptimisticChat({
  messages,
  sendMessage,
  currentUser,
}: UseOptimisticChatOptions): UseOptimisticChatReturn
⋮----
// Add optimistic message immediately
⋮----
// Send actual message
⋮----
// The real message will come back through WebSocket and replace the optimistic one
⋮----
// The optimistic message will remain in the list with error state
// In a real implementation, you might want to update the message status
⋮----
// Telemetry failures should not break error handling
````

## File: src/hooks/chat/use-websocket-chat.ts
````typescript
/**
 * @fileoverview Chat-centric Supabase Realtime hook.
 *
 * Provides realtime chat capabilities backed by Supabase broadcast channels.
 * This hook wraps useRealtimeChannel with domain-specific chat event handling.
 */
⋮----
import { useCallback, useEffect, useMemo } from "react";
import { nowIso } from "@/lib/security/random";
import { useAuthCore } from "@/stores/auth/auth-core";
import { useChatRealtime } from "@/stores/chat/chat-realtime";
import { useRealtimeChannel } from "../supabase/use-realtime-channel";
⋮----
type ConnectionStatus = "connecting" | "connected" | "disconnected" | "error";
⋮----
/**
 * Payload for chat message broadcast events.
 */
export interface ChatMessageBroadcastPayload {
  /** Optional message identifier. */
  id?: string;
  /** Message content (Markdown/plain text). */
  content: string;
  /** ISO timestamp when the message was created. */
  timestamp?: string;
  /** Sender information. */
  sender?: { id: string; name: string; avatar?: string };
}
⋮----
/** Optional message identifier. */
⋮----
/** Message content (Markdown/plain text). */
⋮----
/** ISO timestamp when the message was created. */
⋮----
/** Sender information. */
⋮----
/**
 * Payload for chat typing broadcast events.
 */
export interface ChatTypingBroadcastPayload {
  /** User ID of the typing user. */
  userId: string;
  /** Whether the user is currently typing. */
  isTyping: boolean;
}
⋮----
/** User ID of the typing user. */
⋮----
/** Whether the user is currently typing. */
⋮----
/**
 * Represents a chat message exchanged through the realtime channel.
 */
export interface ChatMessage {
  /** Stable message identifier. */
  id: string;
  /** Message body (Markdown/plain text). */
  content: string;
  /** Client-side timestamp when the message was processed. */
  timestamp: Date;
  /** Basic sender information. */
  sender: { id: string; name: string; avatar?: string };
  /** Delivery state used for optimistic updates. */
  status?: "sending" | "sent" | "failed";
  /** Optional message category, defaults to `text`. */
  type?: "text" | "system" | "typing";
}
⋮----
/** Stable message identifier. */
⋮----
/** Message body (Markdown/plain text). */
⋮----
/** Client-side timestamp when the message was processed. */
⋮----
/** Basic sender information. */
⋮----
/** Delivery state used for optimistic updates. */
⋮----
/** Optional message category, defaults to `text`. */
⋮----
/**
 * Configuration flags for the websocket chat hook.
 */
export interface WebSocketChatOptions {
  /** Whether to automatically connect to the websocket. */
  autoConnect?: boolean;
  /** The type of topic to subscribe to, either `user` or `session`. */
  topicType?: "user" | "session";
  /** The session ID to subscribe to. */
  sessionId?: string;
}
⋮----
/** Whether to automatically connect to the websocket. */
⋮----
/** The type of topic to subscribe to, either `user` or `session`. */
⋮----
/** The session ID to subscribe to. */
⋮----
/**
 * Shape of the realtime chat hook return value.
 */
export interface UseWebSocketChatReturn {
  /** The list of chat messages. */
  messages: ChatMessage[];
  /** The connection status. */
  connectionStatus: ConnectionStatus;
  /** The function to send a message. */
  sendMessage: (content: string) => Promise<void>;
  /** Whether the connection is established. */
  isConnected: boolean;
  /** The function to reconnect to the websocket. */
  reconnect: () => void;
  /** The list of typing users. */
  typingUsers: string[];
  /** The function to start typing. */
  startTyping: () => void;
  /** The function to stop typing. */
  stopTyping: () => void;
}
⋮----
/** The list of chat messages. */
⋮----
/** The connection status. */
⋮----
/** The function to send a message. */
⋮----
/** Whether the connection is established. */
⋮----
/** The function to reconnect to the websocket. */
⋮----
/** The list of typing users. */
⋮----
/** The function to start typing. */
⋮----
/** The function to stop typing. */
⋮----
/**
 * Provides realtime chat capabilities backed by Supabase broadcast channels.
 *
 * @param autoConnect - Whether to automatically connect to the websocket.
 * @param topicType - The type of topic to subscribe to, either `user` or `session`.
 * @param sessionId - The session ID to subscribe to.
 * @returns Realtime connection state and chat helpers.
 */
export function useWebSocketChat({
  autoConnect = true,
  topicType = "user",
  sessionId,
}: WebSocketChatOptions =
⋮----
// Handle incoming chat messages and typing events via onMessage callback
⋮----
// Map channel status to slice connection status
⋮----
// Reset state when topic becomes null
⋮----
/**
   * Sends a chat message through the realtime channel.
   *
   * @param content - The message content to send.
   * @returns Promise that resolves when the message is sent.
   */
⋮----
/**
   * Starts typing indicator for the current user.
   */
⋮----
// Best-effort typing indicator; ignore failures.
⋮----
/**
   * Stops typing indicator for the current user.
   */
⋮----
// Best-effort typing indicator; ignore failures.
⋮----
/**
   * Reconnects to the realtime channel.
   *
   * Note: Supabase Realtime handles reconnection automatically via useRealtimeChannel's
   * backoff logic. This method exists to maintain the hook's API contract.
   */
⋮----
// Reconnection is handled automatically by useRealtimeChannel's backoff logic
⋮----
// Map slice connection status to hook's ConnectionStatus type
⋮----
// Convert slice typing users to array of user IDs
⋮----
// Convert pending messages to ChatMessage format
````

## File: src/hooks/search/utils/response-mappers.ts
````typescript
/**
 * @fileoverview Response mappers for transforming API responses to SearchResults format.
 *
 * Extracted from use-search-orchestration.ts for better maintainability.
 */
⋮----
import { getCategoryFromChainCode } from "@domain/amadeus/chain-codes";
import type {
  Accommodation,
  Activity,
  Flight,
  SearchParams,
  SearchResults,
  SearchType,
} from "@schemas/search";
⋮----
// ===== FLIGHT MAPPERS =====
⋮----
interface FlightItinerary {
  id: string;
  price: number;
  segments: Array<{
    arrival?: string;
    carrier?: string;
    departure?: string;
    destination: string;
    flightNumber?: string;
    origin: string;
  }>;
}
⋮----
interface FlightOffer {
  id: string;
  price: { amount: number; currency: string };
  slices: Array<{
    cabinClass: string;
    segments: Array<{
      arrivalTime?: string;
      carrier?: string;
      departureTime?: string;
      destination: { iata: string };
      durationMinutes?: number;
      flightNumber?: string;
      origin: { iata: string };
    }>;
  }>;
}
⋮----
interface FlightApiResponse {
  currency?: string;
  itineraries?: FlightItinerary[];
  offers?: FlightOffer[];
}
⋮----
/**
 * Maps flight API response (FlightSearchResult) to SearchResults format.
 */
export function mapFlightResponse(data: FlightApiResponse): Flight[]
⋮----
// Prefer itineraries if available, fall back to offers
⋮----
// Estimate duration from departure/arrival if available
⋮----
// Map offers to Flight format
⋮----
// ===== ACCOMMODATION MAPPERS =====
⋮----
interface AccommodationListingResponse {
  address?: { cityName?: string; lines?: string[] };
  amenities?: string[];
  cancellationPolicy?: {
    deadline?: string;
    description?: string;
    refundable?: boolean;
  };
  chainCode?: string;
  geoCode?: { latitude: number; longitude: number };
  hotel?: { hotelId?: string; name?: string };
  id?: string | number;
  name?: string;
  place?: { rating?: number; userRatingCount?: number };
  rooms?: Array<{
    rates?: Array<{
      price?: {
        base?: string | number;
        currency?: string;
        total?: string | number;
      };
    }>;
    roomsLeft?: number;
  }>;
  starRating?: number;
  taxes?: number;
}
⋮----
interface AccommodationApiResponse {
  listings?: AccommodationListingResponse[];
}
⋮----
/**
 * Calculate urgency level based on rooms left.
 */
function calculateUrgency(roomsLeft: number | undefined): "low" | "medium" | "high"
⋮----
/**
 * Maps accommodation API response to SearchResults format.
 * Preserves provider data for UI enrichment (availability, policies, taxes).
 */
export function mapAccommodationResponse(
  data: AccommodationApiResponse,
  searchParams: SearchParams
): Accommodation[]
⋮----
// Extract check-in/check-out from search params if available
⋮----
// Extract price from first room's first rate
⋮----
// Extract roomsLeft from first room (Amadeus provides per-room availability)
⋮----
// Calculate nights for price per night
⋮----
// ===== ACTIVITY MAPPERS =====
⋮----
interface ActivityApiResponse {
  activities?: Activity[];
  metadata?: { total?: number };
}
⋮----
/**
 * Maps activity API response to SearchResults format.
 */
export function mapActivityResponse(data: ActivityApiResponse): Activity[]
⋮----
// ===== UTILITY FUNCTIONS =====
⋮----
function assertUnreachable(_value: never): never
⋮----
/**
 * Returns empty results for a search type (used for graceful failure).
 */
export function getEmptyResults(searchType: SearchType): SearchResults
⋮----
// ===== API ENDPOINTS =====
````

## File: src/hooks/search/use-destination-search.ts
````typescript
/**
 * @fileoverview Destination search hook backed by the Places Text Search API.
 */
⋮----
import type { PlacesSearchRequest } from "@schemas/api";
import type { Destination } from "@schemas/search";
import { useCallback, useEffect, useRef, useState } from "react";
import { useSearchResultsStore } from "@/stores/search-results-store";
⋮----
export interface DestinationSearchParams {
  query: string;
  types?: string[];
  limit?: number;
}
⋮----
export interface DestinationResult {
  placeId: string;
  name: string;
  address: string;
  location?: { lat: number; lng: number };
  types: string[];
}
⋮----
export interface UseDestinationSearchResult {
  searchDestinations: (
    params: DestinationSearchParams,
    signal?: AbortSignal
  ) => Promise<void>;
  isSearching: boolean;
  searchError: Error | null;
  resetSearch: () => void;
  results: DestinationResult[];
}
⋮----
interface PlacesSearchResponse {
  places?: Array<{
    id: string;
    displayName?: { text: string };
    formattedAddress?: string;
    location?: { latitude: number; longitude: number };
    types?: string[];
  }>;
}
⋮----
function normalizeLimit(limit?: number): number
⋮----
/**
 * Hook for destination search functionality.
 *
 * @returns Object with search methods and state
 */
export function useDestinationSearch(): UseDestinationSearchResult
⋮----
const abortHandler = () =>
````

## File: src/hooks/search/use-search-orchestration.ts
````typescript
/**
 * @fileoverview Search orchestration hook that replaces the search-store.ts orchestrator.
 *
 * This hook composes the search params, results, filters, and history stores
 * to provide high-level search operations without cross-store getState() calls.
 */
⋮----
import type { SearchParams, SearchResults, SearchType } from "@schemas/search";
import type {
  ValidatedAccommodationParams,
  ValidatedActivityParams,
  ValidatedDestinationParams,
  ValidatedFlightParams,
} from "@schemas/stores";
import { useCallback, useMemo } from "react";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import { useSearchFiltersStore } from "@/stores/search-filters-store";
import { useSearchHistoryStore } from "@/stores/search-history";
import { useSearchParamsStore } from "@/stores/search-params-store";
import { useSearchResultsStore } from "@/stores/search-results-store";
import {
  getEmptyResults,
  mapAccommodationResponse,
  mapActivityResponse,
  mapFlightResponse,
  SEARCH_ENDPOINTS,
} from "./utils/response-mappers";
⋮----
/** Type for params slices from the store */
interface ParamsSlices {
  accommodationParams: Partial<ValidatedAccommodationParams>;
  activityParams: Partial<ValidatedActivityParams>;
  destinationParams: Partial<ValidatedDestinationParams>;
  flightParams: Partial<ValidatedFlightParams>;
}
⋮----
/** Type-safe extraction of params from slices based on search type */
const getParamsFromSlices = (
  slices: ParamsSlices,
  searchType: SearchType
): Partial<SearchParams> | null =>
⋮----
/**
 * Performs the actual search request to the appropriate API endpoint.
 */
async function performSearchRequest(
  searchType: SearchType,
  params: SearchParams,
  onProgress?: () => void,
  signal?: AbortSignal
): Promise<
⋮----
// Destination searches are handled by a separate hook (useDestinationSearch)
// This orchestration hook focuses on activity, flight, and accommodation searches
⋮----
// Graceful failure: return empty results with warning
⋮----
// Map response to SearchResults format based on search type
⋮----
// Graceful failure: return empty results instead of throwing
⋮----
/**
 * Search orchestration hook result interface.
 */
export interface UseSearchOrchestrationResult {
  // Current state (derived from stores)
  currentSearchType: SearchType | null;
  currentParams: SearchParams | null;
  hasActiveFilters: boolean;
  hasResults: boolean;
  isSearching: boolean;

  // High-level search operations
  initializeSearch: (searchType: SearchType) => void;
  executeSearch: (
    params?: SearchParams,
    signal?: AbortSignal
  ) => Promise<string | null>;
  resetSearch: () => void;

  // Cross-store operations
  loadSavedSearch: (savedSearchId: string) => Promise<boolean>;
  duplicateCurrentSearch: (name: string) => Promise<string | null>;

  // Search workflow helpers
  validateAndExecuteSearch: () => Promise<string | null>;
  applyFiltersAndSearch: () => Promise<string | null>;
  retryLastSearch: () => Promise<string | null>;

  // Quick access helpers
  getSearchSummary: () => {
    searchType: SearchType | null;
    params: SearchParams | null;
    hasResults: boolean;
    resultCount: number;
    hasFilters: boolean;
    filterCount: number;
    isValid: boolean;
  };
}
⋮----
// Current state (derived from stores)
⋮----
// High-level search operations
⋮----
// Cross-store operations
⋮----
// Search workflow helpers
⋮----
// Quick access helpers
⋮----
/**
 * Hook for orchestrating search operations across multiple stores.
 *
 * Replaces the search-store.ts orchestrator with a hook-based approach
 * that uses React subscriptions instead of cross-store getState() calls.
 *
 * @returns Search orchestration result with state and actions.
 */
export function useSearchOrchestration(): UseSearchOrchestrationResult
⋮----
// Subscribe to relevant state from each store
⋮----
/**
   * Initialize search for a specific type.
   */
⋮----
/**
   * Derive current params from store slices (memoized separately to reduce executeSearch dependencies).
   */
⋮----
/**
   * Execute a search with the given or current parameters.
   */
⋮----
// Use provided params or derive from state
⋮----
// Validate parameters
⋮----
// Start the search
⋮----
// Add to recent searches (will update resultsCount after search completes)
⋮----
// Perform real API search based on search type
⋮----
// Set the results
⋮----
/**
   * Reset all search state.
   */
⋮----
/**
   * Load a saved search by ID.
   */
⋮----
// Initialize search type
⋮----
// Load parameters
⋮----
// Mark as used
⋮----
/**
   * Duplicate the current search with a new name.
   */
⋮----
/**
   * Validate parameters and execute search.
   */
⋮----
/**
   * Validate filters and execute search.
   */
⋮----
/**
   * Retry the last search.
   */
⋮----
/**
   * Get a summary of the current search state.
   */
⋮----
// Operations
⋮----
// State
⋮----
// Re-export the hook as useSearchStore for backward compatibility
````

## File: src/hooks/search/use-search.ts
````typescript
/**
 * @fileoverview General-purpose debounced search hook.
 */
⋮----
import { useCallback, useEffect, useRef, useState } from "react";
⋮----
/** Interface defining the return type of the useSearch hook. */
export interface UseSearchResult {
  search: (query: string) => Promise<void>;
  isSearching: boolean;
  results: unknown[];
  error: Error | null;
  clearSearch: () => void;
}
⋮----
/**
 * Hook for general-purpose debounced search functionality.
 *
 * Provides methods for searching, managing search state, and clearing search results.
 *
 * @returns Object with search methods and state
 */
export function useSearch(): UseSearchResult
⋮----
/**
   * Performs the actual search operation.
   *
   * @param query - The search query to perform.
   */
⋮----
/** Clears the current search state. */
⋮----
/** Cleans up the search state on unmount. */
⋮----
/** Returns the search methods and state. */
````

## File: src/hooks/supabase/use-realtime-channel.ts
````typescript
/**
 * @fileoverview Core Supabase Realtime channel hook.
 *
 * This is the single low-level abstraction for all Supabase Realtime channels in the frontend.
 * All feature code must use this hook or its thin wrappers (e.g., useWebSocketChat, useTripRealtime).
 * Never call `supabase.channel(...)` directly in feature code.
 *
 * This hook is domain-agnostic and does not know about specific event types like `chat:message`
 * or `agent_status_update`. Domain hooks translate generic events into store updates.
 */
⋮----
import type {
  RealtimeChannel,
  RealtimePostgresChangesPayload,
} from "@supabase/supabase-js";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { type BackoffConfig, computeBackoffDelay } from "@/lib/realtime/backoff";
import { getBrowserClient, type TypedSupabaseClient } from "@/lib/supabase";
import { useRealtimeConnectionStore } from "@/stores/realtime-connection-store";
⋮----
/** Supabase broadcast event payload structure. */
interface BroadcastPayload<T> {
  type: "broadcast";
  event: string;
  meta?: { replayed?: boolean; id: string };
  payload: T;
}
⋮----
type ChannelInstance = ReturnType<TypedSupabaseClient["channel"]>;
type ChannelSendRequest = Parameters<RealtimeChannel["send"]>[0];
⋮----
/** Connection status for a Realtime channel subscription. */
export type RealtimeConnectionStatus =
  | "idle"
  | "connecting"
  | "subscribed"
  | "error"
  | "closed";
⋮----
/**
 * Options for configuring a Supabase Realtime channel subscription.
 *
 * @template Payload - Expected payload shape for broadcast events.
 */
export interface UseRealtimeChannelOptions<Payload = unknown> {
  /** Whether the channel is private (uses Realtime Authorization). Defaults to true. */
  private?: boolean;
  /** Optional list of event names to filter broadcasts. If omitted, all events are received. */
  events?: string[];
  /** Callback invoked when a broadcast message is received. */
  onMessage?: (payload: Payload, event: string) => void;
  /** Callback invoked when connection status changes. */
  onStatusChange?: (status: RealtimeConnectionStatus) => void;
  /** Optional exponential backoff configuration for reconnection. */
  backoff?: BackoffConfig;
}
⋮----
/** Whether the channel is private (uses Realtime Authorization). Defaults to true. */
⋮----
/** Optional list of event names to filter broadcasts. If omitted, all events are received. */
⋮----
/** Callback invoked when a broadcast message is received. */
⋮----
/** Callback invoked when connection status changes. */
⋮----
/** Optional exponential backoff configuration for reconnection. */
⋮----
/**
 * Result returned from {@link useRealtimeChannel}, containing connection state and helpers.
 *
 * @template Payload - Expected payload shape for broadcast events.
 */
export interface UseRealtimeChannelResult<Payload = unknown> {
  /** The underlying Supabase RealtimeChannel instance, or null if not connected. */
  channel: RealtimeChannel | null;
  /** Current connection status. */
  connectionStatus: RealtimeConnectionStatus;
  /** Error from the last connection attempt, or null if no error. */
  error: Error | null;
  /** Send a broadcast message to the channel. */
  sendBroadcast: (event: string, payload: Payload) => Promise<void>;
  /** Unsubscribe from the channel and close the connection. */
  unsubscribe: () => void;
}
⋮----
/** The underlying Supabase RealtimeChannel instance, or null if not connected. */
⋮----
/** Current connection status. */
⋮----
/** Error from the last connection attempt, or null if no error. */
⋮----
/** Send a broadcast message to the channel. */
⋮----
/** Unsubscribe from the channel and close the connection. */
⋮----
/**
 * Maps Supabase channel status to our connection status type.
 *
 * @param status - Supabase channel status string (e.g., "SUBSCRIBED", "CHANNEL_ERROR").
 * @param hasError - Whether an error object was provided with the status.
 * @returns Mapped connection status for our abstraction.
 */
function mapSupabaseStatus(
  status: string,
  hasError: boolean
): RealtimeConnectionStatus
⋮----
/**
 * Subscribes to a Supabase Realtime topic, returning connection state and helper functions
 * for consuming and emitting broadcast events.
 *
 * This is the single low-level abstraction for all Supabase Realtime channels. All feature
 * code must use this hook or its thin wrappers. Never call `supabase.channel(...)` directly.
 *
 * @template Payload - Expected payload shape for broadcast events.
 * @param topic - Supabase topic to join (e.g., `user:${userId}`, `session:${sessionId}`).
 *   When null, the hook remains idle and does not subscribe to any channel.
 * @param opts - Optional channel configuration including callbacks and backoff settings.
 * @returns Connection state and broadcast helpers.
 */
export function useRealtimeChannel<Payload = unknown>(
  topic: string | null,
  opts: UseRealtimeChannelOptions<Payload> = { private: true }
): UseRealtimeChannelResult<Payload>
⋮----
// Update status and notify callback
⋮----
// Cleanup reconnect timer
⋮----
// Attempt reconnection with backoff
⋮----
// Re-subscribe to trigger reconnection
⋮----
// Main subscription effect
⋮----
// Setup broadcast handlers immediately after channel creation
// Note: Supabase requires an event filter, so events must be specified when onMessage is provided
⋮----
const handler = (payload: BroadcastPayload<Payload>) =>
// TypeScript cannot resolve the correct overload when event is a runtime string.
// The broadcast overload in RealtimeChannel.d.ts:244-267 is correct but TS
// matches the system overload instead. Handler is typed via BroadcastPayload<T>.
// @ts-expect-error - Supabase overload resolution with dynamic event names
⋮----
// Ignore unsubscribe errors during cleanup
⋮----
// Ignore unsubscribe errors
⋮----
export type PostgresChangeEvent = "*" | "INSERT" | "UPDATE" | "DELETE";
⋮----
export type PostgresChangesSubscription = {
  /** Database schema name (defaults to "public"). */
  schema?: string;
  /** Table name to subscribe to. */
  table: string;
  /** Event type to listen for. Defaults to "*" (all). */
  event?: PostgresChangeEvent;
  /** Optional PostgREST-style filter (e.g., `user_id=eq.<uuid>`). */
  filter?: string;
};
⋮----
/** Database schema name (defaults to "public"). */
⋮----
/** Table name to subscribe to. */
⋮----
/** Event type to listen for. Defaults to "*" (all). */
⋮----
/** Optional PostgREST-style filter (e.g., `user_id=eq.<uuid>`). */
⋮----
export interface UsePostgresChangesChannelOptions<
  Row extends Record<string, unknown> = Record<string, unknown>,
> {
  /** Whether the channel is private (uses Realtime Authorization). Defaults to true. */
  private?: boolean;
  /** One or more Postgres change subscriptions to attach to the channel. */
  changes: PostgresChangesSubscription[];
  /** Callback invoked when a Postgres change message is received. */
  onChange?: (payload: RealtimePostgresChangesPayload<Row>) => void;
  /** Callback invoked when connection status changes. */
  onStatusChange?: (status: RealtimeConnectionStatus) => void;
  /** Optional exponential backoff configuration for reconnection. */
  backoff?: BackoffConfig;
}
⋮----
/** Whether the channel is private (uses Realtime Authorization). Defaults to true. */
⋮----
/** One or more Postgres change subscriptions to attach to the channel. */
⋮----
/** Callback invoked when a Postgres change message is received. */
⋮----
/** Callback invoked when connection status changes. */
⋮----
/** Optional exponential backoff configuration for reconnection. */
⋮----
export interface UsePostgresChangesChannelResult {
  channel: RealtimeChannel | null;
  connectionStatus: RealtimeConnectionStatus;
  error: Error | null;
  unsubscribe: () => void;
}
⋮----
/**
 * Subscribe to Postgres changes on a Supabase Realtime channel.
 *
 * This is a thin companion to {@link useRealtimeChannel} for cases where the
 * app needs `postgres_changes` (e.g., invalidating React Query caches on DB updates).
 *
 * @template Row - Shape of `payload.new` / `payload.old` for strongly typed consumers.
 * @param topic - Supabase topic to join (e.g., `trips:${userId}`, `trip:${tripId}`); when null, hook is idle.
 * @param opts - Postgres change subscriptions and callbacks.
 * @returns Connection status and last error, plus an unsubscribe helper.
 */
export function usePostgresChangesChannel<
  Row extends Record<string, unknown> = Record<string, unknown>,
>(
  topic: string | null,
  opts: UsePostgresChangesChannelOptions<Row>
): UsePostgresChangesChannelResult
⋮----
// Compute eventType, defaulting to "*" if not a standard event; Supabase accepts
// all PostgresChangeEvent values. Handler already typed so runtime works correctly.
⋮----
// TypeScript cannot resolve the postgres_changes overload with runtime-computed event types.
// The handler is properly typed via RealtimePostgresChangesPayload<Row>. Use type assertion
// to bypass overload resolution while maintaining runtime correctness.
// biome-ignore lint/suspicious/noExplicitAny: Supabase overload resolution issue
⋮----
// Ignore unsubscribe errors during cleanup
⋮----
// Ignore unsubscribe errors
````

## File: src/hooks/supabase/use-supabase-realtime.ts
````typescript
/**
 * @fileoverview React hook for Supabase realtime connections.
 *
 * Provides realtime connection status and error handling for Supabase Realtime
 * channels by delegating to the shared channel and chat hooks.
 */
⋮----
import { useMemo } from "react";
import { useRealtimeConnectionStore } from "@/stores/realtime-connection-store";
import { useWebSocketChat } from "../chat/use-websocket-chat";
import { useRealtimeChannel } from "./use-realtime-channel";
export interface RealtimeConnectionStatus {
  trips?: "connected" | "disconnected" | "error";
  destinations?: "connected" | "disconnected" | "error";
  chat?: "connected" | "disconnected" | "error";
}
⋮----
export interface RealtimeHookResult {
  connectionStatus: string | RealtimeConnectionStatus;
  isConnected: boolean;
  error: Error | null;
  errors: Error[];
  disconnect?: () => void;
  reconnect?: () => void;
  newMessageCount?: number;
  clearMessageCount?: () => void;
}
⋮----
/**
 * Aggregate hook for overall Supabase realtime status.
 *
 * Currently returns a simple "connected" status to avoid over-abstracting
 * per-channel behaviour. Callers that need detailed semantics should use the
 * more specific hooks (useTripRealtime, useChatRealtime).
 */
export function useSupabaseRealtime(): RealtimeHookResult
⋮----
const reconnect = ()
⋮----
/**
 * Hook for trip-specific realtime subscriptions using Supabase Realtime channels.
 *
 * @param tripId - Trip identifier used to derive the channel topic.
 */
export function useTripRealtime(tripId: string | number | null): RealtimeHookResult
⋮----
/**
 * Hook for chat realtime subscriptions backed by Supabase Realtime broadcast channels.
 *
 * @param sessionId - Chat session identifier used to derive the channel topic.
 */
export function useChatRealtime(sessionId: string | null): RealtimeHookResult
⋮----
/**
 * Hook for summarised realtime status across key domains.
 */
export function useRealtimeStatus()
⋮----
// Keep this simple for now; callers needing richer semantics should compose
// useTripRealtime/useChatRealtime directly.
````

## File: src/hooks/use-budget.ts
````typescript
/**
 * @fileoverview React hooks for budget and expense management.
 *
 * Provides hooks for managing budgets, expenses, alerts, and currency conversion
 * with local state management and API synchronization.
 */
⋮----
import type {
  AddExpenseRequest,
  Budget,
  BudgetAlert,
  CreateBudgetAlertRequest,
  CreateBudgetRequest,
  Expense,
  UpdateBudgetRequest,
  UpdateExpenseRequest,
} from "@schemas/budget";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useEffect } from "react";
import { useAuthenticatedApi } from "@/hooks/use-authenticated-api";
import { type AppError, handleApiError } from "@/lib/api/error-types";
import { staleTimes } from "@/lib/query/config";
import { queryKeys } from "@/lib/query-keys";
import { useBudgetStore } from "@/stores/budget-store";
⋮----
/**
 * Hook for accessing budget store state.
 */
export function useBudget()
⋮----
/**
 * Hook for budget management actions.
 */
export function useBudgetActions()
⋮----
/**
 * Hook for expense management.
 *
 * @param budgetId - Optional budget ID to filter expenses
 */
export function useExpenses(budgetId?: string)
⋮----
/**
 * Hook for alerts management.
 *
 * @param budgetId - Optional budget ID to filter alerts
 */
export function useAlerts(budgetId?: string)
⋮----
// API hooks for server interaction
⋮----
/**
 * Hook for fetching all budgets for the current user.
 */
export function useFetchBudgets()
⋮----
// Convert array to record
⋮----
/**
 * Hook for fetching a single budget.
 *
 * @param id - Budget ID to fetch
 */
export function useFetchBudget(id: string)
⋮----
/**
 * Hook for creating a new budget.
 */
export function useCreateBudget()
⋮----
/**
 * Hook for updating a budget.
 */
export function useUpdateBudget()
⋮----
/**
 * Hook for deleting a budget.
 */
export function useDeleteBudget()
⋮----
/**
 * Hook for fetching expenses for a budget.
 *
 * @param budgetId - Budget ID to fetch expenses for
 */
export function useFetchExpenses(budgetId: string)
⋮----
/**
 * Hook for adding an expense.
 */
export function useAddExpense()
⋮----
/**
 * Hook for updating an expense.
 */
export function useUpdateExpense()
⋮----
/**
 * Hook for deleting an expense.
 */
export function useDeleteExpense()
⋮----
/**
 * Hook for fetching budget alerts.
 *
 * @param budgetId - Budget ID to fetch alerts for
 */
export function useFetchAlerts(budgetId: string)
⋮----
/**
 * Hook for creating a budget alert.
 */
export function useCreateAlert()
⋮----
/**
 * Hook for marking an alert as read.
 */
export function useMarkAlertAsRead()
⋮----
/**
 * Hook for fetching currency exchange rates.
 */
export function useFetchCurrencyRates()
⋮----
refetchInterval: 60 * 60 * 1000, // Refresh currency rates every hour
⋮----
// Transform response to match our store format
````

## File: src/hooks/use-currency.ts
````typescript
/**
 * @fileoverview React hooks for currency management and conversion.
 *
 * Provides hooks for managing currencies, exchange rates, and currency conversion
 * with local state management and API synchronization.
 */
⋮----
import type {
  ConversionResult,
  CurrencyCode,
  UpdateExchangeRatesResponse,
} from "@schemas/currency";
import { UPDATE_EXCHANGE_RATES_RESPONSE_SCHEMA } from "@schemas/currency";
import { useQuery } from "@tanstack/react-query";
import { useCallback, useEffect } from "react";
import { useAuthenticatedApi } from "@/hooks/use-authenticated-api";
import { type AppError, handleApiError, isApiError } from "@/lib/api/error-types";
import { staleTimes } from "@/lib/query/config";
import { queryKeys } from "@/lib/query-keys";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { useCurrencyStore } from "@/stores/currency-store";
⋮----
/**
 * React Query retry policy for currency fetches.
 *
 * @param failureCount - The number of consecutive failures so far.
 * @param error - Normalized application error for the failed request.
 * @returns True when the query should be retried, otherwise false.
 */
function shouldRetryCurrencyQuery(failureCount: number, error: AppError): boolean
⋮----
/**
 * Hook for accessing currency state.
 */
export function useCurrency()
⋮----
/**
 * Hook for currency management operations.
 */
export function useCurrencyActions()
⋮----
/**
 * Hook for exchange rate operations.
 */
export function useExchangeRates()
⋮----
/**
 * Hook for currency conversion operations.
 */
export function useCurrencyConverter()
⋮----
/**
 * Hook for getting currency data like recent pairs and popular currencies.
 */
export function useCurrencyData()
⋮----
/**
 * Hook for fetching exchange rates from API.
 */
export function useFetchExchangeRates()
⋮----
refetchInterval: 60 * 60 * 1000, // Refresh rates every hour
⋮----
// Validate the response
⋮----
/**
 * Hook for fetching a specific exchange rate.
 *
 * @param targetCurrency - Currency code to fetch rate for
 */
export function useFetchExchangeRate(targetCurrency: CurrencyCode)
````

## File: src/hooks/use-dashboard-metrics.ts
````typescript
/**
 * @fileoverview React hook for dashboard metrics data fetching.
 *
 * Uses @tanstack/react-query with automatic polling for fresh data.
 * Validates API responses with Zod schema for type safety.
 */
⋮----
import type { DashboardMetrics, TimeWindow } from "@schemas/dashboard";
import { dashboardMetricsSchema } from "@schemas/dashboard";
import { useQuery } from "@tanstack/react-query";
import { useAuthenticatedApi } from "@/hooks/use-authenticated-api";
import { staleTimes } from "@/lib/query/config";
import { queryKeys } from "@/lib/query-keys";
⋮----
/**
 * Options for the useDashboardMetrics hook.
 */
export interface UseDashboardMetricsOptions {
  /** Time window for metrics aggregation (default: "24h") */
  window?: TimeWindow;
  /** Enable/disable automatic polling (default: true) */
  polling?: boolean;
  /** Custom refetch interval in milliseconds (default: 30000) */
  refetchInterval?: number;
  /** Enable/disable the query (default: true) */
  enabled?: boolean;
}
⋮----
/** Time window for metrics aggregation (default: "24h") */
⋮----
/** Enable/disable automatic polling (default: true) */
⋮----
/** Custom refetch interval in milliseconds (default: 30000) */
⋮----
/** Enable/disable the query (default: true) */
⋮----
/**
 * Hook for fetching dashboard metrics with automatic polling.
 *
 * @param options - Configuration options for the hook
 * @returns Query result with metrics data, loading state, and error handling
 *
 * @example
 * ```tsx
 * const { data, isLoading, isError } = useDashboardMetrics({ window: "7d" });
 * ```
 */
export function useDashboardMetrics(options: UseDashboardMetricsOptions =
⋮----
// Validate response against schema for runtime type safety
````

## File: src/hooks/use-deals.ts
````typescript
/**
 * @fileoverview React hooks for deals management and filtering.
 *
 * Provides hooks for accessing deals, managing filters, saving deals,
 * and handling deal alerts with local state management.
 */
⋮----
import type { Deal, DealFilters, DealState, DealType } from "@schemas/deals";
import { useCallback, useEffect, useMemo } from "react";
import { groupBy, mapToUnique } from "@/lib/collection-utils";
import { useDealsStore } from "@/stores/deals-store";
⋮----
/**
 * Hook for accessing and managing deals.
 */
export function useDeals()
⋮----
// Initialize the store if not already initialized
⋮----
// Get all deals as array
⋮----
// Get filtered deals based on current filters
⋮----
// Get featured deals
⋮----
// Get saved deals
⋮----
// Get recently viewed deals
⋮----
// Get deal statistics
⋮----
// Utility to check if a deal is saved
⋮----
// Utility to check if a deal is featured
⋮----
// Filter by deal type
⋮----
// Toggle the type
⋮----
// Filter by destination
⋮----
// Toggle the destination
⋮----
// Set multiple filters at once
⋮----
// Sort deals by various criteria
⋮----
// Group deals by destination
⋮----
// Group deals by type
⋮----
// Get unique destinations
⋮----
// Get unique providers
⋮----
// Actions
⋮----
// Computed
⋮----
// State
⋮----
// Filtering & Sorting
⋮----
// Utilities
⋮----
// Checks
⋮----
// Reset
⋮----
/**
 * Custom hook for managing deal alerts
 */
export function useDealAlerts()
⋮----
// Get active alerts
⋮----
// Get alerts by type
⋮----
/**
 * Custom hook for featured deals
 */
export function useFeaturedDeals()
⋮----
// Sort featured deals by discount (highest first)
⋮----
// Get top deals (highest discount)
⋮----
// Toggle featured status
⋮----
/**
 * Custom hook for saved deals
 */
export function useSavedDeals()
⋮----
// Toggle saved status
⋮----
// Sort saved deals by expiry (soonest first)
⋮----
// Get deals expiring soon (within 3 days)
````

## File: src/hooks/use-error-handler.ts
````typescript
/**
 * @fileoverview React hook for error handling and reporting.
 *
 * Provides error handling utilities with automatic error reporting,
 * user context, and session tracking.
 */
⋮----
import { useCallback } from "react";
import { errorService } from "@/lib/error-service";
import { secureUuid } from "@/lib/security/random";
import { fireAndForget } from "@/lib/utils";
⋮----
// Extend Window interface for custom properties
⋮----
interface Window {
    userStore?: {
      user?: {
        id?: string;
      };
    };
  }
⋮----
/**
 * Hook for handling errors in React components with automatic reporting.
 *
 * Provides utilities for consistent error handling across the application,
 * including automatic error reporting, user context tracking, and session
 * information collection.
 *
 * @returns Object containing error handling functions
 */
export function useErrorHandler()
⋮----
// Create error report
⋮----
// Report error
⋮----
throw error; // Re-throw to allow component-level handling
⋮----
/**
 * Gets the current user ID from the user store.
 *
 * @returns User ID or undefined if not available
 */
function getUserId(): string | undefined
⋮----
/**
 * Gets or creates a session ID for error tracking.
 *
 * @returns Session ID or undefined if sessionStorage is unavailable
 */
function getSessionId(): string | undefined
````

## File: src/hooks/use-loading.ts
````typescript
/**
 * @fileoverview React hooks for managing loading states.
 *
 * Provides hooks for loading state management with timeout, progress tracking,
 * debouncing, and async operation handling.
 */
⋮----
import { useCallback, useEffect, useRef, useState } from "react";
⋮----
/**
 * Represents the current state of a loading operation.
 */
export interface UseLoadingState {
  /** Whether a loading operation is currently in progress. */
  isLoading: boolean;
  /** Optional message describing the current loading operation. */
  message?: string;
  /** Optional progress percentage (0-100) for the loading operation. */
  progress?: number;
  /** Optional error message if the loading operation failed. */
  error?: string;
}
⋮----
/** Whether a loading operation is currently in progress. */
⋮----
/** Optional message describing the current loading operation. */
⋮----
/** Optional progress percentage (0-100) for the loading operation. */
⋮----
/** Optional error message if the loading operation failed. */
⋮----
/**
 * Configuration options for the useLoading hook.
 */
export interface UseLoadingOptions {
  /** Whether loading should start immediately when the hook initializes. */
  initialLoading?: boolean;
  /** Initial message to display when loading starts. */
  initialMessage?: string;
  /** Timeout in milliseconds after which loading automatically stops. */
  timeout?: number;
  /** Callback function called when the timeout expires. */
  onTimeout?: () => void;
}
⋮----
/** Whether loading should start immediately when the hook initializes. */
⋮----
/** Initial message to display when loading starts. */
⋮----
/** Timeout in milliseconds after which loading automatically stops. */
⋮----
/** Callback function called when the timeout expires. */
⋮----
/**
 * Return type of the useLoading hook containing state and control functions.
 */
export interface UseLoadingReturn {
  /** Whether a loading operation is currently in progress. */
  isLoading: boolean;
  /** Current loading message. */
  message?: string;
  /** Current progress percentage (0-100). */
  progress?: number;
  /** Current error message, if any. */
  error?: string;
  /** Starts a loading operation with an optional message. */
  startLoading: (message?: string) => void;
  /** Stops the current loading operation. */
  stopLoading: () => void;
  /** Sets the progress percentage (clamped between 0-100). */
  setProgress: (progress: number) => void;
  /** Sets the loading message. */
  setMessage: (message: string) => void;
  /** Sets an error message and stops loading. */
  setError: (error: string) => void;
  /** Clears the current error message. */
  clearError: () => void;
  /** Resets all loading state to initial values. */
  reset: () => void;
}
⋮----
/** Whether a loading operation is currently in progress. */
⋮----
/** Current loading message. */
⋮----
/** Current progress percentage (0-100). */
⋮----
/** Current error message, if any. */
⋮----
/** Starts a loading operation with an optional message. */
⋮----
/** Stops the current loading operation. */
⋮----
/** Sets the progress percentage (clamped between 0-100). */
⋮----
/** Sets the loading message. */
⋮----
/** Sets an error message and stops loading. */
⋮----
/** Clears the current error message. */
⋮----
/** Resets all loading state to initial values. */
⋮----
/**
 * Hook for managing loading states with optional timeout.
 *
 * @param options - Configuration options
 * @returns Loading state and control functions
 */
export function useLoading(options: UseLoadingOptions =
⋮----
// Clear timeout on unmount
⋮----
// Set timeout if specified
⋮----
/**
 * Return type of the useAsyncLoading hook for managing async operations.
 *
 * @template T - The return type of the async function
 * @template P - The parameters tuple type of the async function
 */
export interface UseAsyncLoadingReturn<
  T,
  P extends readonly unknown[] = readonly unknown[],
> {
  /** The result data from the last successful async operation. */
  data?: T;
  /** Whether an async operation is currently in progress. */
  isLoading: boolean;
  /** Error message from the last failed async operation. */
  error?: string;
  /** Executes the async function with the provided arguments. */
  execute: (...args: P) => Promise<T>;
  /** Resets the hook state to initial values. */
  reset: () => void;
}
⋮----
/** The result data from the last successful async operation. */
⋮----
/** Whether an async operation is currently in progress. */
⋮----
/** Error message from the last failed async operation. */
⋮----
/** Executes the async function with the provided arguments. */
⋮----
/** Resets the hook state to initial values. */
⋮----
export function useAsyncLoading<T, P extends readonly unknown[]>(
  asyncFn: (...args: P) => Promise<T>
): UseAsyncLoadingReturn<T, P>
⋮----
/**
 * Hook for managing loading state with debounced start/stop operations.
 *
 * Useful for preventing rapid loading state changes in response to frequent
 * user interactions. Both start and stop operations are debounced by the
 * specified delay.
 *
 * @param delay - Debounce delay in milliseconds (default: 300)
 * @returns Loading state with debounced start/stop functions
 */
export function useDebouncedLoading(delay = 300): UseLoadingReturn
````

## File: src/hooks/use-memory.ts
````typescript
/**
 * @fileoverview React hooks for memory and conversation management.
 *
 * Provides hooks for managing user memories, conversation context, search,
 * insights, and memory statistics.
 */
⋮----
import type {
  AddConversationMemoryRequest,
  AddConversationMemoryResponse,
  DeleteUserMemoriesResponse,
  MemoryContextResponse,
  MemoryInsightsResponse,
  SearchMemoriesRequest,
  SearchMemoriesResponse,
  UpdatePreferencesRequest,
  UpdatePreferencesResponse,
} from "@schemas/memory";
import { useMutation, useQuery } from "@tanstack/react-query";
import { useAuthenticatedApi } from "@/hooks/use-authenticated-api";
import { type AppError, handleApiError } from "@/lib/api/error-types";
import { staleTimes } from "@/lib/query/config";
import { queryKeys } from "@/lib/query-keys";
⋮----
/**
 * Hook for fetching user memory context.
 *
 * @param userId - User ID to fetch memory context for
 * @param enabled - Whether the query should run (default: true)
 */
export function useMemoryContext(userId: string, enabled = true)
⋮----
gcTime: 10 * 60 * 1000, // 10 minutes
⋮----
/**
 * Hook for searching user memories.
 */
export function useSearchMemories()
⋮----
/**
 * Hook for updating user preferences.
 *
 * @param userId - User ID to update preferences for
 */
export function useUpdatePreferences(userId: string)
⋮----
/**
 * Hook for getting memory insights.
 *
 * @param userId - User ID to fetch insights for
 * @param enabled - Whether the query should run (default: true)
 */
export function useMemoryInsights(userId: string, enabled = true)
⋮----
gcTime: 30 * 60 * 1000, // 30 minutes
⋮----
/**
 * Hook for adding conversation memory.
 */
export function useAddConversationMemory()
⋮----
/**
 * Hook for deleting user memories.
 *
 * @param userId - User ID to delete memories for
 */
export function useDeleteUserMemories(userId: string)
⋮----
/**
 * Hook for getting memory statistics.
 *
 * @param userId - User ID to fetch stats for
 * @param enabled - Whether the query should run (default: true)
 */
export function useMemoryStats(userId: string, enabled = true)
⋮----
gcTime: 30 * 60 * 1000, // 30 minutes
````

## File: src/hooks/use-performance.ts
````typescript
/**
 * @fileoverview React hooks for performance monitoring.
 *
 * Provides hooks for measuring page load times, component render times,
 * and web vitals tracking.
 */
⋮----
import { useCallback, useEffect, useRef, useState } from "react";
import type { Metric } from "web-vitals";
⋮----
interface PerformanceMetrics {
  loadTime: number;
  renderTime: number;
  bundleSize: number;
  isHydrated: boolean;
}
⋮----
/**
 * Hook for measuring page performance metrics.
 *
 * Tracks load time, render time, bundle size, and hydration status.
 *
 * @returns Performance metrics object
 */
export function usePerformance()
⋮----
// Check if performance API is available
⋮----
// Measure initial load time using Navigation Timing L2
⋮----
// Page load not complete yet - use current time as approximation
⋮----
// Measure render time
⋮----
// Estimate bundle size from network requests
⋮----
// Development-only performance logging for local debugging
⋮----
/**
 * Hook to measure component render time.
 *
 * Logs render time to console in development mode only.
 *
 * @param componentName - Name of the component for logging
 */
export function useComponentPerformance(componentName: string)
⋮----
// No-op handler for web vitals - metrics are tracked but not logged
const noOpVitalsHandler: (metric: Metric) => void = () =>
⋮----
// Web vitals are captured but not logged to console
// Override this with a custom handler for analytics integration
⋮----
/**
 * Hook to report Web Vitals metrics.
 *
 * Dynamically imports and initializes web-vitals library to track
 * Core Web Vitals (CLS, INP, FCP, LCP, TTFB).
 *
 * @param handler - Optional custom handler for web vitals metrics (e.g., for analytics)
 */
export function useWebVitals(handler?: (metric: Metric) => void)
⋮----
// Dynamically import web-vitals to avoid increasing bundle size
⋮----
// Silently fail if web-vitals is not available
````

## File: src/hooks/use-trips.ts
````typescript
/**
 * @fileoverview Unified React hooks for trip-related API operations including CRUD
 * operations, suggestions, real-time updates, and flight data fetching with proper
 * error handling and caching.
 */
⋮----
import type {
  TripCreateInput,
  TripFilters,
  TripSuggestion,
  TripUpdateInput,
  UiTrip,
} from "@schemas/trips";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { useCallback, useMemo } from "react";
import {
  type PostgresChangesSubscription,
  usePostgresChangesChannel,
} from "@/hooks/supabase/use-realtime-channel";
import { useAuthenticatedApi } from "@/hooks/use-authenticated-api";
import { type AppError, handleApiError } from "@/lib/api/error-types";
import { cacheTimes, staleTimes } from "@/lib/query/config";
import { queryKeys } from "@/lib/query-keys";
import { type TypedSupabaseClient, useSupabaseRequired } from "@/lib/supabase";
import type { UpdateTables } from "@/lib/supabase/database.types";
⋮----
/** Trip type alias using canonical schema from @schemas/trips. */
export type Trip = UiTrip;
⋮----
/** Re-export TripSuggestion type for convenience. */
⋮----
/** Parameters for fetching trip suggestions. */
interface TripSuggestionsParams {
  /** Maximum number of suggestions to return. */
  readonly limit?: number;
  /** Maximum budget constraint. */
  readonly budgetMax?: number;
  /** Category filter for suggestions. */
  readonly category?: string;
}
⋮----
/** Maximum number of suggestions to return. */
⋮----
/** Maximum budget constraint. */
⋮----
/** Category filter for suggestions. */
⋮----
/**
 * Hook to fetch trip suggestions from the API with enhanced caching.
 *
 * @param params Optional parameters for filtering and limiting suggestions.
 * @returns Query object containing trip suggestions data, loading state, and error state.
 */
export function useTripSuggestions(params?: TripSuggestionsParams)
⋮----
/**
 * Hook to create a new trip with optimistic updates.
 *
 * @returns Mutation object for creating trips with loading state and error handling.
 */
export function useCreateTrip()
⋮----
// Invalidate and refetch trips lists
⋮----
// Optionally invalidate suggestions if they might be affected
⋮----
type TripTableUpdate = Omit<UpdateTables<"trips">, "id">;
⋮----
/** Data structure for updating a trip. */
export type UpdateTripData = TripUpdateInput & TripTableUpdate;
⋮----
/**
 * Hook to update an existing trip.
 *
 * @returns Mutation object for updating trips with loading state and error handling.
 */
export function useUpdateTrip()
⋮----
// Invalidate specific trip and trips list
⋮----
/**
 * Hook to delete a trip.
 *
 * @returns Mutation object for deleting trips with loading state and error handling.
 */
export function useDeleteTrip()
⋮----
// Invalidate specific trip and trips list
⋮----
/**
 * Converts filter values to API-compatible parameters.
 *
 * @param filters Optional filter object to convert.
 * @returns API parameters object or undefined if no filters provided.
 */
const convertToApiParams = (
  filters?: Record<string, unknown>
): Record<string, string | number | boolean> | undefined =>
⋮----
// Convert other types to string
⋮----
/**
 * Real-time connection status for trip subscriptions.
 */
interface TripRealtimeStatus {
  /** Whether the real-time connection is active. */
  isConnected: boolean;
  /** Array of connection errors encountered. */
  errors: Error[];
}
⋮----
/** Whether the real-time connection is active. */
⋮----
/** Array of connection errors encountered. */
⋮----
function useCurrentUserId(supabase: TypedSupabaseClient): string | null
⋮----
gcTime: 30 * 60 * 1000, // 30 minutes
⋮----
/**
 * Hook to get user's trips with enhanced error handling and real-time updates.
 *
 * @param filters Optional filters to apply to the trip query.
 * @returns Query object containing trips data, loading state, error state,
 * and real-time connection status.
 */
export function useTrips(filters?: TripFilters)
⋮----
/**
 * Hook to fetch a single trip by ID with real-time updates.
 *
 * @param tripId The ID of the trip to fetch, or null/undefined to skip fetching.
 * @returns Query object containing trip data, loading state, error state,
 * and real-time connection status.
 */
export function useTrip(tripId: string | number | null | undefined)
⋮----
/** Represents an upcoming flight with detailed information. */
export interface UpcomingFlight {
  /** Unique identifier for the flight. */
  readonly id: string;
  /** Associated trip identifier if this flight is part of a trip. */
  readonly tripId?: string;
  /** Name of the associated trip. */
  readonly tripName?: string;
  /** Airline code (e.g., "AA", "DL"). */
  readonly airline: string;
  /** Full airline name. */
  readonly airlineName: string;
  /** Flight number (e.g., "AA123"). */
  readonly flightNumber: string;
  /** Departure airport code. */
  readonly origin: string;
  /** Arrival airport code. */
  readonly destination: string;
  /** Scheduled departure time in ISO format. */
  readonly departureTime: string;
  /** Scheduled arrival time in ISO format. */
  readonly arrivalTime: string;
  /** Flight duration in minutes. */
  readonly duration: number;
  /** Number of stops during the flight. */
  readonly stops: number;
  /** Ticket price. */
  readonly price: number;
  /** Currency code for the price. */
  readonly currency: string;
  /** Cabin class (e.g., "economy", "business", "first"). */
  readonly cabinClass: string;
  /** Number of seats still available. */
  readonly seatsAvailable?: number;
  /** Current flight status. */
  readonly status: "upcoming" | "boarding" | "delayed" | "cancelled";
  /** Departure terminal. */
  readonly terminal?: string;
  /** Departure gate. */
  readonly gate?: string;
}
⋮----
/** Unique identifier for the flight. */
⋮----
/** Associated trip identifier if this flight is part of a trip. */
⋮----
/** Name of the associated trip. */
⋮----
/** Airline code (e.g., "AA", "DL"). */
⋮----
/** Full airline name. */
⋮----
/** Flight number (e.g., "AA123"). */
⋮----
/** Departure airport code. */
⋮----
/** Arrival airport code. */
⋮----
/** Scheduled departure time in ISO format. */
⋮----
/** Scheduled arrival time in ISO format. */
⋮----
/** Flight duration in minutes. */
⋮----
/** Number of stops during the flight. */
⋮----
/** Ticket price. */
⋮----
/** Currency code for the price. */
⋮----
/** Cabin class (e.g., "economy", "business", "first"). */
⋮----
/** Number of seats still available. */
⋮----
/** Current flight status. */
⋮----
/** Departure terminal. */
⋮----
/** Departure gate. */
⋮----
/** Parameters for fetching upcoming flights. */
interface UpcomingFlightsParams {
  /** Maximum number of flights to return. */
  readonly limit?: number;
}
⋮----
/** Maximum number of flights to return. */
⋮----
/**
 * Hook to fetch upcoming flights from the API with enhanced real-time handling.
 *
 * @param params Optional parameters for limiting flight results.
 * @returns Query object containing upcoming flights data with real-time updates.
 */
export function useUpcomingFlights(params?: UpcomingFlightsParams)
⋮----
gcTime: cacheTimes.short, // 5 minutes
⋮----
refetchInterval: 2 * 60 * 1000, // Refetch every 2 minutes for fresh flight data
refetchIntervalInBackground: false, // Only when page is visible
staleTime: staleTimes.realtime, // 30 seconds for real-time flight data
````

## File: src/lib/activities/booking.ts
````typescript
/**
 * @fileoverview Activity booking helpers.
 *
 * Provides external booking link resolution and minimal booking flow support.
 */
⋮----
import type { Activity } from "@schemas/search";
⋮----
/** Structured attributes carried with booking telemetry events. */
type TelemetryAttributes = Record<string, string | number | boolean>;
⋮----
/** Known booking domains to prioritize in URL extraction. */
⋮----
/** Regular expression to match valid HTTP/HTTPS URLs, excluding trailing punctuation. */
⋮----
/** Activity type with optional metadata field. */
type ActivityWithMetadata = Activity & { metadata?: unknown };
⋮----
/**
 * Return true when hostname is an IPv4/IPv6 literal (blocks all IP-based hosts).
 *
 * @param hostname Hostname string from a parsed URL.
 * @returns True if hostname is any IP literal.
 */
function isIpAddressHost(hostname: string): boolean
⋮----
const isValidIpv4 = (value: string): boolean =>
⋮----
const isValidIpv6 = (value: string): boolean =>
⋮----
/**
 * Validate a URL string and return a URL object if valid.
 *
 * @param candidate URL string to validate.
 * @returns URL object if valid, null otherwise.
 */
function validateUrl(candidate: string): URL | null
⋮----
/**
 * Return true if hostname matches a known booking domain or its subdomain.
 *
 * @param hostname Hostname to evaluate.
 * @returns True when hostname is within the booking allowlist.
 */
function hasKnownBookingDomain(hostname: string): boolean
⋮----
/**
 * Extract valid http/https URLs from freeform text.
 *
 * @param text Source text to scan.
 * @returns Array of normalized URLs.
 */
function extractUrlsFromText(text?: string): string[]
⋮----
/**
 * Extract and validate a booking-like URL from activity metadata.
 *
 * @param metadata Activity metadata object.
 * @returns First valid URL or null.
 */
function extractMetadataUrl(metadata: unknown): string | null
⋮----
/**
 * Choose best URL preferring known booking hosts; fall back to first valid.
 *
 * @param candidates Candidate URL strings.
 * @returns Selected URL or null.
 */
function pickBestUrl(candidates: string[]): string | null
⋮----
/**
 * Build a Google Maps search URL from coordinates or name/location as fallback.
 *
 * @param activity Activity containing coordinates or name/location.
 * @returns A Google Maps search URL or null.
 */
function buildMapSearchUrl(activity: ActivityWithMetadata): string | null
⋮----
/**
 * Emit booking telemetry via API endpoint.
 *
 * This module is imported by client components, so we always use the API
 * endpoint approach to avoid importing server-only telemetry modules.
 */
async function recordBookingEvent(
  eventName: string,
  attributes?: TelemetryAttributes,
  level: "info" | "warning" | "error" = "info"
): Promise<void>
⋮----
// Always use API endpoint for telemetry (works client and server-side).
// This avoids importing server-only modules in client component bundles.
⋮----
// Prefer sendBeacon in browser for fire-and-forget reliability
⋮----
// Fallback to fetch (works in Node.js and browsers without sendBeacon).
// Use NEXT_PUBLIC_APP_URL only (public) so this stays client-bundle-safe.
⋮----
// Telemetry is best-effort; ignore failures.
⋮----
/**
 * Resolves an external booking URL for an activity.
 *
 * For Google Places activities, returns Google Maps place URL.
 * For AI fallback activities, attempts to extract URL from activity data.
 *
 * @param activity - Activity to get booking URL for.
 * @returns External booking URL or null if unavailable.
 */
export function getActivityBookingUrl(activity: ActivityWithMetadata): string | null
⋮----
/* telemetry is best-effort */
⋮----
/* telemetry is best-effort */
⋮----
/* telemetry is best-effort */
⋮----
/* telemetry is best-effort */
⋮----
/* telemetry is best-effort */
⋮----
/**
 * Opens external booking link for an activity.
 *
 * @param activity - Activity to book.
 * @returns True if URL was opened, false if unavailable.
 */
export function openActivityBooking(activity: ActivityWithMetadata): boolean
````

## File: src/lib/agents/config-resolver.ts
````typescript
/**
 * @fileoverview Agent configuration resolver backed by Supabase with Upstash cache.
 * Fetches configuration for a given agent type and scope, validates via Zod,
 * and caches the result with cache-tag versioning for fast reuse across agents.
 */
⋮----
import type { AgentConfig, AgentType } from "@schemas/configuration";
import { configurationAgentConfigSchema } from "@schemas/configuration";
import { versionedKey } from "@/lib/cache/tags";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import { createAdminSupabase } from "@/lib/supabase/admin";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { recordTelemetryEvent, withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
const CACHE_TTL_SECONDS = 15 * 60; // 15 minutes
⋮----
export type ResolvedAgentConfig = {
  config: AgentConfig;
  versionId: string;
};
⋮----
export type ResolveAgentConfigOptions = {
  scope?: string;
  supabase?: TypedServerSupabase;
  cacheTtlSeconds?: number;
};
⋮----
/**
 * Resolve an agent configuration with cache + Supabase fallback.
 *
 * @param agentType Canonical agent type identifier.
 * @param options Optional resolver overrides.
 * @returns Parsed configuration and active version id.
 */
export async function resolveAgentConfig(
  agentType: AgentType,
  options: ResolveAgentConfigOptions = {}
): Promise<ResolvedAgentConfig>
⋮----
// Use admin client to bypass RLS for agent config lookup
// Agent configs are protected by RLS and require admin privileges
````

## File: src/lib/agents/error-recovery.ts
````typescript
/**
 * @fileoverview Error recovery adapter for agent tool execution.
 *
 * Maps common tool/HTTP errors to user-friendly messages and provides
 * error handlers for AI SDK v6 streaming responses.
 *
 * Handles AI SDK specific errors:
 * - NoSuchToolError: Model tried to call an unknown tool
 * - InvalidToolInputError: Model provided invalid tool arguments
 */
⋮----
import { InvalidToolInputError, NoSuchToolError } from "ai";
⋮----
/**
 * Common error codes from agent tool execution.
 */
export enum AgentErrorCode {
  RateLimitExceeded = "rate_limit_exceeded",
  Unauthorized = "unauthorized",
  ValidationError = "validation_error",
  ToolNotFound = "tool_not_found",
  InvalidToolInput = "invalid_tool_input",
  ToolExecutionFailed = "tool_execution_failed",
  ProviderError = "provider_error",
  NetworkError = "network_error",
  Timeout = "timeout",
  Unknown = "unknown",
}
⋮----
function detectErrorType(message: string): AgentErrorCode | null
⋮----
/**
 * Map error to user-friendly message.
 *
 * Analyzes error message and type to determine appropriate user-facing
 * message. Handles AI SDK v6 specific errors (NoSuchToolError, InvalidToolInputError).
 *
 * @param error Error instance or message string.
 * @returns User-friendly error message.
 */
export function mapErrorToMessage(error: unknown): string
⋮----
// Handle AI SDK v6 specific errors first
⋮----
/**
 * Classify error into AgentErrorCode.
 *
 * Used for telemetry and error tracking.
 *
 * @param error Error to classify.
 * @returns AgentErrorCode classification.
 */
export function classifyError(error: unknown): AgentErrorCode
⋮----
/**
 * Create error handler for AI SDK v6 streaming responses.
 *
 * Returns a function that maps errors to user-friendly messages for
 * display in the UI. Handles AI SDK specific errors (NoSuchToolError,
 * InvalidToolInputError) as well as common HTTP/network errors.
 *
 * @returns Error handler function for use with toUIMessageStreamResponse.
 *
 * @example
 * ```typescript
 * const result = streamText({
 *   model: provider.model,
 *   messages: convertToModelMessages(messages),
 *   tools: myTools,
 * });
 *
 * return result.toUIMessageStreamResponse({
 *   onError: createErrorHandler(),
 * });
 * ```
 */
export function createErrorHandler(): (error: unknown) => string
⋮----
/**
 * Create error handler with telemetry callback.
 *
 * Logs errors to telemetry before returning user-friendly message.
 *
 * @param onError Optional callback for telemetry/logging.
 * @returns Error handler function.
 *
 * @example
 * ```typescript
 * return result.toUIMessageStreamResponse({
 *   onError: createErrorHandlerWithTelemetry((error, code) => {
 *     logger.error('Stream error', { code, error: String(error) });
 *   }),
 * });
 * ```
 */
export function createErrorHandlerWithTelemetry(
  onError?: (error: unknown, code: AgentErrorCode) => void
): (error: unknown) => string
````

## File: src/lib/api/guards/multipart.ts
````typescript
/**
 * @fileoverview Multipart form data validation utilities.
 *
 * Provides canonical helpers for validating and extracting files from multipart
 * form data, consistent with the error handling pattern used in route-helpers.
 */
⋮----
import type { MultipartValidationOptions } from "@schemas/api";
import type { NextResponse } from "next/server";
import { errorResponse } from "@/lib/api/route-helpers";
⋮----
/**
 * Result of multipart validation: either validated files or an error response.
 */
export type MultipartValidationResult = { data: File[] } | { error: NextResponse };
⋮----
/**
 * Validates and extracts files from multipart form data.
 *
 * Canonical helper for route handlers to validate multipart uploads with
 * consistent error responses. Returns validated files or error response.
 *
 * @param formData - FormData object containing files
 * @param options - Validation options
 * @returns Validation result with files or error response
 *
 * @example
 * ```typescript
 * import { FILE_COUNT_LIMITS, FILE_SIZE_LIMITS } from "@schemas/api";
 *
 * const validation = validateMultipart(formData, {
 *   maxSize: FILE_SIZE_LIMITS.STANDARD,
 *   maxFiles: FILE_COUNT_LIMITS.STANDARD,
 * });
 *
 * if ("error" in validation) {
 *   return validation.error;
 * }
 * const files = validation.data;
 * ```
 */
export function validateMultipart(
  formData: FormData,
  options: MultipartValidationOptions
): MultipartValidationResult
````

## File: src/lib/auth/actions.ts
````typescript
/**
 * @fileoverview Server actions for authentication.
 */
⋮----
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { createServerSupabase } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/**
 * Signs the user out and redirects to the login page.
 */
export async function logoutAction(): Promise<never>
````

## File: src/lib/auth/redirect.ts
````typescript
/**
 * @fileoverview Safe redirect URL resolver for auth flows.
 */
⋮----
import { getClientOrigin } from "@/lib/url/client-origin";
⋮----
/** Gets the base origin. */
function getBaseOrigin(): string
⋮----
/**
 * Resolves the redirect URL.
 *
 * @param redirectTo - The redirect URL.
 * @param options - Resolution options.
 * @returns The resolved redirect URL.
 */
export function resolveRedirectUrl(
  redirectTo?: string,
  options?: { absolute?: boolean }
): string
⋮----
// Block protocol-relative URLs
⋮----
// Preserve relative paths while normalizing
⋮----
// ignore malformed env URLs
⋮----
/** The fallback redirect URL. */
````

## File: src/lib/auth/server.ts
````typescript
/**
 * @fileoverview Server-side auth helpers for Next.js App Router.
 *
 * Provides `requireUser` and `getOptionalUser` helpers that wrap the Supabase
 * SSR client and unified getCurrentUser helper. These are intended for use in
 * Server Components, Route Handlers, and Server Actions.
 */
⋮----
import { AUTH_USER_PREFERENCES_SCHEMA, type AuthUser } from "@schemas/stores";
import type { User } from "@supabase/supabase-js";
import { redirect } from "next/navigation";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { createServerSupabase, getCurrentUser } from "@/lib/supabase/server";
⋮----
export interface AuthContext {
  supabase: TypedServerSupabase;
  user: User;
}
⋮----
export interface OptionalAuthContext {
  supabase: TypedServerSupabase;
  user: User | null;
}
⋮----
/**
 * Maps a Supabase `User` into the frontend `AuthUser` shape.
 *
 * Uses user_metadata fields when present and falls back to email-derived
 * display names where appropriate.
 *
 * @param user - Supabase Auth user
 * @returns Mapped AuthUser object
 */
export function mapSupabaseUserToAuthUser(user: User): AuthUser
⋮----
/**
 * Returns the current user if present, or null when unauthenticated.
 *
 * @returns Supabase client and optional user
 */
export async function getOptionalUser(): Promise<OptionalAuthContext>
⋮----
/**
 * Returns the current authenticated user or redirects to /login when missing.
 *
 * @param options Optional redirect configuration
 * @returns Supabase client and authenticated user
 */
export async function requireUser(
  options: { redirectTo?: string } = {}
): Promise<AuthContext>
````

## File: src/lib/cache/hash.ts
````typescript
/**
 * @fileoverview Shared cache key hashing utilities.
 *
 * Provides consistent SHA-256 hashing for cache keys across tools and agents.
 */
⋮----
import { createHash } from "node:crypto";
⋮----
/**
 * Hash input data using SHA-256 and return first 16 hex characters.
 *
 * Used for creating deterministic cache key suffixes from complex input objects.
 * The 16-character hash provides sufficient uniqueness while keeping keys readable.
 *
 * @param input - Value to hash (will be JSON-stringified).
 * @returns First 16 hex characters of SHA-256 hash.
 */
export function hashInputForCache(input: unknown): string
````

## File: src/lib/cache/keys.ts
````typescript
/**
 * @fileoverview Cache key generation utilities for consistent key canonicalization.
 *
 * Ensures cache keys are deterministic by sorting and normalizing input
 * parameters. Handles arrays, primitives, and filters null/undefined values.
 *
 * @example
 * ```ts
 * // Same filters in different order produce same key
 * canonicalizeParamsForCache({ status: "active", limit: 10 }, "trips");
 * // => "trips:limit:10|status:active"
 *
 * canonicalizeParamsForCache({ limit: 10, status: "active" }, "trips");
 * // => "trips:limit:10|status:active" (same result)
 * ```
 */
⋮----
/**
 * Canonicalizes parameters into a deterministic cache key string.
 *
 * Keys are sorted alphabetically, values are lowercased, arrays are
 * sorted and joined with commas. Null/undefined values are omitted.
 *
 * @param params - Parameters object to canonicalize.
 * @param prefix - Optional prefix prepended with colon separator.
 * @returns Canonical cache key string.
 *
 * @example
 * ```ts
 * // Basic usage
 * canonicalizeParamsForCache({ destination: "Paris", status: "planning" });
 * // => "destination:paris|status:planning"
 *
 * // With prefix
 * canonicalizeParamsForCache({ status: "active" }, "trips:user-123");
 * // => "trips:user-123:status:active"
 *
 * // Array values
 * canonicalizeParamsForCache({ tags: ["beach", "adventure"] });
 * // => "tags:adventure,beach" (sorted)
 *
 * // Null/undefined filtered
 * canonicalizeParamsForCache({ status: "active", limit: undefined });
 * // => "status:active"
 * ```
 */
export function canonicalizeParamsForCache(
  params: Record<string, unknown>,
  prefix = ""
): string
````

## File: src/lib/cache/next-cache.ts
````typescript
/**
 * @fileoverview Next.js Cache Components helpers for public endpoints.
 *
 * IMPORTANT: Do NOT use "use cache" in modules that access:
 * - cookies() or headers()
 * - params or searchParams
 * - supabase.auth.getUser() or any auth state
 *
 * For auth-protected routes, use Upstash Redis caching instead.
 * See: docs/development/backend/cache-versioned-keys.md
 *
 * Currently, no routes in this codebase qualify for Cache Components because
 * all data routes are auth-protected. This module provides infrastructure
 * for future public endpoints that may benefit from HTTP-level caching.
 */
⋮----
import { cacheLife, cacheTag } from "next/cache";
⋮----
/**
 * Pre-configured cache profiles aligned with existing Redis TTLs.
 *
 * Usage in public server components/functions:
 * ```
 * "use cache";
 * import { applyCacheProfile, nextCacheTags } from "@/lib/cache/next-cache";
 *
 * export async function getPublicData() {
 *   applyCacheProfile("hour", nextCacheTags.publicConfig);
 *   return await fetchData();
 * }
 * ```
 *
 * @param profile - Cache duration profile
 * @param tag - Cache tag for invalidation via revalidateTag()
 */
export function applyCacheProfile(
  profile: "short" | "hour" | "long",
  tag: NextCacheTag
): void
⋮----
cacheLife("minutes"); // ~5 min
⋮----
cacheLife("days"); // ~24 hours
⋮----
/**
 * Constants for Next.js cache tags.
 *
 * Use revalidateTag() with these to invalidate HTTP-level caches.
 * For Upstash Redis cache invalidation, use bumpTag() from @/lib/cache/tags.
 *
 * @example
 * ```
 * import { revalidateTag } from "next/cache";
 * import { nextCacheTags } from "@/lib/cache/next-cache";
 *
 * // Invalidate public destinations cache
 * revalidateTag(nextCacheTags.popularDestinationsGlobal);
 * ```
 */
⋮----
/** Global popular destinations (unauthenticated variant) */
⋮----
/** Public configuration data */
⋮----
/** Type for available cache tags */
export type NextCacheTag = (typeof nextCacheTags)[keyof typeof nextCacheTags];
````

## File: src/lib/cache/registry.ts
````typescript
// biome-ignore-all lint/style/useNamingConvention: Keys match Supabase table names (snake_case)
⋮----
/**
 * @fileoverview Cache tag registry for database table to cache tag mappings.
 *
 * Centralizes cache invalidation logic to avoid hardcoded mappings scattered
 * across handlers. Edit this file to add/modify cache relationships.
 *
 * @see SPEC-0021 for the full webhook flow mapping table
 */
⋮----
// ===== REGISTRY =====
⋮----
/**
 * Cache tag registry mapping database tables to their cache tags.
 *
 * When a table changes, all associated tags should have their version bumped.
 * Tags are used to compose cache keys as `tag:v{version}:{key}`.
 *
 * Note: Keys use snake_case to match Supabase table naming convention.
 *
 * @see src/lib/cache/tags.ts for bumpTags and getTagVersion functions
 */
⋮----
// Accommodation-related tables
⋮----
// Chat/memory tables
⋮----
// File attachments
⋮----
// Flight-related tables
⋮----
// Search result tables
⋮----
// Trip-related tables
⋮----
// User-related tables
⋮----
/**
 * Type for valid cache table names.
 */
export type CacheTable = keyof typeof CACHE_TAG_REGISTRY;
⋮----
/**
 * Default tags used when a table is not in the registry.
 * These are generic catch-all tags for unknown tables.
 */
⋮----
// ===== EXPORTS =====
⋮----
/**
 * Get cache tags for a database table.
 *
 * Returns the registered tags for known tables, or default tags for unknown tables.
 * This is the primary interface for cache invalidation handlers.
 *
 * @param table - Database table name
 * @returns Array of cache tags to invalidate
 *
 * @example
 * ```ts
 * const tags = getTagsForTable("trips");
 * // => ["trip", "user_trips", "trip_search", "search", "search_cache"]
 *
 * const unknown = getTagsForTable("unknown_table");
 * // => ["search", "cache"]
 * ```
 */
export function getTagsForTable(table: string): string[]
⋮----
/**
 * Check if a table is registered in the cache tag registry.
 *
 * @param table - Database table name to check
 * @returns true if the table has registered cache tags
 */
export function isRegisteredTable(table: string): table is CacheTable
⋮----
/**
 * Get all registered table names.
 *
 * @returns Array of all registered table names
 */
export function getRegisteredTables(): CacheTable[]
⋮----
/**
 * Get all unique cache tags from the registry.
 *
 * @returns Array of all unique cache tags
 */
export function getAllCacheTags(): string[]
````

## File: src/lib/cache/tags.ts
````typescript
/**
 * @fileoverview Cache tag versioning for fine-grained invalidation.
 *
 * Implements a version-based cache invalidation strategy using Redis.
 * Each tag has a monotonically increasing version number. Cache keys
 * include the version, so bumping a tag's version effectively
 * invalidates all entries associated with that tag.
 *
 * @example
 * ```ts
 * // Create versioned cache key
 * const key = await versionedKey("trips", "user:123:list");
 * // => "trips:v1:user:123:list"
 *
 * // After bumping the tag version
 * await bumpTag("trips");
 * const newKey = await versionedKey("trips", "user:123:list");
 * // => "trips:v2:user:123:list" (new version, cache miss)
 * ```
 */
⋮----
import { getRedis } from "@/lib/redis";
import { warnRedisUnavailable } from "@/lib/telemetry/redis";
⋮----
/** Redis feature identifier for telemetry. */
⋮----
/** Namespace prefix for tag version keys. */
⋮----
/**
 * Acquires Redis client with telemetry warning on unavailability.
 *
 * @returns Redis client or undefined if unavailable.
 */
function acquireRedis()
⋮----
/**
 * Gets the current version number for a cache tag.
 *
 * Returns 1 if tag doesn't exist or Redis is unavailable,
 * providing a safe default for cache key generation.
 *
 * @param tag - Cache tag name (e.g., "trips", "attachments").
 * @returns Current version number (>= 1).
 *
 * @example
 * ```ts
 * const version = await getTagVersion("trips");
 * // => 1 (initial) or higher after bumps
 * ```
 */
export async function getTagVersion(tag: string): Promise<number>
⋮----
/**
 * Increments a cache tag's version number.
 *
 * All cache entries using this tag in their versioned key will
 * effectively become stale (cache miss on next read).
 *
 * @param tag - Cache tag name to bump.
 * @returns New version number.
 *
 * @example
 * ```ts
 * // On trip creation, invalidate trips cache
 * await bumpTag("trips");
 * ```
 */
export async function bumpTag(tag: string): Promise<number>
⋮----
/**
 * Increments version numbers for multiple cache tags.
 *
 * Efficient batch invalidation when an operation affects multiple
 * cache categories.
 *
 * @param tags - Array of cache tag names to bump.
 * @returns Map of tag names to their new version numbers.
 *
 * @example
 * ```ts
 * // Invalidate multiple related caches
 * const versions = await bumpTags(["trips", "itineraries", "suggestions"]);
 * // => { trips: 2, itineraries: 1, suggestions: 3 }
 * ```
 */
export async function bumpTags(tags: string[]): Promise<Record<string, number>>
⋮----
/**
 * Creates a versioned cache key by prefixing with current tag version.
 *
 * The resulting key includes the tag's current version, so when the
 * tag is bumped, subsequent reads will generate different keys
 * (cache miss), effectively invalidating the old entries.
 *
 * @param tag - Cache tag name.
 * @param key - Base cache key.
 * @returns Versioned cache key in format "tag:vN:key".
 *
 * @example
 * ```ts
 * const key = await versionedKey("trips", "user:123:list:all");
 * // => "trips:v1:user:123:list:all"
 *
 * // After bumpTag("trips")
 * const newKey = await versionedKey("trips", "user:123:list:all");
 * // => "trips:v2:user:123:list:all"
 * ```
 */
export async function versionedKey(tag: string, key: string): Promise<string>
````

## File: src/lib/cache/upstash.ts
````typescript
/**
 * @fileoverview Upstash Redis caching utilities for JSON payloads.
 *
 * Provides type-safe helpers for caching JSON data in Upstash Redis.
 * All operations gracefully handle Redis unavailability (returns null/void).
 *
 * @example
 * ```ts
 * // Store data with 5-minute TTL
 * await setCachedJson("user:123:trips", trips, 300);
 *
 * // Retrieve cached data
 * const cached = await getCachedJson<Trip[]>("user:123:trips");
 * if (cached) return NextResponse.json(cached);
 *
 * // Invalidate on mutation
 * await deleteCachedJson("user:123:trips");
 * ```
 */
⋮----
import type { z } from "zod";
import { getRedis } from "@/lib/redis";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
type CacheTelemetryOptions = {
  namespace?: string;
};
⋮----
/**
 * Derives a low-cardinality cache "namespace" from a Redis key.
 *
 * This intentionally avoids emitting full keys (which may include user IDs or
 * other high-cardinality data) into telemetry. We only emit the top-level
 * namespace segment (before the first `:`) because later segments may include
 * user-derived or high-cardinality identifiers.
 */
function deriveCacheNamespace(key: string): string
⋮----
// Only allow low-cardinality namespaces (avoid IDs, UUIDs, or user-provided prefixes).
⋮----
/**
 * Result of a cache lookup with explicit status.
 * Allows callers to distinguish cache miss from corrupted data and unavailability.
 */
export type CacheResult<T> =
  | { status: "hit"; data: T }
  | { status: "miss" }
  | { status: "invalid"; raw: unknown }
  | { status: "unavailable" };
⋮----
/**
 * Retrieves a cached JSON value from Upstash Redis.
 *
 * Deserializes the stored JSON string back to the specified type.
 * Returns `null` if Redis is unavailable, key doesn't exist, or
 * deserialization fails.
 *
 * @typeParam T - Expected type of the cached value.
 * @param key - Redis key to fetch.
 * @returns Deserialized value or `null` if not found/invalid.
 *
 * @example
 * ```ts
 * const trips = await getCachedJson<Trip[]>("user:123:trips");
 * ```
 */
export function getCachedJson<T>(
  key: string,
  options?: CacheTelemetryOptions
): Promise<T | null>
⋮----
// We store JSON strings via JSON.stringify(), so we need to parse them manually.
// Upstash Redis only auto-deserializes when storing objects directly, not pre-stringified JSON.
⋮----
// Invalid JSON - return null to indicate cache miss/invalid data
⋮----
/**
 * Retrieves a cached JSON value with explicit status and optional schema validation.
 *
 * Unlike `getCachedJson`, this function returns a discriminated union that lets
 * callers distinguish between cache miss, valid hit, and corrupted/invalid data.
 * When a schema is provided, the cached data is validated against it.
 *
 * @typeParam T - Expected type of the cached value.
 * @param key - Redis key to fetch.
 * @param schema - Optional Zod schema to validate the cached data.
 * @returns CacheResult with status indicating hit, miss, or invalid.
 *
 * @example
 * ```ts
 * const result = await getCachedJsonSafe("config:123", configSchema);
 * if (result.status === "hit") {
 *   return result.data;
 * }
 * if (result.status === "invalid") {
 *   logger.warn("Invalid cached config", { raw: result.raw });
 * }
 * // Fetch fresh data...
 * ```
 */
export function getCachedJsonSafe<T>(
  key: string,
  schema?: z.ZodType<T>,
  options?: CacheTelemetryOptions
): Promise<CacheResult<T>>
⋮----
// We store JSON strings via JSON.stringify(), so we need to parse them manually.
// Upstash Redis only auto-deserializes when storing objects directly, not pre-stringified JSON.
⋮----
// Invalid JSON - return invalid status with raw string
⋮----
/**
 * Stores a JSON value in Upstash Redis with optional TTL.
 *
 * Serializes the value to JSON before storage. If `ttlSeconds` is
 * provided and positive, sets an expiration on the key.
 *
 * @param key - Redis key to store the value under.
 * @param value - Value to serialize and cache (must be JSON-serializable).
 * @param ttlSeconds - Optional TTL in seconds. Ignored if <= 0.
 *
 * @example
 * ```ts
 * // Cache for 5 minutes
 * await setCachedJson("user:123:trips", trips, 300);
 *
 * // Cache indefinitely
 * await setCachedJson("config:features", features);
 * ```
 */
export function setCachedJson(
  key: string,
  value: unknown,
  ttlSeconds?: number,
  options?: CacheTelemetryOptions
): Promise<void>
⋮----
/**
 * Deletes a cached JSON value from Upstash Redis.
 *
 * Use for cache invalidation when underlying data changes.
 * No-op if Redis is unavailable.
 *
 * @param key - Redis key to delete.
 *
 * @example
 * ```ts
 * // Invalidate after trip creation
 * await deleteCachedJson("user:123:trips");
 * ```
 */
export function deleteCachedJson(
  key: string,
  options?: CacheTelemetryOptions
): Promise<void>
⋮----
/**
 * Deletes multiple cached JSON values from Upstash Redis.
 *
 * Efficient batch deletion for invalidating related cache entries.
 * No-op if Redis is unavailable or keys array is empty.
 *
 * @param keys - Array of Redis keys to delete.
 * @returns Number of keys actually deleted, or 0 if Redis unavailable.
 *
 * @example
 * ```ts
 * // Invalidate all user caches on logout
 * const deleted = await deleteCachedJsonMany([
 *   "user:123:trips",
 *   "user:123:suggestions",
 *   "user:123:attachments"
 * ]);
 * ```
 */
export function deleteCachedJsonMany(
  keys: string[],
  options?: CacheTelemetryOptions
): Promise<number>
⋮----
/**
 * Invalidates cache entries matching a user prefix pattern.
 *
 * Deletes the specified cache types for a user. Uses explicit key
 * construction rather than SCAN for predictability and safety.
 *
 * @param userId - User ID whose cache entries should be invalidated.
 * @param cacheTypes - Cache type prefixes to invalidate (e.g., ["trips", "suggestions"]).
 *
 * @example
 * ```ts
 * // Invalidate all trip-related caches for user
 * await invalidateUserCache("user-123", ["trips:list", "trips:suggestions"]);
 * ```
 */
export async function invalidateUserCache(
  userId: string,
  cacheTypes: string[]
): Promise<void>
````

## File: src/lib/calendar/calendar-integration.ts
````typescript
/**
 * @fileoverview Calendar integration abstraction layer.
 *
 * Unified interface for calendar providers with ICS import/export.
 */
⋮----
import type { CalendarEvent, EventDateTime } from "@schemas/calendar";
import { calendarEventSchema } from "@schemas/calendar";
import { toClientAbsoluteUrl } from "@/lib/url/client-origin";
import type { DateRange } from "../dates/unified-date-utils";
import { DateUtils } from "../dates/unified-date-utils";
⋮----
/** Converts relative path to absolute URL (client-side only). */
const toAbsoluteUrl = (path: string): string
⋮----
/** Resolves event date/time value to Date. */
const resolveDateTimeValue = (value: EventDateTime): Date =>
⋮----
/** Serializes event date/time to payload. */
const serializeEventDateTime = (value: EventDateTime) =>
⋮----
/** Normalizes remote event data to calendar event schema. */
const normalizeRemoteEvent = (event: Record<string, unknown>): CalendarEvent
⋮----
/** Serializes event data to payload. */
const serializeEventPayload = (event: CalendarEvent) => (
⋮----
/** Serializes partial event data to payload. */
const serializePartialEventPayload = (event: Partial<CalendarEvent>) =>
⋮----
/** Interface for calendar provider implementations. */
export interface CalendarProvider {
  /**
   * Retrieves events within date range.
   *
   * @param dateRange - Date range to fetch events for.
   * @returns Promise resolving to array of calendar events.
   */
  getEvents(dateRange: DateRange): Promise<CalendarEvent[]>;

  /**
   * Creates new calendar event.
   *
   * @param event - Event data without ID.
   * @returns Promise resolving to created event with ID.
   */
  createEvent(event: Omit<CalendarEvent, "id">): Promise<CalendarEvent>;

  /**
   * Updates existing calendar event.
   *
   * @param id - Event ID to update.
   * @param event - Partial event data to update.
   * @returns Promise resolving to updated event.
   */
  updateEvent(id: string, event: Partial<CalendarEvent>): Promise<CalendarEvent>;

  /**
   * Deletes calendar event.
   *
   * @param id - Event ID to delete.
   * @returns Promise resolving when event is deleted.
   */
  deleteEvent(id: string): Promise<void>;

  /**
   * Exports events to ICS format.
   *
   * @param events - Array of events to export.
   * @returns Promise resolving to ICS string content.
   */
  exportToIcs(events: CalendarEvent[]): Promise<string>;

  /**
   * Imports events from ICS format.
   *
   * @param icsContent - ICS content to parse.
   * @returns Promise resolving to array of imported events.
   */
  importFromIcs(icsContent: string): Promise<CalendarEvent[]>;
}
⋮----
/**
   * Retrieves events within date range.
   *
   * @param dateRange - Date range to fetch events for.
   * @returns Promise resolving to array of calendar events.
   */
getEvents(dateRange: DateRange): Promise<CalendarEvent[]>;
⋮----
/**
   * Creates new calendar event.
   *
   * @param event - Event data without ID.
   * @returns Promise resolving to created event with ID.
   */
createEvent(event: Omit<CalendarEvent, "id">): Promise<CalendarEvent>;
⋮----
/**
   * Updates existing calendar event.
   *
   * @param id - Event ID to update.
   * @param event - Partial event data to update.
   * @returns Promise resolving to updated event.
   */
updateEvent(id: string, event: Partial<CalendarEvent>): Promise<CalendarEvent>;
⋮----
/**
   * Deletes calendar event.
   *
   * @param id - Event ID to delete.
   * @returns Promise resolving when event is deleted.
   */
deleteEvent(id: string): Promise<void>;
⋮----
/**
   * Exports events to ICS format.
   *
   * @param events - Array of events to export.
   * @returns Promise resolving to ICS string content.
   */
exportToIcs(events: CalendarEvent[]): Promise<string>;
⋮----
/**
   * Imports events from ICS format.
   *
   * @param icsContent - ICS content to parse.
   * @returns Promise resolving to array of imported events.
   */
importFromIcs(icsContent: string): Promise<CalendarEvent[]>;
⋮----
/** Supabase-based calendar provider implementation. */
export class SupabaseCalendarProvider implements CalendarProvider
⋮----
/**
   * Retrieves events from Supabase backend within date range.
   *
   * @param dateRange - Date range to fetch events for.
   * @returns Promise resolving to array of calendar events.
   */
async getEvents(dateRange: DateRange): Promise<CalendarEvent[]>
⋮----
/**
   * Creates event via Supabase backend API.
   *
   * @param event - Event data without ID.
   * @returns Promise resolving to created event.
   */
async createEvent(event: Omit<CalendarEvent, "id">): Promise<CalendarEvent>
⋮----
/**
   * Updates event via Supabase backend API.
   *
   * @param id - Event ID to update.
   * @param event - Partial event data.
   * @returns Promise resolving to updated event.
   */
async updateEvent(id: string, event: Partial<CalendarEvent>): Promise<CalendarEvent>
⋮----
/**
   * Deletes event via Supabase backend API.
   *
   * @param id - Event ID to delete.
   */
async deleteEvent(id: string): Promise<void>
⋮----
/**
   * Exports events to ICS via Supabase backend API.
   *
   * @param events - Array of events to export.
   * @returns Promise resolving to ICS string content.
   */
async exportToIcs(events: CalendarEvent[]): Promise<string>
⋮----
/**
   * Imports events from ICS via Supabase backend API.
   *
   * @param icsContent - ICS content to parse.
   * @returns Promise resolving to array of imported events.
   */
async importFromIcs(icsContent: string): Promise<CalendarEvent[]>
⋮----
/**
 * Converts EventDateTime to Google Calendar API format.
 *
 * @param value - Event date/time value.
 * @returns Google Calendar date/time payload.
 */
const toGoogleDateTimePayload = (value: EventDateTime) =>
⋮----
/**
 * Google Calendar API provider implementation.
 *
 * Server-only: requires API key and must not be used in client components.
 */
export class GoogleCalendarProvider implements CalendarProvider
⋮----
/**
   * Asserts provider is used server-side only.
   *
   * @throws Error if used in client context.
   */
assertServer()
⋮----
/**
   * Creates Google Calendar provider instance.
   *
   * @param apiKey - Google Calendar API key.
   * @param calendarId - Calendar ID. Defaults to "primary".
   */
constructor(apiKey: string, calendarId: string = "primary")
⋮----
/**
   * Retrieves events from Google Calendar within date range.
   *
   * @param dateRange - Date range to fetch events for.
   * @returns Promise resolving to array of calendar events.
   */
⋮----
/**
   * Creates event via Google Calendar API.
   *
   * @param event - Event data without ID.
   * @returns Promise resolving to created event.
   */
⋮----
/**
   * Updates event via Google Calendar API.
   *
   * @param id - Event ID to update.
   * @param event - Partial event data.
   * @returns Promise resolving to updated event.
   */
⋮----
/**
   * Deletes event via Google Calendar API.
   *
   * @param id - Event ID to delete.
   */
⋮----
/**
   * Exports events to ICS via backend API.
   *
   * @param events - Array of events to export.
   * @returns Promise resolving to ICS string content.
   */
⋮----
/**
   * Imports events from ICS via backend API.
   *
   * @param icsContent - ICS content to parse.
   * @returns Promise resolving to array of imported events.
   */
⋮----
/**
 * Factory for creating calendar provider instances.
 */
⋮----
create(
    type: "supabase" | "google",
    options?: { apiKey?: string; calendarId?: string }
): CalendarProvider
````

## File: src/lib/calendar/google.ts
````typescript
/**
 * @fileoverview Google Calendar REST API v3 client wrapper.
 *
 * Thin wrapper around Google Calendar REST API using Supabase OAuth tokens.
 * All methods require server-side execution and authenticated user sessions.
 */
⋮----
import type {
  CalendarEvent,
  CalendarList,
  CreateEventRequest,
  EventsListRequest,
  EventsListResponse,
  FreeBusyRequest,
  FreeBusyResponse,
  UpdateEventRequest,
} from "@schemas/calendar";
import { getGoogleProviderToken } from "./auth";
⋮----
/**
 * Error thrown when Google Calendar API request fails.
 */
export class GoogleCalendarApiError extends Error
⋮----
constructor(
    message: string,
    public statusCode?: number,
    public response?: unknown
)
⋮----
/**
 * Make authenticated request to Google Calendar API.
 *
 * @param endpoint - API endpoint (relative to base URL)
 * @param options - Fetch options (method, body, etc.)
 * @returns Promise resolving to JSON response
 * @throws GoogleCalendarApiError on API errors
 */
async function googleCalendarRequest<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T>
⋮----
// biome-ignore lint/style/useNamingConvention: HTTP header name
⋮----
/**
 * Get list of calendars for the authenticated user.
 *
 * @returns Promise resolving to calendar list
 */
export function listCalendars(): Promise<CalendarList>
⋮----
/**
 * Get calendar details by ID.
 *
 * @param calendarId - Calendar ID (default: "primary")
 * @returns Promise resolving to calendar details
 */
export function getCalendar(
  calendarId: string = "primary"
): Promise<CalendarList["items"][number]>
⋮----
/**
 * List events from a calendar.
 *
 * @param params - Event list parameters
 * @returns Promise resolving to events list response
 */
export function listEvents(params: EventsListRequest): Promise<EventsListResponse>
⋮----
/**
 * Get a specific event by ID.
 *
 * @param calendarId - Calendar ID (default: "primary")
 * @param eventId - Event ID
 * @returns Promise resolving to calendar event
 */
export function getEvent(
  eventId: string,
  calendarId: string = "primary"
): Promise<CalendarEvent>
⋮----
/**
 * Create a new calendar event.
 *
 * @param calendarId - Calendar ID (default: "primary")
 * @param event - Event creation request
 * @returns Promise resolving to created calendar event
 */
export function createEvent(
  event: CreateEventRequest,
  calendarId: string = "primary"
): Promise<CalendarEvent>
⋮----
// Convert Zod schema to Google Calendar API format
⋮----
// Handle travel metadata via extended properties
⋮----
// biome-ignore lint/style/useNamingConvention: Private metadata field name
⋮----
/**
 * Update an existing calendar event.
 *
 * @param calendarId - Calendar ID (default: "primary")
 * @param eventId - Event ID
 * @param event - Event update request
 * @returns Promise resolving to updated calendar event
 */
export function updateEvent(
  eventId: string,
  event: UpdateEventRequest,
  calendarId: string = "primary"
): Promise<CalendarEvent>
⋮----
// Handle travel metadata via extended properties
⋮----
// biome-ignore lint/style/useNamingConvention: Private metadata field name
⋮----
/**
 * Delete a calendar event.
 *
 * @param calendarId - Calendar ID (default: "primary")
 * @param eventId - Event ID
 * @returns Promise resolving when deletion completes
 */
export async function deleteEvent(
  eventId: string,
  calendarId: string = "primary"
): Promise<void>
⋮----
/**
 * Query free/busy information for calendars.
 *
 * @param request - Free/busy query request
 * @returns Promise resolving to free/busy response
 */
export function queryFreeBusy(request: FreeBusyRequest): Promise<FreeBusyResponse>
````

## File: src/lib/calendar/trip-export.ts
````typescript
/**
 * @fileoverview Utilities for exporting trip itineraries to calendar events.
 */
⋮----
import type { CalendarEvent } from "@schemas/calendar";
import { calendarEventSchema } from "@schemas/calendar";
import type { UiTrip } from "@schemas/trips";
import { DateUtils } from "@/lib/dates/unified-date-utils";
⋮----
/**
 * Converts a trip structure into structured calendar events.
 *
 * @param trip - Trip definition including destinations and activities.
 * @returns Serialized calendar events.
 */
export function tripToCalendarEvents(trip: UiTrip): CalendarEvent[]
⋮----
// Trip start event
⋮----
// Destination events
⋮----
// Arrival event
⋮----
// Activities
⋮----
// Departure event
⋮----
/**
 * Exports a trip to ICS by invoking the calendar export API route.
 *
 * @param trip - Trip data to export.
 * @param calendarName - Optional calendar name override.
 * @returns Serialized ICS content returned by the API.
 */
export async function exportTripToIcs(
  trip: UiTrip,
  calendarName?: string
): Promise<string>
````

## File: src/lib/circuit-breaker/index.ts
````typescript
/**
 * @fileoverview Circuit breaker pattern implementation using Upstash Redis.
 *
 * Prevents cascading failures during external service outages by:
 * - Tracking failure counts per service
 * - Opening circuit when threshold exceeded
 * - Allowing half-open probes after cooldown
 * - Auto-closing after successful probes
 *
 * @see https://learn.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker
 */
⋮----
import { getRedis } from "@/lib/redis";
import { recordTelemetryEvent, withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
// ===== TYPES =====
⋮----
/**
 * Circuit breaker state.
 */
export type CircuitState = "closed" | "open" | "half-open";
⋮----
/**
 * Configuration for a circuit breaker.
 */
export interface CircuitBreakerConfig {
  /** Service name for identification */
  name: string;
  /** Number of failures before opening circuit */
  failureThreshold?: number;
  /** Cooldown period in seconds before trying half-open */
  cooldownSeconds?: number;
  /** Number of successful probes needed to close circuit */
  successThreshold?: number;
  /** TTL for failure count in seconds */
  failureWindowSeconds?: number;
}
⋮----
/** Service name for identification */
⋮----
/** Number of failures before opening circuit */
⋮----
/** Cooldown period in seconds before trying half-open */
⋮----
/** Number of successful probes needed to close circuit */
⋮----
/** TTL for failure count in seconds */
⋮----
/**
 * Result of a circuit breaker check.
 */
export interface CircuitCheckResult {
  /** Whether the request should be allowed */
  allowed: boolean;
  /** Current circuit state */
  state: CircuitState;
  /** If not allowed, reason for rejection */
  reason?: string;
}
⋮----
/** Whether the request should be allowed */
⋮----
/** Current circuit state */
⋮----
/** If not allowed, reason for rejection */
⋮----
// ===== CONSTANTS =====
⋮----
// ===== HELPERS =====
⋮----
function getFailureCountKey(name: string): string
⋮----
function getOpenedAtKey(name: string): string
⋮----
function getSuccessCountKey(name: string): string
⋮----
// ===== CIRCUIT BREAKER =====
⋮----
/**
 * Check if a request should be allowed through the circuit breaker.
 *
 * @param config - Circuit breaker configuration
 * @returns Whether the request is allowed and current state
 */
export async function checkCircuit(
  config: CircuitBreakerConfig
): Promise<CircuitCheckResult>
⋮----
// Fail open if Redis unavailable
⋮----
// Check if circuit is open
⋮----
// Circuit is open, reject request
⋮----
// Cooldown passed, allow half-open probe
⋮----
// Check failure count
⋮----
// Threshold exceeded, open circuit
⋮----
/**
 * Record a failure for a service.
 *
 * Uses Redis SETEX for atomic set-with-expiry when setting initial value and
 * a Lua script to atomically increment + refresh TTL for subsequent failures.
 *
 * @param config - Circuit breaker configuration
 */
export async function recordFailure(
  config: Pick<CircuitBreakerConfig, "name" | "failureWindowSeconds">
): Promise<void>
⋮----
// Atomically increment failure count and refresh TTL to avoid TOCTOU races
⋮----
// Reset success count on failure
⋮----
/**
 * Record a success for a service.
 *
 * If in half-open state, may close the circuit after enough successes.
 *
 * @param config - Circuit breaker configuration
 */
export async function recordSuccess(
  config: Pick<CircuitBreakerConfig, "name" | "successThreshold">
): Promise<void>
⋮----
// Check if circuit was open (we're in half-open)
⋮----
// In half-open state, track successes
⋮----
// Enough successes, close circuit
⋮----
// Circuit was closed, just reset failure count on success
⋮----
/**
 * Get the current state of a circuit breaker (read-only).
 *
 * Unlike checkCircuit, this function performs a read-only lookup without
 * any side effects (no circuit opening, no threshold evaluation, no metrics).
 *
 * @param name - Service name
 * @returns Current circuit state
 */
export async function getCircuitState(
  name: string,
  cooldownSeconds = DEFAULT_COOLDOWN_SECONDS
): Promise<CircuitState>
⋮----
return "closed"; // Fail open if Redis unavailable
⋮----
// Circuit was opened - check if cooldown has passed
⋮----
// Use provided cooldown for read-only state check
⋮----
/**
 * Manually reset a circuit breaker (for admin/recovery).
 *
 * @param name - Service name
 */
export async function resetCircuit(name: string): Promise<void>
⋮----
/**
 * Execute a function with circuit breaker protection.
 *
 * @param config - Circuit breaker configuration
 * @param fn - Function to execute
 * @returns Function result or null if circuit is open
 */
export async function withCircuitBreaker<T>(
  config: CircuitBreakerConfig,
  fn: () => Promise<T>
): Promise<
````

## File: src/lib/client/clipboard.ts
````typescript
/**
 * @fileoverview Clipboard helpers with fallbacks for older browsers.
 * Must only be imported in client components.
 */
⋮----
export type ClipboardCopyResult =
  | { ok: true; method: "clipboard" | "fallback" }
  | {
      ok: false;
      reason: "permission-denied" | "insecure-context" | "unavailable" | "failed";
      error?: unknown;
    };
⋮----
function copyTextWithExecCommand(text: string): boolean
⋮----
/**
 * Toast function type for clipboard feedback.
 */
type ToastFn = (opts: {
  description: string;
  title: string;
  variant?: "default" | "destructive";
}) => void;
⋮----
/**
 * Standard toast messages for clipboard copy results.
 */
export interface CopyToastMessages {
  /** Toast shown on successful copy. */
  success: { title: string; description: string };
  /** Toast shown when clipboard permission is denied. */
  permissionDenied?: { title: string; description: string };
  /** Toast shown in insecure contexts (non-HTTPS). */
  insecureContext?: { title: string; description: string };
  /** Toast shown when clipboard API is unavailable. */
  unavailable?: { title: string; description: string };
  /** Toast shown on generic copy failure. */
  failed?: { title: string; description: string };
}
⋮----
/** Toast shown on successful copy. */
⋮----
/** Toast shown when clipboard permission is denied. */
⋮----
/** Toast shown in insecure contexts (non-HTTPS). */
⋮----
/** Toast shown when clipboard API is unavailable. */
⋮----
/** Toast shown on generic copy failure. */
⋮----
/**
 * Copies text to clipboard and shows appropriate toast feedback.
 *
 * @param text - Text to copy to clipboard
 * @param toast - Toast function from useToast hook
 * @param messages - Optional custom toast messages (merged with defaults)
 * @returns The clipboard copy result
 *
 * @example
 * ```tsx
 * const { toast } = useToast();
 * const result = await copyToClipboardWithToast(shareUrl, toast, {
 *   success: { title: "Link Copied", description: "Share link copied to clipboard" }
 * });
 * ```
 */
export async function copyToClipboardWithToast(
  text: string,
  toast: ToastFn,
  messages?: Partial<CopyToastMessages>
): Promise<ClipboardCopyResult>
⋮----
export async function copyTextToClipboard(text: string): Promise<ClipboardCopyResult>
````

## File: src/lib/client/session.ts
````typescript
/**
 * @fileoverview Client-side session utilities.
 * Uses browser storage APIs - must only be imported in client components.
 */
⋮----
import { secureUuid } from "@/lib/security/random";
⋮----
/**
 * Get or create a per-session identifier for error tracking and telemetry.
 *
 * The ID is stored in `sessionStorage` under the key `session_id`. If it does
 * not exist, a new ID is generated using `secureUuid()` and persisted. When
 * called in environments without access to `sessionStorage` (e.g., server
 * rendering, certain privacy contexts), the function returns `undefined`.
 *
 * @returns A stable session identifier string or `undefined` when unavailable.
 */
export function getSessionId(): string | undefined
````

## File: src/lib/config/helpers.ts
````typescript
/**
 * @fileoverview Shared helpers for configuration API routes.
 * Provides canonical validation schemas and authorization utilities.
 */
⋮----
import { configurationScopeSchema } from "@schemas/configuration";
import { z } from "zod";
⋮----
/**
 * Canonical scope schema for parsing query parameters.
 * Accepts string input, validates against ConfigurationScope enum, defaults to "global".
 */
⋮----
/**
 * Type guard assertion for admin users.
 * Throws a 403 error if the user is not an admin.
 *
 * @param user - User object from authentication context
 * @throws Error with status 403 if user is not an admin
 */
export function ensureAdmin(
  user: unknown
  // biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case
): asserts user is
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case
````

## File: src/lib/constants/images.ts
````typescript
/**
 * @fileoverview Shared image constants used across the application.
 */
⋮----
/**
 * Public fallback image URL/path for hotel listings.
 *
 * `NEXT_PUBLIC_*` values are inlined at build time (not read at runtime). This module
 * trims the inlined `NEXT_PUBLIC_FALLBACK_HOTEL_IMAGE` value and falls back to
 * `"/globe.svg"` when not provided. Expected format is a public URL or a public path.
 */
````

## File: src/lib/dates/recurring-rules.ts
````typescript
/**
 * @fileoverview Recurring date generation utilities using date-fns v4.
 * Provides RecurringRule type and RecurringDateGenerator for creating
 * date sequences and parsing RRULE strings without external dependencies.
 */
⋮----
import type { RecurrenceFrequency, RecurringRule } from "@schemas/temporal";
import { recurringRuleSchema } from "@schemas/temporal";
import { DateUtils } from "./unified-date-utils";
⋮----
// Re-export types from schemas
⋮----
/**
 * Utility class for generating recurring date sequences and parsing RRULE strings.
 *
 * Provides methods to create date occurrences based on recurrence rules and
 * convert between RecurringRule objects and RFC 5545 RRULE format strings.
 *
 * @class RecurringDateGenerator
 */
// biome-ignore lint/complexity/noStaticOnlyClass: Shared via static methods.
export class RecurringDateGenerator
⋮----
/**
   * Generates a list of dates that match a recurring rule starting from a given date.
   *
   * @param startDate - Anchor date for generating occurrences.
   * @param rule - Recurrence definition to apply.
   * @param limit - Maximum number of occurrences to emit (default 50).
   * @returns Array of generated occurrence dates.
   */
static generateOccurrences(
    startDate: Date,
    rule: RecurringRule,
    limit: number = 50
): Date[]
⋮----
static generateWeeklyWithDays(
    startDate: Date,
    rule: RecurringRule,
    limit: number
): Date[]
⋮----
/**
   * Checks if a given date matches the recurrence rule constraints.
   *
   * @private
   * @param date - The date to check.
   * @param startDate - The original start date for context.
   * @param rule - The recurrence rule to match against.
   * @returns True if the date matches the rule, false otherwise.
   */
static matchesRule(date: Date, _startDate: Date, rule: RecurringRule): boolean
⋮----
/**
   * Calculates the next occurrence date based on the recurrence rule.
   *
   * @private
   * @param date - The current date.
   * @param rule - The recurrence rule to apply.
   * @returns The next date that should be checked.
   */
static nextOccurrence(date: Date, rule: RecurringRule): Date
⋮----
/**
   * Parses an RFC 5545 RRULE string into a RecurringRule object.
   *
   * @param rrule - RRULE string containing frequency definitions.
   * @returns Parsed recurrence configuration.
   */
// biome-ignore lint/style/useNamingConvention: Preserve RR abbreviation for RFC terminology.
static parseRRule(rrule: string): RecurringRule
⋮----
// Validate and parse the rule using Zod schema
⋮----
/**
   * Converts a RecurringRule object into an RFC 5545 RRULE string.
   *
   * @param rule - Recurrence configuration to encode.
   * @returns Valid RRULE string representation.
   */
// biome-ignore lint/style/useNamingConvention: Preserve RR abbreviation for RFC terminology.
static toRRule(rule: RecurringRule): string
````

## File: src/lib/dates/unified-date-utils.ts
````typescript
/**
 * @fileoverview Unified date utility helpers built on date-fns v4 with typed
 * inputs, validation, and formatting presets for Tripsage frontend modules.
 */
⋮----
import {
  addDays,
  addHours,
  addMinutes,
  addMonths,
  addWeeks,
  addYears,
  differenceInDays,
  differenceInMonths,
  differenceInWeeks,
  differenceInYears,
  eachDayOfInterval,
  eachMonthOfInterval,
  eachWeekOfInterval,
  endOfDay,
  endOfMonth,
  endOfWeek,
  endOfYear,
  format,
  getUnixTime,
  isAfter as isAfterFn,
  isBefore as isBeforeFn,
  isSameDay,
  isSameMonth,
  isSameWeek,
  isSameYear,
  isValid as isValidFn,
  max as maxFn,
  min as minFn,
  parse,
  parseISO,
  startOfDay,
  startOfMonth,
  startOfWeek,
  startOfYear,
  subDays,
  subMonths,
  subWeeks,
  subYears,
} from "date-fns";
⋮----
/**
 * Predefined date format patterns used throughout the application.
 *
 * @constant DATE_FORMATS
 */
⋮----
/** Format for API responses with timezone. */
⋮----
/** Default display format for UI. */
⋮----
/** Format for date input fields. */
⋮----
/** ISO 8601 format with timezone. */
⋮----
/** Long format with seconds. */
⋮----
/** Short date-only format. */
⋮----
/**
 * Represents a date range with start and end dates.
 * Uses schema format (startDate/endDate) for consistency.
 */
export type DateRange = {
  /** Start date of the range (inclusive). */
  start: Date;
  /** End date of the range (inclusive). */
  end: Date;
};
⋮----
/** Start date of the range (inclusive). */
⋮----
/** End date of the range (inclusive). */
⋮----
/**
 * Validates that a date instance is valid.
 *
 * @private
 * @param date - The date to validate.
 * @throws Error if the date is invalid.
 */
function ensureValidDate(date: Date): void
⋮----
/**
 * Unified date utility class providing consistent date operations.
 *
 * Wraps date-fns v4 functionality with a stable API and error handling.
 * All methods validate inputs and provide consistent behavior across the application.
 *
 * @class DateUtils
 */
// biome-ignore lint/complexity/noStaticOnlyClass: Shared utility API consumed as static class across app.
export class DateUtils
⋮----
/**
   * Parses a date string into a Date object.
   *
   * @param dateString - The date string to parse.
   * @param pattern - Optional pattern for parsing. Defaults to ISO parsing.
   * @returns A parsed Date object.
   * @throws Error if the date string is empty or invalid.
   */
static parse(dateString: string, pattern?: string): Date
⋮----
/**
   * Checks if a date is valid.
   *
   * @param date - The date to validate.
   * @returns True if the date is valid, false otherwise.
   */
static isValid(date: Date): boolean
⋮----
/**
   * Formats a date using the specified pattern.
   *
   * @param date - The date to format.
   * @param pattern - The format pattern to use. Defaults to display format.
   * @returns The formatted date string.
   */
static format(date: Date, pattern: string = DATE_FORMATS.display): string
⋮----
/**
   * Formats a date for display in the UI.
   *
   * @param date - The date to format.
   * @returns The formatted display string.
   */
static formatDisplay(date: Date): string
⋮----
/**
   * Formats a date for input fields.
   *
   * @param date - The date to format.
   * @returns The formatted input string.
   */
static formatForInput(date: Date): string
⋮----
/**
   * Formats a date for API consumption (ISO format).
   *
   * @param date - The date to format.
   * @returns The ISO formatted date string.
   */
static formatForApi(date: Date): string
⋮----
/**
   * Adds a specified amount of time to a date.
   *
   * @param date - The base date.
   * @param amount - The amount to add.
   * @param unit - The time unit to add.
   * @returns The new date with the added time.
   */
static add(
    date: Date,
    amount: number,
    unit: "minutes" | "hours" | "days" | "weeks" | "months" | "years"
): Date
⋮----
static subtract(
    date: Date,
    amount: number,
    unit: "days" | "weeks" | "months" | "years"
): Date
⋮----
static startOf(date: Date, unit: "day" | "week" | "month" | "year"): Date
⋮----
static endOf(date: Date, unit: "day" | "week" | "month" | "year"): Date
⋮----
static isAfter(date: Date, compareDate: Date): boolean
⋮----
static isBefore(date: Date, compareDate: Date): boolean
⋮----
static isSame(
    date: Date,
    compareDate: Date,
    unit: "day" | "week" | "month" | "year"
): boolean
⋮----
static difference(
    date1: Date,
    date2: Date,
    unit: "days" | "weeks" | "months" | "years"
): number
⋮----
static min(...dates: Date[]): Date
⋮----
static max(...dates: Date[]): Date
⋮----
static eachDay(startDate: Date, endDate: Date): Date[]
⋮----
static eachWeek(startDate: Date, endDate: Date): Date[]
⋮----
static eachMonth(startDate: Date, endDate: Date): Date[]
⋮----
static toUnix(date: Date): number
⋮----
static compare(date1: Date, date2: Date): number
````

## File: src/lib/env/client.ts
````typescript
/**
 * @fileoverview Client-safe environment variable access.
 *
 * This module exports only NEXT_PUBLIC_* environment variables that are
 * safe to expose in client bundles. All values are validated at build time
 * and frozen to prevent mutation.
 */
⋮----
import type { ClientEnv } from "@schemas/env";
import { clientEnvSchema } from "@schemas/env";
import { isBuildPhase } from "@/lib/utils/build-phase";
⋮----
/**
 * Normalize an optional environment variable by trimming and removing falsy values.
 *
 * Treats `undefined`, empty strings, and the string "undefined" (case-insensitive,
 * e.g., "undefined", "UNDEFINED", "Undefined") as absent. This prevents drift
 * between environment configuration and runtime behavior.
 *
 * @param value - Raw environment variable value (may be undefined or whitespace)
 * @returns Trimmed value or undefined if empty/falsy
 */
function normalizeOptionalEnvVar(value: string | undefined): string | undefined
⋮----
/**
 * Extract and validate client-safe environment variables.
 *
 * @returns Validated client environment object
 * @throws Error if validation fails (except during build/development)
 */
function validateClientEnv(): ClientEnv
⋮----
// Avoid enumerating process.env in client bundles; Next.js inlines env var
// accesses but does not guarantee process.env is enumerable in the browser.
⋮----
// Only allow placeholder NEXT_PUBLIC_* values in development, or when explicitly
// opted-in during build (e.g. docs/CI builds). NEXT_PUBLIC_* values are inlined
// into client bundles at build time.
⋮----
// Return partial object with defaults for development/build
⋮----
// Validate and freeze client environment at module load
⋮----
/**
 * Get validated client environment variables.
 *
 * @returns Frozen client environment object
 */
export function getClientEnv(): ClientEnv
⋮----
/**
 * Get a specific client environment variable by key.
 *
 * @param key - Environment variable key (must be NEXT_PUBLIC_*)
 * @returns Environment variable value
 * @throws Error if key is missing or invalid
 */
export function getClientEnvVar<T extends keyof ClientEnv>(key: T): ClientEnv[T]
⋮----
/**
 * Get client environment variable with fallback.
 *
 * @param key - Environment variable key
 * @param fallback - Fallback value if key is missing
 * @returns Environment variable value or fallback
 */
export function getClientEnvVarWithFallback<T extends keyof ClientEnv>(
  key: T,
  fallback: ClientEnv[T]
): ClientEnv[T]
⋮----
// Google Maps Platform helpers (client-safe)
/**
 * Get Google Maps Platform browser API key.
 *
 * Browser key must be HTTP referrer-restricted to Maps JS only.
 *
 * @returns Browser API key or undefined if not configured
 */
export function getGoogleMapsBrowserKey(): string | undefined
⋮----
// Export frozen public env object for convenience
````

## File: src/lib/env/index.ts
````typescript
/**
 * @fileoverview Environment variable access module.
 *
 * This barrel file exports explicit server and client entrypoints.
 * Import from './server' for server-only access, './client' for client-safe access.
 *
 * DO NOT import from this index in client components - use explicit paths.
 */
⋮----
// Client-safe exports
⋮----
// Server-only exports (will fail if imported in client)
````

## File: src/lib/env/runtime-env.ts
````typescript
/**
 * @fileoverview Runtime environment detection helpers.
 */
⋮----
/**
 * Determine the runtime environment for server-side feature gating.
 *
 * Prefers `VERCEL_ENV` when present and otherwise falls back to a normalized
 * value derived from `NODE_ENV`.
 */
export function getRuntimeEnv(): "production" | "preview" | "development" | "test"
````

## File: src/lib/errors/get-unknown-error-message.ts
````typescript
/**
 * @fileoverview Error helpers for normalizing unknown failures.
 */
⋮----
/**
 * Returns a human-readable message from an unknown error value.
 *
 * Prefer this for promise rejection reasons (e.g., from Promise.allSettled()).
 *
 * @param reason - The thrown/rejected value to extract a message from.
 * @param fallback - Optional fallback message when no error message is available.
 * @returns A trimmed message when present, otherwise the fallback string.
 */
function trimmedOrFallback(message: string, fallback: string): string
⋮----
/**
 * Returns a human-readable message from an unknown error value.
 *
 * @param reason - The thrown/rejected value to extract a message from.
 * @param fallback - Optional fallback message when no error message is available.
 * @returns A trimmed message when present, otherwise the fallback string.
 */
export function getUnknownErrorMessage(
  reason: unknown,
  fallback = "Unknown error"
): string
````

## File: src/lib/flights/popular-routes-cache.ts
````typescript
/**
 * @fileoverview Cache keys/constants for popular flight routes.
 *
 * Kept outside route modules because Next.js route handlers may only export
 * specific symbols (e.g. GET/POST, runtime, etc.).
 */
⋮----
/**
 * Bump this version whenever the popular routes response structure changes
 * to force cache invalidation.
 */
````

## File: src/lib/google/caching.ts
````typescript
/**
 * @fileoverview Google Maps Platform caching utilities with compliance enforcement.
 *
 * Enforces Google Maps Platform policies:
 * - place_id can be stored indefinitely
 * - lat/lng can be cached for max 30 days (2592000 seconds)
 * - Other Places content must not be persisted
 */
⋮----
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
⋮----
/**
 * Maximum TTL for cached latitude/longitude values per Google Maps Platform policy.
 *
 * Policy: "Customer may temporarily cache latitude and longitude values from
 * the Places API for up to 30 consecutive calendar days."
 */
const MAX_LAT_LNG_TTL_SECONDS = 30 * 24 * 60 * 60; // 30 days = 2592000 seconds
⋮----
/**
 * Cache a place_id value indefinitely (policy-compliant).
 *
 * Place IDs are exempt from caching restrictions and can be stored indefinitely.
 *
 * @param key Cache key (should include "place_id" prefix).
 * @param placeId Place ID value to cache.
 */
export async function cachePlaceId(key: string, placeId: string): Promise<void>
⋮----
/**
 * Retrieve a cached place_id value.
 *
 * @param key Cache key.
 * @returns Cached place ID or null if not found.
 */
export async function getCachedPlaceId(key: string): Promise<string | null>
⋮----
/**
 * Cache latitude/longitude coordinates with policy-compliant TTL.
 *
 * Enforces 30-day maximum TTL per Google Maps Platform policy. If provided
 * TTL exceeds maximum, it is capped to 30 days.
 *
 * @param key Cache key (should include "lat_lng" or "geocode" prefix).
 * @param coords Coordinates object with lat and lon.
 * @param ttlSeconds Requested TTL in seconds (will be capped to 30 days max).
 */
export async function cacheLatLng(
  key: string,
  coords: { lat: number; lon: number },
  ttlSeconds?: number
): Promise<void>
⋮----
/**
 * Retrieve cached latitude/longitude coordinates.
 *
 * @param key Cache key.
 * @returns Cached coordinates or null if not found.
 */
export async function getCachedLatLng(
  key: string
): Promise<
⋮----
/**
 * Maximum allowed TTL for lat/lng caching (30 days in seconds).
 */
````

## File: src/lib/google/client.ts
````typescript
/**
 * @fileoverview Centralized Google API client helpers for server-side calls.
 *
 * Provides thin wrappers around Google APIs (Places, Routes, Geocoding, Timezone)
 * with retry logic, input validation, and consistent error handling.
 *
 * Includes NDJSON parsing for streaming endpoints like computeRouteMatrix.
 */
⋮----
import { retryWithBackoff } from "@/lib/http/retry";
⋮----
// === Coordinate Validation ===
⋮----
/**
 * Validates latitude and longitude coordinates.
 *
 * Throws descriptive errors if coordinates are invalid. Used by multiple
 * API functions to ensure consistent validation and error messages.
 *
 * @param lat - Latitude to validate (-90 to 90).
 * @param lng - Longitude to validate (-180 to 180).
 * @throws Error if coordinates are not finite numbers or out of valid range.
 */
function validateCoordinates(lat: number, lng: number): void
⋮----
// === NDJSON Helpers ===
⋮----
/**
 * Parses a newline-delimited JSON (NDJSON) response body into an array of objects.
 *
 * Google Routes API computeRouteMatrix returns NDJSON streams where each line
 * is a separate JSON object, not a single JSON array. This helper reads the
 * response text and parses each non-empty line as JSON.
 *
 * @param response - Fetch Response object to parse.
 * @returns Promise resolving to array of parsed JSON objects.
 * @throws Error if any line fails to parse as JSON.
 */
export async function parseNdjsonResponse<T = unknown>(
  response: Response
): Promise<T[]>
⋮----
/**
 * Parameters for Google Places Text Search API request.
 */
type PlacesSearchParams = {
  /** Google Maps API key for authentication. */
  apiKey: string;
  /** Request body containing search query and options. */
  body: Record<string, unknown>;
  /** Field mask specifying which place fields to return. */
  fieldMask: string;
};
⋮----
/** Google Maps API key for authentication. */
⋮----
/** Request body containing search query and options. */
⋮----
/** Field mask specifying which place fields to return. */
⋮----
/**
 * Parameters for Google Places Details API request.
 */
type PlaceDetailsParams = {
  /** Google Maps API key for authentication. */
  apiKey: string;
  /** Field mask specifying which place fields to return. */
  fieldMask: string;
  /** Place ID to fetch details for. */
  placeId: string;
  /** Session token for autocomplete session termination (optional). */
  sessionToken?: string;
};
⋮----
/** Google Maps API key for authentication. */
⋮----
/** Field mask specifying which place fields to return. */
⋮----
/** Place ID to fetch details for. */
⋮----
/** Session token for autocomplete session termination (optional). */
⋮----
/**
 * Performs a text search against Google Places API with retry logic.
 *
 * @param params - Search parameters including API key, request body, and field mask.
 * @returns Promise resolving to the API response.
 * @throws Error if all retry attempts fail.
 */
export async function postPlacesSearch(params: PlacesSearchParams): Promise<Response>
⋮----
/**
 * Fetches place details from Google Places API with retry logic.
 *
 * @param params - Details parameters including API key, place ID, and field mask.
 * @returns Promise resolving to the API response.
 * @throws Error if all retry attempts fail.
 */
export async function getPlaceDetails(params: PlaceDetailsParams): Promise<Response>
⋮----
/**
 * Parameters for Google Places Nearby Search API request.
 */
type NearbySearchParams = {
  /** Google Maps API key for authentication. */
  apiKey: string;
  /** Field mask specifying which place fields to return. */
  fieldMask: string;
  /** Array of place type filters (e.g., ["tourist_attraction", "museum"]). */
  includedTypes?: string[];
  /** Latitude of the search center. */
  lat: number;
  /** Longitude of the search center. */
  lng: number;
  /** Maximum number of results to return (1-20). */
  maxResultCount?: number;
  /** Search radius in meters (max 50000). */
  radiusMeters?: number;
};
⋮----
/** Google Maps API key for authentication. */
⋮----
/** Field mask specifying which place fields to return. */
⋮----
/** Array of place type filters (e.g., ["tourist_attraction", "museum"]). */
⋮----
/** Latitude of the search center. */
⋮----
/** Longitude of the search center. */
⋮----
/** Maximum number of results to return (1-20). */
⋮----
/** Search radius in meters (max 50000). */
⋮----
// === Routes API v2 ===
⋮----
/**
 * Parameters for Google Routes API computeRoutes request.
 */
type ComputeRoutesParams = {
  /** Google Maps API key for authentication. */
  apiKey: string;
  /** Request body containing origin, destination, and options. */
  body: Record<string, unknown>;
  /** Field mask specifying which route fields to return. */
  fieldMask: string;
};
⋮----
/** Google Maps API key for authentication. */
⋮----
/** Request body containing origin, destination, and options. */
⋮----
/** Field mask specifying which route fields to return. */
⋮----
/**
 * Performs a computeRoutes request against Google Routes API with retry logic.
 *
 * @param params - Route parameters including API key, request body, and field mask.
 * @returns Promise resolving to the API response.
 * @throws Error if all retry attempts fail.
 */
export async function postComputeRoutes(
  params: ComputeRoutesParams
): Promise<Response>
⋮----
/**
 * Parameters for Google Routes API computeRouteMatrix request.
 */
type ComputeRouteMatrixParams = {
  /** Google Maps API key for authentication. */
  apiKey: string;
  /** Request body containing origins, destinations, and options. */
  body: Record<string, unknown>;
  /** Field mask specifying which matrix fields to return. */
  fieldMask: string;
};
⋮----
/** Google Maps API key for authentication. */
⋮----
/** Request body containing origins, destinations, and options. */
⋮----
/** Field mask specifying which matrix fields to return. */
⋮----
/**
 * Performs a computeRouteMatrix request against Google Routes API with retry logic.
 *
 * @param params - Matrix parameters including API key, request body, and field mask.
 * @returns Promise resolving to the API response.
 * @throws Error if all retry attempts fail.
 */
export async function postComputeRouteMatrix(
  params: ComputeRouteMatrixParams
): Promise<Response>
⋮----
// === Legacy Geocoding API ===
⋮----
/**
 * Parameters for Google Geocoding API forward geocode request.
 */
type GeocodeParams = {
  /** Address string to geocode. */
  address: string;
  /** Google Maps API key for authentication. */
  apiKey: string;
};
⋮----
/** Address string to geocode. */
⋮----
/** Google Maps API key for authentication. */
⋮----
/**
 * Performs forward geocoding against Google Geocoding API with retry logic.
 *
 * @param params - Geocode parameters including API key and address.
 * @returns Promise resolving to the API response.
 * @throws Error if all retry attempts fail.
 */
export async function getGeocode(params: GeocodeParams): Promise<Response>
⋮----
// Validate address parameter
⋮----
/**
 * Parameters for Google Geocoding API reverse geocode request.
 */
type ReverseGeocodeParams = {
  /** Google Maps API key for authentication. */
  apiKey: string;
  /** Latitude of the location to reverse geocode. */
  lat: number;
  /** Longitude of the location to reverse geocode. */
  lng: number;
};
⋮----
/** Google Maps API key for authentication. */
⋮----
/** Latitude of the location to reverse geocode. */
⋮----
/** Longitude of the location to reverse geocode. */
⋮----
/**
 * Performs reverse geocoding against Google Geocoding API with retry logic.
 *
 * @param params - Reverse geocode parameters including API key and coordinates.
 * @returns Promise resolving to the API response.
 * @throws Error if all retry attempts fail.
 */
export async function getReverseGeocode(
  params: ReverseGeocodeParams
): Promise<Response>
⋮----
// === Legacy Timezone API ===
⋮----
/**
 * Parameters for Google Timezone API request.
 */
type TimezoneParams = {
  /** Google Maps API key for authentication. */
  apiKey: string;
  /** Latitude of the location. */
  lat: number;
  /** Longitude of the location. */
  lng: number;
  /** Unix timestamp in seconds (defaults to current time). */
  timestamp?: number;
};
⋮----
/** Google Maps API key for authentication. */
⋮----
/** Latitude of the location. */
⋮----
/** Longitude of the location. */
⋮----
/** Unix timestamp in seconds (defaults to current time). */
⋮----
/**
 * Fetches timezone information from Google Timezone API with retry logic.
 *
 * @param params - Timezone parameters including API key, coordinates, and optional timestamp.
 * @returns Promise resolving to the API response.
 * @throws Error if all retry attempts fail.
 */
export async function getTimezone(params: TimezoneParams): Promise<Response>
⋮----
// === Places Photo API ===
⋮----
/**
 * Parameters for Google Places API photo media request.
 */
type PlacePhotoParams = {
  /** Google Maps API key for authentication. */
  apiKey: string;
  /** Maximum height in pixels (optional). */
  maxHeightPx?: number;
  /** Maximum width in pixels (optional). */
  maxWidthPx?: number;
  /** Photo resource name (e.g., "places/ABC/photos/XYZ"). */
  photoName: string;
  /** If true, skip HTTP redirect and return photo URI instead (optional). */
  skipHttpRedirect?: boolean;
};
⋮----
/** Google Maps API key for authentication. */
⋮----
/** Maximum height in pixels (optional). */
⋮----
/** Maximum width in pixels (optional). */
⋮----
/** Photo resource name (e.g., "places/ABC/photos/XYZ"). */
⋮----
/** If true, skip HTTP redirect and return photo URI instead (optional). */
⋮----
/**
 * Fetches place photo from Google Places API with retry logic.
 *
 * @param params - Photo parameters including API key, photo name, and optional dimensions.
 * @returns Promise resolving to the API response (photo bytes or redirect).
 * @throws Error if all retry attempts fail.
 */
export async function getPlacePhoto(params: PlacePhotoParams): Promise<Response>
⋮----
// Google Places Photo API requires at least one dimension parameter
⋮----
// Validate photo dimensions if provided (Google Places Photo API limit is 4800)
⋮----
// === Places Nearby Search API ===
⋮----
/**
 * Performs a nearby search against Google Places API with retry logic.
 *
 * @param params - Search parameters including coordinates, radius, and place types.
 * @returns Promise resolving to the API response.
 * @throws Error if all retry attempts fail.
 */
export async function postNearbySearch(params: NearbySearchParams): Promise<Response>
````

## File: src/lib/google/places-activities.ts
````typescript
/**
 * @fileoverview Google Places API (New) helpers for activity search.
 *
 * Provides activity-specific query builders, field masks, and mapping
 * from Places API responses to Activity schema.
 */
⋮----
import type { Activity } from "@schemas/search";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { getPlaceDetails, postPlacesSearch } from "@/lib/google/client";
import { normalizePlacesTextQuery } from "@/lib/google/places-utils";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Field mask for Places Text Search (activities).
 *
 * Only requests Essentials-tier fields needed for Activity schema:
 * id, displayName, formattedAddress, location, rating, userRatingCount,
 * photos.name, types, priceLevel.
 */
⋮----
/**
 * Field mask for Places Details (activities).
 *
 * Includes additional fields for detailed activity view:
 * editorialSummary, regularOpeningHours.
 */
⋮----
/**
 * Google Places API response types (minimal, for mapping only).
 */
type PlacesLocation = {
  latitude: number;
  longitude: number;
};
⋮----
type PlacesPhoto = {
  name: string;
  widthPx?: number;
  heightPx?: number;
};
⋮----
type PlacesPlace = {
  id: string;
  displayName?: { text: string; languageCode?: string };
  formattedAddress?: string;
  location?: PlacesLocation;
  rating?: number;
  userRatingCount?: number;
  photos?: PlacesPhoto[];
  types?: string[];
  priceLevel?:
    | "PRICE_LEVEL_FREE"
    | "PRICE_LEVEL_INEXPENSIVE"
    | "PRICE_LEVEL_MODERATE"
    | "PRICE_LEVEL_EXPENSIVE"
    | "PRICE_LEVEL_VERY_EXPENSIVE";
  editorialSummary?: { text: string; languageCode?: string };
};
⋮----
type PlacesSearchResponse = {
  places?: PlacesPlace[];
};
⋮----
type PlacesDetailsResponse = PlacesPlace;
⋮----
/** Maximum number of photos to include per activity. */
⋮----
/** Default photo dimensions for activity images. */
⋮----
/**
 * Maps Google Places priceLevel to Activity price index (0-4).
 *
 * @param priceLevel - Google Places price level string.
 * @returns Price index (0 = free, 1 = inexpensive, ..., 4 = very expensive).
 */
function mapPriceLevelToIndex(priceLevel?: PlacesPlace["priceLevel"]): number
⋮----
return 2; // Default to moderate if unknown
⋮----
/**
 * Extracts primary activity type from Places types array.
 *
 * Filters for activity-relevant types and returns the first match,
 * or falls back to a generic type.
 *
 * @param types - Array of Places type strings.
 * @returns Primary activity type string.
 */
function extractActivityType(types?: string[]): string
⋮----
// Common activity-related types from Places API
⋮----
/**
 * Builds client-safe photo URLs via the server-side photo proxy.
 *
 * Limits results to MAX_ACTIVITY_PHOTOS (5) to balance visual richness
 * with payload size and rendering performance. The photo proxy route
 * handles API key authentication internally.
 *
 * @param photos - Array of PlacesPhoto objects.
 * @returns Array of client-safe photo URLs.
 */
function buildPhotoUrls(photos?: PlacesPhoto[]): string[]
⋮----
// Limit to MAX_ACTIVITY_PHOTOS to balance richness with performance
⋮----
/**
 * Maps a Google Places place to Activity schema.
 *
 * @param place - Places API place object.
 * @param date - ISO date string for the activity (defaults to today).
 * @returns Activity object.
 */
export function mapPlacesPlaceToActivity(
  place: PlacesPlace,
  date: string = new Date().toISOString().split("T")[0]
): Activity
⋮----
// Use editorialSummary if available, otherwise generate a simple description
⋮----
// Default duration: 2 hours (120 minutes) for activities
⋮----
/**
 * Builds an activity-specific search query for Google Places.
 *
 * Formats query as "{category} activities in {destination}" or
 * "activities in {destination}" if category is missing.
 *
 * @param destination - Destination location string.
 * @param category - Optional activity category.
 * @returns Normalized search query string.
 */
export function buildActivitySearchQuery(
  destination: string,
  category?: string
): string
⋮----
/**
 * Performs a Google Places Text Search for activities.
 *
 * @param query - Search query string.
 * @param maxResults - Maximum number of results (default: 20).
 * @returns Array of Activity objects.
 */
export async function searchActivitiesWithPlaces(
  query: string,
  maxResults: number = 20
): Promise<Activity[]>
⋮----
/**
 * Fetches detailed activity information from Google Places.
 *
 * @param placeId - Google Place ID.
 * @returns Activity object with full details, or null if not found.
 */
export async function getActivityDetailsFromPlaces(
  placeId: string
): Promise<Activity | null>
````

## File: src/lib/google/places-enrichment.ts
````typescript
/**
 * @fileoverview Google Places enrichment helper with policy-compliant caching.
 *
 * Enriches hotel-like listings with Google Places data. Only caches place_id
 * (indefinite) and lat/lng (30 days max) per Google Maps Platform policy.
 * Full place details are always fetched fresh and never persisted.
 */
⋮----
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { cacheLatLng, cachePlaceId, getCachedPlaceId } from "@/lib/google/caching";
import { getPlaceDetails, postPlacesSearch } from "@/lib/google/client";
import {
  buildGeocodeCacheKey,
  buildQueryToPlaceIdKey,
  normalizePlacesTextQuery,
} from "@/lib/google/places-utils";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Field mask for Places search when finding place_id (minimal fields).
 */
⋮----
/**
 * Field mask for Places details (full UI fields).
 */
⋮----
/**
 * Hotel-like listing structure expected for enrichment.
 */
export type HotelLikeListing = {
  hotel?: {
    name?: string;
    address?: {
      cityName?: string;
      lines?: string[];
    };
  };
};
⋮----
/**
 * Enriches a hotel-like listing with Google Places data.
 *
 * Searches for the property by name and address, then fetches detailed place
 * information. Only caches place_id and lat/lng per Google policy; details
 * are always fetched fresh.
 *
 * @param listing - Accommodation listing with hotel name and address.
 * @returns Enriched listing with place and placeDetails properties, or original listing if enrichment fails.
 */
export async function enrichHotelListingWithPlaces<T extends HotelLikeListing>(
  listing: T
): Promise<T &
⋮----
// Check for cached place_id mapping (policy-compliant: place_id can be cached indefinitely)
⋮----
// If no cached mapping, search for place_id
⋮----
// Cache place_id mapping (indefinite) and lat/lng separately (30 days)
⋮----
// Cache place_id indefinitely (policy-compliant)
⋮----
// Cache lat/lng separately with 30-day TTL (policy-compliant)
⋮----
// Always fetch fresh details (never cache full payloads per policy)
⋮----
// Return listing with minimal place info if details fetch fails
⋮----
// Return enriched listing with fresh details (not cached)
````

## File: src/lib/google/places-format.ts
````typescript
/**
 * @fileoverview Client-safe formatting utilities for Google Places data.
 *
 * Provides formatting functions that can be used in both client and server components.
 */
⋮----
/**
 * Format Google Places destination types into human-readable labels.
 *
 * Maps Google Places API type identifiers to user-friendly display names.
 * Returns up to 2 types joined with commas.
 *
 * @param types - Array of Google Places type identifiers (e.g., "locality", "country").
 * @returns Formatted string of destination types (e.g., "City, Country").
 */
export function formatDestinationTypes(types: string[]): string
⋮----
// biome-ignore lint/style/useNamingConvention: API values use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: API values use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: API values use snake_case
````

## File: src/lib/google/places-geocoding.ts
````typescript
/**
 * @fileoverview Google Places geocoding helper with policy-compliant caching.
 *
 * Resolves location strings to lat/lng coordinates using Google Places Text Search.
 * Caches results for up to 30 days per Google Maps Platform policy.
 */
⋮----
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { cacheLatLng, getCachedLatLng } from "@/lib/google/caching";
import { postPlacesSearch } from "@/lib/google/client";
import {
  buildGeocodeCacheKey,
  normalizePlacesTextQuery,
} from "@/lib/google/places-utils";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Field mask for geocoding requests (minimal fields needed for lat/lng).
 */
⋮----
/**
 * Resolves a location string to geographic coordinates.
 *
 * Uses cached results when available to reduce API calls. Caches successful
 * lookups for 30 days per Google Maps Platform policy.
 *
 * @param location - Location string to geocode (e.g., "New York, NY").
 * @returns Coordinates object with lat/lon, or null if location not found or API unavailable.
 */
export async function resolveLocationToLatLng(
  location: string
): Promise<
````

## File: src/lib/google/places-utils.ts
````typescript
/**
 * @fileoverview Shared utilities for Google Places API integration.
 *
 * Provides normalization and cache key helpers for Places queries.
 */
⋮----
import { hashInputForCache } from "@/lib/cache/hash";
⋮----
/**
 * Normalizes a text query for Google Places search.
 *
 * Trims whitespace, lowercases, and collapses multiple spaces into one.
 * Used consistently across geocoding and enrichment to ensure cache hits.
 *
 * @param text - Raw text query (e.g., "New York, NY" or hotel name/address).
 * @returns Normalized query string.
 */
export function normalizePlacesTextQuery(text: string): string
⋮----
/**
 * Builds a hashed cache key for geocoding queries.
 *
 * Uses SHA-256 hash to avoid exposing raw location strings in Redis keys.
 *
 * @param normalizedQuery - Normalized location query string.
 * @returns Cache key like "googleplaces:geocode:<hash>".
 */
export function buildGeocodeCacheKey(normalizedQuery: string): string
⋮----
/**
 * Builds a hashed cache key for query-to-place-id mappings.
 *
 * Uses SHA-256 hash to avoid exposing raw search queries in Redis keys.
 * This mapping stores only place_id (policy-compliant).
 *
 * @param normalizedQuery - Normalized search query string.
 * @returns Cache key like "places:q2id:<hash>".
 */
export function buildQueryToPlaceIdKey(normalizedQuery: string): string
````

## File: src/lib/google/polyline.ts
````typescript
/**
 * @fileoverview Polyline encoding/decoding utilities for Google Maps Routes.
 *
 * Provides utilities for decoding encoded polylines from Routes API responses
 * for client-side map rendering.
 */
⋮----
/**
 * Decode an encoded polyline string to an array of [lat, lng] coordinates.
 *
 * Implements the Google Polyline Algorithm Format.
 *
 * @param encoded Encoded polyline string from Routes API.
 * @returns Array of [latitude, longitude] coordinate pairs.
 */
export function decodePolyline(encoded: string): Array<[number, number]>
⋮----
/**
 * Encode an array of [lat, lng] coordinates to a polyline string.
 *
 * @param coordinates Array of [latitude, longitude] coordinate pairs.
 * @returns Encoded polyline string.
 */
export function encodePolyline(coordinates: Array<[number, number]>): string
⋮----
/**
 * Encode a single delta value for polyline encoding.
 *
 * @param value Delta value to encode.
 * @returns Encoded string segment.
 */
function encodeValue(value: number): string
````

## File: src/lib/http/retry.ts
````typescript
/**
 * @fileoverview Lightweight retry helper with exponential backoff and jitter.
 */
⋮----
import { secureRandomFloat } from "@/lib/security/random";
⋮----
/**
 * Retry configuration for {@link retryWithBackoff}.
 */
export type RetryOptions = {
  /** Maximum attempts including the initial call. */
  attempts: number;
  /** Base delay in milliseconds for backoff (attempt 1 waits baseDelayMs). */
  baseDelayMs: number;
  /** Optional cap for delay. */
  maxDelayMs?: number;
  /** Jitter ratio (0-1) to randomize delays. */
  jitterRatio?: number;
  /** Optional jitter generator for deterministic testing; receives jitterRange. */
  jitterFn?: (jitterRange: number) => number;
  /** Predicate to decide if an error is retryable. */
  isRetryable?: (error: unknown, attempt: number) => boolean;
  /** Hook invoked before each retry attempt. */
  onRetry?: (info: { attempt: number; delayMs: number; error: unknown }) => void;
};
⋮----
/** Maximum attempts including the initial call. */
⋮----
/** Base delay in milliseconds for backoff (attempt 1 waits baseDelayMs). */
⋮----
/** Optional cap for delay. */
⋮----
/** Jitter ratio (0-1) to randomize delays. */
⋮----
/** Optional jitter generator for deterministic testing; receives jitterRange. */
⋮----
/** Predicate to decide if an error is retryable. */
⋮----
/** Hook invoked before each retry attempt. */
⋮----
/**
 * Executes an async function with bounded retries and backoff jitter.
 *
 * @param fn Function to execute.
 * @param options Retry configuration.
 * @returns Result of fn if successful.
 * @throws Last error after exhausting retries.
 */
export async function retryWithBackoff<T>(
  fn: (attempt: number) => Promise<T>,
  options: RetryOptions
): Promise<T>
⋮----
function calculateDelay(params: {
  attempt: number;
  baseDelayMs: number;
  maxDelayMs?: number;
  jitterRatio: number;
jitterFn?: (jitterRange: number)
⋮----
function delay(ms: number): Promise<void>
⋮----
function clamp(value: number, min: number, max: number): number
⋮----
/**
 * Options for fetch retry behavior.
 */
export type FetchRetryOptions = {
  /**
   * Timeout in milliseconds. Default: 12000.
   */
  timeoutMs?: number;
  /**
   * Maximum number of retries (attempts = retries + 1). Default: 2.
   */
  retries?: number;
  /**
   * Base backoff delay in milliseconds. Actual delay is backoffMs * 2^attempt.
   * Default: 100.
   */
  backoffMs?: number;
};
⋮----
/**
   * Timeout in milliseconds. Default: 12000.
   */
⋮----
/**
   * Maximum number of retries (attempts = retries + 1). Default: 2.
   */
⋮----
/**
   * Base backoff delay in milliseconds. Actual delay is backoffMs * 2^attempt.
   * Default: 100.
   */
⋮----
/**
 * Fetch with timeout and retries.
 *
 * Implements exponential backoff between retry attempts using retryWithBackoff.
 * Throws errors with `code` and `meta` properties for consistent error handling.
 *
 * @param url - The URL to fetch.
 * @param init - Fetch options (RequestInit).
 * @param options - Retry and timeout options.
 * @returns The Response object on success.
 * @throws {Error} Error with `code` property set to "fetch_timeout" or "fetch_failed",
 *   and `meta` property containing attempt details.
 */
export function fetchWithRetry(
  url: string,
  init: RequestInit,
  options: FetchRetryOptions = {}
): Promise<Response>
⋮----
// Fresh controller and timeout for each attempt
⋮----
// Propagate caller aborts to our controller
⋮----
onCallerAbort = ()
⋮----
// Don't retry on timeout errors or abort errors
````

## File: src/lib/memory/mem0-adapter.ts
````typescript
/**
 * @fileoverview Mem0 adapter for memory orchestrator.
 *
 * Uses the official mem0ai Node SDK to enrich `fetchContext` intents by
 * retrieving user-specific memories for the current session.
 *
 * This adapter is optional and only enabled when MEM0_API_KEY is configured.
 * Uses MemoryClient for hosted Mem0 service.
 */
⋮----
import type { MemoryContextResponse } from "@schemas/chat";
import type {
  MemoryAdapter,
  MemoryAdapterContext,
  MemoryAdapterExecutionResult,
  MemoryIntent,
} from "./orchestrator";
⋮----
/**
 * Cached Mem0 client wrapper to avoid recreating MemoryClient instances.
 * The client is created once and reused for all memory fetch operations.
 */
⋮----
/**
 * Lazy loader for Mem0 SDK. We avoid importing the package when it is not
 * configured to keep bundles lean in environments without Mem0.
 *
 * The client is cached and reused across requests to avoid unnecessary
 * instantiation and potential connection/resource issues.
 */
async function loadMem0Client(): Promise<
⋮----
// Reuse cached client if API key hasn't changed
⋮----
// Import SDK only when needed
⋮----
// Create and cache the wrapper
⋮----
// biome-ignore lint/style/useNamingConvention: Mem0 API expects user_id
⋮----
// Mem0 returns Memory[] array, convert to expected format
⋮----
function getMem0ApiKey(): string | undefined
⋮----
// Server-side only - never expose to client
⋮----
async function handleFetchContext(
  intent: Extract<MemoryIntent, { type: "fetchContext" }>,
  _ctx: MemoryAdapterContext
): Promise<MemoryAdapterExecutionResult>
⋮----
// Use a simple query tying context to the current session.
⋮----
/**
 * Create Mem0 adapter if configuration is available.
 *
 * Returns null when Mem0 is not configured so callers can exclude it from
 * the orchestrator pipeline without additional checks.
 */
export function createMem0Adapter(): MemoryAdapter | null
⋮----
async handle(
      intent: MemoryIntent,
      ctx: MemoryAdapterContext
): Promise<MemoryAdapterExecutionResult>
````

## File: src/lib/memory/turn-utils.ts
````typescript
/**
 * @fileoverview Helpers for converting chat payloads into memory turns
 * and persisting them through the orchestrator.
 */
⋮----
import type { Message, MessageRole } from "@schemas/chat";
import type { UIMessage } from "ai";
import { handleMemoryIntent } from "@/lib/memory/orchestrator";
import { nowIso, secureUuid } from "@/lib/security/random";
⋮----
type ConversationRole = Extract<MessageRole, "assistant" | "user">;
⋮----
/**
 * Checks if a value is a record.
 *
 * @param value - The value to check.
 * @returns True if the value is a record, false otherwise.
 */
function isRecord(value: unknown): value is Record<string, unknown>
⋮----
/**
 * Flattens a list of text parts into a single string.
 * @param value - The value to flatten.
 * @returns A string.
 */
function flattenTextParts(value: unknown): string
⋮----
/**
 * Creates a memory turn from a text.
 *
 * @param role - The role of the turn.
 * @param content - The content of the turn.
 * @param overrides - The overrides to apply to the turn.
 * @returns A memory turn.
 */
function createMemoryTurn(
  role: ConversationRole,
  content: string,
  overrides: { id?: string; timestamp?: string } = {}
): Message | null
⋮----
/**
 * Converts a UI message to a memory turn.
 *
 * @param message - The UI message to convert.
 * @returns A memory turn or null if the message is not a user or assistant message.
 */
export function uiMessageToMemoryTurn(message: UIMessage): Message | null
⋮----
/**
 * Creates a memory turn from a text.
 *
 * @param role - The role of the turn.
 * @param content - The content of the turn.
 * @returns A memory turn.
 */
export function createTextMemoryTurn(
  role: ConversationRole,
  content: string
): Message | null
⋮----
/**
 * Converts a list of messages to a memory turn.
 *
 * @param messages - The messages to convert.
 * @returns A memory turn or null if no assistant messages are found.
 */
export function assistantResponseToMemoryTurn(messages: unknown[]): Message | null
⋮----
/**
 * Persists a memory turn to the database.
 *
 * @param logger - The logger to use.
 * @param sessionId - The session ID.
 * @param turn - The turn to persist.
 * @param userId - The user ID.
 * @returns A promise that resolves when the turn is persisted.
 */
export async function persistMemoryTurn({
  logger,
  sessionId,
  turn,
  userId,
}: {
logger?:
````

## File: src/lib/memory/upstash-adapter.ts
````typescript
/**
 * @fileoverview Upstash adapter for memory orchestrator.
 *
 * Delegates durable memory sync operations to QStash-backed jobs and uses
 * Upstash Redis for best-effort ephemeral state when available.
 */
⋮----
import {
  enqueueConversationMemorySync,
  enqueueFullMemorySync,
  enqueueIncrementalMemorySync,
} from "@/lib/qstash/memory-sync";
import { getRedis } from "@/lib/redis";
import type {
  MemoryAdapter,
  MemoryAdapterContext,
  MemoryAdapterExecutionResult,
  MemoryIntent,
} from "./orchestrator";
⋮----
async function handleOnTurnCommitted(
  intent: Extract<MemoryIntent, { type: "onTurnCommitted" }>
): Promise<MemoryAdapterExecutionResult>
⋮----
async function handleSyncSession(
  intent: Extract<MemoryIntent, { type: "syncSession" | "backfillSession" }>
): Promise<MemoryAdapterExecutionResult>
⋮----
async function writeEphemeralSessionHint(
  intent: MemoryIntent,
  ctx: MemoryAdapterContext
): Promise<void>
⋮----
// TTL-friendly timestamp
⋮----
// Best-effort cache; ignore errors
⋮----
/**
 * Create Upstash memory adapter.
 *
 * Responsibilities:
 * - Queue durable memory sync jobs via QStash for conversation, full, and incremental syncs.
 * - Maintain optional ephemeral hints in Redis to aid observability/debugging.
 */
export function createUpstashMemoryAdapter(): MemoryAdapter
⋮----
async handle(
      intent: MemoryIntent,
      ctx: MemoryAdapterContext
): Promise<MemoryAdapterExecutionResult>
⋮----
// Fire-and-forget: cache last intent for this session
````

## File: src/lib/payments/booking-payment.ts
````typescript
/**
 * @fileoverview Booking payment processing utilities.
 *
 * Handles payment authorization/charge and refunds for accommodation bookings.
 */
⋮----
import { createPaymentIntent, getPaymentIntent, refundPayment } from "./stripe-client";
⋮----
/**
 * Process booking payment and create accommodation booking.
 *
 * @param params - Booking payment parameters
 * @returns Payment confirmation details
 * @throws {Error} On payment failures
 */
export type ProcessBookingParams = {
  amount: number; // amount in smallest currency unit (e.g., cents)
  currency: string;
  paymentMethodId: string;
  customerId?: string;
  user: {
    email: string;
    name: string;
    phone?: string;
  };
};
⋮----
amount: number; // amount in smallest currency unit (e.g., cents)
⋮----
export type ProcessedPayment = {
  paymentIntentId: string;
};
⋮----
export async function processBookingPayment(
  params: ProcessBookingParams
): Promise<ProcessedPayment>
⋮----
// biome-ignore lint/style/useNamingConvention: Stripe metadata uses snake_case
⋮----
/**
 * Refund a booking payment.
 *
 * @param paymentIntentId - Stripe payment intent ID
 * @param amount - Optional partial refund amount in cents
 * @returns Refund confirmation
 */
export async function refundBookingPayment(
  paymentIntentId: string,
  amount?: number
): Promise<
⋮----
/**
 * Verify payment intent status before proceeding with booking.
 *
 * @param paymentIntentId - Stripe payment intent ID
 * @returns True if payment is confirmed, false otherwise
 */
export async function verifyPaymentStatus(paymentIntentId: string): Promise<boolean>
````

## File: src/lib/payments/stripe-client.ts
````typescript
/**
 * @fileoverview Stripe client for payment processing.
 *
 * Server-only module for creating payment intents and processing refunds.
 * Used for accommodation booking payments.
 */
⋮----
import Stripe from "stripe";
import { getServerEnvVar } from "@/lib/env/server";
import { getRequiredServerOrigin } from "@/lib/url/server-origin";
⋮----
/**
 * Get or create Stripe client instance.
 *
 * @returns Stripe client instance
 * @throws {Error} If STRIPE_SECRET_KEY is not configured
 */
export function getStripeClient(): Stripe
⋮----
// Use default API version (latest) - explicitly setting causes type mismatch
⋮----
/**
 * Create a payment intent for a booking.
 *
 * @param params - Payment intent parameters
 * @returns Stripe PaymentIntent
 * @throws {Stripe.errors.StripeError} On Stripe API errors
 */
export function createPaymentIntent(params: {
  amount: number; // Amount in cents
  currency: string;
  paymentMethodId: string;
  customerId?: string;
  metadata?: Record<string, string>;
}): Promise<Stripe.PaymentIntent>
⋮----
amount: number; // Amount in cents
⋮----
// biome-ignore lint/style/useNamingConvention: Stripe API uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Stripe API uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Stripe API uses snake_case
⋮----
/**
 * Refund a payment intent.
 *
 * @param paymentIntentId - Stripe payment intent ID
 * @param amount - Optional partial refund amount in cents (full refund if omitted)
 * @returns Stripe Refund
 * @throws {Stripe.errors.StripeError} On Stripe API errors
 */
export function refundPayment(
  paymentIntentId: string,
  amount?: number
): Promise<Stripe.Refund>
⋮----
// biome-ignore lint/style/useNamingConvention: Stripe API uses snake_case
⋮----
/**
 * Retrieve a payment intent by ID.
 *
 * @param paymentIntentId - Stripe payment intent ID
 * @returns Stripe PaymentIntent
 * @throws {Stripe.errors.StripeError} On Stripe API errors
 */
export function getPaymentIntent(
  paymentIntentId: string
): Promise<Stripe.PaymentIntent>
````

## File: src/lib/qstash/client.ts
````typescript
/**
 * @fileoverview Shared QStash client with enforced retry policy per ADR-0048.
 *
 * Centralizes QStash job enqueuing to ensure consistent retry configuration
 * across all webhook handlers. Implements policy defined in ADR-0048:
 * - 5 retries (6 total attempts)
 * - Exponential backoff starting at 10s
 *
 * Also provides a factory pattern for test injection support.
 */
⋮----
import { Client } from "@upstash/qstash";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
import { recordTelemetryEvent, withTelemetrySpan } from "@/lib/telemetry/span";
import { QSTASH_RETRY_CONFIG } from "./config";
⋮----
// ===== TYPES =====
⋮----
/**
 * QStash client interface for dependency injection.
 * Matches the subset of Client methods we use.
 */
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash API naming
export type QStashClientLike = {
  // biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash method name
  publishJSON: (opts: {
    url: string;
    body: unknown;
    headers?: Record<string, string>;
    retries?: number;
    delay?: number;
    deduplicationId?: string;
    callback?: string;
  }) => Promise<{ messageId: string; url?: string; scheduled?: boolean }>;
};
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash method name
⋮----
// ===== TEST INJECTION =====
⋮----
// Test injection point (follows factory.ts pattern)
⋮----
/**
 * Override QStash client factory for tests.
 * Pass null to reset to production behavior.
 *
 * @example
 * ```ts
 * import { setQStashClientFactoryForTests } from "@/lib/qstash/client";
 * import { createQStashMock } from "@/test/upstash/qstash-mock";
 *
 * const qstash = createQStashMock();
 * setQStashClientFactoryForTests(() => new qstash.Client({ token: "test" }));
 *
 * // After tests
 * setQStashClientFactoryForTests(null);
 * ```
 */
// biome-ignore lint/style/useNamingConvention: mirrors QStash naming
export function setQStashClientFactoryForTests(
  factory: (() => QStashClientLike) | null
): void
⋮----
// ===== CLIENT SINGLETON =====
⋮----
/**
 * Get or create the QStash client singleton.
 * Uses test factory if set, otherwise creates production client.
 *
 * @returns QStash client or null if QSTASH_TOKEN is not configured
 */
export function getQstashClient(): QStashClientLike | null
⋮----
/**
 * Check if QStash is available (token is configured).
 */
export function isQstashAvailable(): boolean
⋮----
// ===== HELPERS =====
⋮----
/**
 * Parse a delay string (e.g., "10s", "5m") to seconds.
 *
 * @throws Error if the delay string format is invalid
 */
function parseDelayToSeconds(delay: string): number
⋮----
type DelayUnit = "s" | "m" | "h" | "d";
⋮----
// ===== JOB ENQUEUE =====
⋮----
/**
 * Options for enqueuing a job.
 */
export interface EnqueueJobOptions {
  /** Deduplication ID to prevent duplicate jobs (optional) */
  deduplicationId?: string;
  /** Delay before first delivery in seconds */
  delay?: number;
  /** Override default retry count */
  retries?: number;
}
⋮----
/** Deduplication ID to prevent duplicate jobs (optional) */
⋮----
/** Delay before first delivery in seconds */
⋮----
/** Override default retry count */
⋮----
/**
 * Result of a successful job enqueue.
 */
export interface EnqueueJobResult {
  /** QStash message ID for tracking */
  messageId: string;
}
⋮----
/** QStash message ID for tracking */
⋮----
/**
 * Enqueue a job to a QStash-backed worker endpoint.
 *
 * Enforces ADR-0048 retry policy:
 * - 5 retries (6 total attempts)
 * - Exponential backoff starting at 10s
 *
 * @param jobType - Type identifier for the job (used in telemetry)
 * @param payload - Job payload to deliver
 * @param path - Worker endpoint path (e.g., "/api/jobs/notify-collaborators")
 * @param options - Optional enqueue configuration
 * @returns EnqueueJobResult with messageId, or null if QStash unavailable
 *
 * @example
 * ```ts
 * const result = await enqueueJob(
 *   "notify-collaborators",
 *   { eventKey, payload },
 *   "/api/jobs/notify-collaborators"
 * );
 * if (result) {
 *   console.log("Enqueued:", result.messageId);
 * }
 * ```
 */
export async function enqueueJob(
  jobType: string,
  payload: unknown,
  path: string,
  options: EnqueueJobOptions = {}
): Promise<EnqueueJobResult | null>
⋮----
// Get origin for building full URL
⋮----
// Deduplication is caller-controlled; random IDs defeat dedup purpose
⋮----
// Parse delay from config (e.g., "10s" -> 10)
⋮----
// Publish with enforced retry policy from ADR-0048
⋮----
// Handle response - messageId is present on PublishToUrlResponse
⋮----
/**
 * Enqueue a job with error handling that returns success/failure status.
 *
 * Unlike `enqueueJob`, this function catches errors and returns a result
 * object suitable for handlers that need to implement fallback behavior.
 *
 * @param jobType - Type identifier for the job
 * @param payload - Job payload to deliver
 * @param path - Worker endpoint path
 * @param options - Optional enqueue configuration
 * @returns Object with success status and optional error/messageId
 */
export async function tryEnqueueJob(
  jobType: string,
  payload: unknown,
  path: string,
  options: EnqueueJobOptions = {}
): Promise<
  { success: true; messageId: string } | { success: false; error: Error | null }
> {
  try {
    const result = await enqueueJob(jobType, payload, path, options);
````

## File: src/lib/qstash/config.ts
````typescript
/**
 * @fileoverview QStash configuration constants per ADR-0048.
 */
⋮----
/**
 * QStash retry configuration for webhook job handlers.
 * Max 6 total attempts (1 initial + 5 retries) with exponential backoff.
 */
⋮----
/** Initial delay before first retry (QStash uses exponential backoff) */
⋮----
/** Number of retry attempts after initial failure */
⋮----
/** Redis key prefix for dead letter queue entries */
⋮----
/** TTL for DLQ entries in seconds (7 days) */
⋮----
/** Maximum number of DLQ entries to keep per job type */
⋮----
/** Threshold for DLQ size alerts */
⋮----
/** QStash signing key header name */
````

## File: src/lib/qstash/dlq.ts
````typescript
/**
 * @fileoverview Dead Letter Queue (DLQ) implementation for failed QStash jobs.
 *
 * Per ADR-0048, failed jobs after max retries are stored in Redis for later review.
 * Implements:
 * - Payload sanitization to prevent PII exposure
 * - Alerting via telemetry events for monitoring
 * - Atomic LREM operations for thread-safe removal
 * - Error stack trace preservation for debugging
 */
⋮----
import { z } from "zod";
import { getRedis } from "@/lib/redis";
import { nowIso, secureUuid } from "@/lib/security/random";
import { warnRedisUnavailable } from "@/lib/telemetry/redis";
import { recordTelemetryEvent, withTelemetrySpan } from "@/lib/telemetry/span";
import {
  DLQ_ALERT_THRESHOLD,
  DLQ_KEY_PREFIX,
  DLQ_MAX_ENTRIES,
  DLQ_TTL_SECONDS,
} from "./config";
⋮----
// ===== CONSTANTS =====
⋮----
/**
 * Sensitive field names to redact from payloads before storing in DLQ.
 * These patterns protect PII and credentials if Redis is compromised.
 * Includes both camelCase and snake_case variants.
 */
⋮----
// Authentication & secrets
⋮----
// Personal identifiers
⋮----
// Financial
⋮----
// Contact info
⋮----
// ===== SCHEMAS =====
⋮----
/**
 * Schema for a DLQ entry stored in Redis.
 */
⋮----
/** Number of attempts made before final failure */
⋮----
/** Error message or stringified error */
⋮----
/** Error code if available (e.g., "ECONNREFUSED") */
⋮----
/** Error stack trace for debugging */
⋮----
/** ISO timestamp when the job was moved to DLQ */
⋮----
/** Unique identifier for this DLQ entry */
⋮----
/** Type of job that failed (e.g., "notify-collaborators") */
⋮----
/** Original job payload (sanitized to remove PII) */
⋮----
// biome-ignore lint/style/useNamingConvention: DLQ is established acronym for Dead Letter Queue
export type DLQEntry = z.infer<typeof dlqEntrySchema>;
⋮----
// ===== DLQ OPERATIONS =====
⋮----
/**
 * Push a failed job to the Dead Letter Queue in Redis.
 *
 * Implements:
 * - Payload sanitization to redact PII before storage
 * - Alerting via telemetry events for monitoring
 * - Error stack trace storage for debugging
 *
 * @param jobType - Type of job (e.g., "notify-collaborators", "memory-sync")
 * @param payload - Original job payload (will be sanitized)
 * @param error - Error message or object
 * @param attempts - Number of attempts made
 * @return Promise resolving to the DLQ entry ID, or null if Redis unavailable
 */
// biome-ignore lint/style/useNamingConvention: DLQ is established acronym for Dead Letter Queue
export async function pushToDLQ(
  jobType: string,
  payload: unknown,
  error: unknown,
  attempts: number
): Promise<string | null>
⋮----
// Extract error details including stack trace
⋮----
// Sanitize payload to prevent PII exposure
⋮----
// Use LPUSH to add to front of list - returns new list length
⋮----
// Trim list to max entries to prevent unbounded growth
⋮----
// Set TTL on the list (refreshed on each push)
⋮----
// Emit alerting event for observability
⋮----
// Use LPUSH return value (new length) for threshold check - avoids extra Redis call
⋮----
/**
 * List DLQ entries for a specific job type or all types.
 *
 * @param jobType - Filter by job type (optional, lists all if not provided)
 * @param limit - Maximum entries to return (default 100)
 * @return Promise resolving to array of DLQ entries
 */
// biome-ignore lint/style/useNamingConvention: DLQ is established acronym for Dead Letter Queue
export async function listDLQEntries(
  jobType?: string,
  limit = 100
): Promise<DLQEntry[]>
⋮----
// Single job type query
⋮----
// Scan all DLQ keys (pattern: qstash-dlq:*)
⋮----
let perTypeLimit = Math.max(1, Math.ceil(limit / 10)); // Initial conservative estimate
⋮----
/**
 * Remove a specific DLQ entry by ID.
 *
 * Uses atomic LREM operation to prevent race conditions during concurrent
 * removals. The previous read-modify-write pattern could lose entries
 * when multiple workers processed the same list.
 *
 * @param jobType - Job type the entry belongs to
 * @param entryId - Entry ID to remove
 * @return Promise resolving to true if removed, false otherwise
 */
// biome-ignore lint/style/useNamingConvention: DLQ is established acronym for Dead Letter Queue
export async function removeDLQEntry(
  jobType: string,
  entryId: string
): Promise<boolean>
⋮----
// Atomically scan and remove matching entry via Lua to avoid race conditions
⋮----
/**
 * Get the count of DLQ entries for a job type.
 *
 * @param jobType - Job type to count
 * @return Promise resolving to entry count
 */
// biome-ignore lint/style/useNamingConvention: DLQ is established acronym for Dead Letter Queue
export async function getDLQCount(jobType: string): Promise<number>
⋮----
// ===== HELPERS =====
⋮----
/**
 * Parse a raw DLQ entry from Redis.
 *
 * @param raw - Raw entry from Redis (string or object)
 * @return Parsed DLQ entry or null if invalid
 */
function parseDlqEntry(raw: unknown): DLQEntry | null
⋮----
/**
 * Sanitize a payload before storing in DLQ to prevent PII exposure.
 *
 * - Strings are never stored verbatim: we try JSON.parse, otherwise redact.
 * - Objects/arrays are recursively redacted by field name.
 * - Other primitives are returned as-is.
 *
 * @param payload - Raw payload to sanitize
 * @return Sanitized payload with sensitive fields redacted
 */
function sanitizePayloadForDlq(
  payload: unknown,
  seen: WeakSet<object> = new WeakSet()
): unknown
⋮----
// Recursively sanitize nested objects (including record/old_record)
````

## File: src/lib/qstash/memory-sync.ts
````typescript
/**
 * @fileoverview QStash memory sync job enqueue utilities.
 * Provides typed helpers for enqueuing memory sync operations with proper
 * deduplication and error handling.
 */
⋮----
import type { MemorySyncJob } from "@schemas/webhooks";
import { secureUuid } from "@/lib/security/random";
import { getRequiredServerOrigin } from "@/lib/url/server-origin";
import { getQstashClient } from "./client";
⋮----
/**
 * Enqueue a memory sync job via QStash with deduplication.
 *
 * @param payload - Memory sync job payload.
 * @param options - Optional enqueue configuration.
 * @return Promise resolving to enqueue result.
 */
export async function enqueueMemorySync(
  payload: MemorySyncJob["payload"],
  options: {
    delay?: number;
    retries?: number;
    idempotencyKey?: string;
  } = {}
): Promise<
⋮----
// Use getRequiredServerOrigin which throws in production if not configured
⋮----
/**
 * Enqueue conversation memory storage for a chat session.
 *
 * @param sessionId - Chat session identifier.
 * @param userId - User identifier.
 * @param messages - Conversation messages to store.
 * @return Promise resolving to enqueue result.
 */
export function enqueueConversationMemorySync(
  sessionId: string,
  userId: string,
  messages: Array<{
    content: string;
    role: "user" | "assistant" | "system";
    timestamp: string;
    metadata?: Record<string, unknown>;
  }>
): Promise<
⋮----
delay: 1000, // Small delay to batch rapid messages
⋮----
/**
 * Enqueue full memory context sync for a session.
 *
 * @param sessionId - Chat session identifier.
 * @param userId - User identifier.
 * @return Promise resolving to enqueue result.
 */
export function enqueueFullMemorySync(
  sessionId: string,
  userId: string
): Promise<
⋮----
/**
 * Enqueue incremental memory context update.
 *
 * @param sessionId - Chat session identifier.
 * @param userId - User identifier.
 * @return Promise resolving to enqueue result.
 */
export function enqueueIncrementalMemorySync(
  sessionId: string,
  userId: string
): Promise<
⋮----
delay: 5000, // Debounce incremental updates
````

## File: src/lib/query/config.ts
````typescript
/**
 * @fileoverview Shared TanStack Query timing constants (milliseconds).
 */
⋮----
/** Stale times for different query types (ms). */
⋮----
// Core domains
budget: 5 * 60 * 1000, // 5 minutes - budget data
⋮----
// App-wide feature groups
categories: 60 * 60 * 1000, // 1 hour - typically stable reference data
chat: 30 * 1000, // 30 seconds - conversation context
configuration: 60 * 60 * 1000, // 1 hour - app/config data changes rarely
currency: 60 * 60 * 1000, // 1 hour - exchange rates rarely change
dashboard: 30 * 1000, // 30 seconds - fast-changing metrics
default: 5 * 60 * 1000, // 5 minutes - global fallback
files: 5 * 60 * 1000, // 5 minutes - attachment listings, etc.
memory: 5 * 60 * 1000, // 5 minutes - user preferences
realtime: 30 * 1000, // 30 seconds - realtime-adjacent computed data
search: 2 * 60 * 1000, // 2 minutes - search results
stats: 15 * 60 * 1000, // 15 minutes - derived aggregates
suggestions: 15 * 60 * 1000, // 15 minutes - recommendations
trips: 2 * 60 * 1000, // 2 minutes - trip data
user: 5 * 60 * 1000, // 5 minutes - user/session scoped data
⋮----
/** Cache times for different retention periods (ms). */
⋮----
long: 60 * 60 * 1000, // 1 hour
medium: 10 * 60 * 1000, // 10 minutes
short: 5 * 60 * 1000, // 5 minutes
````

## File: src/lib/rag/reranker.ts
````typescript
/**
 * @fileoverview Pluggable reranker interface with Together.ai implementation.
 *
 * Provides cross-encoder reranking to improve RAG result relevance.
 * Primary: Together.ai with Mixedbread mxbai-rerank-large-v2
 * Fallback: NoOp reranker returns documents unchanged
 */
⋮----
import { togetherai } from "@ai-sdk/togetherai";
import type { RagSearchResult, RerankerConfig } from "@schemas/rag";
import { rerankerConfigSchema } from "@schemas/rag";
import { rerank } from "ai";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Pluggable reranker interface.
 * Implementations must rerank documents and return scores.
 */
export interface Reranker {
  /**
   * Reranks documents by relevance to the query.
   *
   * @param query - User's search query.
   * @param documents - Retrieved documents to rerank.
   * @param topN - Number of top results to return.
   * @returns Reranked results with relevance scores.
   */
  rerank(
    query: string,
    documents: RagSearchResult[],
    topN: number
  ): Promise<RagSearchResult[]>;
}
⋮----
/**
   * Reranks documents by relevance to the query.
   *
   * @param query - User's search query.
   * @param documents - Retrieved documents to rerank.
   * @param topN - Number of top results to return.
   * @returns Reranked results with relevance scores.
   */
rerank(
    query: string,
    documents: RagSearchResult[],
    topN: number
  ): Promise<RagSearchResult[]>;
⋮----
/**
 * Together.ai reranker using Mixedbread mxbai-rerank-large-v2.
 *
 * Features:
 * - 100x cheaper than Cohere ($0.002/1k vs $0.05/1k queries)
 * - Native AI SDK v6 support via @ai-sdk/togetherai
 * - 100+ languages, 8K context, code/SQL support
 * - ELO 1468 quality (competitive for RAG)
 */
export class TogetherReranker implements Reranker
⋮----
constructor(config: Partial<RerankerConfig> =
⋮----
// biome-ignore lint/suspicious/useAwait: Returns withTelemetrySpan promise which is async
async rerank(
    query: string,
    documents: RagSearchResult[],
    topN: number
): Promise<RagSearchResult[]>
⋮----
// Map reranked results back to original documents with scores
⋮----
// Sort by rerank score (already sorted by rerank(), but ensure order)
⋮----
// Log error but don't throw - allow graceful fallback
⋮----
// Fallback: return original documents sorted by combined score
⋮----
/**
 * NoOp reranker that returns documents unchanged.
 * Used as fallback when reranking is disabled or fails.
 */
export class NoOpReranker implements Reranker
⋮----
// biome-ignore lint/suspicious/useAwait: Interface requires async signature
async rerank(
    _query: string,
    documents: RagSearchResult[],
    topN: number
): Promise<RagSearchResult[]>
⋮----
// Return documents sorted by combined score, limited to topN
⋮----
/**
 * Factory function to create a reranker instance.
 *
 * @param config - Reranker configuration.
 * @returns Configured reranker instance.
 *
 * @example
 * ```typescript
 * const reranker = createReranker({ provider: "together", timeout: 700 });
 * const reranked = await reranker.rerank(query, documents, 10);
 * ```
 */
export function createReranker(config: Partial<RerankerConfig> =
⋮----
// TypeScript exhaustiveness check
````

## File: src/lib/ratelimit/config.ts
````typescript
/**
 * @fileoverview Rate limit configuration for agent workflows.
 *
 * Provides rate limiting for agent tool execution within agent runtime.
 * Route-level rate limiting is handled by lib/ratelimit/routes.ts via
 * withApiGuards. Per ADR-0032.
 */
⋮----
import type { AgentWorkflowKind } from "@schemas/agents";
⋮----
/**
 * Default rate limit window for all workflows.
 *
 * All workflows use a 1-minute sliding window for rate limiting.
 */
⋮----
/**
 * Per-tool rate limit configuration mapping workflows to their request limits.
 *
 * Defines the maximum number of tool calls allowed per window for each
 * workflow. Limits are chosen based on workflow complexity and resource usage.
 */
⋮----
/**
 * Workflow-specific rate limit metadata shared across guardrails.
 */
export type WorkflowRateLimit = {
  identifier: string;
  limit: number;
  window: typeof RATE_LIMIT_WINDOW;
};
⋮----
/**
 * Builds a workflow-specific rate limit configuration.
 *
 * Returns a rate limit configuration object with the workflow-specific limit
 * and the default window. Uses the AgentWorkflowKind enum for type safety.
 *
 * @param workflow The agent workflow identifier from AgentWorkflowKind enum.
 * @param identifier Stable user or IP-based identifier (already hashed if needed).
 * @returns Rate limit configuration with workflow-specific limit and default window.
 * @throws {Error} If workflow is not found in configuration (should not happen due to Record type).
 */
export function buildRateLimit(
  workflow: AgentWorkflowKind,
  identifier: string
): WorkflowRateLimit
````

## File: src/lib/realtime/backoff.ts
````typescript
/**
 * @fileoverview Exponential backoff helper for Realtime reconnection logic.
 * Pure, deterministic utility with no React or Supabase dependencies.
 */
⋮----
import type { BackoffConfig } from "@schemas/realtime";
import { backoffConfigSchema } from "@schemas/realtime";
⋮----
// Re-export type from schemas
⋮----
/**
 * Computes the backoff delay for a given attempt number using exponential backoff.
 *
 * @param attempt - Zero-based attempt number (0 = first retry, 1 = second retry, etc.).
 * @param config - Backoff configuration parameters (validated via Zod schema).
 * @returns Delay in milliseconds. Returns 0 for attempt <= 0.
 *
 * @example
 * ```ts
 * const config = { initialDelayMs: 1000, maxDelayMs: 30000, factor: 2 };
 * computeBackoffDelay(0, config); // 1000ms
 * computeBackoffDelay(1, config); // 2000ms
 * computeBackoffDelay(2, config); // 4000ms
 * computeBackoffDelay(10, config); // 30000ms (capped at maxDelayMs)
 * ```
 */
export function computeBackoffDelay(attempt: number, config: BackoffConfig): number
⋮----
// Validate config using Zod schema
⋮----
/**
 * Default backoff configuration used across realtime reconnection flows.
 */
````

## File: src/lib/realtime/status.ts
````typescript
/**
 * @fileoverview Shared realtime status types and helpers.
 */
⋮----
import type { ConnectionStatus } from "@schemas/realtime";
⋮----
/**
 * Maps low-level Supabase channel states to the app-level connection status.
 */
export function mapChannelStateToStatus(
  state: "idle" | "connecting" | "subscribed" | "error" | "closed",
  hasError: boolean
): ConnectionStatus
⋮----
/**
 * Human-friendly label for rendering connection status.
 */
export function formatConnectionStatus(status: ConnectionStatus): string
````

## File: src/lib/repositories/trips-repo.ts
````typescript
/**
 * @fileoverview Trip repository: typed Supabase CRUD + UI mapping with Zod validation.
 */
⋮----
import type { TripsInsert, TripsRow, TripsUpdate } from "@schemas/supabase";
import {
  tripsInsertSchema,
  tripsRowSchema,
  tripsUpdateSchema,
} from "@schemas/supabase";
import { createClient, type TypedSupabaseClient } from "@/lib/supabase";
import { insertSingle, updateSingle } from "@/lib/supabase/typed-helpers";
import { mapDbTripToUi } from "@/lib/trips/mappers";
⋮----
/**
 * Gets a Supabase client, throwing if unavailable (e.g., during SSR).
 * @internal
 */
function getClientOrThrow(): TypedSupabaseClient
⋮----
// Re-export types from schemas
export type TripRow = TripsRow;
export type TripInsert = TripsInsert;
export type TripUpdate = TripsUpdate;
⋮----
/**
 * Creates a new trip in the database.
 *
 * Validates the input data using Zod schema, inserts the trip record,
 * and returns the created trip in UI-friendly format.
 *
 * @param data - Trip creation data excluding user_id, plus required user_id
 * @returns Promise resolving to the created trip in UI format
 * @throws Error if validation fails or database insertion fails
 */
export async function createTrip(
  // biome-ignore lint/style/useNamingConvention: Database column names use snake_case
  data: Omit<TripInsert, "user_id"> & { user_id: string }
)
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// Validate input using Zod schema
⋮----
// Validate response using Zod schema
⋮----
/**
 * Updates an existing trip in the database.
 *
 * Validates the update data using Zod schema, updates the trip record
 * for the specified ID and user, and returns the updated trip in UI-friendly format.
 * Only allows updates for trips owned by the specified user.
 *
 * @param id - The numeric ID of the trip to update
 * @param userId - The user ID for ownership verification
 * @param updates - Partial trip data to update
 * @returns Promise resolving to the updated trip in UI format
 * @throws Error if validation fails, trip not found, or database update fails
 */
export async function updateTrip(id: number, userId: string, updates: TripUpdate)
⋮----
// Validate input using Zod schema
⋮----
// Validate response using Zod schema
⋮----
/**
 * Retrieves all trips from the database.
 *
 * Fetches all trip records ordered by creation date (newest first)
 * and returns them in UI-friendly format.
 *
 * @returns Promise resolving to array of trips in UI format
 * @throws Error if database query fails
 */
export async function listTrips()
⋮----
// Validate all rows using Zod schema
⋮----
/**
 * Deletes a trip from the database.
 *
 * Removes the trip record with the specified ID. If userId is provided,
 * only deletes trips owned by that user for additional security.
 *
 * @param id - The numeric ID of the trip to delete
 * @param userId - Optional user ID for ownership verification
 * @returns Promise resolving to true if deletion succeeded
 * @throws Error if database deletion fails
 */
export async function deleteTrip(id: number, userId?: string)
````

## File: src/lib/schema/json-schema.ts
````typescript
/**
 * @fileoverview JSON Schema generation utilities for Zod schemas.
 * Uses Zod v4.2.0 native .toJSONSchema() for OpenAPI documentation.
 */
⋮----
import { z } from "zod";
⋮----
/**
 * JSON Schema generation target formats.
 * - json-schema-draft-2020-12: Standard JSON Schema
 * - openapi-3.1: OpenAPI 3.1 compatible schema
 */
export type JsonSchemaTarget = "json-schema-draft-2020-12" | "openapi-3.1";
⋮----
/**
 * Options for JSON Schema generation.
 */
export interface ToJsonSchemaOptions {
  /** Target format for the generated schema. Defaults to openapi-3.1. */
  target?: JsonSchemaTarget;
}
⋮----
/** Target format for the generated schema. Defaults to openapi-3.1. */
⋮----
/**
 * Generate JSON Schema from a Zod schema for OpenAPI 3.1 compatibility.
 *
 * @example
 * ```typescript
 * const userSchema = z.object({ name: z.string(), age: z.number() });
 * const jsonSchema = toJsonSchema(userSchema);
 * // => { type: "object", properties: { name: { type: "string" }, age: { type: "number" } }, required: ["name", "age"] }
 * ```
 */
export function toJsonSchema<T extends z.ZodType>(
  schema: T,
  options?: ToJsonSchemaOptions
): Record<string, unknown>
⋮----
/**
 * Generate JSON Schema for multiple schemas as a registry.
 * Useful for generating schemas for all API endpoints at once.
 *
 * @example
 * ```typescript
 * const schemas = {
 *   User: userSchema,
 *   Trip: tripSchema,
 *   Flight: flightSchema,
 * };
 * const registry = toJsonSchemaRegistry(schemas);
 * // => { User: {...}, Trip: {...}, Flight: {...} }
 * ```
 */
export function toJsonSchemaRegistry(
  schemas: Record<string, z.ZodType>,
  options?: ToJsonSchemaOptions
): Record<string, unknown>
⋮----
/**
 * Generate JSON Schema with metadata from a described Zod schema.
 * Preserves .describe() and .meta() annotations in the output.
 *
 * @example
 * ```typescript
 * const schema = z.object({
 *   email: z.email().describe("User's email address"),
 *   age: z.number().min(18).describe("User's age (must be 18+)"),
 * }).meta({ title: "User", description: "A user entity" });
 *
 * const jsonSchema = toJsonSchemaWithMetadata(schema);
 * ```
 */
export function toJsonSchemaWithMetadata<T extends z.ZodType>(
  schema: T,
  options?: ToJsonSchemaOptions
): Record<string, unknown>
````

## File: src/lib/security/api-key-validation.ts
````typescript
/**
 * @fileoverview API key input validation helpers.
 *
 * These checks are intentionally lightweight to avoid false negatives; server-side
 * validation remains the source of truth.
 */
⋮----
export type ApiKeyValidationResult =
  | { ok: true; apiKey: string }
  | { ok: false; apiKey: string; error: string };
⋮----
export type ApiKeyService = "openai" | "openrouter" | "anthropic" | "xai";
⋮----
function getExpectedApiKeyPrefix(service: ApiKeyService): string
⋮----
function getPrefixMismatchError(service: ApiKeyService, apiKey: string): string
⋮----
function getServiceDisplayName(service: ApiKeyService): string
⋮----
/**
 * Validate a user-provided API key input for basic client-side sanity checks.
 *
 * @param rawApiKey - Raw user input (may include surrounding whitespace).
 * @param options - Optional validation options.
 * @param options.minLength - Minimum length (defaults to DEFAULT_API_KEY_MIN_LENGTH).
 * @param options.service - When provided, performs a lightweight provider-specific prefix check.
 * @returns An ApiKeyValidationResult containing the trimmed apiKey and ok/error fields.
 */
export function validateApiKeyInput(
  rawApiKey: string,
  options?: { minLength?: number; service?: ApiKeyService }
): ApiKeyValidationResult
````

## File: src/lib/security/botid.ts
````typescript
/**
 * @fileoverview BotID integration for bot detection on high-value API routes.
 *
 * Provides server-side bot detection using Vercel BotID to protect chat and
 * agent endpoints from sophisticated automated bots. Verified AI assistants
 * (ChatGPT, Perplexity, Claude, etc.) are allowed through while still being
 * subject to rate limiting.
 *
 * Per ADR-0059 and SPEC-0038.
 *
 * @see https://vercel.com/docs/botid
 */
⋮----
import { checkBotId } from "botid/server";
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/**
 * Result type from checkBotId with verified bot info.
 * The actual return type is a union, but we extract the fields we need.
 */
export interface BotIdVerification {
  isBot: boolean;
  isHuman: boolean;
  isVerifiedBot: boolean;
  bypassed: boolean;
  verifiedBotName?: string;
  verifiedBotCategory?: string;
}
⋮----
/**
 * Categories of verified bots allowed through BotID protection.
 *
 * Currently allows AI assistants (ChatGPT, Perplexity, Claude web search, etc.)
 * while blocking other bot categories (search crawlers, monitors, etc.).
 *
 * @see https://vercel.com/docs/botid/verified-bots
 * @see https://bots.fyi for the full verified bot directory
 */
⋮----
type AllowedBotCategory = (typeof ALLOWED_VERIFIED_BOT_CATEGORIES)[number];
⋮----
/**
 * Error thrown when a bot is detected attempting to access a protected route.
 *
 * Contains the route name and verification info for logging and debugging.
 */
export class BotDetectedError extends Error
⋮----
constructor(routeName: string, verification: BotIdVerification)
⋮----
/**
   * User-friendly error message for display.
   */
get userMessage(): string
⋮----
/**
   * Convert to JSON for logging (excludes sensitive verification details).
   */
// biome-ignore lint/style/useNamingConvention: Standard JSON serialization method
toJSON()
⋮----
/**
 * Type guard to check if an error is a BotDetectedError.
 *
 * @param error - The error to check.
 * @returns True if the error is a BotDetectedError.
 */
export function isBotDetectedError(error: unknown): error is BotDetectedError
⋮----
/**
 * Options for the assertHumanOrThrow function.
 */
export interface AssertHumanOptions {
  /**
   * BotID detection level.
   * - "basic": Free tier, validates browser sessions (default)
   * - "deep": Kasada-powered analysis with thousands of signals ($1/1000 calls)
   *
   * @default "basic"
   */
  level?: "basic" | "deep";

  /**
   * Whether to allow verified AI assistants (ChatGPT, Perplexity, Claude, etc.).
   * They will still be subject to rate limiting via Upstash.
   *
   * @default true
   */
  allowVerifiedAiAssistants?: boolean;
}
⋮----
/**
   * BotID detection level.
   * - "basic": Free tier, validates browser sessions (default)
   * - "deep": Kasada-powered analysis with thousands of signals ($1/1000 calls)
   *
   * @default "basic"
   */
⋮----
/**
   * Whether to allow verified AI assistants (ChatGPT, Perplexity, Claude, etc.).
   * They will still be subject to rate limiting via Upstash.
   *
   * @default true
   */
⋮----
/**
 * Asserts that the current request is from a human user, not a bot.
 *
 * This function performs BotID verification and throws a BotDetectedError
 * if a bot is detected (unless it's a verified AI assistant and that
 * option is enabled).
 *
 * @param routeName - Name of the route being protected (for logging).
 * @param options - Configuration options.
 * @throws {BotDetectedError} If a bot is detected.
 *
 * @example
 * ```typescript
 * // In a route handler:
 * await assertHumanOrThrow("chat.stream", {
 *   allowVerifiedAiAssistants: true,
 * });
 * ```
 *
 * @see https://vercel.com/docs/botid/get-started
 */
export async function assertHumanOrThrow(
  routeName: string,
  options: AssertHumanOptions = {}
): Promise<void>
⋮----
// Normalize the result to our interface (handle union type)
⋮----
// Allow verified AI assistants (ChatGPT, Perplexity, Claude, etc.)
⋮----
// Return without throwing - bot is allowed but still subject to rate limiting
⋮----
// Log the bot detection event
⋮----
/**
 * Response schema for bot detection errors (403 Forbidden).
 *
 * Used for consistent error responses across protected routes.
 */
````

## File: src/lib/security/mfa-client.ts
````typescript
/**
 * @fileoverview Client-safe MFA API helpers for dashboard UI.
 */
⋮----
import type {
  BackupCodeRegenerateInput,
  BackupCodeVerifyInput,
  MfaChallengeInput,
  MfaFactor,
  MfaVerificationInput,
} from "@schemas/mfa";
⋮----
/** Basic JSON fetch wrapper that throws on non-2xx with normalized message. */
async function fetchJson<T>(url: string, init?: RequestInit): Promise<T>
⋮----
/** Lists MFA factors and current AAL. */
export async function refreshMfaFactors(): Promise<
⋮----
/** Starts TOTP enrollment and returns QR code + challenge identifiers. */
export async function startMfaEnrollment(): Promise<
⋮----
/** Issues a new MFA challenge for an existing factor. */
export async function resendMfaChallenge(input: MfaChallengeInput): Promise<
⋮----
/**
 * Verifies a TOTP MFA code. After a successful verification, refetch factors/AAL
 * to keep the UI state in sync, mirroring the previous server action contract.
 */
export async function verifyMfaTotp(input: MfaVerificationInput): Promise<
⋮----
/** Verifies a backup code. */
export async function verifyMfaBackup(code: string): Promise<
⋮----
/** Regenerates backup codes (requires AAL2). */
export async function regenerateMfaBackups(count: number): Promise<
⋮----
/** Revokes other sessions for the current user. */
export async function revokeOtherSessions(): Promise<void>
````

## File: src/lib/security/mfa-error.ts
````typescript
/**
 * @fileoverview Shared MFA error classification and logging helpers.
 */
⋮----
import type { createServerLogger } from "@/lib/telemetry/logger";
⋮----
export type MfaErrorClassification = {
  status: number;
  code: string;
  reason: string;
};
⋮----
/**
 * Classify MFA-related errors into status/code/reason tuples for responses.
 */
export function classifyMfaError(
  error: unknown,
  fallbackCode = "internal_error"
): MfaErrorClassification
⋮----
/**
 * Log MFA errors with sanitized metadata. Avoids passing raw error objects to the
 * logger; uses message/code/status plus selected context fields.
 */
export function logMfaError(
  logger: ReturnType<typeof createServerLogger>,
  error: unknown,
  context?: Record<string, unknown>,
  fallbackCode = "internal_error"
): void
⋮----
function sanitizeContext(context?: Record<string, unknown>): Record<string, unknown>
⋮----
function pickStatus(error: unknown): number | undefined
⋮----
function deriveCode(message: string): string | undefined
⋮----
function deriveReason(message: string): string | undefined
⋮----
function normalizeMessage(error: unknown): string
````

## File: src/lib/security/prompt-sanitizer.ts
````typescript
/**
 * @fileoverview Shared AI prompt sanitization utilities.
 *
 * Provides functions to sanitize user inputs before interpolation into AI prompts,
 * preventing prompt injection attacks. Can be used across all AI-generating routes.
 *
 * @see https://owasp.org/www-project-top-ten/ (A03:2021 - Injection)
 */
⋮----
/**
 * Common prompt injection patterns to detect.
 * These patterns are commonly used to hijack LLM behavior.
 */
⋮----
// Directive commands that try to override system prompts
⋮----
// Attempts to invoke tools or functions
⋮----
// Attempts to ignore previous instructions
⋮----
// JSON injection attempts
⋮----
// Role-playing attempts
⋮----
/**
 * Sanitize a string for safe use in AI prompts.
 *
 * Removes control characters, collapses whitespace, and limits length.
 * Does NOT detect injection patterns - use `hasInjectionRisk()` for that.
 *
 * @param input - The string to sanitize.
 * @param maxLength - Maximum allowed length (default: 200).
 * @returns Sanitized string safe for prompt interpolation.
 *
 * @example
 * ```ts
 * const safeName = sanitizeForPrompt(userInput.name, 100);
 * const prompt = `Analyze hotel: "${safeName}"`;
 * ```
 */
export function sanitizeForPrompt(input: string, maxLength = 200): string
⋮----
// biome-ignore lint/suspicious/noControlCharactersInRegex: intentional - removing control chars for security
⋮----
.replace(/[\n\r\t]/g, " ") // Replace newlines/tabs with spaces
.replace(/["\\`]/g, "") // Remove quotes that could break formatting (keep apostrophes)
.replace(/\s+/g, " ") // Collapse multiple spaces
⋮----
.slice(0, maxLength); // Limit length
⋮----
/**
 * Sanitize a string with injection pattern detection.
 *
 * Applies basic sanitization and replaces known injection patterns
 * with safe placeholders. Use for high-risk inputs like user messages.
 *
 * @param input - The string to sanitize.
 * @param maxLength - Maximum allowed length (default: 1000).
 * @returns Sanitized string with injection patterns neutralized.
 *
 * @example
 * ```ts
 * const safeMessage = sanitizeWithInjectionDetection(userMessage, 5000);
 * ```
 */
export function sanitizeWithInjectionDetection(
  input: string,
  maxLength = 1000
): string
⋮----
// biome-ignore lint/suspicious/noControlCharactersInRegex: intentional - removing control chars for security
⋮----
.replace(controlCharPattern, "") // Remove control characters
.replace(/\s+/g, " ") // Collapse whitespace
⋮----
// Apply injection pattern filtering with fresh regex instances
⋮----
/**
 * Check if a string contains potential injection patterns.
 *
 * Returns true if any known injection patterns are detected.
 * Use for logging/monitoring without blocking.
 *
 * @param input - The string to check.
 * @returns True if injection patterns detected.
 *
 * @example
 * ```ts
 * if (hasInjectionRisk(userMessage)) {
 *   logger.warn("Potential injection attempt detected");
 * }
 * ```
 */
export function hasInjectionRisk(input: string): boolean
⋮----
// Create fresh regex instances to avoid global flag state issues
⋮----
export function isFilteredValue(value: string | undefined | null): boolean
⋮----
/**
 * Sanitize an array of strings for prompt use.
 *
 * Limits array size, sanitizes each element, and filters empty results.
 *
 * @param items - Array of strings to sanitize.
 * @param maxItems - Maximum number of items (default: 10).
 * @param maxItemLength - Maximum length per item (default: 50).
 * @param detectInjection - Whether to run injection-aware sanitization.
 * @returns Sanitized array.
 *
 * @example
 * ```ts
 * const safeAmenities = sanitizeArray(hotel.amenities, 10, 30);
 * ```
 */
export function sanitizeArray(
  items: string[],
  maxItems = 10,
  maxItemLength = 50,
  detectInjection = false
): string[]
⋮----
/**
 * Sanitize a record/object for prompt use.
 *
 * Applies sanitization to all string values in an object.
 *
 * @param record - Object with string values to sanitize.
 * @param maxValueLength - Maximum length per value (default: 200).
 * @param detectInjection - Whether to run injection-aware sanitization.
 * @returns New object with sanitized values.
 *
 * @example
 * ```ts
 * const safePrefs = sanitizeRecord(userPreferences, 100);
 * ```
 */
export function sanitizeRecord(
  record: Record<string, string | undefined>,
  maxValueLength = 200,
  detectInjection = false
): Record<string, string>
⋮----
/**
 * Sanitize both keys and values of a record for prompt use.
 * Skips entries with empty sanitized keys. Colliding sanitized keys keep the first value.
 *
 * @param record - Object with string keys/values to sanitize.
 * @param maxKeyLength - Maximum length for each key (default: 50).
 * @param maxValueLength - Maximum length for each value (default: 200).
 */
export function sanitizeRecordKeysAndValues(
  record: Record<string, string | undefined>,
  maxKeyLength = 50,
  maxValueLength = 200
): Record<string, string>
````

## File: src/lib/security/service.ts
````typescript
/**
 * @fileoverview Shared security data accessors for events and metrics.
 */
⋮----
import {
  type ActiveSession,
  activeSessionSchema,
  type SecurityEvent,
  type SecurityMetrics,
  securityEventSchema,
  securityMetricsSchema,
} from "@schemas/security";
import type { TypedAdminSupabase } from "@/lib/supabase/admin";
⋮----
/** Audit log row type. */
type AuditLogRow = {
  id: string;
  createdAt: string;
  ipAddress: string | null;
  payload: Record<string, unknown>;
};
⋮----
/** 24 hours in milliseconds. */
⋮----
/**
 * Maps an audit log action to a security event type.
 *
 * @param action - The audit log action to map.
 * @returns The security event type.
 */
const mapEventType = (action?: string): SecurityEvent["type"] =>
⋮----
const mapRisk = (type: SecurityEvent["type"]): SecurityEvent["riskLevel"] =>
⋮----
/**
 * Get the security events for a user.
 *
 * @param adminSupabase - The admin Supabase client.
 * @param userId - The ID of the user to get the security events for.
 * @returns The security events.
 */
export async function getUserSecurityEvents(
  adminSupabase: TypedAdminSupabase,
  userId: string
): Promise<SecurityEvent[]>
⋮----
/**
 * Get the security metrics for a user.
 *
 * @param adminSupabase - The admin Supabase client.
 * @param userId - The ID of the user to get the security metrics for.
 * @returns The security metrics.
 */
export async function getUserSecurityMetrics(
  adminSupabase: TypedAdminSupabase,
  userId: string
): Promise<SecurityMetrics>
⋮----
/**
 * Get the sessions for a user.
 *
 * @param adminSupabase - The admin Supabase client.
 * @param userId - The ID of the user to get the sessions for.
 * @returns The sessions.
 */
export async function getUserSessions(
  adminSupabase: TypedAdminSupabase,
  userId: string
): Promise<ActiveSession[]>
⋮----
// biome-ignore lint/complexity/useLiteralKeys: upstream column names are snake_case
⋮----
// biome-ignore lint/complexity/useLiteralKeys: upstream column names are snake_case
⋮----
// biome-ignore lint/complexity/useLiteralKeys: upstream column names are snake_case
⋮----
// biome-ignore lint/complexity/useLiteralKeys: upstream column names are snake_case
````

## File: src/lib/supabase/admin.ts
````typescript
/**
 * @fileoverview Server-only Supabase admin client factory using service role key.
 * Used exclusively by Next.js Route Handlers to call SECURITY DEFINER RPCs.
 */
⋮----
import type { SupabaseClient } from "@supabase/supabase-js";
import { createClient } from "@supabase/supabase-js";
import { getServerEnvVar } from "@/lib/env/server";
import type { Database } from "./database.types";
⋮----
export type TypedAdminSupabase = SupabaseClient<Database>;
⋮----
/**
 * Create an admin Supabase client authenticated with the service-role key.
 *
 * This client must only be used on the server (never bundled to the client)
 * and is intended for invoking SECURITY DEFINER functions and administrative
 * operations that require elevated privileges.
 *
 * @returns A typed Supabase admin client instance.
 * @throws Error when required environment variables are missing.
 */
export function createAdminSupabase(): TypedAdminSupabase
⋮----
/** Cached singleton for reuse within a request lifecycle. */
⋮----
/**
 * Returns a cached admin Supabase client, creating it if absent.
 *
 * Safe to use in server-only contexts; avoids per-call instantiation while
 * still honoring serverless re-instantiation on cold starts.
 */
export function getAdminSupabase(): TypedAdminSupabase
````

## File: src/lib/supabase/client.ts
````typescript
/**
 * @fileoverview Browser Supabase client factory and React hook.
 * Provides a singleton typed client for the Database schema.
 */
⋮----
import { createBrowserClient } from "@supabase/ssr";
import type { SupabaseClient } from "@supabase/supabase-js";
import { useMemo } from "react";
import { getClientEnvVar } from "@/lib/env/client";
import type { Database } from "./database.types";
⋮----
/** Type alias for Supabase client with Database schema. */
export type TypedSupabaseClient = SupabaseClient<Database>;
⋮----
/** The browser singleton Supabase client. */
⋮----
get(_target, prop)
⋮----
/**
 * Return the browser singleton Supabase client.
 * Instantiated once and reused across the app, including non-React modules
 * (e.g., Zustand stores) that share the authenticated instance.
 *
 * @returns The browser singleton Supabase client.
 */
export function getBrowserClient(): TypedSupabaseClient | null
⋮----
// During SSR/prerender, return null to signal client unavailability
⋮----
// Allow the app to boot in dev/build placeholder mode without crashing.
⋮----
/**
 * React hook to get the Supabase client.
 * Memoizes the client to prevent unnecessary re-renders.
 *
 * @returns The browser singleton Supabase client. Returns null during SSR.
 *   For hooks that require a non-null client, use {@link useSupabaseRequired} instead.
 */
export function useSupabase(): TypedSupabaseClient | null
⋮----
/**
 * React hook that returns a Supabase client, throwing if unavailable.
 *
 * Throws during SSR (window undefined) or if Supabase environment variables are missing.
 * Use only in client components after hydration.
 *
 * @throws Error if Supabase client cannot be initialized.
 */
export function useSupabaseRequired(): TypedSupabaseClient
⋮----
/**
 * Create a new Supabase client instance (for special cases)
 * Use useSupabase() hook in components instead
 */
export function createClient(): TypedSupabaseClient | null
⋮----
// During SSR/prerender, return null to signal client unavailability
⋮----
// Intentionally create a fresh client (used by utility code that expects non-singleton behavior)
````

## File: src/lib/supabase/guards.ts
````typescript
/**
 * @fileoverview Shared Supabase client utilities that are safe for any runtime.
 */
⋮----
import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "./database.types";
⋮----
type SupabaseAuthApi = SupabaseClient<Database>["auth"];
⋮----
/**
 * Narrowly determines whether the provided value looks like a Supabase client.
 *
 * The check intentionally validates a few core APIs (auth/from/channel) instead
 * of relying on duck-typing a single property, which produced false positives.
 */
export function isSupabaseClient(client: unknown): client is SupabaseClient<Database>
````

## File: src/lib/telemetry/agents.ts
````typescript
/**
 * @fileoverview Telemetry recording for agent tool execution events.
 *
 * Provides structured event recording with OpenTelemetry spans for agent
 * workflow tool execution, including cache hits, durations, and errors.
 */
⋮----
import type { AgentWorkflowKind } from "@schemas/agents";
import { withTelemetrySpan } from "./span";
⋮----
/**
 * Agent tool execution event data.
 *
 * Captures workflow context, tool name, execution status, duration,
 * cache hit status, and optional error message for observability.
 */
export type AgentToolEvent = {
  workflow: AgentWorkflowKind;
  tool: string;
  status: "success" | "error";
  durationMs: number;
  cacheHit?: boolean;
  errorMessage?: string;
};
⋮----
/**
 * Record an agent tool execution event with telemetry.
 *
 * Creates an OpenTelemetry span with attributes for workflow, tool name,
 * status, duration, cache hit, and error message (if present). Error
 * messages are redacted from span attributes for security.
 *
 * @param event - Tool execution event data to record.
 * @returns Promise that resolves when telemetry is recorded.
 */
export function recordAgentToolEvent(event: AgentToolEvent): Promise<void>
````

## File: src/lib/telemetry/alerts.ts
````typescript
/**
 * @fileoverview Emits structured operational alerts for log-based monitoring.
 *
 * Alerts are recorded via OpenTelemetry for distributed tracing and integration
 * with external monitoring systems. Log drains can subscribe to OTEL events
 * to trigger alerting workflows.
 */
⋮----
import { TELEMETRY_SERVICE_NAME } from "@/lib/telemetry/constants";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
⋮----
export type AlertSeverity = "info" | "warning" | "error";
⋮----
export type OperationalAlertOptions = {
  attributes?: Record<string, string | number | boolean | null | undefined>;
  severity?: AlertSeverity;
};
⋮----
/**
 * Emits a structured operational alert via OpenTelemetry.
 *
 * Alerts are recorded as telemetry events that external monitoring systems
 * can consume to trigger alerting workflows. Downstream log drains and
 * OTEL collectors integrate with the telemetry infrastructure.
 *
 * @param event - Stable event name (e.g., redis.unavailable).
 * @param options - Optional severity + attribute metadata.
 */
export function emitOperationalAlert(
  event: string,
  options: OperationalAlertOptions = {}
): void
⋮----
// Record to OTel for distributed tracing and monitoring integration
````

## File: src/lib/telemetry/client-errors.ts
````typescript
/**
 * @fileoverview Client-side helpers for recording errors on the active span.
 *
 * This module is safe to import from client components and libraries. It
 * encapsulates direct OpenTelemetry API usage so that other modules do not
 * depend on `@opentelemetry/api` directly.
 */
⋮----
import { SpanStatusCode, trace } from "@opentelemetry/api";
import {
  buildSanitizedErrorForTelemetry,
  sanitizeClientErrorMessage,
} from "./client-sanitize";
import {
  MAX_ERROR_MESSAGE_LENGTH,
  REDACTED_VALUE,
  SENSITIVE_METADATA_KEY_RE,
} from "./constants";
⋮----
/**
 * Metadata to attach to error spans for debugging context.
 */
export interface ErrorSpanMetadata {
  /** Component or module context */
  context?: string;
  /** Action being performed when error occurred */
  action?: string;
  /** Additional metadata */
  [key: string]: unknown;
}
⋮----
/** Component or module context */
⋮----
/** Action being performed when error occurred */
⋮----
/** Additional metadata */
⋮----
/**
 * Sanitizes a metadata value for span attributes by applying redaction and truncation.
 *
 * @param key - Metadata key name to check for sensitive patterns.
 * @param value - Value to sanitize.
 * @returns Sanitized value: redacted if key is sensitive, truncated if string is too long, otherwise unchanged.
 */
function sanitizeMetadataValue(key: string, value: string): string
⋮----
// Truncate and add ellipsis indicator (total length stays within limit)
⋮----
/**
 * Records an exception and error status on the active span, if one exists.
 *
 * Intended for client-side error reporting to link errors with the current
 * trace without requiring direct OpenTelemetry imports in callers.
 *
 * @param error - Error instance to record on the active span.
 * @param metadata - Optional metadata to attach as span attributes.
 */
export function recordClientErrorOnActiveSpan(
  error: Error,
  metadata?: ErrorSpanMetadata
): void
⋮----
// Add optional metadata as span attributes
⋮----
// Only set primitive values as attributes
````

## File: src/lib/telemetry/client-sanitize.ts
````typescript
/**
 * @fileoverview Client-side telemetry redaction helpers.
 *
 * Client spans can accidentally include user-provided values (error messages,
 * metadata, etc.). These helpers apply conservative redaction/truncation so we
 * avoid exporting secrets/PII via span status messages or exception events.
 */
⋮----
import { MAX_ERROR_MESSAGE_LENGTH } from "@/lib/telemetry/constants";
⋮----
export type SanitizedClientErrorMessage = {
  message: string;
  redacted: boolean;
  truncated: boolean;
};
⋮----
export function sanitizeClientErrorMessage(
  message: string
): SanitizedClientErrorMessage
⋮----
export function buildSanitizedErrorForTelemetry(error: Error, message: string): Error
````

## File: src/lib/telemetry/client.ts
````typescript
/**
 * @fileoverview Client-side OpenTelemetry initialization.
 *
 * Provides WebTracerProvider setup for browser tracing with automatic
 * fetch instrumentation to enable distributed tracing from client to server.
 * Client-side error recording is handled separately in `client-errors.ts`.
 */
⋮----
import { type Span, SpanStatusCode, trace } from "@opentelemetry/api";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { registerInstrumentations } from "@opentelemetry/instrumentation";
import { FetchInstrumentation } from "@opentelemetry/instrumentation-fetch";
import { BatchSpanProcessor, type SpanProcessor } from "@opentelemetry/sdk-trace-base";
import { WebTracerProvider } from "@opentelemetry/sdk-trace-web";
import { getClientEnvVarWithFallback } from "@/lib/env/client";
import {
  buildSanitizedErrorForTelemetry,
  sanitizeClientErrorMessage,
} from "./client-sanitize";
⋮----
/**
 * Module-level flag to prevent double-initialization.
 * React Strict Mode calls effects twice, so we guard against re-initialization.
 */
⋮----
/**
 * Runs a client-side operation inside an OTEL span. No-op safe if tracing is not initialized.
 *
 * @param name - The name of the span.
 * @param attributes - Span attributes (must be low-cardinality and MUST NOT contain PII/secrets).
 * @param fn - The function to run inside the span.
 * @returns The result of the function.
 */
export async function withClientTelemetrySpan<T>(
  name: string,
  attributes: Record<string, string | number | boolean> | undefined,
  fn: () => Promise<T> | T
): Promise<T>
⋮----
/**
 * Gets the OTLP trace endpoint URL from environment or uses default.
 *
 * @returns OTLP endpoint URL
 */
function getOtlpEndpoint(): string
⋮----
// Use validated client environment variable
⋮----
/**
 * Initializes client-side OpenTelemetry tracing.
 *
 * Sets up WebTracerProvider with:
 * - BatchSpanProcessor for efficient span export
 * - FetchInstrumentation to automatically trace fetch requests
 * - Trace context propagation via traceparent headers
 *
 * This function is idempotent and safe to call multiple times.
 * It will only initialize once, even in React Strict Mode.
 *
 * @throws Error if called in a non-browser environment
 */
export function initTelemetry(): void
⋮----
// Guard: prevent double-initialization
⋮----
// Guard: ensure we're in a browser environment
⋮----
// Set flag immediately to prevent concurrent initialization attempts
// This prevents race conditions where multiple calls could partially initialize
// If initialization fails, we don't retry (telemetry is non-critical)
⋮----
// Configure exporter
⋮----
// Create batch span processor for efficient export
⋮----
// Create tracer provider and attach span processor
// Note: the runtime WebTracerProvider implements addSpanProcessor even though
// the public typings don't currently surface it, so we widen the type here.
type WebTracerProviderWithProcessor = WebTracerProvider & {
      addSpanProcessor: (processor: SpanProcessor) => void;
    };
⋮----
// Register the provider (makes it the global tracer provider and exporter active)
⋮----
// Configure fetch instrumentation to propagate trace context
⋮----
// Clear timing resources after span ends to prevent memory leaks
⋮----
// Propagate trace headers only to exact same-origin requests
⋮----
// Register instrumentations
⋮----
// Telemetry is optional on the client; swallow errors to avoid impacting UX.
````

## File: src/lib/telemetry/constants.ts
````typescript
/**
 * @fileoverview Shared telemetry constants.
 *
 * This module exports telemetry constants that can be used in both
 * server and client contexts without boundary violations.
 */
⋮----
/** Canonical tracer/service name for frontend observability. */
⋮----
/** Whether to suppress console output in telemetry alerts (for performance tests). */
⋮----
/** Maximum length for error messages in telemetry (truncate beyond this). */
⋮----
/** Maximum length for individual log field values before truncation with marker. */
⋮----
/** Placeholder value for redacted sensitive data in telemetry. */
⋮----
/** Regex pattern to identify sensitive metadata keys that should be redacted. */
````

## File: src/lib/telemetry/logger.ts
````typescript
/**
 * @fileoverview Server-side logging helpers backed by OpenTelemetry.
 *
 * Provides lightweight helpers to emit structured log events without using
 * console.* in production code. The logger is a thin shim over
 * recordTelemetryEvent so all emitted messages travel through the same
 * tracing/export pipeline as the rest of our telemetry surface. For client
 * components/tests, prefer direct console usage guarded by NODE_ENV checks.
 */
⋮----
import type { TelemetrySpanAttributes } from "@/lib/telemetry/span";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
import {
  MAX_LOG_FIELD_LENGTH,
  REDACTED_VALUE,
  SENSITIVE_METADATA_KEY_RE,
} from "./constants";
⋮----
type LogLevel = "info" | "warning" | "error";
⋮----
export type LogMetadata = Record<string, unknown>;
⋮----
export interface CreateServerLoggerOptions {
  /**
   * Keys in metadata to redact from telemetry logs.
   * @default []
   */
  redactKeys?: string[];
  /**
   * Redact the primary log message (`log.message`) attribute.
   *
   * Use this for scopes that might accidentally include user input or provider
   * error text in the message parameter. Prefer placing details into metadata
   * fields like `error`/`errorMessage` (which are redacted by default) and keep
   * `message` as a short, non-sensitive summary.
   *
   * @default false
   */
  redactMessage?: boolean;
}
⋮----
/**
   * Keys in metadata to redact from telemetry logs.
   * @default []
   */
⋮----
/**
   * Redact the primary log message (`log.message`) attribute.
   *
   * Use this for scopes that might accidentally include user input or provider
   * error text in the message parameter. Prefer placing details into metadata
   * fields like `error`/`errorMessage` (which are redacted by default) and keep
   * `message` as a short, non-sensitive summary.
   *
   * @default false
   */
⋮----
export interface ServerLogger {
  error: (message: string, metadata?: LogMetadata) => void;
  info: (message: string, metadata?: LogMetadata) => void;
  warn: (message: string, metadata?: LogMetadata) => void;
}
⋮----
function normalizeRedactionKey(key: string): string
⋮----
function buildRedactionKeySet(redactKeys: string[]): Set<string>
⋮----
function shouldRedactKey(key: string, redactionKeys: Set<string>): boolean
⋮----
function safeJsonStringify(value: unknown, redactionKeys: Set<string>): string
⋮----
function normalizeAttributes(
  scope: string,
  message: string,
  metadata: LogMetadata | undefined,
  redactionKeys: Set<string>,
  redactMessage: boolean
): TelemetrySpanAttributes
⋮----
function emitLog(
  scope: string,
  level: LogLevel,
  message: string,
  metadata?: LogMetadata,
  redactKeys: string[] = [],
  redactMessage = false
)
⋮----
/**
 * Creates a server logger instance for structured logging via OpenTelemetry.
 *
 * Metadata is encoded into `log.*` span attributes. Prefer passing primitive values.
 * Non-primitive metadata is JSON-stringified with best-effort redaction for common
 * sensitive keys (e.g., tokens, passwords, API keys). Always avoid passing PII or
 * secrets. Keep `message` as a short, non-sensitive summary; do not include user
 * input or provider error strings in the message text.
 *
 * @param scope - Logger scope (e.g., "api.keys", "tools.accommodations")
 * @param options - Optional configuration including redaction keys
 * @returns Logger instance with error, info, and warn methods
 *
 * @example
 * const logger = createServerLogger("api.keys", { redactKeys: ["apiKey"] });
 * logger.info("Key stored", { userId: "123", apiKey: "sk-..." }); // apiKey will be redacted
 */
export function createServerLogger(
  scope: string,
  options: CreateServerLoggerOptions = {}
): ServerLogger
````

## File: src/lib/telemetry/span.ts
````typescript
/**
 * @fileoverview Telemetry span utilities.
 *
 * Provides OpenTelemetry span helpers with attribute redaction and lightweight event logging.
 * Client-side tracing setup still lives in `./client` (this module does not initialize OTEL).
 */
⋮----
import { type Span, SpanStatusCode, type Tracer, trace } from "@opentelemetry/api";
import { getTelemetryTracer } from "@/lib/telemetry/tracer";
import { REDACTED_VALUE } from "./constants";
⋮----
// Re-export Span type for use by other modules (avoids direct @opentelemetry/api imports)
⋮----
/**
 * Telemetry span attributes are key-value pairs attached to spans.
 */
export type TelemetrySpanAttributes = Record<string, string | number | boolean>;
⋮----
/**
 * Options for wrapping operations in telemetry spans.
 */
export type WithTelemetrySpanOptions = {
  attributes?: TelemetrySpanAttributes;
  redactKeys?: string[];
};
⋮----
/**
 * Options for recording telemetry events.
 */
export type TelemetryLogOptions = {
  attributes?: TelemetrySpanAttributes;
  level?: "info" | "warning" | "error";
};
⋮----
/**
 * Ensures span has all expected methods by wrapping with no-op fallbacks.
 *
 * This proxy handles cases where span implementations (e.g., mock spans in tests
 * or partial OTEL implementations) may not provide all standard Span methods.
 * Rather than throwing on missing methods, we return chainable no-ops.
 */
function ensureSpanCapabilities(span: Span): Span
⋮----
// Use Proxy to avoid mutating the original span object
⋮----
get(target, prop, receiver)
⋮----
// No-op fallback for spans without addEvent capability
⋮----
// No-op fallback for spans without setAttribute capability
⋮----
// No-op fallback for spans without exception recording capability
⋮----
// No-op fallback for spans without status capability
⋮----
// No-op fallback for spans without end capability
⋮----
// Delegate all other properties/methods to the original span
⋮----
// Lazy tracer to allow tests to inject mocks before first span creation.
⋮----
function getTracer(): Tracer
⋮----
/**
 * Common span execution logic for both sync and async operations.
 *
 * Uses a second proxy (separate from ensureSpanCapabilities) to intercept
 * recordException calls. This tracking ensures we don't set span status to OK
 * after the execute callback has already recorded an exception. Without this,
 * non-throwing error paths that call recordException would be overwritten.
 *
 * @internal
 */
function executeSpan<T>(
  span: Span,
  execute: (span: Span) => T | Promise<T>,
  isAsync: boolean
): T | Promise<T>
⋮----
// Wrap recordException calls without mutating the original span.
⋮----
const handleResult = (result: T): T =>
⋮----
// Only set status to OK if no exception was recorded
// This allows execute() to set status to ERROR for non-throwing error cases
⋮----
const handleError = (error: unknown): never =>
⋮----
/**
 * Wraps a synchronous operation inside an OpenTelemetry span and ensures the span
 * status reflects success or error outcomes.
 *
 * @param name Span name.
 * @param options Attribute and redaction config.
 * @param execute Operation to execute inside the span.
 * @returns Result of the execute callback.
 */
export function withTelemetrySpanSync<T>(
  name: string,
  options: WithTelemetrySpanOptions,
  execute: (span: Span) => T
): T
⋮----
const runner = (span: Span): T
⋮----
/**
 * Wraps an async operation inside an OpenTelemetry span and ensures the span
 * status reflects success or error outcomes.
 *
 * @param name Span name.
 * @param options Attribute and redaction config.
 * @param execute Operation to execute inside the span.
 * @returns Result of the execute callback.
 */
export function withTelemetrySpan<T>(
  name: string,
  options: WithTelemetrySpanOptions,
  execute: (span: Span) => Promise<T> | T
): Promise<T>
⋮----
/**
 * Sanitizes telemetry span attributes by redacting sensitive keys.
 *
 * @param attributes - The attributes to sanitize.
 * @param redactKeys - The keys to redact.
 * @returns The sanitized attributes.
 */
export function sanitizeAttributes(
  attributes?: TelemetrySpanAttributes,
  redactKeys: string[] = []
): TelemetrySpanAttributes | undefined
⋮----
/**
 * Records a telemetry event with structured attributes.
 *
 * Creates a brief span for logging events that don't require full operation tracing.
 * Uses span events for structured logging without console output.
 *
 * @param eventName - Concise event identifier (e.g., "api.keys.parse_error")
 * @param options - Event attributes and severity level
 */
export function recordTelemetryEvent(
  eventName: string,
  options: TelemetryLogOptions = {}
): void
⋮----
// Add event to span without console logging
⋮----
/**
 * Adds an event to the current active span, if one exists.
 *
 * This is intended for low-level libraries that need to attach
 * contextual events without creating new spans or depending on
 * OpenTelemetry APIs directly.
 *
 * @param eventName - Concise event identifier.
 * @param attributes - Optional event attributes.
 * @param redactKeys - Optional list of attribute keys to redact.
 */
export function addEventToActiveSpan(
  eventName: string,
  attributes?: TelemetrySpanAttributes,
  redactKeys: string[] = []
): void
⋮----
/**
 * Records an exception and error status on a specific span.
 *
 * @param span - Span to record the error on.
 * @param error - Error instance to record.
 */
export function recordErrorOnSpan(span: Span, error: Error): void
⋮----
/**
 * Records an exception and error status on the active span, if present.
 *
 * This helper is used by higher-level services (e.g., error reporting)
 * to integrate with tracing without importing OpenTelemetry directly.
 *
 * @param error - Error instance to record on the span.
 */
export function recordErrorOnActiveSpan(error: Error): void
````

## File: src/lib/telemetry/store-logger.ts
````typescript
/**
 * @fileoverview Client-side logger for Zustand stores.
 *
 * Provides a structured logging interface for client-side stores that
 * integrates with OTEL tracing for error recording. Warnings and info
 * are no-op in production to avoid console pollution.
 */
⋮----
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
⋮----
export type StoreLogLevel = "error" | "warn" | "info";
⋮----
export interface StoreLogOptions {
  storeName: string;
  metadata?: Record<string, unknown>;
}
⋮----
interface StoreLogDetails {
  [key: string]: unknown;
}
⋮----
/**
 * Client-side logger for Zustand stores.
 *
 * Records errors to the active OTEL span when available.
 * Falls back to no-op in production for non-errors.
 *
 * @param options - Configuration options including store name
 * @returns Logger object with error, warn, and info methods
 */
export function createStoreLogger(options: StoreLogOptions)
⋮----
/**
     * Log an error and record it on the active OTEL span.
     *
     * @param message - Error message
     * @param details - Additional context to include with the error
     */
error(message: string, details?: StoreLogDetails)
⋮----
// Always attach context details to the error
⋮----
/**
     * Log an info message. Development-only logging.
     *
     * @param message - Info message
     * @param details - Additional context
     */
info(message: string, details?: StoreLogDetails)
⋮----
// Ignore stringification errors
⋮----
/**
     * Log a warning. Development-only logging.
     *
     * @param message - Warning message
     * @param details - Additional context
     */
warn(message: string, details?: StoreLogDetails)
⋮----
// Ignore stringification errors
````

## File: src/lib/telemetry/tracer.ts
````typescript
/**
 * @fileoverview Shared tracer utilities for TripSage telemetry.
 */
⋮----
import { type Tracer, trace } from "@opentelemetry/api";
import { TELEMETRY_SERVICE_NAME } from "./constants";
⋮----
/**
 * Returns the shared tracer instance for TripSage telemetry.
 *
 * @returns OpenTelemetry tracer bound to the canonical shared service name.
 */
export function getTelemetryTracer(): Tracer
````

## File: src/lib/tokens/budget.ts
````typescript
/**
 * @fileoverview Token counting and clamping utilities for AI SDK calls.
 * Prefers provider-reported usage where available; these helpers provide
 * fallback estimation and safe max token clamping.
 */
⋮----
import type { ClampResult, TokenChatMessage } from "@schemas/tokens";
import { Tiktoken } from "js-tiktoken/lite";
import cl100kBase from "js-tiktoken/ranks/cl100k_base";
// Prefer lite ranks to avoid bundling all encodings.
// o200k_base matches modern OpenAI models (e.g., gpt-4o, gpt-5 families).
// cl100k_base covers older OpenAI models; retained as a fallback.
import o200kBase from "js-tiktoken/ranks/o200k_base";
import { getModelContextLimit } from "./limits";
⋮----
/**
 * Extended Tiktoken interface with optional free method for WASM cleanup.
 */
interface TiktokenWithFree extends Tiktoken {
  free?: () => void;
}
⋮----
// Re-export types from schemas (using TokenChatMessage to avoid conflict with api.ChatMessage)
⋮----
export type ChatMessage = TokenChatMessage;
⋮----
/** Heuristic fallback ratio: ~4 characters per token (UNVERIFIED for non-OpenAI). */
⋮----
/** Cache for tokenizer instances to avoid repeated WASM instantiation. */
⋮----
/**
 * Upper bound of total characters to pass through WASM tokenizer.
 * If aggregated input exceeds this, fallback to heuristic for performance.
 */
⋮----
/**
 * Select a tokenizer encoding based on model hint.
 *
 * @param modelHint Optional model identifier (e.g., "gpt-4o").
 * @returns Tiktoken instance or null if we should fallback to heuristic.
 */
function selectTokenizer(modelHint?: string): Tiktoken | null
⋮----
// Dispose previous tokenizer if the WASM exposes free().
⋮----
/**
 * Count tokens for an array of texts, using OpenAI-compatible tokenizer when possible.
 * If tokenizer is not available for the model, fallback to a conservative heuristic.
 *
 * @param texts Input text fragments to count.
 * @param modelHint Optional model identifier (guides tokenizer selection).
 * @returns Total token count across all texts.
 */
export function countTokens(texts: string[], modelHint?: string): number
⋮----
// Heuristic fast-path when text size is very large to avoid heavy WASM work.
⋮----
// Release WASM resources if available and not using the shared cache.
⋮----
// Heuristic fallback
⋮----
/**
 * Clamp desired max output tokens based on model context window and prompt length.
 * Counts tokens from message content fields only. System prompt is included when present.
 *
 * @param messages Chat messages to be sent to the model.
 * @param desiredMax Requested max output tokens.
 * @param modelName Model identifier; used to resolve context window.
 * @param table Optional limits override table.
 * @returns ClampResult with final maxTokens and reasons for any clamping.
 */
export function clampMaxTokens(
  messages: ChatMessage[],
  desiredMax: number,
  modelName: string | undefined,
  table?: Record<string, number>
): ClampResult
⋮----
// Normalize desired max
⋮----
/**
 * Helper to compute prompt token count (content-only) for a message list.
 *
 * @param messages Chat messages.
 * @param modelHint Optional model hint for tokenizer selection.
 * @returns Token count of the prompt.
 */
export function countPromptTokens(messages: ChatMessage[], modelHint?: string): number
````

## File: src/lib/tokens/limits.ts
````typescript
/**
 * @fileoverview Model context window limits (in tokens) and helpers.
 * Maintains per-model context limits for safe clamping in AI SDK calls.
 */
⋮----
import type { ModelLimitsTable } from "@schemas/tokens";
⋮----
// Re-export type from schemas
⋮----
/**
 * Canonical context window limits (tokens) for known models.
 * Keys are normalized lowercase substrings matched against model names.
 */
⋮----
// Anthropic
⋮----
// OpenAI
⋮----
// xAI (conservative default unless provider docs specify higher)
⋮----
/** Default context window (tokens) when model is unknown. */
⋮----
/**
 * Resolve the context window limit for a given model.
 * Performs a lowercase substring match against known keys.
 *
 * @param modelName The model identifier (e.g., "gpt-4o").
 * @param table Optional override table.
 * @returns Context window token limit.
 */
export function getModelContextLimit(
  modelName: string | undefined,
  table: ModelLimitsTable = MODEL_LIMITS
): number
````

## File: src/lib/trips/mappers.ts
````typescript
/**
 * @fileoverview Canonical mapper functions for converting between database and UI trip representations.
 * Single source of truth for DB↔UI transformations.
 */
⋮----
import type { TripsRow } from "@schemas/supabase";
import type { ItineraryItemCreateInput, UiTrip } from "@schemas/trips";
import type { Database, Json } from "@/lib/supabase/database.types";
⋮----
/**
 * Maps a database trip row to UI-friendly trip object format.
 *
 * Performs transformation from database schema (snake_case, budget as number)
 * to client-side representation (camelCase, budget as number with currency sibling).
 *
 * @param row - The raw trip row from Supabase database
 * @returns UI-formatted trip object with camelCase properties
 */
export function mapDbTripToUi(row: TripsRow): UiTrip
⋮----
/**
 * Maps a validated itinerary item input into a Supabase `itinerary_items` insert payload.
 *
 * Keeps snake_case column naming localized to a single helper.
 *
 * @param item - Validated itinerary item data.
 * @param userId - Owning user id.
 */
export function mapItineraryItemCreateToDbInsert(
  item: ItineraryItemCreateInput,
  userId: string
): Database["public"]["Tables"]["itinerary_items"]["Insert"]
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase columns use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase columns use snake_case
````

## File: src/lib/trips/parse-trip-date.ts
````typescript
/**
 * @fileoverview Shared trip date parsing helper with consistent error handling.
 */
⋮----
import { DateUtils } from "@/lib/dates/unified-date-utils";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
⋮----
type TripDateParseTelemetry = {
  action?: string;
  context?: string;
};
⋮----
export function parseTripDate(
  value?: string | null,
  telemetry?: TripDateParseTelemetry
): Date | null
````

## File: src/lib/ui/parse-schema-card.ts
````typescript
/**
 * @fileoverview Utility to parse schema cards from chat message text.
 *
 * Extracts JSON from text (handles codefenced and plain JSON) and identifies
 * schema versions for rendering appropriate UI components.
 */
⋮----
import {
  accommodationSearchResultSchema,
  budgetPlanResultSchema,
  destinationResearchResultSchema,
  itineraryPlanResultSchema,
} from "@schemas/agents";
import { flightSearchResultSchema } from "@schemas/flights";
import type { z } from "zod";
⋮----
type FlightSearchResult = z.infer<typeof flightSearchResultSchema>;
type AccommodationSearchResult = z.infer<typeof accommodationSearchResultSchema>;
type BudgetPlanResult = z.infer<typeof budgetPlanResultSchema>;
type DestinationResearchResult = z.infer<typeof destinationResearchResultSchema>;
type ItineraryPlanResult = z.infer<typeof itineraryPlanResultSchema>;
⋮----
/**
 * Parsed schema card result.
 */
export type ParsedSchemaCard =
  | { data: FlightSearchResult; kind: "flight" }
  | { data: AccommodationSearchResult; kind: "stay" }
  | { data: BudgetPlanResult; kind: "budget" }
  | { data: DestinationResearchResult; kind: "destination" }
  | { data: ItineraryPlanResult; kind: "itinerary" };
⋮----
/**
 * Parse a schema card from chat message text.
 *
 * Attempts to extract JSON from text (handles markdown codefenced JSON and
 * plain JSON) and validates against known schema versions. Returns null if
 * no valid schema card is found.
 *
 * @param text - Text content from chat message.
 * @returns Parsed schema card with kind and data, or null if not found/invalid.
 */
export function parseSchemaCard(text: string): ParsedSchemaCard | null
⋮----
// Attempt to extract JSON from text (may be wrapped in markdown code blocks)
⋮----
// Not valid JSON, return null
⋮----
// Disambiguate by explicit schemaVersion to avoid false positives on schemas
⋮----
// Unreachable: switch covers all return branches including default
````

## File: src/lib/url/client-origin.ts
````typescript
/**
 * @fileoverview Client-safe origin resolution helpers.
 */
⋮----
import { getClientEnvVarWithFallback } from "@/lib/env/client";
⋮----
/**
 * Resolves the application origin for client-side contexts.
 *
 * Prefers browser location, then trusted public env vars.
 */
export function getClientOrigin(): string
⋮----
// Dev-only nudge to configure site/base URL; avoids server-side console usage
⋮----
/**
 * Converts a relative path to an absolute URL using the client origin.
 */
export function toClientAbsoluteUrl(path: string): string
````

## File: src/lib/url/safe-href.ts
````typescript
/**
 * @fileoverview Safe href sanitizer for AI/tool-derived links.
 *
 * React does not sanitize URL protocols in href/src attributes. This helper
 * enforces a small allow-list for untrusted links before rendering.
 */
⋮----
/**
 * Returns a safe href string or undefined if unsafe/invalid.
 *
 * - Allows absolute http/https/mailto URLs.
 * - Allows same-origin relative paths that start with `/`.
 * - Blocks protocol-relative (`//`) and any other schemes (e.g., javascript:, data:).
 */
export function safeHref(raw?: string | null): string | undefined
⋮----
// invalid URL
````

## File: src/lib/utils/amenity-categorization.ts
````typescript
/**
 * Categorize amenities into essential, premium, and unique buckets.
 * Keeps logic reusable and testable across hotel personalization surfaces.
 */
export interface AmenityCategories {
  essential: string[];
  premium: string[];
  unique: string[];
  normalizedString: string;
}
⋮----
export function categorizeAmenities(amenities?: string[] | null): AmenityCategories
⋮----
// Guard against null/undefined input
⋮----
// Enforce precedence: essential > premium > unique
⋮----
// Single-pass classification with word boundary matching
⋮----
// Empty after trimming (e.g., whitespace-only), add to unique
⋮----
// Check essential keywords with word boundaries
⋮----
// Check premium keywords with word boundaries
⋮----
// No keyword matched, add to unique
````

## File: src/lib/utils/build-phase.ts
````typescript
/**
 * @fileoverview Next.js build-phase detection shared across server/client.
 */
⋮----
import { PHASE_EXPORT, PHASE_PRODUCTION_BUILD } from "next/constants";
⋮----
/**
 * Check if we're in Next.js build or export phase.
 */
export function isBuildPhase(): boolean
````

## File: src/lib/collection-utils.ts
````typescript
/**
 * @fileoverview Collection utility functions for array manipulation.
 */
⋮----
/**
 * Groups array items by a key derived from each item.
 *
 * @template T - The type of items in the array
 * @template K - The type of the grouping key (string or number)
 * @param arr - The array to group
 * @param key - Function that returns the grouping key for each item
 * @returns An object where keys are the grouping values and values are arrays of items
 *
 * @example
 * const users = [
 *   { id: 1, role: 'admin' },
 *   { id: 2, role: 'user' },
 *   { id: 3, role: 'admin' }
 * ];
 * const byRole = groupBy(users, u => u.role);
 * // { admin: [...], user: [...] }
 */
export function groupBy<T, K extends string | number>(
  arr: T[],
  key: (item: T) => K
): Record<K, T[]>
⋮----
/**
 * Maps items to values and returns unique results (preserving first-seen order).
 *
 * @template T - The type of items in the array
 * @template U - The mapped value type
 *
 * @remarks
 * Uniqueness is determined by JavaScript `Set` equality (SameValueZero): primitives
 * are deduplicated by value, while objects/arrays/functions are deduplicated by
 * reference. If your mapper returns objects, different instances with the same
 * contents will not be considered equal—prefer returning a stable primitive key
 * (e.g., an `id`) when you need value-based deduplication.
 * @param arr - The array to map
 * @param mapper - Function that maps each item to a value
 * @returns A list of unique mapped values
 */
export function mapToUnique<T, U>(arr: ReadonlyArray<T>, mapper: (item: T) => U): U[]
````

## File: src/lib/error-service.ts
````typescript
/**
 * @fileoverview Error service for logging, reporting, and telemetry integration.
 * Client-only module - uses browser globals (localStorage, navigator, window).
 */
⋮----
import {
  type ErrorReport,
  type ErrorServiceConfig,
  errorReportSchema,
} from "@schemas/errors";
import { secureId } from "@/lib/security/random";
import {
  type ErrorSpanMetadata,
  recordClientErrorOnActiveSpan,
} from "@/lib/telemetry/client-errors";
⋮----
/**
 * Error service for logging and reporting errors
 */
class ErrorService
⋮----
constructor(config: ErrorServiceConfig)
⋮----
/**
   * Report an error with validation
   */
async reportError(
    report: ErrorReport,
    spanMetadata?: ErrorSpanMetadata
): Promise<void>
⋮----
// Validate the error report using Zod
⋮----
// Record exception to active OpenTelemetry span if available.
// This links the error to the distributed trace for better observability.
⋮----
// Create Error object from report for span recording
⋮----
// Don't fail error reporting if OTel recording fails
// Telemetry errors are non-critical
⋮----
// Error reporting disabled - silently skip
⋮----
// Add to queue for processing
⋮----
// Store in localStorage for persistence if enabled
⋮----
// Process the queue
⋮----
// Silently fail error reporting to avoid recursive error loops
⋮----
/**
   * Process error queue with retry logic
   */
private async processQueue(): Promise<void>
⋮----
// Silently fail queue processing to avoid recursive errors
⋮----
/**
   * Send error report to remote service
   */
private async sendErrorReport(report: ErrorReport, retryCount = 0): Promise<void>
⋮----
// No endpoint configured - silently skip
⋮----
// biome-ignore lint/style/useNamingConvention: HTTP header name
⋮----
// Exponential backoff
⋮----
// Silently fail after max retries to avoid recursive errors
⋮----
/**
   * Store error in localStorage for offline persistence
   */
private storeErrorLocally(report: ErrorReport): void
⋮----
// Clean up old errors (keep last 10)
⋮----
// Silently fail local storage operations
⋮----
/**
   * Clean up old local errors
   */
private cleanupLocalErrors(): void
⋮----
// Keep only the last 10 errors
⋮----
// Silently fail cleanup operations
⋮----
/**
   * Create error report from error and additional info
   */
createErrorReport(
    error: Error,
    errorInfo?: { componentStack?: string },
    additionalInfo?: Partial<ErrorReport>
): ErrorReport
⋮----
// Default error service instance
````

## File: src/lib/geo.ts
````typescript
/**
 * @fileoverview Geographic distance calculation utilities.
 */
⋮----
/** Earth's radius in kilometers. */
⋮----
/** Coordinates interface. */
export interface Coordinates {
  lat: number;
  lng: number;
}
⋮----
/**
 * Calculates the great-circle distance between two points using the Haversine formula.
 *
 * @param from - Origin coordinates.
 * @param to - Destination coordinates.
 * @returns Distance in kilometers.
 */
export function calculateDistanceKm(from: Coordinates, to: Coordinates): number
````

## File: src/lib/routes.ts
````typescript
/**
 * @fileoverview Centralized application routes.
 *
 * Provides a single source of truth for all internal routes to ensure
 * consistency across the application.
 */
⋮----
// Demo route
⋮----
// Chat
⋮----
// Dashboard routes
⋮----
// Root
⋮----
// Auth routes
⋮----
// Legal routes
⋮----
// Search results
````

## File: src/mocks/unified-search-mocks.ts
````typescript
/**
 * @fileoverview Demo mock results for unified search.
 *
 * These mocks are intentionally not imported at module scope by UI components.
 * Load them dynamically behind `process.env.NODE_ENV === "development"` guards.
 */
⋮----
import type { FlightResult, HotelResult } from "@schemas/search";
````

## File: src/prompts/agents.ts
````typescript
/**
 * @fileoverview System prompt builders for agent workflows.
 *
 * Constructs system instructions for destination research, itinerary planning,
 * flight search, accommodation search, budget planning, and router classification
 * agents. Prompts include context from user requests and optional metadata.
 */
⋮----
import type {
  BudgetPlanRequest,
  DestinationResearchRequest,
  ItineraryPlanRequest,
} from "@schemas/agents";
import type { FlightSearchRequest } from "@schemas/flights";
⋮----
/**
 * Base context shared across prompt builders.
 *
 * Optional metadata that can be included in any agent prompt for
 * personalization and context.
 */
type BasePromptContext = {
  userName?: string;
  locale?: string;
  travelStyle?: string;
  safetySummary?: string;
};
⋮----
/**
 * Input type for destination research prompt builder.
 *
 * Combines base context, destination research request parameters, and
 * optional provider summary for external findings.
 */
export type DestinationPromptInput = BasePromptContext &
  DestinationResearchRequest & {
    providerSummary?: string;
  };
⋮----
/**
 * Build system prompt for destination research agent.
 *
 * Constructs instructions for researching a destination, including travel
 * style, dates, interests, safety context, and external provider findings.
 *
 * @param input - Destination research request with optional context and provider summary.
 * @returns System prompt string for the destination research agent.
 */
export function buildDestinationPrompt(input: DestinationPromptInput): string
⋮----
/**
 * Input type for itinerary planning prompt builder.
 *
 * Combines base context with itinerary planning request parameters.
 */
export type ItineraryPromptInput = BasePromptContext & ItineraryPlanRequest;
⋮----
/**
 * Build system prompt for itinerary planning agent.
 *
 * Constructs instructions for generating a multi-day itinerary, including
 * destination, duration, dates, interests, party size, and budget guidance.
 *
 * @param input - Itinerary planning request with optional context.
 * @returns System prompt string for the itinerary planning agent.
 */
export function buildItineraryPrompt(input: ItineraryPromptInput): string
⋮----
/**
 * Input type for flight search prompt builder.
 *
 * Combines base context with flight search request parameters.
 */
export type FlightPromptInput = BasePromptContext & FlightSearchRequest;
⋮----
/**
 * Build system prompt for flight search agent.
 *
 * Constructs instructions for searching flights, including route, departure
 * date, optional return date, passenger count, and cabin class.
 *
 * @param input - Flight search request with optional context.
 * @returns System prompt string for the flight search agent.
 */
export function buildFlightPrompt(input: FlightPromptInput): string
⋮----
/**
 * Input type for accommodation search prompt builder.
 *
 * Defines parameters for searching accommodations including destination,
 * check-in/out dates, guest count, and optional preferences.
 */
export type AccommodationPromptInput = {
  destination: string;
  checkIn: string;
  checkOut: string;
  guests?: number;
  preferences?: string[];
};
⋮----
/**
 * Build system prompt for accommodation search agent.
 *
 * Constructs instructions for finding accommodations, including destination,
 * dates, guest count, and optional preferences.
 *
 * @param input - Accommodation search parameters.
 * @returns System prompt string for the accommodation search agent.
 */
export function buildAccommodationPrompt(input: AccommodationPromptInput): string
⋮----
/**
 * Input type for budget planning prompt builder.
 *
 * Combines base context with budget planning request parameters.
 */
export type BudgetPromptInput = BasePromptContext & BudgetPlanRequest;
⋮----
/**
 * Build system prompt for budget planning agent.
 *
 * Constructs instructions for generating a travel budget, including destination,
 * duration, travel style, optional budget cap, and allocation categories.
 *
 * @param input - Budget planning request with optional context.
 * @returns System prompt string for the budget planning agent.
 */
export function buildBudgetPrompt(input: BudgetPromptInput): string
⋮----
/**
 * Build system prompt for router classification agent.
 *
 * Constructs instructions for classifying user messages into agent workflows.
 * Returns a prompt that instructs the model to return JSON with agent workflow,
 * confidence score, and reasoning.
 *
 * @returns System prompt string for the router classification agent.
 */
export function buildRouterPrompt(): string
````

## File: src/stores/auth/auth-core.ts
````typescript
/**
 * @fileoverview Auth core slice - login, register, user management.
 */
⋮----
import type { AuthUser } from "@schemas/stores";
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { useAuthSession } from "@/stores/auth/auth-session";
import { getDisplayName } from "@/stores/helpers";
⋮----
const computeUserDisplayName = (user: AuthUser | null): string
⋮----
/**
 * Auth core state interface.
 */
interface AuthCoreState {
  // State
  isAuthenticated: boolean;
  user: AuthUser | null;
  error: string | null;
  isLoading: boolean;
  isLoggingIn: boolean;
  isRegistering: boolean;

  // Computed
  userDisplayName: string;

  // Actions
  logout: () => Promise<void>;
  setUser: (user: AuthUser | null) => void;
  clearError: () => void;
  initialize: () => Promise<void>;
}
⋮----
// State
⋮----
// Computed
⋮----
// Actions
⋮----
/**
 * Initial auth core view-model state.
 * This state mirrors, but does not own, Supabase SSR session authority.
 */
⋮----
/**
 * Auth core store hook.
 */
⋮----
// Initial state
⋮----
// Check if user is already authenticated via Supabase SSR session.
⋮----
// Swallow errors and fall through to resetting state.
⋮----
const clearSessionState = (): void =>
⋮----
// Call server route that uses createServerSupabase
⋮----
// Even if logout fails on server, clear local state
⋮----
// Computed
⋮----
// Selectors
export const useUser = ()
export const useIsAuthenticated = ()
export const useAuthLoading = ()
export const useAuthError = ()
````

## File: src/stores/auth/auth-session.ts
````typescript
/**
 * @fileoverview Auth session slice - mirrors Supabase SSR session state for UI purposes only.
 *
 * Supabase cookies remain the single source of truth for authentication.
 * This slice intentionally does not persist or manage access/refresh tokens.
 */
⋮----
import type { AuthSession } from "@schemas/stores";
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { timeUntil } from "@/stores/helpers";
⋮----
/**
 * Auth session state interface.
 */
interface AuthSessionState {
  // State
  session: AuthSession | null;

  // Computed
  sessionTimeRemaining: number;

  // Actions
  setSession: (session: AuthSession | null) => void;
  resetSession: () => void;
}
⋮----
// State
⋮----
// Computed
⋮----
// Actions
⋮----
/**
 * Auth session store hook.
 */
⋮----
get sessionTimeRemaining()
⋮----
// Selectors
export const useSessionTimeRemaining = ()
````

## File: src/stores/auth/auth-validation.ts
````typescript
/**
 * @fileoverview Auth validation slice - password reset, email verification.
 * Part of the composable auth store refactor (Phase 3).
 */
⋮----
import { create } from "zustand";
import { devtools } from "zustand/middleware";
⋮----
/**
 * Interface for password reset request.
 */
export interface PasswordResetRequest {
  email: string;
}
⋮----
/**
 * Interface for password reset.
 */
export interface PasswordReset {
  token: string;
  newPassword: string;
  confirmPassword: string;
}
⋮----
/**
 * Auth validation state interface.
 */
interface AuthValidationState {
  // Loading states
  isResettingPassword: boolean;
  isVerifyingEmail: boolean;

  // Error states
  passwordResetError: string | null;
  registerError: string | null;

  // Actions
  requestPasswordReset: (request: PasswordResetRequest) => Promise<boolean>;
  resetPassword: (reset: PasswordReset) => Promise<boolean>;
  changePassword: (currentPassword: string, newPassword: string) => Promise<boolean>;
  verifyEmail: (token: string) => Promise<boolean>;
  resendEmailVerification: () => Promise<boolean>;
  clearPasswordResetError: () => void;
  clearRegisterError: () => void;
}
⋮----
// Loading states
⋮----
// Error states
⋮----
// Actions
⋮----
/**
 * Auth validation store hook.
 */
⋮----
// Initial state
⋮----
// Actions
⋮----
// Selectors
export const usePasswordResetError = ()
export const useIsResettingPassword = ()
````

## File: src/stores/auth/reset-auth.ts
````typescript
import { authCoreInitialState, useAuthCore } from "@/stores/auth/auth-core";
import { useAuthSession } from "@/stores/auth/auth-session";
import {
  authValidationInitialState,
  useAuthValidation,
} from "@/stores/auth/auth-validation";
⋮----
/**
 * Resets all auth-related Zustand slices to their initial view-model state.
 *
 * This helper mirrors Supabase SSR session authority but never mutates or
 * persists tokens. It should be the single entrypoint for clearing client-side
 * auth view state across tests and runtime flows such as logout.
 */
export const resetAuthState = (): void =>
⋮----
// Reset auth-core view-model state (user snapshot and flags).
⋮----
// Clear any persisted auth-core snapshot to avoid leaking state across sessions.
⋮----
// Reset session slice via its public API to avoid shape drift.
⋮----
// Reset validation slice flags and errors.
````

## File: src/stores/chat/chat-messages.ts
````typescript
/**
 * @fileoverview Chat messages slice - sessions, messages, streaming.
 *
 * Manages chat sessions, message history, streaming state, and tool calls.
 * Client-only slice - no direct Supabase clients or server logic.
 */
⋮----
import type { ChatSession, Message } from "@schemas/chat";
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { generateId, getCurrentTimestamp } from "@/stores/helpers";
⋮----
// Memory sync handled server-side via orchestrator - no client-side memory store needed
⋮----
/** Chat messages state interface. */
export interface ChatMessagesState {
  // State
  sessions: ChatSession[];
  currentSessionId: string | null;
  isLoading: boolean;
  error: string | null;

  // Computed
  currentSession: ChatSession | null;

  // Session actions
  createSession: (title?: string, userId?: string, agentId?: string) => string;
  setCurrentSession: (sessionId: string) => void;
  deleteSession: (sessionId: string) => void;
  renameSession: (sessionId: string, title: string) => void;

  // Message actions
  addMessage: (sessionId: string, message: Omit<Message, "id" | "timestamp">) => string;
  updateMessage: (
    sessionId: string,
    messageId: string,
    updates: Partial<Omit<Message, "id" | "timestamp">>
  ) => void;
  clearMessages: (sessionId: string) => void;

  // Tool actions
  addToolResult: (
    sessionId: string,
    messageId: string,
    callId: string,
    result: unknown
  ) => void;

  // Utility
  clearError: () => void;
  exportSessionData: (sessionId: string) => string;
  importSessionData: (jsonData: string) => string | null;
}
⋮----
// State
⋮----
// Computed
⋮----
// Session actions
⋮----
// Message actions
⋮----
// Tool actions
⋮----
// Utility
⋮----
// Track object URLs for attachment cleanup
const objectUrls = new Map<string, Set<string>>(); // sessionId -> Set<objectUrl>
⋮----
const deriveCurrentSession = (
  sessions: ChatSession[],
  currentSessionId: string | null
): ChatSession | null =>
⋮----
/**
 * Chat messages store hook.
 */
⋮----
// Revoke object URLs for this session
⋮----
// Revoke object URLs for this session
⋮----
// Basic validation
⋮----
// Selectors
export const useCurrentSession = ()
export const useSessions = ()
export const useIsLoading = ()
export const useChatError = ()
````

## File: src/stores/chat/chat-realtime.ts
````typescript
/**
 * @fileoverview Chat realtime slice - WebSocket, agent status, typing.
 *
 * Manages real-time connection status, typing indicators, agent status updates,
 * and pending message queues. Client-only slice - actual channel management
 * stays in hooks/route handlers.
 */
⋮----
import type { Message } from "@schemas/chat";
import type {
  AgentStatusBroadcastPayload,
  ChatMessageBroadcastPayload,
  ChatTypingBroadcastPayload,
  ConnectionStatus,
} from "@schemas/realtime";
import { CONNECTION_STATUS_SCHEMA } from "@schemas/realtime";
import { create } from "zustand";
import { getCurrentTimestamp } from "@/stores/helpers";
⋮----
/**
 * Chat realtime state interface.
 */
export interface ChatRealtimeState {
  // State
  connectionStatus: ConnectionStatus;
  isRealtimeEnabled: boolean;
  typingUsers: Record<string, { userId: string; username?: string; timestamp: string }>;
  pendingMessages: Message[];
  agentStatuses: Record<string, AgentStatusBroadcastPayload>; // sessionId -> status

  // Connection actions
  setChatConnectionStatus: (status: ConnectionStatus) => void;
  setRealtimeEnabled: (enabled: boolean) => void;
  resetRealtimeState: () => void;

  // Typing actions
  setUserTyping: (sessionId: string, userId: string, username?: string) => void;
  removeUserTyping: (sessionId: string, userId: string) => void;
  clearTypingUsers: (sessionId: string) => void;

  // Message queue
  addPendingMessage: (message: Message) => void;
  removePendingMessage: (messageId: string) => void;

  // Agent status
  updateAgentStatus: (
    sessionId: string,
    status: Partial<AgentStatusBroadcastPayload>
  ) => void;

  // Broadcast handlers
  handleRealtimeMessage: (
    sessionId: string,
    payload: ChatMessageBroadcastPayload
  ) => void;
  handleTypingUpdate: (sessionId: string, payload: ChatTypingBroadcastPayload) => void;
  handleAgentStatusUpdate: (
    sessionId: string,
    payload: AgentStatusBroadcastPayload
  ) => void;
}
⋮----
// State
⋮----
agentStatuses: Record<string, AgentStatusBroadcastPayload>; // sessionId -> status
⋮----
// Connection actions
⋮----
// Typing actions
⋮----
// Message queue
⋮----
// Agent status
⋮----
// Broadcast handlers
⋮----
/**
 * Chat realtime store hook.
 */
⋮----
// This handler is called by hooks that manage actual Supabase channels
// The slice just tracks state - actual message addition goes through messages slice
⋮----
// Note: Actual message addition should be handled by the calling hook
// which will use the messages slice's addMessage action
⋮----
// Validate status matches schema
⋮----
// Auto-remove after 3 seconds
⋮----
// Selectors
export const useConnectionStatus = ()
export const useAgentStatus = (sessionId: string)
export const useTypingUsers = (sessionId: string)
export const usePendingMessages = ()
export const useIsRealtimeEnabled = ()
````

## File: src/stores/search-filters/filter-configs.ts
````typescript
/**
 * @fileoverview Filter and sort configurations by search type.
 *
 * Extracted from search-filters-store.ts to reduce store size and improve maintainability.
 */
⋮----
import type { SearchType } from "@schemas/search";
import type {
  SortDirection,
  ValidatedFilterOption,
  ValidatedSortOption,
} from "@schemas/stores";
⋮----
/** Flight filter configurations */
⋮----
options: [], // Populated dynamically from API results
⋮----
/** Accommodation filter configurations */
⋮----
/** Activity filter configurations */
⋮----
/** Destination filter configurations */
⋮----
/** Filter configurations by search type */
⋮----
/** Relevance sort option shared across search types */
⋮----
/** Common sort options shared across search types */
⋮----
/** Flight sort options */
⋮----
/** Accommodation sort options */
⋮----
/** Activity sort options */
⋮----
/** Destination sort options */
⋮----
/** Sort configurations by search type */
⋮----
/** Get default filters for a search type */
export const getDefaultFilters = (type: SearchType): ValidatedFilterOption[]
⋮----
/** Get default sort options for a search type */
export const getDefaultSortOptions = (type: SearchType): ValidatedSortOption[]
````

## File: src/stores/search-history/analytics.ts
````typescript
/**
 * @fileoverview Analytics slice for search history store.
 */
⋮----
import type { SearchType } from "@schemas/search";
import type { StateCreator } from "zustand";
import type { AnalyticsSlice, SearchHistoryState } from "./types";
⋮----
export const createAnalyticsSlice: StateCreator<
  SearchHistoryState,
  [],
  [],
  AnalyticsSlice
> = (_set, get) => (
⋮----
// Generate search trends (last 30 days)
⋮----
// Popular search times (by hour)
⋮----
topDestinations: [], // Would be populated from actual search data
````

## File: src/stores/search-history/collections.ts
````typescript
/**
 * @fileoverview Collections slice for search history store.
 */
⋮----
import type { SearchCollection } from "@schemas/stores";
import { searchCollectionSchema } from "@schemas/stores";
import type { StateCreator } from "zustand";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import { generateId, getCurrentTimestamp } from "../helpers";
import type { CollectionsSlice, SearchHistoryState } from "./types";
⋮----
export const createCollectionsSlice: StateCreator<
  SearchHistoryState,
  [],
  [],
  CollectionsSlice
> = (set, _get) => (
````

## File: src/stores/search-history/index.ts
````typescript
/**
 * @fileoverview Search history store composed from modular slices.
 */
⋮----
import type { SearchType } from "@schemas/search";
import type { SearchHistoryItem, ValidatedSavedSearch } from "@schemas/stores";
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { createAnalyticsSlice } from "./analytics";
import { createCollectionsSlice } from "./collections";
import { createQuickSearchesSlice } from "./quick";
import {
  createRecentSearchesSlice,
  DEFAULT_AUTO_CLEANUP_DAYS,
  DEFAULT_MAX_RECENT_SEARCHES,
} from "./recent";
import { createSavedSearchesSlice } from "./saved";
import { createSuggestionsSlice } from "./suggestions";
import type { SearchHistoryState } from "./types";
⋮----
// Compose all slices
⋮----
// Spread all slices
⋮----
// Utility actions
⋮----
get favoriteSearches(): ValidatedSavedSearch[]
⋮----
get recentSearchesByType()
⋮----
get searchAnalytics()
⋮----
// Computed properties (defined at composition level where get() is available)
get totalSavedSearches()
⋮----
// Settings management
⋮----
// Apply cleanup if enabled
````

## File: src/stores/search-history/quick.ts
````typescript
/**
 * @fileoverview Quick searches slice for search history store.
 */
⋮----
import type { QuickSearch } from "@schemas/stores";
import { quickSearchSchema } from "@schemas/stores";
import type { StateCreator } from "zustand";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import { generateId, getCurrentTimestamp } from "../helpers";
import type { QuickSearchesSlice, SearchHistoryState } from "./types";
⋮----
export const createQuickSearchesSlice: StateCreator<
  SearchHistoryState,
  [],
  [],
  QuickSearchesSlice
> = (set, get) => (
````

## File: src/stores/search-history/recent.ts
````typescript
/**
 * @fileoverview Recent searches slice for search history store.
 */
⋮----
import type { SearchHistoryItem } from "@schemas/stores";
import { searchHistoryItemSchema } from "@schemas/stores";
import type { StateCreator } from "zustand";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import { generateId, getCurrentTimestamp } from "../helpers";
import type { RecentSearchesSlice, SearchHistoryState } from "./types";
⋮----
export const createRecentSearchesSlice: StateCreator<
  SearchHistoryState,
  [],
  [],
  RecentSearchesSlice
> = (set, get) => (
⋮----
// Check if similar search already exists (avoid duplicates)
⋮----
// Update existing search timestamp
⋮----
// Add new search
⋮----
// Update search suggestions
````

## File: src/stores/search-history/saved.ts
````typescript
/**
 * @fileoverview Saved searches slice for search history store.
 */
⋮----
import type { SearchParams } from "@schemas/search";
import type { ValidatedSavedSearch } from "@schemas/stores";
import { savedSearchSchema } from "@schemas/stores";
import type { StateCreator } from "zustand";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import { generateId, getCurrentTimestamp } from "../helpers";
import type { SavedSearchesSlice, SearchHistoryState } from "./types";
⋮----
export const createSavedSearchesSlice: StateCreator<
  SearchHistoryState,
  [],
  [],
  SavedSearchesSlice
> = (set, get) => (
````

## File: src/stores/search-history/selectors.ts
````typescript
/**
 * @fileoverview Selector hooks for search history store.
 */
⋮----
import type { SearchType } from "@schemas/search";
import type { SearchHistoryItem, ValidatedSavedSearch } from "@schemas/stores";
import { useSearchHistoryStore } from "./index";
import type { SearchHistoryState } from "./types";
⋮----
// Basic selectors
export const useRecentSearches = (searchType?: SearchType, limit?: number)
⋮----
export const useSavedSearches = (searchType?: SearchType)
⋮----
export const useFavoriteSearches = ()
⋮----
export const useSearchCollections = ()
⋮----
export const useQuickSearches = ()
⋮----
export const useSearchSuggestions = (
  query: string,
  searchType?: SearchType,
  limit?: number
)
⋮----
export const useSearchAnalytics = (dateRange?:
⋮----
export const useSearchHistoryLoading = ()
⋮----
// Compute selectors (for external use without hooks)
export const selectRecentSearchesByTypeFrom = (
  state: SearchHistoryState
): Record<SearchType, SearchHistoryItem[]> =>
⋮----
export const selectFavoriteSearchesFrom = (
  state: SearchHistoryState
): ValidatedSavedSearch[]
⋮----
export const selectTotalSavedSearchesFrom = (state: SearchHistoryState): number
````

## File: src/stores/search-history/suggestions.ts
````typescript
/**
 * @fileoverview Search suggestions slice for search history store.
 */
⋮----
import type { StateCreator } from "zustand";
import { getCurrentTimestamp } from "../helpers";
import type { SearchHistoryState, SearchSuggestion, SuggestionsSlice } from "./types";
⋮----
/**
 * Extracts meaningful search text from search parameters.
 */
const extractSearchText = (params: Record<string, unknown>): string =>
⋮----
export const createSuggestionsSlice: StateCreator<
  SearchHistoryState,
  [],
  [],
  SuggestionsSlice
> = (set, get) => (
⋮----
].slice(0, 200), // Keep top 200 terms
⋮----
// Sort by frequency and recency
⋮----
// Helper to add suggestion with deduplication
const addSuggestion = (suggestion: SearchSuggestion): boolean =>
⋮----
// Process recent searches (limit to 50 most recent)
⋮----
// Process saved searches (limit to 20)
⋮----
// Process popular terms (limit to 10)
````

## File: src/stores/search-history/types.ts
````typescript
/**
 * @fileoverview Type definitions for search history store slices.
 */
⋮----
import type { SearchParams, SearchType } from "@schemas/search";
import type {
  QuickSearch,
  SearchCollection,
  SearchHistoryItem,
  ValidatedSavedSearch,
} from "@schemas/stores";
⋮----
export interface SearchSuggestion {
  id: string;
  text: string;
  searchType: SearchType;
  frequency: number;
  lastUsed: string;
  source: "history" | "saved" | "popular";
}
⋮----
export interface SearchAnalytics {
  totalSearches: number;
  searchesByType: Record<SearchType, number>;
  averageSearchDuration: number;
  mostUsedSearchTypes: Array<{
    type: SearchType;
    count: number;
    percentage: number;
  }>;
  searchTrends: Array<{ date: string; count: number }>;
  popularSearchTimes: Array<{ hour: number; count: number }>;
  topDestinations: Array<{ destination: string; count: number }>;
  savedSearchUsage: Array<{
    searchId: string;
    name: string;
    usageCount: number;
  }>;
}
⋮----
// Slice interfaces
export interface RecentSearchesSlice {
  recentSearches: SearchHistoryItem[];
  maxRecentSearches: number;
  autoSaveEnabled: boolean;
  autoCleanupDays: number;
  addRecentSearch: (
    searchType: SearchType,
    params: SearchParams,
    metadata?: Partial<SearchHistoryItem>
  ) => void;
  clearRecentSearches: (searchType?: SearchType) => void;
  removeRecentSearch: (searchId: string) => void;
  cleanupOldSearches: () => void;
  getRecentSearchesByType: (
    searchType: SearchType,
    limit?: number
  ) => SearchHistoryItem[];
}
⋮----
export interface SavedSearchesSlice {
  savedSearches: ValidatedSavedSearch[];
  isLoading: boolean;
  error: string | null;
  saveSearch: (
    name: string,
    searchType: SearchType,
    params: SearchParams,
    options?: {
      description?: string;
      tags?: string[];
      isFavorite?: boolean;
      isPublic?: boolean;
    }
  ) => Promise<string | null>;
  updateSavedSearch: (
    searchId: string,
    updates: Partial<ValidatedSavedSearch>
  ) => Promise<boolean>;
  deleteSavedSearch: (searchId: string) => Promise<boolean>;
  duplicateSavedSearch: (searchId: string, newName: string) => Promise<string | null>;
  markSearchAsUsed: (searchId: string) => void;
  toggleSearchFavorite: (searchId: string) => void;
  searchSavedSearches: (
    query: string,
    filters?: {
      searchType?: SearchType;
      tags?: string[];
      isFavorite?: boolean;
    }
  ) => ValidatedSavedSearch[];
  getSavedSearchesByType: (searchType: SearchType) => ValidatedSavedSearch[];
  getSavedSearchesByTag: (tag: string) => ValidatedSavedSearch[];
  clearError: () => void;
}
⋮----
export interface CollectionsSlice {
  searchCollections: SearchCollection[];
  createCollection: (
    name: string,
    description?: string,
    searchIds?: string[]
  ) => Promise<string | null>;
  updateCollection: (
    collectionId: string,
    updates: Partial<SearchCollection>
  ) => Promise<boolean>;
  deleteCollection: (collectionId: string) => Promise<boolean>;
  addSearchToCollection: (collectionId: string, searchId: string) => void;
  removeSearchFromCollection: (collectionId: string, searchId: string) => void;
}
⋮----
export interface QuickSearchesSlice {
  quickSearches: QuickSearch[];
  createQuickSearch: (
    label: string,
    searchType: SearchType,
    params: SearchParams,
    options?: {
      icon?: string;
      color?: string;
      sortOrder?: number;
    }
  ) => Promise<string | null>;
  updateQuickSearch: (
    quickSearchId: string,
    updates: Partial<QuickSearch>
  ) => Promise<boolean>;
  deleteQuickSearch: (quickSearchId: string) => void;
  reorderQuickSearches: (quickSearchIds: string[]) => void;
}
⋮----
export interface SuggestionsSlice {
  searchSuggestions: SearchSuggestion[];
  popularSearchTerms: Array<{
    term: string;
    count: number;
    searchType: SearchType;
  }>;
  getSearchSuggestions: (
    query: string,
    searchType?: SearchType,
    limit?: number
  ) => SearchSuggestion[];
  updateSearchSuggestions: () => void;
  addSearchTerm: (term: string, searchType: SearchType) => void;
}
⋮----
export interface AnalyticsSlice {
  getSearchAnalytics: (dateRange?: { start: string; end: string }) => SearchAnalytics;
  getMostUsedSearches: (limit?: number) => ValidatedSavedSearch[];
  getSearchTrends: (
    searchType?: SearchType,
    days?: number
  ) => Array<{ date: string; count: number }>;
}
⋮----
export interface SettingsSlice {
  updateSettings: (settings: {
    maxRecentSearches?: number;
    autoSaveEnabled?: boolean;
    autoCleanupDays?: number;
  }) => void;
}
⋮----
export interface UtilitySlice {
  clearAllData: () => void;
  reset: () => void;
}
⋮----
// Combined state type
export type SearchHistoryState = RecentSearchesSlice &
  SavedSearchesSlice &
  CollectionsSlice &
  QuickSearchesSlice &
  SuggestionsSlice &
  AnalyticsSlice &
  SettingsSlice &
  UtilitySlice & {
    // Computed properties
    totalSavedSearches: number;
    recentSearchesByType: Record<SearchType, SearchHistoryItem[]>;
    favoriteSearches: ValidatedSavedSearch[];
    searchAnalytics: SearchAnalytics;
  };
⋮----
// Computed properties
````

## File: src/stores/search-params/handlers/accommodation-handler.ts
````typescript
/**
 * @fileoverview Handler for accommodation search parameters.
 */
⋮----
import {
  accommodationSearchParamsStoreSchema,
  type ValidatedAccommodationParams,
} from "@schemas/stores";
import { registerHandler } from "../registry";
import type { SearchParamsHandler } from "../types";
⋮----
/** Default accommodation search parameters. */
⋮----
/**
 * Accommodation search parameters handler.
 * Manages default values, validation, and required field checking for accommodations.
 */
⋮----
getDefaults()
⋮----
getSchema()
⋮----
hasRequiredParams(params)
⋮----
mergeParams(current, updates)
⋮----
validate(params)
⋮----
// Register on module load
````

## File: src/stores/search-params/handlers/activity-handler.ts
````typescript
/**
 * @fileoverview Handler for activity search parameters.
 */
⋮----
import {
  activitySearchParamsStoreSchema,
  type ValidatedActivityParams,
} from "@schemas/stores";
import { registerHandler } from "../registry";
import type { SearchParamsHandler } from "../types";
⋮----
/** Default activity search parameters. */
⋮----
/**
 * Activity search parameters handler.
 * Manages default values, validation, and required field checking for activities.
 */
⋮----
getDefaults()
⋮----
getSchema()
⋮----
hasRequiredParams(params)
⋮----
mergeParams(current, updates)
⋮----
validate(params)
⋮----
// Register on module load
````

## File: src/stores/search-params/handlers/destination-handler.ts
````typescript
/**
 * @fileoverview Handler for destination search parameters.
 */
⋮----
import {
  destinationSearchParamsStoreSchema,
  type ValidatedDestinationParams,
} from "@schemas/stores";
import { registerHandler } from "../registry";
import type { SearchParamsHandler } from "../types";
⋮----
/** Default destination search parameters. */
⋮----
/**
 * Destination search parameters handler.
 * Manages default values, validation, and required field checking for destinations.
 */
⋮----
getDefaults()
⋮----
getSchema()
⋮----
hasRequiredParams(params)
⋮----
mergeParams(current, updates)
⋮----
validate(params)
⋮----
// Register on module load
````

## File: src/stores/search-params/handlers/flight-handler.ts
````typescript
/**
 * @fileoverview Handler for flight search parameters.
 */
⋮----
import {
  flightSearchParamsStoreSchema,
  type ValidatedFlightParams,
} from "@schemas/stores";
import { registerHandler } from "../registry";
import type { SearchParamsHandler } from "../types";
⋮----
/** Default flight search parameters. */
⋮----
/**
 * Flight search parameters handler.
 * Manages default values, validation, and required field checking for flights.
 */
⋮----
getDefaults()
⋮----
getSchema()
⋮----
hasRequiredParams(params)
⋮----
mergeParams(current, updates)
⋮----
validate(params)
⋮----
// Register on module load
````

## File: src/stores/search-params/handlers/index.ts
````typescript
/**
 * @fileoverview Registry for all search parameter handlers
 * Each handler is responsible for a specific search type's parameter validation, defaults, and serialization.
 * Handlers are automatically registered when imported.
 */
⋮----
import { accommodationHandler } from "./accommodation-handler";
import { activityHandler } from "./activity-handler";
import { destinationHandler } from "./destination-handler";
import { flightHandler } from "./flight-handler";
⋮----
export const registerAllHandlers = () =>
⋮----
// Handlers self-register on import via registerHandler.
````

## File: src/stores/search-params/registry.ts
````typescript
/**
 * @fileoverview Registry for search params handlers.
 *
 * Provides handler registration and lookup for the strategy pattern.
 * Consumers must import handler files separately to trigger registration.
 */
⋮----
import type { SearchType } from "@schemas/stores";
import type { SearchParamsHandler } from "./types";
⋮----
/**
 * Register a handler for a search type.
 * Called at module load time by each handler.
 *
 * @param handler - The handler to register
 * @throws Error if a handler is already registered for the search type
 */
export function registerHandler<T>(handler: SearchParamsHandler<T>): void
⋮----
/**
 * Get handler for a search type.
 *
 * @param searchType - The search type to get handler for
 * @returns The handler for the search type
 * @throws Error if no handler is registered for the search type
 */
export function getHandler<T = unknown>(
  searchType: SearchType
): SearchParamsHandler<T>
⋮----
/**
 * Check if a handler is registered for a search type.
 *
 * @param searchType - The search type to check
 * @returns True if a handler is registered
 */
export function hasHandler(searchType: SearchType): boolean
⋮----
/**
 * Get all registered search types.
 *
 * @returns Array of registered search types
 */
export function getRegisteredTypes(): SearchType[]
````

## File: src/stores/search-params/types.ts
````typescript
/**
 * @fileoverview Search params handler interface for strategy pattern.
 *
 * This module defines the handler interface that each search type implements
 * to provide type-specific parameter handling. The strategy pattern eliminates
 * switch statements and enables extensibility - adding a new search type only
 * requires creating a new handler file.
 */
⋮----
import type { SearchParams } from "@schemas/search";
import type { SearchType } from "@schemas/stores";
import type { ZodError, z } from "zod";
⋮----
/**
 * Handler interface for search type-specific parameter logic.
 *
 * Each search type implements this interface to handle its own:
 * - Default values
 * - Validation rules (via Zod schema)
 * - Required fields check
 * - Parameter merging
 *
 * @template T - The specific params type for this search type
 */
export interface SearchParamsHandler<T = unknown> {
  /** The search type this handler manages */
  readonly searchType: SearchType;

  /** Returns the Zod schema for validating parameters. */
  getSchema(): z.ZodType<T>;

  /** Returns default parameters for this search type. */
  getDefaults(): Partial<T>;

  /**
   * Validates parameters using the Zod schema.
   * Returns fully validated parameters on success, or a ZodError on failure.
   *
   * @param params - Partial parameters to validate
   * @returns Validation result with fully validated T on success, or ZodError
   */
  validate(
    params: Partial<T>
  ): { success: true; data: T } | { success: false; error: ZodError };

  /**
   * Checks if minimum required params are present for search.
   * This determines if a search can be executed.
   *
   * @param params - Partial parameters to check
   */
  hasRequiredParams(params: Partial<T>): boolean;

  /**
   * Merges updates into existing params with type-specific logic.
   *
   * @param current - Current parameters
   * @param updates - Updates to apply
   */
  mergeParams(current: Partial<T>, updates: Partial<T>): Partial<T>;

  /**
   * Converts fully validated params to the generic SearchParams union type.
   * Called with params that have successfully passed validate().
   * Optional method; implement only if SearchParams conversion is needed.
   */
  toSearchParams?(params: T): SearchParams;
}
⋮----
/** The search type this handler manages */
⋮----
/** Returns the Zod schema for validating parameters. */
getSchema(): z.ZodType<T>;
⋮----
/** Returns default parameters for this search type. */
getDefaults(): Partial<T>;
⋮----
/**
   * Validates parameters using the Zod schema.
   * Returns fully validated parameters on success, or a ZodError on failure.
   *
   * @param params - Partial parameters to validate
   * @returns Validation result with fully validated T on success, or ZodError
   */
validate(
    params: Partial<T>
):
⋮----
/**
   * Checks if minimum required params are present for search.
   * This determines if a search can be executed.
   *
   * @param params - Partial parameters to check
   */
hasRequiredParams(params: Partial<T>): boolean;
⋮----
/**
   * Merges updates into existing params with type-specific logic.
   *
   * @param current - Current parameters
   * @param updates - Updates to apply
   */
mergeParams(current: Partial<T>, updates: Partial<T>): Partial<T>;
⋮----
/**
   * Converts fully validated params to the generic SearchParams union type.
   * Called with params that have successfully passed validate().
   * Optional method; implement only if SearchParams conversion is needed.
   */
toSearchParams?(params: T): SearchParams;
⋮----
/** Type helper for extracting the params type from a handler. */
export type HandlerParams<H> = H extends SearchParamsHandler<infer T> ? T : never;
````

## File: src/stores/selectors/search-selectors.ts
````typescript
/**
 * @fileoverview Cross-store selectors for search domain.
 *
 * Provides unified access to search state across params, filters, results, and history stores.
 */
⋮----
import type { SearchResults, SearchType } from "@schemas/search";
import { useSearchFiltersStore } from "../search-filters-store";
import { useSearchHistoryStore } from "../search-history";
import { useSearchParamsStore } from "../search-params-store";
import { useSearchResultsStore } from "../search-results-store";
⋮----
/** Get result array length for a search type */
const getResultCount = (results: SearchResults, searchType: SearchType): number =>
⋮----
type SearchResultArray<T extends SearchType> = T extends "flight"
  ? NonNullable<SearchResults["flights"]>
  : T extends "accommodation"
    ? NonNullable<SearchResults["accommodations"]>
    : T extends "activity"
      ? NonNullable<SearchResults["activities"]>
      : T extends "destination"
        ? NonNullable<SearchResults["destinations"]>
        : never;
⋮----
/** Get result array for a search type */
const getResultsForType = <T extends SearchType>(
  results: SearchResults,
  searchType: T
): SearchResultArray<T> =>
⋮----
// Exhaustive check: ensure all SearchType cases are handled
⋮----
/**
 * Combined search state summary for display.
 */
export const useSearchSummary = () =>
⋮----
/**
 * Active filters summary for display.
 */
export const useActiveFiltersSummary = () =>
⋮----
/**
 * Search validation state across stores.
 */
export const useSearchValidation = () =>
⋮----
/**
 * Combined search history context.
 */
export const useSearchHistorySummary = () =>
⋮----
/**
 * Search results context for a specific type.
 */
export const useSearchResultsByType = (searchType: SearchType | null) =>
⋮----
/**
 * Search suggestions for autocomplete.
 */
export const useSearchSuggestionsSelector = (
  query: string,
  searchType?: SearchType,
  limit = 10
) =>
````

## File: src/stores/ui/command-palette.ts
````typescript
/**
 * @fileoverview Command palette slice for UI store.
 */
⋮----
import type { StateCreator } from "zustand";
import { useUiStore } from "./index";
import type { CommandPaletteSlice, CommandPaletteState, UiState } from "./types";
⋮----
export const createCommandPaletteSlice: StateCreator<
  UiState,
  [],
  [],
  CommandPaletteSlice
> = (set) => (
⋮----
// ===== SELECTOR HOOKS =====
⋮----
/** Select whether the command palette is open */
export const useCommandPaletteOpen = ()
⋮----
/** Select the command palette query */
export const useCommandPaletteQuery = ()
⋮----
/** Select the command palette results */
export const useCommandPaletteResults = ()
````

## File: src/stores/ui/features.ts
````typescript
/**
 * @fileoverview Feature flags slice for UI store.
 */
⋮----
import type { StateCreator } from "zustand";
import type { FeatureFlags, FeaturesSlice, UiState } from "./types";
⋮----
export const createFeaturesSlice: StateCreator<UiState, [], [], FeaturesSlice> = (
  set
) => (
````

## File: src/stores/ui/index.ts
````typescript
/**
 * @fileoverview UI state management store using Zustand with TypeScript validation.
 *
 * This module composes multiple slices for better maintainability and tree-shaking.
 */
⋮----
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import {
  createCommandPaletteSlice,
  DEFAULT_COMMAND_PALETTE_STATE,
} from "./command-palette";
import { createFeaturesSlice } from "./features";
import { createLoadingSlice } from "./loading";
import { createModalSlice, DEFAULT_MODAL_STATE } from "./modal";
import { createNavigationSlice, DEFAULT_NAVIGATION_STATE } from "./navigation";
import { createNotificationsSlice } from "./notifications";
import { createSidebarSlice, DEFAULT_SIDEBAR_STATE } from "./sidebar";
import { createThemeSlice } from "./theme";
import type { UiState } from "./types";
⋮----
// Compose all slices
⋮----
// Spread all slices
⋮----
// Computed properties (getters) - defined at the top level where get() is available
get isDarkMode()
⋮----
get isLoading()
⋮----
// Utility actions
⋮----
get unreadNotificationCount()
````

## File: src/stores/ui/loading.ts
````typescript
/**
 * @fileoverview Loading state slice for UI store.
 */
⋮----
import { loadingStateSchema } from "@schemas/stores";
import type { StateCreator } from "zustand";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import type { LoadingSlice, UiState } from "./types";
⋮----
export const createLoadingSlice: StateCreator<UiState, [], [], LoadingSlice> = (
  set,
  _get
) => (
⋮----
// isLoading is defined as a computed getter in the main store composition
````

## File: src/stores/ui/modal.ts
````typescript
/**
 * @fileoverview Modal slice for UI store.
 */
⋮----
import type { StateCreator } from "zustand";
import { useUiStore } from "./index";
import type { ModalSlice, ModalState, UiState } from "./types";
⋮----
export const createModalSlice: StateCreator<UiState, [], [], ModalSlice> = (set) => (
⋮----
// ===== SELECTOR HOOKS =====
⋮----
/** Select whether the modal is open */
export const useModalOpen = ()
⋮----
/** Select the modal component */
export const useModalComponent = ()
⋮----
/** Select the modal props */
export const useModalProps = ()
⋮----
/** Select the modal size */
export const useModalSize = ()
````

## File: src/stores/ui/navigation.ts
````typescript
/**
 * @fileoverview Navigation slice for UI store.
 */
⋮----
import type { StateCreator } from "zustand";
import type { NavigationSlice, NavigationState, UiState } from "./types";
⋮----
export const createNavigationSlice: StateCreator<UiState, [], [], NavigationSlice> = (
  set
) => (
````

## File: src/stores/ui/notifications.ts
````typescript
/**
 * @fileoverview Notifications slice for UI store.
 */
⋮----
import { notificationSchema } from "@schemas/stores";
import type { StateCreator } from "zustand";
import { nowIso, secureId } from "@/lib/security/random";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import type { NotificationsSlice, UiState } from "./types";
⋮----
const GENERATE_ID = ()
const GET_CURRENT_TIMESTAMP = ()
⋮----
// Map to store timeout IDs keyed by notification ID
⋮----
export const createNotificationsSlice: StateCreator<
  UiState,
  [],
  [],
  NotificationsSlice
> = (set, get) => (
⋮----
notifications: [result.data, ...state.notifications].slice(0, 50), // Keep max 50 notifications
⋮----
// Auto-remove notification if duration is specified
⋮----
// Clear all pending timeouts
⋮----
// Clear the associated timeout if it exists
⋮----
// unreadNotificationCount is defined as a computed getter in the main store composition
````

## File: src/stores/ui/selectors.ts
````typescript
/**
 * @fileoverview Selector hooks for UI store.
 */
⋮----
import { useUiStore } from "./index";
⋮----
// ===== THEME SELECTORS =====
⋮----
/** Selector hook for the current theme setting. */
export const useTheme = ()
⋮----
/** Selector hook for dark mode status. */
export const useIsDarkMode = ()
⋮----
// ===== SIDEBAR SELECTORS =====
⋮----
/** Selector hook for sidebar state. */
export const useSidebar = ()
⋮----
// ===== NAVIGATION SELECTORS =====
⋮----
/** Selector hook for navigation state. */
export const useNavigation = ()
⋮----
// ===== NOTIFICATIONS SELECTORS =====
⋮----
/** Selector hook for notifications array. */
export const useNotifications = ()
⋮----
/** Selector hook for unread notification count. */
export const useUnreadNotificationCount = ()
⋮----
// ===== MODAL SELECTORS =====
⋮----
/** Selector hook for modal state. */
export const useModal = ()
⋮----
// ===== COMMAND PALETTE SELECTORS =====
⋮----
/** Selector hook for command palette state. */
export const useCommandPalette = ()
⋮----
// ===== LOADING SELECTORS =====
⋮----
/** Selector hook for loading states map. */
export const useLoadingStates = ()
⋮----
/** Selector hook for global loading status. */
export const useIsLoading = ()
⋮----
// ===== FEATURES SELECTORS =====
⋮----
/** Selector hook for feature flags. */
export const useFeatures = ()
````

## File: src/stores/ui/sidebar.ts
````typescript
/**
 * @fileoverview Sidebar slice for UI store.
 */
⋮----
import type { StateCreator } from "zustand";
import type { SidebarSlice, SidebarState, UiState } from "./types";
⋮----
export const createSidebarSlice: StateCreator<UiState, [], [], SidebarSlice> = (
  set
) => (
````

## File: src/stores/ui/theme.ts
````typescript
/**
 * @fileoverview Theme slice for UI store.
 */
⋮----
import { themeSchema } from "@schemas/stores";
import type { StateCreator } from "zustand";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import type { ThemeSlice, UiState } from "./types";
⋮----
export const createThemeSlice: StateCreator<UiState, [], [], ThemeSlice> = (
  set,
  get
) => (
⋮----
// isDarkMode is defined as a computed getter in the main store composition
````

## File: src/stores/ui/types.ts
````typescript
/**
 * @fileoverview Type definitions for UI store slices.
 */
⋮----
import type { LoadingState, LoadingStates, Notification, Theme } from "@schemas/stores";
⋮----
// ===== SIDEBAR TYPES =====
⋮----
export interface SidebarState {
  isOpen: boolean;
  isCollapsed: boolean;
  isPinned: boolean;
}
⋮----
// ===== NAVIGATION TYPES =====
⋮----
export interface NavigationState {
  activeRoute: string;
  breadcrumbs: Array<{
    label: string;
    href?: string;
  }>;
}
⋮----
// ===== MODAL TYPES =====
⋮----
export interface ModalState {
  isOpen: boolean;
  component: string | null;
  props?: Record<string, unknown>;
  size?: "sm" | "md" | "lg" | "xl" | "full";
  closeOnOverlayClick?: boolean;
}
⋮----
// ===== COMMAND PALETTE TYPES =====
⋮----
export interface CommandPaletteState {
  isOpen: boolean;
  query: string;
  results: Array<{
    id: string;
    title: string;
    description?: string;
    action: () => void;
    category?: string;
    icon?: string;
  }>;
}
⋮----
// ===== FEATURE FLAGS =====
⋮----
export interface FeatureFlags {
  enableAnimations: boolean;
  enableSounds: boolean;
  enableHaptics: boolean;
  enableAnalytics: boolean;
  enableBetaFeatures: boolean;
}
⋮----
// ===== SLICE INTERFACES =====
⋮----
export interface ThemeSlice {
  theme: Theme;
  isDarkMode: boolean;
  setTheme: (theme: Theme) => void;
  toggleTheme: () => void;
}
⋮----
export interface SidebarSlice {
  sidebar: SidebarState;
  toggleSidebar: () => void;
  setSidebarOpen: (isOpen: boolean) => void;
  setSidebarCollapsed: (isCollapsed: boolean) => void;
  setSidebarPinned: (isPinned: boolean) => void;
}
⋮----
export interface NavigationSlice {
  navigation: NavigationState;
  setActiveRoute: (route: string) => void;
  setBreadcrumbs: (breadcrumbs: NavigationState["breadcrumbs"]) => void;
  addBreadcrumb: (breadcrumb: NavigationState["breadcrumbs"][0]) => void;
}
⋮----
export interface LoadingSlice {
  loadingStates: LoadingStates;
  isLoading: boolean;
  setLoadingState: (key: string, state: LoadingState) => void;
  clearLoadingState: (key: string) => void;
  clearAllLoadingStates: () => void;
}
⋮----
export interface NotificationsSlice {
  notifications: Notification[];
  unreadNotificationCount: number;
  addNotification: (notification: Omit<Notification, "id" | "createdAt">) => string;
  removeNotification: (id: string) => void;
  markNotificationAsRead: (id: string) => void;
  clearAllNotifications: () => void;
}
⋮----
export interface ModalSlice {
  modal: ModalState;
  openModal: (
    component: string,
    props?: Record<string, unknown>,
    options?: Partial<ModalState>
  ) => void;
  closeModal: () => void;
  updateModalProps: (props: Record<string, unknown>) => void;
}
⋮----
export interface CommandPaletteSlice {
  commandPalette: CommandPaletteState;
  openCommandPalette: () => void;
  closeCommandPalette: () => void;
  setCommandPaletteQuery: (query: string) => void;
  setCommandPaletteResults: (results: CommandPaletteState["results"]) => void;
}
⋮----
export interface FeaturesSlice {
  features: FeatureFlags;
  toggleFeature: (feature: keyof FeatureFlags) => void;
  setFeature: (feature: keyof FeatureFlags, enabled: boolean) => void;
}
⋮----
export interface UtilitySlice {
  reset: () => void;
}
⋮----
// ===== COMBINED STATE =====
⋮----
export type UiState = ThemeSlice &
  SidebarSlice &
  NavigationSlice &
  LoadingSlice &
  NotificationsSlice &
  ModalSlice &
  CommandPaletteSlice &
  FeaturesSlice &
  UtilitySlice;
````

## File: src/stores/agent-status-store.ts
````typescript
/**
 * @fileoverview Zustand store that tracks realtime agent metrics, lifecycle
 * events, and resource usage for dashboard consumers.
 */
⋮----
import type {
  Agent,
  AgentActivity,
  AgentStatusType,
  AgentTask,
  ResourceUsage,
} from "@schemas/agent-status";
import { create } from "zustand";
import type { RealtimeConnectionStatus } from "@/hooks/supabase/use-realtime-channel";
import { nowIso, secureId } from "@/lib/security/random";
⋮----
/**
 * Task update payload dispatched from realtime events.
 */
export type AgentTaskUpdate =
  | {
      /** Start a task for the agent. */
      type: "start";
      /** Optional server-provided task id. */
      taskId?: string;
      /** Task title shown in dashboards. */
      title: string;
      /** Optional human readable description. */
      description?: string;
    }
  | {
      /** Update a running task's status/progress. */
      type: "progress";
      /** Target task identifier. */
      taskId: string;
      /** Optional progress percentage (0-100). */
      progress?: number;
      /** Optional status override. */
      status?: AgentTask["status"];
    }
  | {
      /** Mark a task as completed or failed. */
      type: "complete";
      /** Completed task identifier. */
      taskId: string;
      /** Optional failure reason. */
      error?: string;
    };
⋮----
/** Start a task for the agent. */
⋮----
/** Optional server-provided task id. */
⋮----
/** Task title shown in dashboards. */
⋮----
/** Optional human readable description. */
⋮----
/** Update a running task's status/progress. */
⋮----
/** Target task identifier. */
⋮----
/** Optional progress percentage (0-100). */
⋮----
/** Optional status override. */
⋮----
/** Mark a task as completed or failed. */
⋮----
/** Completed task identifier. */
⋮----
/** Optional failure reason. */
⋮----
/**
 * Slice describing the realtime connection state for agent status topics.
 */
export interface AgentStatusConnectionState {
  /** Current low-level connection status. */
  status: RealtimeConnectionStatus;
  /** Last error message, if any. */
  error: string | null;
  /** Number of consecutive retry attempts triggered by backoff helper. */
  retryCount: number;
  /** Timestamp for the last status transition. */
  lastChangedAt: string | null;
  /** The active Supabase topic (e.g., `user:123`). */
  topic: string | null;
}
⋮----
/** Current low-level connection status. */
⋮----
/** Last error message, if any. */
⋮----
/** Number of consecutive retry attempts triggered by backoff helper. */
⋮----
/** Timestamp for the last status transition. */
⋮----
/** The active Supabase topic (e.g., `user:123`). */
⋮----
/**
 * Zustand store contract for agent status data and derived views.
 */
export interface AgentStatusState {
  /** Ordered agent list used by dashboards. */
  agents: Agent[];
  /** Agents that are neither idle nor completed/error. */
  activeAgents: Agent[];
  /** Ordered audit trail of agent activities. */
  activities: AgentActivity[];
  /** Rolling resource usage samples. */
  resourceUsage: ResourceUsage[];
  /** Connection slice shared with realtime hooks. */
  connection: AgentStatusConnectionState;
  /** Whether dashboards requested monitoring. */
  isMonitoring: boolean;
  /** Timestamp for the last processed event. */
  lastEventAt: string | null;
  /** Internal map keyed by agent id. */
  agentsById: Record<string, Agent>;
  /** Stable ordering of agents for deterministic UIs. */
  agentOrder: string[];
  /** Register or refresh a batch of agents from server snapshots. */
  registerAgents: (agents: Agent[]) => void;
  /** Update agent lifecycle & progress from realtime broadcasts. */
  updateAgentStatus: (
    agentId: string,
    status: AgentStatusType,
    options?: {
      progress?: number;
      name?: string;
      description?: string;
      metadata?: Agent["metadata"];
      type?: Agent["type"];
    }
  ) => void;
  /** Apply task lifecycle updates triggered by realtime events. */
  updateAgentTask: (agentId: string, update: AgentTaskUpdate) => void;
  /** Append a structured activity entry. */
  recordActivity: (activity: Omit<AgentActivity, "id" | "timestamp">) => void;
  /** Append a resource usage sample. */
  recordResourceUsage: (usage: Omit<ResourceUsage, "timestamp">) => void;
  /** Update connection slice state (status/errors/retries). */
  setAgentStatusConnection: (update: Partial<AgentStatusConnectionState>) => void;
  /** Toggle monitoring flag used by dashboards. */
  setMonitoring: (enabled: boolean) => void;
  /** Reset store to initial state. */
  resetAgentStatusState: () => void;
}
⋮----
/** Ordered agent list used by dashboards. */
⋮----
/** Agents that are neither idle nor completed/error. */
⋮----
/** Ordered audit trail of agent activities. */
⋮----
/** Rolling resource usage samples. */
⋮----
/** Connection slice shared with realtime hooks. */
⋮----
/** Whether dashboards requested monitoring. */
⋮----
/** Timestamp for the last processed event. */
⋮----
/** Internal map keyed by agent id. */
⋮----
/** Stable ordering of agents for deterministic UIs. */
⋮----
/** Register or refresh a batch of agents from server snapshots. */
⋮----
/** Update agent lifecycle & progress from realtime broadcasts. */
⋮----
/** Apply task lifecycle updates triggered by realtime events. */
⋮----
/** Append a structured activity entry. */
⋮----
/** Append a resource usage sample. */
⋮----
/** Update connection slice state (status/errors/retries). */
⋮----
/** Toggle monitoring flag used by dashboards. */
⋮----
/** Reset store to initial state. */
⋮----
const clampProgress = (value: number | undefined, fallback: number): number =>
⋮----
const deriveAgents = (map: Record<string, Agent>, order: string[]): Agent[]
⋮----
const deriveActiveAgents = (agents: Agent[]): Agent[]
⋮----
const ensureAgent = (
  map: Record<string, Agent>,
  agentId: string,
  overrides?: Partial<Agent>
): Agent =>
⋮----
const withDerivedCollections = (
  state: Omit<AgentStatusState, "agents" | "activeAgents">
): AgentStatusState =>
⋮----
const initialConnectionState = (): AgentStatusConnectionState => (
⋮----
const createDataState = () => (
⋮----
/**
 * Provides the agent status store hook that powers dashboard state and derived
 * collections.
 *
 * @returns Bound store interface with state selectors and mutators for agent
 * telemetry.
 */
````

## File: src/stores/comparison-store.ts
````typescript
/**
 * @fileoverview Zustand store for managing comparison items across search types.
 *
 * Replaces sessionStorage-based comparison lists with a centralized store that
 * supports cross-type comparisons, persistence, and computed derived state.
 */
⋮----
import type {
  Accommodation,
  Activity,
  Destination,
  FlightResult,
  SearchType,
} from "@schemas/search";
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { nowIso } from "@/lib/security/random";
import { withComputed } from "./middleware/computed";
⋮----
type ComparisonData<T extends SearchType> = T extends "flight"
  ? FlightResult
  : T extends "accommodation"
    ? Accommodation
    : T extends "activity"
      ? Activity
      : T extends "destination"
        ? Destination
        : unknown;
⋮----
/** Single item in the comparison list. */
export interface ComparisonItem<T extends SearchType = SearchType> {
  id: string;
  type: T;
  data: ComparisonData<T>;
  addedAt: string;
}
⋮----
/** Core state for comparison management. */
interface ComparisonState {
  items: ComparisonItem[];
  maxItems: number;

  // Actions
  addItem: <T extends SearchType>(
    type: T,
    id: string,
    data: ComparisonData<T> | Record<string, unknown>
  ) => boolean;
  removeItem: (id: string) => void;
  clearByType: (type: SearchType) => void;
  clearAll: () => void;
  hasItem: (id: string) => boolean;
  getItemsByType: (type: SearchType) => ComparisonItem[];
  reset: () => void;
}
⋮----
// Actions
⋮----
/** Computed derived state. */
interface ComputedState {
  itemCount: number;
  canAdd: boolean;
  itemsByTypeMap: Map<SearchType, ComparisonItem[]>;
  idsSet: Set<string>;
}
⋮----
// Check if already at max or item exists
⋮----
// Computed properties (initialized, will be overwritten by middleware)
⋮----
// Utility selectors
export const useComparisonItems = ()
⋮----
export const useComparisonItemCount = ()
⋮----
export const useCanAddComparison = ()
⋮----
export const useComparisonItemsByType = (type: SearchType)
⋮----
export const useHasComparisonItem = (id: string)
````

## File: src/stores/currency-store.ts
````typescript
/**
 * @fileoverview Currency store for managing currency data, exchange rates,
 * and currency conversion functionality using Zustand with persistence.
 */
⋮----
import {
  CONVERSION_RESULT_SCHEMA,
  type ConversionResult,
  CURRENCY_CODE_SCHEMA,
  CURRENCY_PAIR_SCHEMA,
  CURRENCY_SCHEMA,
  type Currency,
  type CurrencyCode,
  type CurrencyPair,
  type CurrencyState,
  EXCHANGE_RATE_SCHEMA,
  type ExchangeRate,
} from "@schemas/currency";
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
⋮----
// Common currencies with symbols and decimal places
// ISO 4217 defines currency codes in UPPER_CASE (international standard)
⋮----
/**
 * Interface for the currency store extending base currency state with actions.
 */
interface CurrencyStore extends CurrencyState {
  // Currency management
  /** Sets the base currency for conversions and rate calculations. */
  setBaseCurrency: (currency: CurrencyCode) => void;

  /** Adds a new currency to the store after validation. */
  addCurrency: (currency: unknown) => boolean;

  /** Removes a currency from the store and cleans up related data. */
  removeCurrency: (code: CurrencyCode) => void;

  // Exchange rate management
  /** Updates the exchange rate for a specific currency pair. */
  updateExchangeRate: (
    targetCurrency: CurrencyCode,
    rate: number,
    timestamp?: string
  ) => void;

  /** Updates multiple exchange rates at once. */
  updateAllExchangeRates: (rates: Record<string, number>, timestamp?: string) => void;

  // Favorites management
  /** Adds a currency to the favorites list. */
  addFavoriteCurrency: (code: CurrencyCode) => void;

  /** Removes a currency from the favorites list. */
  removeFavoriteCurrency: (code: CurrencyCode) => void;

  // Conversion utilities
  /** Converts an amount between two currencies. */
  convertAmount: (
    amount: number,
    fromCurrency: CurrencyCode,
    toCurrency: CurrencyCode
  ) => ConversionResult | null;

  // Additional features
  /** Gets recent currency pairs for quick access. */
  getRecentCurrencyPairs: () => CurrencyPair[];

  /** Gets the list of popular/favorite currencies. */
  getPopularCurrencies: () => Currency[];

  /** Retrieves currency information by code. */
  getCurrencyByCode: (code: string) => Currency | undefined;

  /** Formats an amount with appropriate currency symbol and locale. */
  formatAmountWithCurrency: (amount: number, currencyCode: string) => string;
}
⋮----
// Currency management
/** Sets the base currency for conversions and rate calculations. */
⋮----
/** Adds a new currency to the store after validation. */
⋮----
/** Removes a currency from the store and cleans up related data. */
⋮----
// Exchange rate management
/** Updates the exchange rate for a specific currency pair. */
⋮----
/** Updates multiple exchange rates at once. */
⋮----
// Favorites management
/** Adds a currency to the favorites list. */
⋮----
/** Removes a currency from the favorites list. */
⋮----
// Conversion utilities
/** Converts an amount between two currencies. */
⋮----
// Additional features
/** Gets recent currency pairs for quick access. */
⋮----
/** Gets the list of popular/favorite currencies. */
⋮----
/** Retrieves currency information by code. */
⋮----
/** Formats an amount with appropriate currency symbol and locale. */
⋮----
// Helper functions
const GET_CURRENT_TIMESTAMP = ()
⋮----
// Validate the currency code
const VALIDATE_CURRENCY_CODE = (code: unknown): code is CurrencyCode =>
⋮----
// Validate the currency object
// const validateCurrency = (currency: unknown): currency is Currency => {
//   return CurrencySchema.safeParse(currency).success;
// }; // Future validation
⋮----
/**
 * Zustand store hook for currency management with persistence.
 *
 * Provides comprehensive currency functionality including:
 * - Currency data management and validation
 * - Exchange rate handling and conversion calculations
 * - Favorite currencies management
 * - Formatted currency display
 *
 * @returns Currency store hook with state and actions
 */
⋮----
// Validate the currency against the schema
⋮----
// Favorites management
⋮----
// Validate the currency code
⋮----
// Conversion utilities
⋮----
// Validate inputs
⋮----
// Same currency, no conversion needed
⋮----
// Convert from base currency
⋮----
// Convert to base currency
⋮----
// Convert between two non-base currencies
⋮----
// Convert via the base currency
⋮----
// Initial state
⋮----
// Utility methods
⋮----
// Base currency to favorites
⋮----
// Validate the currency code
⋮----
// Don't remove the base currency
⋮----
// Create new state objects without the currency
⋮----
// Remove the currency from all state
⋮----
// Validate the currency code
⋮----
// Currency management
⋮----
// Validate the currency code
⋮----
// Don't update if the currency is already the base or doesn't exist
⋮----
// When changing base currency, we need to recalculate all exchange rates
⋮----
// Calculate new exchange rates relative to the new base currency
⋮----
if (currencyCode === currency) return; // Skip the new base currency
⋮----
// Create and validate the new exchange rate
⋮----
// Add the old base currency to the exchange rates
⋮----
// Skip if it's the base currency or invalid code
⋮----
// Create and validate the new exchange rate
⋮----
// Exchange rate management
⋮----
// Validate the currency code
⋮----
// Validate the rate
⋮----
if (targetCurrency === state.baseCurrency) return state; // Can't set exchange rate for base currency
⋮----
// Create and validate the new exchange rate
⋮----
// Only persist state that should be saved between sessions
⋮----
// Do not persist common currencies as they're defined in code
````

## File: src/stores/deals-store.ts
````typescript
/**
 * @fileoverview Zustand store for managing travel deals, alerts, and filters.
 */
⋮----
import {
  DEAL_ALERT_SCHEMA,
  DEAL_SCHEMA,
  type Deal,
  type DealAlert,
  type DealState,
  type DealStats,
  type DealType,
} from "@schemas/deals";
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { nowIso, secureId } from "@/lib/security/random";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import { createComputeFn, withComputed } from "@/stores/middleware/computed";
⋮----
interface DealsStore extends DealState {
  // Base state fields materialized on the store
  deals: Record<string, Deal>;
  featuredDeals: string[];
  savedDeals: string[];
  recentlyViewedDeals: string[];
  // Computed, derived state (kept in sync via withComputed middleware)
  featuredDealItems: Deal[];
  savedDealItems: Deal[];
  recentlyViewedDealItems: Deal[];
  alerts: DealAlert[];
  filters: DealState["filters"] | undefined;
  lastUpdated: string | null;
  isInitialized: boolean;
  // Deals management
  setDeals: (deals: Record<string, Deal>) => void;
  addDeal: (deal: unknown) => boolean;
  updateDeal: (id: string, updates: Partial<Deal>) => boolean;
  removeDeal: (id: string) => void;

  // Featured deals
  setFeaturedDeals: (dealIds: string[]) => void;
  addToFeaturedDeals: (dealId: string) => void;
  removeFromFeaturedDeals: (dealId: string) => void;

  // Deal alerts
  setAlerts: (alerts: DealAlert[]) => void;
  addAlert: (alert: unknown) => boolean;
  updateAlert: (id: string, updates: Partial<DealAlert>) => boolean;
  removeAlert: (id: string) => void;
  toggleAlertActive: (id: string) => void;

  // Saved deals
  setSavedDeals: (dealIds: string[]) => void;
  addToSavedDeals: (dealId: string) => void;
  removeFromSavedDeals: (dealId: string) => void;

  // Recently viewed deals
  addToRecentlyViewed: (dealId: string) => void;
  clearRecentlyViewed: () => void;

  // Filtering
  setFilters: (filters: DealState["filters"]) => void;
  clearFilters: () => void;

  // Computed properties & utilities
  getDealById: (id: string) => Deal | undefined;
  getAlertById: (id: string) => DealAlert | undefined;
  getFilteredDeals: () => Deal[];
  getFeaturedDeals: () => Deal[];
  getSavedDeals: () => Deal[];
  getRecentlyViewedDeals: () => Deal[];
  getDealsStats: () => DealStats;

  // State management
  initialize: () => void;
  reset: () => void;
}
⋮----
// Base state fields materialized on the store
⋮----
// Computed, derived state (kept in sync via withComputed middleware)
⋮----
// Deals management
⋮----
// Featured deals
⋮----
// Deal alerts
⋮----
// Saved deals
⋮----
// Recently viewed deals
⋮----
// Filtering
⋮----
// Computed properties & utilities
⋮----
// State management
⋮----
// Helper functions
const GENERATE_ID = ()
const GET_CURRENT_TIMESTAMP = ()
⋮----
// Calculate percentage discount
const CALCULATE_DISCOUNT_PERCENTAGE = (
  originalPrice: number,
  price: number
): number =>
⋮----
// Calculate deals statistics
const CALCULATE_DEALS_STATS = (deals: Deal[]): DealStats =>
⋮----
// Skip if no deals
⋮----
// biome-ignore lint/style/useNamingConvention: External API field names
⋮----
// biome-ignore lint/style/useNamingConvention: External API field names
⋮----
// Count by type
⋮----
// biome-ignore lint/style/useNamingConvention: External API field names
⋮----
// biome-ignore lint/style/useNamingConvention: External API field names
⋮----
// Count by destination
⋮----
// Calculate average savings and discount
⋮----
// Count by type
⋮----
// Count by destination
⋮----
// Calculate savings and discount
⋮----
// Calculate averages
⋮----
// Match deal against filters
const MATCH_DEAL_WITH_FILTERS = (
  deal: Deal,
  filters?: DealState["filters"]
): boolean =>
⋮----
// Match deal type
⋮----
// Match origin
⋮----
// Match destination
⋮----
// Match provider
⋮----
// Match minimum discount
⋮----
// Match maximum price
⋮----
// Match date range
⋮----
const pickDealsByIds = (state: DealsStore, dealIds: readonly string[]): Deal[] =>
⋮----
// Ensure deal has required timestamps
⋮----
// Recently viewed deals
⋮----
// Remove if already exists (to move to front)
⋮----
// Add to front and limit to 20 items
⋮----
// Initial state
⋮----
// Computed properties & utilities
⋮----
// State management
⋮----
// Remove from all collections
⋮----
// Deal alerts
⋮----
// Deals management
⋮----
// Featured deals
⋮----
// Filtering
⋮----
// Saved deals
⋮----
// Only persist certain parts of the state
⋮----
// Don't persist deals, as they may become outdated
// Don't persist filters, reset them on reload
````

## File: src/stores/helpers.ts
````typescript
/**
 * @fileoverview Shared helper functions for Zustand stores.
 * Centralizes common patterns to avoid duplication across stores.
 */
⋮----
import { nowIso, secureId } from "@/lib/security/random";
⋮----
/**
 * Generate cryptographically secure ID.
 * @param length Desired length of the ID (default 12)
 * @returns A secure identifier string
 */
export const generateId = (length = 12): string
⋮----
/**
 * Get current timestamp in ISO format.
 * @returns ISO timestamp string
 */
export const getCurrentTimestamp = (): string
⋮----
/**
 * Check if ISO timestamp is in the past (expired).
 * @param timestamp ISO timestamp string or null
 * @returns True if timestamp is null or in the past
 */
export const isExpired = (timestamp: string | null): boolean =>
⋮----
/**
 * Calculate milliseconds until timestamp.
 * @param timestamp ISO timestamp string or null
 * @returns Milliseconds until timestamp, or 0 if timestamp is null or in the past
 */
export const timeUntil = (timestamp: string | null): number =>
⋮----
/**
 * Create display name from user object.
 * @param user User object with displayName, firstName, lastName, and email
 * @returns Display name string
 */
export const getDisplayName = (
  user: {
    displayName?: string;
    firstName?: string;
    lastName?: string;
    email: string;
  } | null
): string =>
````

## File: src/stores/realtime-connection-store.ts
````typescript
/**
 * @fileoverview Global store for Supabase Realtime connection health.
 */
⋮----
import type { ConnectionStatus } from "@schemas/realtime";
import type { RealtimeChannel } from "@supabase/supabase-js";
import { create } from "zustand";
import { computeBackoffDelay, DEFAULT_BACKOFF_CONFIG } from "@/lib/realtime/backoff";
import { mapChannelStateToStatus } from "@/lib/realtime/status";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
⋮----
export interface RealtimeConnectionEntry {
  id: string;
  status: ConnectionStatus;
  lastActivity: Date | null;
  lastError: Error | null;
  lastErrorAt: Date | null;
  channel: RealtimeChannel | null;
}
⋮----
export interface RealtimeConnectionSummary {
  /** Number of connections currently in "connected" status. */
  connectedCount: number;
  /** Total number of tracked realtime connections. */
  totalCount: number;
  isConnected: boolean;
  /** Most recent error across connections (if any). */
  lastError: Error | null;
  /** Timestamp of the most recent error (if any). */
  lastErrorAt: Date | null;
  reconnectAttempts: number;
  lastReconnectAt: Date | null;
}
⋮----
/** Number of connections currently in "connected" status. */
⋮----
/** Total number of tracked realtime connections. */
⋮----
/** Most recent error across connections (if any). */
⋮----
/** Timestamp of the most recent error (if any). */
⋮----
interface RealtimeConnectionStore {
  connections: Record<string, RealtimeConnectionEntry>;
  reconnectAttempts: number;
  lastReconnectAt: Date | null;
  isReconnecting: boolean;
  registerChannel: (channel: RealtimeChannel) => void;
  updateStatus: (
    channelId: string,
    state: "idle" | "connecting" | "subscribed" | "error" | "closed",
    hasError: boolean,
    error?: Error | null
  ) => void;
  updateActivity: (channelId: string) => void;
  removeChannel: (channelId: string) => void;
  reconnectAll: () => Promise<void>;
  summary: () => RealtimeConnectionSummary;
}
⋮----
// ignore
````

## File: src/stores/search-filters-store.ts
````typescript
/**
 * @fileoverview Zustand store for managing search filters, sort options, and presets.
 */
⋮----
import type { SearchType } from "@schemas/search";
import {
  type ActiveFilter,
  type FilterPreset,
  type FilterValue,
  filterPresetSchema,
  filterValueSchema,
  searchTypeSchema,
  sortOptionSchema,
  type ValidatedFilterOption,
  type ValidatedSortOption,
} from "@schemas/stores";
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import { generateId, getCurrentTimestamp } from "./helpers";
import { createComputeFn, withComputed } from "./middleware/computed";
import {
  FILTER_CONFIGS,
  getDefaultSortOptions,
  SORT_CONFIGS,
} from "./search-filters/filter-configs";
⋮----
// Search filters store interface
interface SearchFiltersState {
  // Available filters and sort options by search type
  availableFilters: Record<SearchType, ValidatedFilterOption[]>;
  availableSortOptions: Record<SearchType, ValidatedSortOption[]>;

  // Active filters and sorting
  activeFilters: Record<string, ActiveFilter>;
  activeSortOption: ValidatedSortOption | null;
  currentSearchType: SearchType | null;

  // Filter presets
  filterPresets: FilterPreset[];
  activePreset: FilterPreset | null;

  // Filter state management
  isApplyingFilters: boolean;
  filterValidationErrors: Record<string, string>;

  // Computed properties
  hasActiveFilters: boolean;
  activeFilterCount: number;
  canClearFilters: boolean;
  currentFilters: ValidatedFilterOption[];
  currentSortOptions: ValidatedSortOption[];
  appliedFilterSummary: string;

  // Sort options configuration

  // Active filter management
  setActiveFilter: (filterId: string, value: FilterValue) => boolean;
  removeActiveFilter: (filterId: string) => void;
  updateActiveFilter: (filterId: string, value: FilterValue) => boolean;
  clearAllFilters: () => void;
  clearFiltersByCategory: (category: string) => void;

  // Bulk filter operations
  setMultipleFilters: (filters: Record<string, FilterValue>) => boolean;
  applyFiltersFromObject: (filterObject: Record<string, unknown>) => boolean;

  // Reset filters to default (optionally scoped by search type)
  resetFiltersToDefault: (searchType?: SearchType) => void;

  // Sort management
  setActiveSortOption: (option: ValidatedSortOption | null) => void;
  setSortById: (optionId: string) => void;
  toggleSortDirection: () => void;
  resetSortToDefault: (searchType?: SearchType) => void;

  // Filter presets
  saveFilterPreset: (name: string, description?: string) => string | null;
  loadFilterPreset: (presetId: string) => boolean;
  updateFilterPreset: (presetId: string, updates: Partial<FilterPreset>) => boolean;
  deleteFilterPreset: (presetId: string) => void;
  duplicateFilterPreset: (presetId: string, newName: string) => string | null;
  incrementPresetUsage: (presetId: string) => void;

  // Filter validation
  validateFilter: (filterId: string, value: FilterValue) => boolean;
  validateAllFilters: () => boolean;
  getFilterValidationError: (filterId: string) => string | null;

  // Search type context
  setSearchType: (searchType: SearchType) => void;

  // Utility actions
  clearValidationErrors: () => void;
  clearValidationError: (filterId: string) => void;
  reset: () => void;
  softReset: () => void; // Keeps configuration but clears active state
}
⋮----
// Available filters and sort options by search type
⋮----
// Active filters and sorting
⋮----
// Filter presets
⋮----
// Filter state management
⋮----
// Computed properties
⋮----
// Sort options configuration
⋮----
// Active filter management
⋮----
// Bulk filter operations
⋮----
// Reset filters to default (optionally scoped by search type)
⋮----
// Sort management
⋮----
// Filter presets
⋮----
// Filter validation
⋮----
// Search type context
⋮----
// Utility actions
⋮----
softReset: () => void; // Keeps configuration but clears active state
⋮----
/** Validate a range filter value against min/max constraints. */
const validateRangeValue = (
  value: FilterValue,
  config: ValidatedFilterOption
):
⋮----
// Helper to compute derived state using shared middleware
⋮----
/** Use the search filters store */
⋮----
// Active filters and sorting
⋮----
// Only apply if filter ID exists in current configuration
⋮----
// Validate the value can be a FilterValue
⋮----
// Initial state - use pre-computed config objects
⋮----
// Utility actions
⋮----
// Filter presets
⋮----
// Computed properties (initialized by middleware)
⋮----
// Filter state management
⋮----
// Convert preset filters back to active filters
⋮----
// Increment usage count
⋮----
activePreset: null, // Clear active preset when filters change
⋮----
// Filter presets
⋮----
// Active filter management
⋮----
activePreset: null, // Clear active preset when filters change manually
⋮----
// Sort management
⋮----
activePreset: null, // Clear active preset when sort changes
⋮----
// Bulk filter operations
⋮----
// Search type context
⋮----
activePreset: null, // Clear preset when changing search type
⋮----
// Filter validation
⋮----
const setError = (error: string) =>
⋮----
const clearError = () =>
⋮----
// Zod schema validation first
⋮----
// Type-specific validation
⋮----
// Handle range type filters using helper
⋮----
// Persist filter presets and available configurations
⋮----
// Utility selectors for common use cases
export const useActiveFilters = ()
export const useActiveSortOption = ()
export const useCurrentFilters = ()
export const useCurrentSortOptions = ()
export const useHasActiveFilters = ()
export const useActiveFilterCount = ()
export const useFilterPresets = (searchType?: SearchType)
export const useFilterValidationErrors = ()
export const useIsApplyingFilters = ()
````

## File: src/stores/search-params-store.ts
````typescript
/**
 * @fileoverview Search parameters store.
 */
⋮----
import type {
  ActivitySearchParams,
  FlightSearchParams,
  SearchAccommodationParams,
  SearchParams,
} from "@schemas/search";
import {
  accommodationSearchParamsStoreSchema,
  activitySearchParamsStoreSchema,
  destinationSearchParamsStoreSchema,
  flightSearchParamsStoreSchema,
  type SearchType,
  searchTypeSchema,
  type ValidatedAccommodationParams,
  type ValidatedActivityParams,
  type ValidatedDestinationParams,
  type ValidatedFlightParams,
} from "@schemas/stores";
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { createStoreLogger } from "@/lib/telemetry/store-logger";
import { registerAllHandlers } from "./search-params/handlers";
import { getHandler } from "./search-params/registry";
⋮----
// Ensure handlers are registered deterministically at startup
⋮----
/** Schema registry for parameter validation by search type */
⋮----
/** Keys for params in state by search type */
⋮----
// Search parameters store interface
interface SearchParamsState {
  // Current search context
  currentSearchType: SearchType | null;

  // Search parameters for each type
  flightParams: Partial<ValidatedFlightParams>;
  accommodationParams: Partial<ValidatedAccommodationParams>;
  activityParams: Partial<ValidatedActivityParams>;
  destinationParams: Partial<ValidatedDestinationParams>;

  // Validation states
  isValidating: Record<SearchType, boolean>;
  validationErrors: Record<SearchType, string | null>;

  // Computed properties
  currentParams: SearchParams | null;
  hasValidParams: boolean;
  isDirty: boolean;

  // Parameter management actions
  setSearchType: (type: SearchType) => void;
  updateParams: (type: SearchType, params: Partial<SearchParams>) => Promise<boolean>;
  updateFlightParams: (params: Partial<ValidatedFlightParams>) => Promise<boolean>;
  updateAccommodationParams: (
    params: Partial<ValidatedAccommodationParams>
  ) => Promise<boolean>;
  updateActivityParams: (params: Partial<ValidatedActivityParams>) => Promise<boolean>;
  updateDestinationParams: (
    params: Partial<ValidatedDestinationParams>
  ) => Promise<boolean>;

  // Bulk operations
  setFlightParams: (params: Partial<ValidatedFlightParams>) => void;
  setAccommodationParams: (params: Partial<ValidatedAccommodationParams>) => void;
  setActivityParams: (params: Partial<ValidatedActivityParams>) => void;
  setDestinationParams: (params: Partial<ValidatedDestinationParams>) => void;

  // Reset and validation
  resetParams: (type?: SearchType) => void;
  resetCurrentParams: () => void;
  validateParams: (type: SearchType) => Promise<boolean>;
  validateCurrentParams: () => Promise<boolean>;

  // Template and presets
  loadParamsFromTemplate: (
    template: SearchParams,
    type: SearchType
  ) => Promise<boolean>;
  createParamsTemplate: () => SearchParams | null;

  // Utility actions
  clearValidationErrors: () => void;
  clearValidationError: (type: SearchType) => void;
  markClean: () => void;
  reset: () => void;
}
⋮----
// Current search context
⋮----
// Search parameters for each type
⋮----
// Validation states
⋮----
// Computed properties
⋮----
// Parameter management actions
⋮----
// Bulk operations
⋮----
// Reset and validation
⋮----
// Template and presets
⋮----
// Utility actions
⋮----
/** Get default parameters for a search type using the handler. */
const getDefaultParams = (type: SearchType): Partial<SearchParams> =>
⋮----
/** Validate search parameters using the handler. */
const validateSearchParams = (
  params: Partial<SearchParams>,
  type: SearchType
): boolean =>
⋮----
/** Check if required parameters are present using the handler. */
const hasRequiredParams = (
  params: Partial<SearchParams>,
  type: SearchType
): boolean =>
⋮----
/** Get current params for a search type from state. */
const getParamsForType = (
  state: {
    flightParams: Partial<ValidatedFlightParams>;
    accommodationParams: Partial<ValidatedAccommodationParams>;
    activityParams: Partial<ValidatedActivityParams>;
    destinationParams: Partial<ValidatedDestinationParams>;
  },
  type: SearchType
): Partial<SearchParams> =>
⋮----
/** Compute derived current params and validity for the given state snapshot. */
const computeDerivedState = (
  state: Pick<
    SearchParamsState,
    | "accommodationParams"
    | "activityParams"
    | "currentSearchType"
    | "destinationParams"
    | "flightParams"
  >
): Pick<SearchParamsState, "currentParams" | "hasValidParams"> =>
⋮----
/** Create a search params store instance. */
⋮----
/** Clear a specific validation error. */
⋮----
/** Clear all validation errors. */
⋮----
/** Create a template of current params for a search type. */
⋮----
// Initial state
⋮----
get isDirty()
⋮----
/** Validation states. */
⋮----
/** Load params from a template for a search type. */
⋮----
// This getter will automatically update the isDirty computed property
⋮----
// Reset and validation
⋮----
/** Set activity parameters using the handler. */
⋮----
/** Set destination parameters using the handler. */
⋮----
/** Set flight parameters using the handler. */
⋮----
/** Set search type and initialize default parameters. */
⋮----
// Initialize default parameters if not set yet
⋮----
/** Type-safe accommodation params update. */
⋮----
/** Type-safe activity params update. */
⋮----
/** Type-safe destination params update. */
⋮----
/** Type-safe flight params update. */
⋮----
/** Generic parameter update with validation. */
⋮----
/** Validate current parameters using the handler. */
⋮----
/** Validate parameters using the handler. */
⋮----
// Only persist parameters, not validation states
⋮----
// Utility selectors for common use cases
export const useSearchType = ()
export const useCurrentSearchParams = ()
export const useFlightParams = ()
export const useAccommodationParams = ()
export const useActivityParams = ()
export const useDestinationParams = ()
export const useSearchParamsValidation = ()
⋮----
/**
 * Compute the current parameters based on the store state snapshot.
 *
 * @param state - The search params store state snapshot.
 * @returns The params object for the current search type, or null.
 */
export const selectCurrentParamsFrom = (
  state: SearchParamsState
): SearchParams | null =>
````

## File: src/stores/search-results-store.ts
````typescript
/**
 * @fileoverview Zustand store for managing search results, pagination, and performance metrics.
 */
⋮----
import type { SearchResults, SearchType } from "@schemas/search";
import type {
  ErrorDetails,
  SearchContext,
  SearchMetrics,
  SearchStatus,
} from "@schemas/stores";
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";
import { nowIso, secureId } from "@/lib/security/random";
import { createComputeFn, withComputed } from "./middleware/computed";
⋮----
// Schemas imported from @schemas/stores
⋮----
// Search results store interface
interface SearchResultsState {
  // Current search state
  status: SearchStatus;
  currentSearchId: string | null;
  currentSearchType: SearchType | null;

  // Results data
  results: SearchResults;
  resultsBySearch: Record<string, SearchResults>;

  // Search context and metadata
  searchHistory: SearchContext[];
  currentContext: SearchContext | null;

  // Error handling
  error: ErrorDetails | null;
  errorHistory: Array<ErrorDetails & { searchId: string }>;

  // Loading and progress
  isSearching: boolean;
  searchProgress: number; // 0-100

  // Pagination and performance
  pagination: {
    currentPage: number;
    totalPages: number;
    resultsPerPage: number;
    totalResults: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
  };

  // Performance tracking
  metrics: SearchMetrics | null;
  performanceHistory: Array<SearchMetrics & { searchId: string }>;

  // Computed properties
  hasResults: boolean;
  isEmptyResults: boolean;
  canRetry: boolean;
  searchDuration: number | null;

  // Search execution actions
  startSearch: (searchType: SearchType, params: Record<string, unknown>) => string;
  updateSearchProgress: (searchId: string, progress: number) => void;
  setSearchResults: (
    searchId: string,
    results: SearchResults,
    metrics?: SearchMetrics
  ) => void;
  setSearchError: (searchId: string, error: ErrorDetails) => void;
  cancelSearch: (searchId?: string) => void;
  completeSearch: (searchId: string) => void;

  // Results management
  clearResults: (searchType?: SearchType) => void;
  clearAllResults: () => void;
  appendResults: (searchId: string, newResults: SearchResults) => void;

  // Pagination actions
  setPage: (page: number) => void;
  nextPage: () => void;
  previousPage: () => void;
  setResultsPerPage: (perPage: number) => void;

  // Search history management
  getSearchById: (searchId: string) => SearchContext | null;
  getResultsById: (searchId: string) => SearchResults | null;
  getRecentSearches: (searchType?: SearchType, limit?: number) => SearchContext[];
  clearSearchHistory: () => void;
  removeSearchFromHistory: (searchId: string) => void;

  // Error management
  retryLastSearch: () => Promise<string | null>;
  clearError: () => void;
  clearErrorHistory: () => void;

  // Performance monitoring
  getAverageSearchDuration: (searchType?: SearchType) => number;
  getSearchSuccessRate: (searchType?: SearchType) => number;
  getPerformanceInsights: () => {
    averageDuration: number;
    successRate: number;
    totalSearches: number;
    errorRate: number;
  };

  // Utility actions
  reset: () => void;
  softReset: () => void; // Keeps history but clears current state
}
⋮----
// Current search state
⋮----
// Results data
⋮----
// Search context and metadata
⋮----
// Error handling
⋮----
// Loading and progress
⋮----
searchProgress: number; // 0-100
⋮----
// Pagination and performance
⋮----
// Performance tracking
⋮----
// Computed properties
⋮----
// Search execution actions
⋮----
// Results management
⋮----
// Pagination actions
⋮----
// Search history management
⋮----
// Error management
⋮----
// Performance monitoring
⋮----
// Utility actions
⋮----
softReset: () => void; // Keeps history but clears current state
⋮----
// Helper functions
const GENERATE_SEARCH_ID = () => `search_$
const GET_CURRENT_TIMESTAMP = ()
⋮----
// Helper to check if there are any results
const getHasResults = (state: SearchResultsState): boolean
⋮----
// Helper to compute derived state
⋮----
// Default states
⋮----
// Results management
⋮----
// Map singular search type to plural result key
⋮----
// Error handling
⋮----
// Performance monitoring
⋮----
// Search history management
⋮----
// Count searches that completed without error
⋮----
// Computed properties
⋮----
// Loading and progress
⋮----
// Performance tracking
⋮----
// Pagination
⋮----
// Utility actions
⋮----
// Results data
⋮----
// Error management
⋮----
// Start a new search with the same parameters
⋮----
// Search context and metadata
⋮----
// Pagination actions
⋮----
// Mark search as completed (with error) in history
⋮----
].slice(-20), // Keep last 20 errors
⋮----
// Calculate pagination based on results
⋮----
].slice(-50), // Keep last 50 searches
⋮----
// Search execution actions
⋮----
results: {}, // Clear previous results
⋮----
// Initial state
⋮----
performanceHistory: state.performanceHistory.slice(-30), // Keep last 30 performance records
⋮----
Object.entries(state.resultsBySearch).slice(-10) // Keep last 10 result sets
⋮----
// Persist search history and cached results, but not current search state
searchHistory: state.searchHistory.slice(-20), // Keep last 20 searches
⋮----
// Utility selectors for common use cases
export const useSearchStatus = ()
export const useSearchResults = ()
export const useIsSearching = ()
export const useSearchProgress = ()
export const useSearchError = ()
export const useSearchPagination = ()
export const useSearchMetrics = ()
export const useSearchHistory = (searchType?: SearchType, limit?: number)
export const useHasSearchResults = ()
export const useCanRetrySearch = ()
````

## File: src/stores/trip-itinerary-store.ts
````typescript
/**
 * @fileoverview Zustand store for trip itinerary (destinations) state.
 *
 * Trip core fields are owned by the backend and accessed via React Query (`use-trips`).
 * This store only persists client-side itinerary/destination planning data keyed by trip id.
 */
⋮----
import type { TripDestination } from "@schemas/trips";
import { create } from "zustand";
import { persist } from "zustand/middleware";
⋮----
type PersistedTripStoreV0 = {
  currentTrip?: { id?: string; destinations?: TripDestination[] } | null;
  trips?: Array<{ id?: string; destinations?: TripDestination[] }>;
};
⋮----
interface TripItineraryState {
  destinationsByTripId: Record<string, TripDestination[]>;

  setDestinations: (tripId: string, destinations: TripDestination[]) => void;
  addDestination: (tripId: string, destination: TripDestination) => void;
  updateDestination: (
    tripId: string,
    destinationId: string,
    update: Partial<TripDestination>
  ) => void;
  removeDestination: (tripId: string, destinationId: string) => void;
  clearTripItinerary: (tripId: string) => void;
}
⋮----
const collect = (tripId?: string, destinations?: TripDestination[]) =>
⋮----
/**
       * Use the legacy key name to preserve previously persisted trip itinerary
       * state from the former `trip-store` implementation.
       */
````

## File: src/test/ai-sdk/mock-model.ts
````typescript
/**
 * @fileoverview AI SDK test utilities using official MockLanguageModelV3.
 *
 * Provides utilities for testing AI SDK v6 flows with accurate model behavior.
 * Uses official MockLanguageModelV3 from ai/test and simulateReadableStream from ai.
 *
 * @example
 * ```typescript
 * import { createMockModel, createStreamingMockModel } from '@/test/ai-sdk/mock-model';
 * import { generateText, streamText } from 'ai';
 *
 * test('generates text', async () => {
 *   const model = createMockModel({ text: 'Hello from AI!' });
 *   const result = await generateText({ model, prompt: 'Say hello' });
 *   expect(result.text).toBe('Hello from AI!');
 * });
 *
 * test('streams text', async () => {
 *   const model = createStreamingMockModel({ chunks: ['Hello', ' World'] });
 *   const result = streamText({ model, prompt: 'Say hello' });
 *   let text = '';
 *   for await (const chunk of result.textStream) { text += chunk; }
 *   expect(text).toBe('Hello World');
 * });
 * ```
 */
⋮----
import { simulateReadableStream } from "ai";
import { MockLanguageModelV3 } from "ai/test";
⋮----
type FinishReason =
  | "stop"
  | "length"
  | "content-filter"
  | "tool-calls"
  | "error"
  | "other"
  | "unknown";
⋮----
/**
 * Input token count structure for AI SDK v6 beta.148+.
 * Supports cache-aware token tracking.
 */
type InputTokenCount = {
  total: number | undefined;
  noCache: number | undefined;
  cacheRead: number | undefined;
  cacheWrite: number | undefined;
};
⋮----
/**
 * Output token count structure for AI SDK v6 beta.148+.
 * Supports text and reasoning token breakdown.
 */
type OutputTokenCount = {
  total: number | undefined;
  text: number | undefined;
  reasoning: number | undefined;
};
⋮----
/**
 * Usage structure matching LanguageModelV3Usage in AI SDK v6 beta.148+.
 */
type UsageLike = {
  inputTokens: InputTokenCount;
  outputTokens: OutputTokenCount;
  totalTokens: InputTokenCount;
};
⋮----
/**
 * Creates a usage object compatible with LanguageModelV3Usage.
 */
function createUsage(input: number, output: number): UsageLike
⋮----
/**
 * Options for creating a mock language model.
 */
export interface MockModelOptions {
  /** Text content to return */
  text?: string;
  /** Finish reason (default: 'stop') */
  finishReason?: FinishReason;
  /** Token usage (default: {input: 10, output: 20}) */
  usage?: {
    inputTokens?: number;
    outputTokens?: number;
  };
  /** Warnings to include */
  warnings?: Array<{ type: string; message: string }>;
}
⋮----
/** Text content to return */
⋮----
/** Finish reason (default: 'stop') */
⋮----
/** Token usage (default: {input: 10, output: 20}) */
⋮----
/** Warnings to include */
⋮----
/**
 * Creates a mock language model using AI SDK's official MockLanguageModelV3.
 *
 * This provides accurate simulation of AI SDK behavior for testing.
 *
 * @param options Configuration for the mock model
 * @returns Configured mock model instance
 *
 * @example
 * ```typescript
 * const model = createMockModel({
 *   text: 'Paris is the capital of France',
 *   usage: { inputTokens: 15, outputTokens: 8 },
 * });
 * ```
 */
export function createMockModel(options: MockModelOptions =
⋮----
/**
 * Creates a mock language model that supports tool calls.
 *
 * @param options Configuration including tool calls to return
 * @returns Configured mock model with tool support
 *
 * @example
 * ```typescript
 * const model = createMockToolModel({
 *   toolCalls: [
 *     {
 *       toolCallId: 'call-1',
 *       toolName: 'get_weather',
 *       args: { location: 'Paris' },
 *     },
 *   ],
 * });
 * ```
 */
export function createMockToolModel(
  options: {
    toolCalls?: Array<{
      toolCallId: string;
      toolName: string;
      args: unknown;
    }>;
    text?: string;
  } = {}
)
⋮----
// biome-ignore lint/suspicious/noExplicitAny: MockLanguageModelV3 requires complex types that are difficult to infer correctly
⋮----
/**
 * Options for creating a streaming mock model.
 */
export interface StreamingMockModelOptions {
  /** Text chunks to stream */
  chunks: string[];
  /** Finish reason (default: 'stop') */
  finishReason?: FinishReason;
  /** Token usage (default: {inputTokens: 10, outputTokens: 20}) */
  usage?: {
    inputTokens?: number;
    outputTokens?: number;
    totalTokens?: number;
  };
}
⋮----
/** Text chunks to stream */
⋮----
/** Finish reason (default: 'stop') */
⋮----
/** Token usage (default: {inputTokens: 10, outputTokens: 20}) */
⋮----
/**
 * Creates a streaming mock model using AI SDK's simulateReadableStream.
 *
 * Use this for testing streamText flows with deterministic streaming behavior.
 *
 * @param options Configuration for the streaming mock
 * @returns Configured streaming mock model
 *
 * @example
 * ```typescript
 * const model = createStreamingMockModel({
 *   chunks: ['Hello', ', ', 'World', '!'],
 * });
 *
 * const result = streamText({ model, prompt: 'Greet me' });
 * let text = '';
 * for await (const chunk of result.textStream) {
 *   text += chunk;
 * }
 * expect(text).toBe('Hello, World!');
 * ```
 */
export function createStreamingMockModel(options: StreamingMockModelOptions)
⋮----
/**
 * Options for creating a streaming tool mock model.
 */
export interface StreamingToolMockModelOptions {
  /** Tool calls to include in the stream */
  toolCalls: Array<{
    toolCallId: string;
    toolName: string;
    args: unknown;
  }>;
  /** Optional text to include before tool calls */
  textBefore?: string;
  /** Optional text to include after tool results */
  textAfter?: string;
  /** Optional finish reason for stream completion */
  finishReason?: FinishReason | null;
  /** Optional token usage to surface */
  usage?: {
    completionTokens?: number;
    promptTokens?: number;
    totalTokens?: number;
  };
}
⋮----
/** Tool calls to include in the stream */
⋮----
/** Optional text to include before tool calls */
⋮----
/** Optional text to include after tool results */
⋮----
/** Optional finish reason for stream completion */
⋮----
/** Optional token usage to surface */
⋮----
/**
 * Creates a streaming mock model with tool calls.
 *
 * Use for testing streaming agents that make tool calls.
 * Uses AI SDK v6 stream part types (tool-input-start, tool-input-delta, tool-input-end).
 *
 * @param options Configuration for tool calls
 * @returns Configured streaming mock model with tool support
 *
 * @example
 * ```typescript
 * const model = createStreamingToolMockModel({
 *   toolCalls: [{
 *     toolCallId: 'call-1',
 *     toolName: 'searchFlights',
 *     args: { origin: 'NYC', destination: 'LAX' },
 *   }],
 * });
 * ```
 */
export function createStreamingToolMockModel(options: StreamingToolMockModelOptions)
⋮----
// Build stream chunks using AI SDK v6 LanguageModelV3StreamPart types
// Tool calls use tool-input-* types in v6 with `delta` field
type StreamChunk =
    | { type: "text-start"; id: string }
    | { type: "text-delta"; id: string; delta: string }
    | { type: "text-end"; id: string }
    | { type: "tool-input-start"; id: string; toolName: string }
    | { type: "tool-input-delta"; id: string; delta: string }
    | { type: "tool-input-end"; id: string }
    | {
        type: "finish";
        finishReason: "tool-calls" | "stop";
        logprobs: undefined;
        usage: UsageLike;
      };
⋮----
// Add text before if present
⋮----
// Add tool calls using v6 tool-input-* types
⋮----
// Add text after if present
⋮----
// Add finish
⋮----
// biome-ignore lint/suspicious/noExplicitAny: MockLanguageModelV3 stream types vary across AI SDK betas
⋮----
/**
 * Creates a mock model that returns structured JSON for generateObject tests.
 *
 * @param jsonObject The object to return as stringified JSON text
 * @returns Mock model configured for structured output
 *
 * @example
 * ```typescript
 * const model = createMockObjectModel({
 *   classification: 'flightSearch',
 *   confidence: 0.95,
 * });
 *
 * const result = await generateObject({
 *   model,
 *   schema: mySchema,
 *   prompt: 'Classify this',
 * });
 * expect(result.object.classification).toBe('flightSearch');
 * ```
 */
export function createMockObjectModel<T>(jsonObject: T)
⋮----
/**
 * Creates a streaming mock model for streamObject tests.
 *
 * Streams the JSON object incrementally for partial object testing.
 *
 * @param jsonObject The object to stream as JSON
 * @returns Mock model configured for streaming structured output
 *
 * @example
 * ```typescript
 * const model = createStreamingObjectMockModel({
 *   name: 'Paris',
 *   country: 'France',
 * });
 *
 * const { partialObjectStream } = streamObject({
 *   model,
 *   schema: destinationSchema,
 *   prompt: 'Describe Paris',
 * });
 *
 * for await (const partial of partialObjectStream) {
 *   console.log(partial);
 * }
 * ```
 */
export function createStreamingObjectMockModel<T>(jsonObject: T)
⋮----
// Split JSON into smaller chunks for realistic streaming
⋮----
/** Re-export simulateReadableStream for direct use in tests */
````

## File: src/test/ai-sdk/stream-utils.ts
````typescript
/**
 * @fileoverview Stream testing utilities for AI SDK v6.
 *
 * Provides utilities for testing streaming AI responses and UI message streams.
 * Complements mock-model.ts for higher-level stream testing scenarios.
 *
 * @example
 * ```typescript
 * import { createMockStreamResponse, collectStreamChunks } from '@/test/ai-sdk/stream-utils';
 *
 * test('handles streaming response', async () => {
 *   const stream = createMockStreamResponse({
 *     chunks: ['Hello', ' ', 'World'],
 *   });
 *   const result = await collectStreamChunks(stream);
 *   expect(result).toBe('Hello World');
 * });
 * ```
 */
⋮----
/**
 * Options for creating a mock streaming response.
 */
export interface MockStreamOptions {
  /** Chunks to stream */
  chunks: string[];
  /** Initial delay before first chunk (ms) */
  initialDelayMs?: number;
  /** Delay between chunks (ms) */
  chunkDelayMs?: number;
}
⋮----
/** Chunks to stream */
⋮----
/** Initial delay before first chunk (ms) */
⋮----
/** Delay between chunks (ms) */
⋮----
/**
 * Creates a mock ReadableStream for testing streaming responses.
 *
 * This simulates AI SDK's streaming behavior for testing UI components
 * that consume streaming text.
 *
 * @param options Configuration for the stream
 * @returns ReadableStream that emits configured chunks
 *
 * @example
 * ```typescript
 * const stream = createMockStreamResponse({
 *   chunks: ['First', ' chunk', ' last'],
 *   chunkDelayMs: 50,
 * });
 * ```
 */
export function createMockStreamResponse(
  options: MockStreamOptions
): ReadableStream<string>
⋮----
async start(controller)
⋮----
// Initial delay
⋮----
// Enqueue chunks
⋮----
// Delay between chunks
⋮----
/**
 * Creates a mock AI SDK streaming response with proper SSE formatting.
 *
 * This simulates the actual format returned by AI SDK's streaming endpoints.
 *
 * @param options Stream configuration
 * @returns ReadableStream in AI SDK streaming format
 *
 * @example
 * ```typescript
 * const stream = createMockAiStreamResponse({
 *   textChunks: ['Hello', ' ', 'World'],
 * });
 * ```
 */
export function createMockAiStreamResponse(options: {
  textChunks: string[];
  messageId?: string;
}): ReadableStream<string>
⋮----
const encode = (payload: unknown) => `data: $
⋮----
async function readAllChunks(stream: ReadableStream<string>): Promise<string[]>
⋮----
// ignore cancellation errors to surface original error
⋮----
/**
 * Collects all chunks from a ReadableStream into a single string.
 *
 * Utility for asserting on complete stream output in tests.
 *
 * @param stream The stream to collect
 * @returns Promise resolving to concatenated string
 *
 * @example
 * ```typescript
 * const stream = createMockStreamResponse({ chunks: ['a', 'b', 'c'] });
 * const result = await collectStreamChunks(stream);
 * expect(result).toBe('abc');
 * ```
 */
export async function collectStreamChunks(
  stream: ReadableStream<string>
): Promise<string>
⋮----
/**
 * Collects stream chunks as an array.
 *
 * Use when you need to inspect individual chunks.
 *
 * @param stream The stream to collect
 * @returns Promise resolving to array of chunks
 */
export async function collectStreamChunksArray(
  stream: ReadableStream<string>
): Promise<string[]>
⋮----
/**
 * Creates a mock UI message stream response for testing route handlers.
 *
 * Simulates the format returned by toUIMessageStreamResponse().
 *
 * @param options Configuration for the stream
 * @returns Response object with streaming body
 *
 * @example
 * ```typescript
 * const response = createMockUiMessageStreamResponse({
 *   textChunks: ['Hello', ' World'],
 *   finishReason: 'stop',
 * });
 * ```
 */
export function createMockUiMessageStreamResponse(options: {
  textChunks: string[];
  messageId?: string;
  finishReason?: "stop" | "length" | "tool-calls" | "error";
  toolCalls?: Array<{
    toolCallId: string;
    toolName: string;
    args: unknown;
  }>;
}): Response
⋮----
// Start event
⋮----
// Text content
⋮----
// Tool calls
⋮----
// Build events as objects and stringify once to ensure proper JSON encoding
⋮----
// Finish event
⋮----
// biome-ignore lint/style/useNamingConvention: HTTP header name
⋮----
/**
 * Creates a mock error response for testing error handling.
 *
 * @param error Error message or object
 * @param status HTTP status code (default: 500)
 * @returns Response with error body
 */
export function createMockErrorResponse(
  error: string | { message: string; code?: string },
  status = 500
): Response
````

## File: src/test/factories/api-response-factory.ts
````typescript
/**
 * @fileoverview Factory for creating API response mocks for testing.
 */
⋮----
/**
 * Generic API response structure.
 */
export interface ApiResponse<T = unknown> {
  data: T;
  message?: string;
  status: number;
  success: boolean;
}
⋮----
/**
 * Paginated API response structure.
 */
export interface PaginatedResponse<T = unknown> {
  data: T[];
  hasMore: boolean;
  page: number;
  pageSize: number;
  total: number;
  totalPages: number;
}
⋮----
/**
 * API error response structure.
 */
export interface ApiErrorResponse {
  error: string;
  message: string;
  status: number;
  success: false;
  details?: Record<string, unknown>;
}
⋮----
/**
 * Options for creating a mock API response.
 */
export interface ApiResponseOptions<T> {
  data?: T;
  message?: string;
  status?: number;
  success?: boolean;
}
⋮----
/**
 * Creates a mock successful API response.
 *
 * @param options - Response options
 * @returns Mock API response
 */
export function createMockApiResponse<T = unknown>(
  options: ApiResponseOptions<T> = {}
): ApiResponse<T>
⋮----
/**
 * Creates a mock API error response.
 *
 * @param options - Error response options
 * @returns Mock API error response
 */
export function createMockApiError(
  options: {
    error?: string;
    message?: string;
    status?: number;
    details?: Record<string, unknown>;
  } = {}
): ApiErrorResponse
⋮----
/**
 * Options for creating a paginated response.
 */
export interface PaginatedResponseOptions<T> {
  data?: T[];
  hasMore?: boolean;
  page?: number;
  pageSize?: number;
  total?: number;
}
⋮----
/**
 * Creates a mock paginated API response.
 *
 * @param options - Pagination options
 * @returns Mock paginated response
 */
export function createMockPaginatedResponse<T = unknown>(
  options: PaginatedResponseOptions<T> = {}
): PaginatedResponse<T>
⋮----
/**
 * Create mock Response object for testing.
 *
 * @param data - Response data
 * @param status - HTTP status code (default: 200)
 * @returns Mock Response object
 */
export function createMockResponse<T>(data: T, status = 200): Response
````

## File: src/test/factories/auth-user-factory.ts
````typescript
/**
 * @fileoverview Factory for creating AuthUser test data.
 */
⋮----
import type { AuthUser } from "@schemas/stores";
⋮----
export interface AuthUserOverrides {
  id?: string;
  email?: string;
  displayName?: string;
  firstName?: string;
  lastName?: string;
  createdAt?: string;
  updatedAt?: string;
  isEmailVerified?: boolean;
  preferences?: AuthUser["preferences"];
}
⋮----
/**
 * Creates a mock AuthUser with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete AuthUser object
 */
export const createAuthUser = (overrides: AuthUserOverrides =
⋮----
/**
 * Creates multiple AuthUsers at once.
 *
 * @param count - Number of users to create
 * @param overridesFn - Optional function to customize each user (receives index)
 * @returns Array of AuthUser objects
 */
export const createAuthUsers = (
  count: number,
  overridesFn?: (index: number) => AuthUserOverrides
): AuthUser[] =>
⋮----
/**
 * Resets the auth user ID counter for deterministic test data.
 * Call this in beforeEach() if you need consistent IDs across test runs.
 */
export const resetAuthUserFactory = (): void =>
````

## File: src/test/factories/calendar-factory.ts
````typescript
/**
 * @fileoverview Calendar test data factories.
 */
⋮----
import type { CalendarEvent } from "@schemas/calendar";
import { calendarEventSchema } from "@schemas/calendar";
⋮----
export const createCalendarEvent = (
  overrides: Partial<CalendarEvent> = {}
): CalendarEvent =>
⋮----
export const resetCalendarFactory = () =>
````

## File: src/test/factories/chat-factory.ts
````typescript
/**
 * @fileoverview Factory for creating ChatSession and Message test data.
 */
⋮----
import type { ChatSession, Message } from "@schemas/chat";
⋮----
/**
 * Create mock chat session.
 *
 * @param overrides - Partial session to override defaults
 * @returns A complete chat session
 */
export function createMockSession(overrides: Partial<ChatSession> =
⋮----
/**
 * Create mock message.
 *
 * @param overrides - Partial message to override defaults
 * @returns A complete message
 */
export function createMockMessage(overrides: Partial<Message> =
````

## File: src/test/factories/filter-factory.ts
````typescript
/**
 * @fileoverview Factory for creating Filter and Sort test data.
 */
⋮----
export interface FilterOption {
  id: string;
  category: string;
  label: string;
  value: string | number | boolean;
  enabled?: boolean;
}
⋮----
export interface SortOption {
  id: string;
  field: string;
  direction: "asc" | "desc";
  label?: string;
}
⋮----
export interface FilterPreset {
  id: string;
  name: string;
  filters: FilterOption[];
  sortOptions?: SortOption[];
  createdAt?: string;
}
⋮----
/**
 * Creates a mock FilterOption with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete FilterOption object
 */
export const createFilter = (overrides: Partial<FilterOption> =
⋮----
/**
 * Creates a mock SortOption with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete SortOption object
 */
export const createSortOption = (overrides: Partial<SortOption> =
⋮----
/**
 * Creates a mock FilterPreset with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete FilterPreset object
 */
export const createFilterPreset = (
  overrides: Partial<FilterPreset> = {}
): FilterPreset =>
⋮----
/**
 * Creates multiple filters at once.
 *
 * @param count - Number of filters to create
 * @param overridesFn - Optional function to customize each filter (receives index)
 * @returns Array of FilterOption objects
 */
export const createFilters = (
  count: number,
  overridesFn?: (index: number) => Partial<FilterOption>
): FilterOption[] =>
⋮----
/**
 * Creates a preset with common price filters.
 *
 * @returns A FilterPreset configured for price filtering
 */
export const createPriceFilterPreset = (): FilterPreset =>
⋮----
/**
 * Creates a preset with common rating filters.
 *
 * @returns A FilterPreset configured for rating filtering
 */
export const createRatingFilterPreset = (): FilterPreset =>
⋮----
/**
 * Resets all filter-related ID counters for deterministic test data.
 */
export const resetFilterFactory = (): void =>
````

## File: src/test/factories/form-data-factory.ts
````typescript
/**
 * @fileoverview Factory for creating FormData and File mocks for testing.
 */
⋮----
/**
 * Options for creating a mock File.
 */
export interface FileOptions {
  content?: string | Blob;
  lastModified?: number;
  name?: string;
  size?: number;
  type?: string;
}
⋮----
/**
 * Options for creating a mock ImageFile.
 */
export interface ImageFileOptions extends FileOptions {
  height?: number;
  width?: number;
}
⋮----
/**
 * Options for creating FormData.
 */
export interface FormDataOptions {
  entries?: Array<[string, string | File]>;
}
⋮----
/**
 * Validation error structure.
 */
export interface FormValidationError {
  field: string;
  message: string;
  code?: string;
}
⋮----
/**
 * Creates a mock File object.
 *
 * @param options - File options
 * @returns Mock File object
 */
export function createMockFile(options: FileOptions =
⋮----
// Override size if explicitly provided
⋮----
/**
 * Creates a mock ImageFile object.
 *
 * @param options - Image file options
 * @returns Mock File object with image properties
 */
export function createMockImageFile(options: ImageFileOptions =
⋮----
// Add image-specific properties
⋮----
/**
 * Creates a mock FormData object.
 *
 * @param options - FormData options
 * @returns Mock FormData object
 */
export function createMockFormData(options: FormDataOptions =
⋮----
/**
 * Options for creating a validation error.
 */
export interface ValidationErrorOptions {
  code?: string;
  field: string;
  message?: string;
}
⋮----
/**
 * Creates a mock form validation error.
 *
 * @param options - Error options
 * @returns Mock validation error
 */
export function createMockFormValidationError(
  options: ValidationErrorOptions
): FormValidationError
````

## File: src/test/factories/reset.ts
````typescript
/**
 * @fileoverview Centralized factory reset utilities.
 * Call resetAllFactories() in beforeEach() to ensure deterministic test data.
 */
⋮----
import { resetAuthUserFactory } from "./auth-user-factory";
import { resetCalendarFactory } from "./calendar-factory";
import { resetFilterFactory } from "./filter-factory";
import { resetSearchFactory } from "./search-factory";
import { resetTripFactory } from "./trip-factory";
import { resetUserFactory } from "./user-factory";
⋮----
/**
 * Resets all factory ID counters to their initial state.
 * Call this in beforeEach() to ensure consistent, deterministic IDs across test runs.
 *
 * @example
 * beforeEach(() => {
 *   resetAllFactories();
 * });
 */
export const resetAllFactories = (): void =>
````

## File: src/test/factories/search-factory.ts
````typescript
/**
 * @fileoverview Factory for creating Search and SearchResult test data.
 */
⋮----
export interface SearchQueryOverrides {
  id?: string;
  user_id?: string;
  query?: string;
  destination?: string;
  start_date?: string;
  end_date?: string;
  budget?: number;
  passengers?: number;
  created_at?: string;
}
⋮----
export interface SearchResultOverrides {
  id?: string;
  search_id?: string;
  type?: "flight" | "hotel" | "activity";
  title?: string;
  description?: string;
  price?: number;
  currency?: string;
  rating?: number;
  url?: string;
  image_url?: string;
}
⋮----
export interface DealOverrides {
  id?: string;
  title?: string;
  description?: string;
  price?: number;
  original_price?: number;
  currency?: string;
  destination?: string;
  valid_from?: string;
  valid_to?: string;
  discount_percentage?: number;
  deal_type?: "flight" | "hotel" | "package";
}
⋮----
/**
 * Creates a mock SearchQuery with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete SearchQuery object
 */
export const createSearchQuery = (
  overrides: SearchQueryOverrides = {}
): SearchQueryOverrides &
⋮----
/**
 * Creates a mock SearchResult with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete SearchResult object
 */
export const createSearchResult = (
  overrides: SearchResultOverrides = {}
): SearchResultOverrides &
⋮----
/**
 * Creates a mock Deal with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete Deal object
 */
export const createDeal = (
  overrides: DealOverrides = {}
): DealOverrides &
⋮----
/**
 * Creates multiple search results at once.
 *
 * @param count - Number of results to create
 * @param overridesFn - Optional function to customize each result (receives index)
 * @returns Array of SearchResult objects
 */
export const createSearchResults = (
  count: number,
  overridesFn?: (index: number) => SearchResultOverrides
): Array<SearchResultOverrides &
⋮----
/**
 * Creates multiple deals at once.
 *
 * @param count - Number of deals to create
 * @param overridesFn - Optional function to customize each deal (receives index)
 * @returns Array of Deal objects
 */
export const createDeals = (
  count: number,
  overridesFn?: (index: number) => DealOverrides
): Array<DealOverrides &
⋮----
/**
 * Resets all search-related ID counters for deterministic test data.
 */
export const resetSearchFactory = (): void =>
⋮----
import type { SearchHistoryItem, ValidatedSavedSearch } from "@schemas/stores";
⋮----
/**
 * Create mock search history item.
 *
 * @param overrides - Partial search history item to override defaults
 * @returns A complete search history item
 */
export function createMockSearchItem(
  overrides: Partial<SearchHistoryItem> = {}
): SearchHistoryItem
⋮----
/**
 * Create mock saved search.
 *
 * @param overrides - Partial saved search to override defaults
 * @returns A complete saved search
 */
export function createMockSavedSearch(
  overrides: Partial<ValidatedSavedSearch> = {}
): ValidatedSavedSearch
````

## File: src/test/factories/stores.ts
````typescript
/**
 * @fileoverview Shared test factories for Zustand store states.
 *
 * Provides reusable, typed helpers to construct partial store states for tests
 * with sensible defaults. Avoids duplication and hidden coupling across suites.
 */
⋮----
import type { AgentStatusState } from "@/stores/agent-status-store";
import type { ChatMessagesState } from "@/stores/chat/chat-messages";
import type { ChatRealtimeState } from "@/stores/chat/chat-realtime";
⋮----
/**
 * Create a mock ChatMessagesState with minimal defaults and optional overrides.
 *
 * @param overrides Optional partial state overrides.
 * @returns A ChatMessagesState-like object for mocking `useChatMessages`.
 */
export function createMockChatMessagesState(
  overrides: Partial<ChatMessagesState> = {}
): ChatMessagesState
⋮----
get currentSession()
⋮----
/**
 * Create a mock ChatRealtimeState with minimal defaults and optional overrides.
 *
 * @param overrides Optional partial state overrides.
 * @returns A ChatRealtimeState-like object for mocking `useChatRealtime`.
 */
export function createMockChatRealtimeState(
  overrides: Partial<ChatRealtimeState> = {}
): ChatRealtimeState
⋮----
/**
 * Create a mock AgentStatusState with minimal defaults and optional overrides.
 *
 * Arrays default to empty to ensure deterministic tests. Timestamps are left to
 * the test to control via vi.setSystemTime/Date stubs when needed.
 *
 * @param overrides Optional partial state overrides.
 * @returns An AgentStatusState-like object for mocking `useAgentStatusStore`.
 */
export function createMockAgentStatusState(
  overrides: Partial<AgentStatusState> = {}
): AgentStatusState
````

## File: src/test/factories/trip-factory.ts
````typescript
/**
 * @fileoverview Factory for creating Trip and related test data.
 */
⋮----
export interface TripOverrides {
  id?: string;
  userId?: string;
  destination?: string;
  startDate?: string;
  endDate?: string;
  budget?: number;
  currency?: string;
  status?: "planning" | "booked" | "completed" | "cancelled";
  createdAt?: string;
  updatedAt?: string;
  title?: string;
  travelers?: number;
  tripType?: "leisure" | "business" | "family" | "solo" | "other";
}
⋮----
export interface FlightOverrides {
  id?: string;
  tripId?: string;
  airline?: string;
  flightNumber?: string;
  departureAirport?: string;
  arrivalAirport?: string;
  departureTime?: string;
  arrivalTime?: string;
  price?: number;
  currency?: string;
  bookingReference?: string;
}
⋮----
export interface HotelOverrides {
  id?: string;
  tripId?: string;
  name?: string;
  address?: string;
  checkInDate?: string;
  checkOutDate?: string;
  pricePerNight?: number;
  currency?: string;
  bookingReference?: string;
  rating?: number;
}
⋮----
/**
 * Creates a mock Trip with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete Trip object
 */
export const createTrip = (
  overrides: TripOverrides = {}
): TripOverrides &
⋮----
/**
 * Creates a mock Flight with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete Flight object
 */
export const createFlight = (
  overrides: FlightOverrides = {}
): FlightOverrides &
⋮----
/**
 * Creates a mock Hotel booking with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete Hotel object
 */
export const createHotel = (
  overrides: HotelOverrides = {}
): HotelOverrides &
⋮----
/**
 * Creates multiple trips at once.
 *
 * @param count - Number of trips to create
 * @param overridesFn - Optional function to customize each trip (receives index)
 * @returns Array of Trip objects
 */
export const createTrips = (
  count: number,
  overridesFn?: (index: number) => TripOverrides
): Array<TripOverrides &
⋮----
/**
 * Resets all trip-related ID counters for deterministic test data.
 */
export const resetTripFactory = (): void =>
````

## File: src/test/factories/user-factory.ts
````typescript
/**
 * @fileoverview Factory for creating User test data.
 */
⋮----
import type { User } from "@supabase/supabase-js";
⋮----
export interface UserOverrides {
  id?: string;
  email?: string;
  created_at?: string;
  app_metadata?: Record<string, unknown>;
  user_metadata?: Record<string, unknown>;
  aud?: string;
}
⋮----
/**
 * Creates a mock User with sensible defaults.
 *
 * @param overrides - Properties to override defaults
 * @returns A complete User object
 */
export const createUser = (overrides: UserOverrides =
⋮----
/**
 * Creates multiple users at once.
 *
 * @param count - Number of users to create
 * @param overridesFn - Optional function to customize each user (receives index)
 * @returns Array of User objects
 */
export const createUsers = (
  count: number,
  overridesFn?: (index: number) => UserOverrides
): User[] =>
⋮----
/**
 * Resets the user ID counter for deterministic test data.
 * Call this in beforeEach() if you need consistent IDs across test runs.
 */
export const resetUserFactory = (): void =>
````

## File: src/test/fixtures/deals.ts
````typescript
/**
 * @fileoverview Zod-backed fixture builders for deals and alerts.
 * Ensures test data always matches current schema requirements.
 */
⋮----
import {
  DEAL_ALERT_SCHEMA,
  DEAL_SCHEMA,
  type Deal,
  type DealAlert,
} from "@schemas/deals";
import { nowIso, secureId } from "@/lib/security/random";
⋮----
/**
 * Creates a valid Deal fixture using Zod schema validation.
 *
 * @param overrides Optional partial deal to override defaults.
 * @returns A Deal object that passes DEAL_SCHEMA validation.
 */
export function createDealFixture(overrides: Partial<Deal> =
⋮----
// Validate and return parsed result
⋮----
/**
 * Creates a valid DealAlert fixture using Zod schema validation.
 *
 * @param overrides Optional partial alert to override defaults.
 * @returns A DealAlert object that passes DEAL_ALERT_SCHEMA validation.
 */
export function createDealAlertFixture(overrides: Partial<DealAlert> =
⋮----
// Validate and return parsed result
⋮----
/**
 * Creates an invalid deal object for testing validation failures.
 * Intentionally omits required fields or uses invalid values.
 *
 * @param invalidFields Fields to set to invalid values.
 * @returns An object that will fail DEAL_SCHEMA validation.
 */
export function createInvalidDealFixture(
  invalidFields: Partial<Record<keyof Deal, unknown>> = {}
): unknown
⋮----
// Missing required fields: createdAt, currency, description, destination, expiryDate, price, provider, title, type, updatedAt, url
⋮----
/**
 * Creates an invalid alert object for testing validation failures.
 * Intentionally omits required fields or uses invalid values.
 *
 * @param invalidFields Fields to set to invalid values.
 * @returns An object that will fail DEAL_ALERT_SCHEMA validation.
 */
export function createInvalidDealAlertFixture(
  invalidFields: Partial<Record<keyof DealAlert, unknown>> = {}
): unknown
⋮----
// Missing required fields: createdAt, id, updatedAt
````

## File: src/test/fixtures/flights.ts
````typescript
import type { UpcomingFlight } from "@/hooks/use-trips";
````

## File: src/test/helpers/mock.ts
````typescript
/**
 * @fileoverview Generic mock helpers for React Query and other testing utilities.
 */
⋮----
import type { UseInfiniteQueryResult, UseQueryResult } from "@tanstack/react-query";
import { vi } from "vitest";
⋮----
/**
 * Creates a mock TanStack Query result for testing React Query hooks.
 * Provides realistic query state with customizable data, error, and loading states.
 *
 * @param data Optional data to return from the query
 * @param error Optional error to return from the query
 * @param isLoading Whether the query is in loading state
 * @param isError Whether the query is in error state
 * @returns A complete UseQueryResult mock with all required properties
 */
export const createMockUseQueryResult = <T, E = Error>(
  data: T | null = null,
  error: E | null = null,
  isLoading = false,
  isError = false
): UseQueryResult<T, E> =>
⋮----
/**
 * Creates a mock TanStack Query infinite query result for testing infinite scroll hooks.
 * Provides default values for all infinite query properties with optional overrides.
 *
 * @param overrides Optional properties to override in the mock result
 * @returns A complete UseInfiniteQueryResult mock with realistic default values
 */
export const createMockInfiniteQueryResult = <T, E = Error>(
  overrides: Partial<UseInfiniteQueryResult<T, E>> = {}
): UseInfiniteQueryResult<T, E> =>
````

## File: src/test/helpers/query-client.ts
````typescript
/**
 * @fileoverview Shared QueryClient helpers for tests.
 *
 * Keep this module React-free so it can be used from setup files without
 * pulling in component providers.
 */
⋮----
import type { QueryClient } from "@tanstack/react-query";
import { createMockQueryClient } from "./query";
⋮----
export const getTestQueryClient = (): QueryClient =>
⋮----
export const resetTestQueryClient = (): void =>
````

## File: src/test/helpers/query.tsx
````typescript
/**
 * @fileoverview Lightweight typed mocks for TanStack Query primitives used in tests.
 */
⋮----
import type {
  MutateOptions,
  QueryClient,
  UseMutationResult,
} from "@tanstack/react-query";
import { QueryClient as TanStackQueryClient } from "@tanstack/react-query";
import { vi } from "vitest";
import { createMockUseQueryResult } from "./mock";
⋮----
type MutationState<T, E, V> = {
  data: T | undefined;
  error: E | null;
  status: "idle" | "pending" | "success" | "error";
  variables: V | undefined;
};
⋮----
type QueryState<T, E> = {
  data: T | undefined;
  error: E | null;
  status: "pending" | "success" | "error";
};
⋮----
/**
 * Controller that allows tests to drive mutation state transitions manually.
 */
export interface MutationController<T, E, V> {
  /** Set the mutation into a pending/loading state. */
  triggerMutate: (variables: V) => void;
  /** Resolve the mutation with data. */
  triggerSuccess: (data: T) => void;
  /** Reject the mutation with an error. */
  triggerError: (error: E) => void;
  /** Reset the mutation back to the idle state. */
  reset: () => void;
}
⋮----
/** Set the mutation into a pending/loading state. */
⋮----
/** Resolve the mutation with data. */
⋮----
/** Reject the mutation with an error. */
⋮----
/** Reset the mutation back to the idle state. */
⋮----
/**
 * Controller that allows tests to drive query state transitions manually.
 */
export interface QueryController<T, E> {
  /** Set the query to loading/pending. */
  triggerLoading: () => void;
  /** Resolve the query with data. */
  triggerSuccess: (data: T) => void;
  /** Reject the query with an error. */
  triggerError: (error: E) => void;
  /** Invoke the mock refetch handler. */
  triggerRefetch: () => void;
  /** Reset the query back to pending with no data. */
  reset: () => void;
}
⋮----
/** Set the query to loading/pending. */
⋮----
/** Resolve the query with data. */
⋮----
/** Reject the query with an error. */
⋮----
/** Invoke the mock refetch handler. */
⋮----
/** Reset the query back to pending with no data. */
⋮----
/**
 * Create a test QueryClient with retries disabled and zero cache persistence.
 * @returns QueryClient configured for deterministic unit tests.
 */
export const createMockQueryClient = (): QueryClient
⋮----
/**
 * Build a controlled mutation result along with its controller helpers.
 * @returns A tuple containing the mutation result and controller.
 */
export function createControlledMutation<T, E = Error, V = void, C = unknown>()
⋮----
/**
 * Convenience helper returning only the mutation result for simple tests.
 * @returns A mocked mutation result along with its controller.
 */
export function mockUseMutation<T, E, V, C = unknown>()
⋮----
/**
 * Build a controlled query result together with a controller.
 * @returns A tuple containing the query result and controller.
 */
export function createControlledQuery<T, E = Error>()
⋮----
/**
 * Simplified query mock for components that only need success/error toggling.
 * @param initialData Optional data to seed the query with.
 * @param initialError Optional error to seed the query with.
 * @returns The mocked query result and controller.
 */
export function mockUseQuery<T, E>(initialData?: T, initialError?: E)
````

## File: src/test/helpers/schema.ts
````typescript
/**
 * @fileoverview Centralized schema test helpers.
 *
 * Provides utilities for testing Zod schemas:
 * - Schema validation assertions
 * - Parse error expectations
 */
⋮----
import type { ZodError, z } from "zod";
⋮----
/**
 * Assert that a value passes schema validation.
 *
 * @param schema - Zod schema to validate against
 * @param value - Value to validate
 * @returns Validated value
 * @throws If validation fails
 */
export function expectValid<T>(schema: z.ZodSchema<T>, value: unknown): T
⋮----
/**
 * Assert that a value fails schema validation with expected error.
 *
 * @param schema - Zod schema to validate against
 * @param value - Value that should fail validation
 * @param expectedError - Optional expected error message or path
 * @returns ZodError from failed validation
 * @throws If validation unexpectedly succeeds
 */
export function expectParseError(
  schema: z.ZodSchema<unknown>,
  value: unknown,
  expectedError?: string | string[]
): ZodError
````

## File: src/test/mocks/botid.ts
````typescript
/**
 * @fileoverview Shared BotID mock helpers for deterministic test behavior.
 *
 * Route tests commonly stub `botid/server` to avoid noisy warnings and to keep
 * bot-detection behavior consistent across suites.
 */
⋮----
import type { BotIdVerification } from "@/lib/security/botid";
⋮----
/**
 * Deterministic "human" BotID response used across tests.
 *
 * Matches the shape used by `createMockBotIdResponse` in `src/lib/security/__tests__/botid.test.ts`.
 */
````

## File: src/test/mocks/cache.ts
````typescript
/**
 * @fileoverview Shared Upstash cache mock helpers for tests.
 *
 * Provides an in-memory implementation matching the `@/lib/cache/upstash`
 * surface (getCachedJson, setCachedJson, deleteCachedJson, deleteCachedJsonMany).
 * Use per-suite instances to avoid cross-test leakage and keep hoisted vi.mock
 * factories simple.
 */
⋮----
import { vi } from "vitest";
⋮----
export type UpstashCacheMock = {
  store: Map<string, string>;
  getCachedJson: ReturnType<typeof vi.fn>;
  setCachedJson: ReturnType<typeof vi.fn>;
  deleteCachedJson: ReturnType<typeof vi.fn>;
  deleteCachedJsonMany: ReturnType<typeof vi.fn>;
  reset: () => void;
  module: {
    getCachedJson: UpstashCacheMock["getCachedJson"];
    setCachedJson: UpstashCacheMock["setCachedJson"];
    deleteCachedJson: UpstashCacheMock["deleteCachedJson"];
    deleteCachedJsonMany: UpstashCacheMock["deleteCachedJsonMany"];
    __reset: UpstashCacheMock["reset"];
  };
};
⋮----
/**
 * Build a fresh Upstash cache mock instance.
 *
 * Example:
 *   const upstash = buildUpstashCacheMock();
 *   vi.mock("@/lib/cache/upstash", () => upstash.module);
 *   beforeEach(() => upstash.reset());
 */
export function buildUpstashCacheMock(): UpstashCacheMock
⋮----
const reset = (): void =>
⋮----
/**
 * Convenience helper for hoisted Upstash cache mocks in vitest.
 *
 * Usage:
 *   const { cache, factory } = hoistedUpstashMock();
 *   vi.mock("@/lib/cache/upstash", factory);
 *   beforeEach(() => cache.reset());
 */
export function hoistedUpstashMock():
````

## File: src/test/mocks/media-query.ts
````typescript
/**
 * @fileoverview MediaQueryList mock factory for responsive design tests.
 * Use this instead of global mocks to improve test boot time.
 *
 * Usage:
 *   import { createMockMatchMedia } from "@/test/mocks/media-query";
 *
 *   it("should respond to dark mode", () => {
 *     const matchMedia = createMockMatchMedia({ "(prefers-color-scheme: dark)": true });
 *     window.matchMedia = matchMedia;
 *     // ... test code
 *   });
 */
⋮----
import { vi } from "vitest";
⋮----
export interface MediaQueryConfig {
  [query: string]: boolean;
}
⋮----
/**
 * Creates a mock MediaQueryList for a specific query.
 *
 * @param query - The media query string
 * @param matches - Whether the query matches
 * @returns A MediaQueryList-compatible mock
 */
export const createMockMediaQueryList = (
  query: string,
  matches: boolean
): MediaQueryList => (
⋮----
/**
 * Creates a mock matchMedia function that responds to configured queries.
 *
 * @param config - Map of query strings to match results
 * @param defaultMatches - Default result for unconfigured queries
 * @returns A matchMedia-compatible function
 *
 * @example
 * const matchMedia = createMockMatchMedia({
 *   "(prefers-color-scheme: dark)": true,
 *   "(min-width: 768px)": false,
 * });
 * window.matchMedia = matchMedia;
 */
export const createMockMatchMedia = (
  config: MediaQueryConfig = {},
  defaultMatches = false
): ((query: string) => MediaQueryList) =>
⋮----
/**
 * Installs a mock matchMedia on window for tests.
 *
 * @param config - Media query configuration
 * @returns The mock matchMedia function
 *
 * @example
 * beforeEach(() => {
 *   installMockMatchMedia({ "(prefers-color-scheme: dark)": true });
 * });
 */
export const installMockMatchMedia = (
  config: MediaQueryConfig = {}
): ((query: string) => MediaQueryList) =>
````

## File: src/test/mocks/rehype-harden.ts
````typescript
/**
 * @fileoverview Minimal rehype-harden stub for tests to avoid ESM/CJS packaging issues
 * in downstream dependencies when running under Vitest.
 */
⋮----
export default function rehypeHarden()
⋮----
// Return a no-op transformer
⋮----
// no-op
````

## File: src/test/mocks/server-only.ts
````typescript
/**
 * @fileoverview Vitest shim for Next.js `server-only` virtual module.
 */
````

## File: src/test/mocks/storage.ts
````typescript
/**
 * @fileoverview Storage mock factory for tests that need localStorage/sessionStorage.
 * Use this instead of global mocks to improve test boot time.
 *
 * Usage:
 *   import { createMockStorage } from "@/test/mocks/storage";
 *
 *   it("should save to storage", () => {
 *     const storage = createMockStorage();
 *     storage.setItem("key", "value");
 *     expect(storage.getItem("key")).toBe("value");
 *   });
 */
⋮----
import { vi } from "vitest";
⋮----
/**
 * Creates a mock Storage implementation backed by a Map.
 * Fully implements the Web Storage API with Vitest spies.
 *
 * @param initialData - Optional initial key-value pairs
 * @returns A Storage-compatible mock object with spy functions
 */
export const createMockStorage = (initialData?: Record<string, string>): Storage =>
⋮----
get length()
⋮----
/**
 * Installs the mock storage on window for tests that expect global access.
 *
 * @param type - "localStorage" or "sessionStorage"
 * @param initialData - Optional initial data
 * @returns The mock storage instance
 *
 * @example
 * beforeEach(() => {
 *   installMockStorage("localStorage", { token: "abc123" });
 * });
 */
export const installMockStorage = (
  type: "localStorage" | "sessionStorage",
  initialData?: Record<string, string>
): Storage =>
````

## File: src/test/mocks/toast.ts
````typescript
import { vi } from "vitest";
⋮----
type ToastProps = Record<string, unknown>;
⋮----
export const resetToastMocks = () =>
````

## File: src/test/msw/handlers/amadeus.ts
````typescript
/**
 * @fileoverview MSW handlers for Amadeus Self-Service Hotels endpoints.
 */
⋮----
import type { HttpHandler } from "msw";
import { HttpResponse, http } from "msw";
````

## File: src/test/msw/handlers/auth-routes.ts
````typescript
/**
 * @fileoverview MSW handlers for app auth routes used in component/store tests.
 */
⋮----
import type { HttpHandler } from "msw";
import { HttpResponse, http } from "msw";
import { createAuthUser } from "@/test/factories/auth-user-factory";
⋮----
type AuthRouteOptions = {
  user?: ReturnType<typeof createAuthUser>;
};
const buildDefaultUser = (overrides?: AuthRouteOptions["user"])
⋮----
export const createAuthRouteHandlers = (
  options: AuthRouteOptions = {}
): HttpHandler[] =>
````

## File: src/test/msw/handlers/auth.ts
````typescript
/**
 * @fileoverview MSW handlers for authentication endpoints.
 *
 * Provides default mock responses for:
 * - /api/auth/login
 * - /api/auth/register
 * - /api/auth/logout
 * - /api/auth/me
 * - /api/auth/callback
 */
⋮----
import { HttpResponse, http } from "msw";
⋮----
/**
 * Default auth handlers providing happy-path responses.
 */
⋮----
// GET /api/auth/me - Current user endpoint
⋮----
// biome-ignore lint/style/useNamingConvention: align with Supabase response fields
⋮----
// POST /api/auth/login - Login endpoint
⋮----
// biome-ignore lint/style/useNamingConvention: align with Supabase response fields
⋮----
// biome-ignore lint/style/useNamingConvention: align with Supabase response fields
⋮----
// POST /api/auth/register - Registration endpoint
⋮----
// POST /api/auth/logout - Logout endpoint
⋮----
// GET /api/auth/callback - OAuth callback endpoint
````

## File: src/test/msw/handlers/chat.ts
````typescript
/**
 * @fileoverview MSW handlers for chat API endpoints.
 *
 * Provides default mock responses for:
 * - /api/chat/sessions
 * - /api/chat/stream
 */
⋮----
import { HttpResponse, http } from "msw";
⋮----
/**
 * Default chat handlers providing happy-path responses.
 */
⋮----
// GET /api/chat/sessions - List chat sessions
⋮----
// biome-ignore lint/style/useNamingConvention: match persisted schema fields
⋮----
// POST /api/chat/sessions - Create chat session
⋮----
// biome-ignore lint/style/useNamingConvention: match persisted schema fields
⋮----
// POST /api/chat/stream - Streaming chat endpoint (stubbed as immediate response)
⋮----
// GET /api/chat/stream - stream fetch in tests
⋮----
// POST /api/ai/stream - AI streaming endpoint for demo
⋮----
start(controller)
⋮----
// POST /api/telemetry/ai-demo - Telemetry for AI demo
⋮----
// fallback relative handlers
````

## File: src/test/msw/handlers/error-reporting.ts
````typescript
/**
 * @fileoverview MSW handlers for client-side error reporting.
 *
 * Provides reusable handler factories for the ErrorService tests so suites can
 * capture posted payloads or simulate flaky network conditions without
 * hand-rolling inline MSW handlers.
 */
⋮----
import type { ErrorReport } from "@schemas/errors";
import type { HttpHandler } from "msw";
import { HttpResponse, http } from "msw";
⋮----
/** Default endpoint used by ErrorService in tests. */
⋮----
export interface RecordedErrorReport {
  body: ErrorReport;
  headers: Headers;
}
⋮----
/**
 * Create a handler that records every posted error report.
 *
 * @param endpoint - Error reporting endpoint to intercept.
 * @returns MSW handler and an array that accumulates captured requests.
 */
export function createErrorReportingRecorder(endpoint = ERROR_REPORTING_ENDPOINT):
⋮----
/**
 * Create a handler that fails a configurable number of times before succeeding.
 *
 * Useful for exercising retry logic without duplicating inline handlers.
 *
 * @param options.failTimes - Number of initial calls that should throw.
 * @param options.endpoint - Endpoint to intercept.
 * @returns MSW handler plus a getter for total call count.
 */
export function createFlakyErrorReportingHandler(options?: {
  failTimes?: number;
  endpoint?: string;
}):
⋮----
/**
 * Default happy-path handler for error reporting.
 *
 * Added to the global server so unmocked error posts are still intercepted.
 */
````

## File: src/test/msw/handlers/external-apis.ts
````typescript
/**
 * @fileoverview MSW handlers for external API endpoints.
 *
 * Provides default mock responses for third-party APIs used by the application.
 * Tests can override these handlers using server.use() for specific scenarios.
 */
⋮----
import { HttpResponse, http } from "msw";
⋮----
/**
 * Default external API handlers providing happy-path responses.
 */
⋮----
// OpenWeatherMap API - Current Weather Data
⋮----
// biome-ignore lint/style/useNamingConvention: match OpenWeatherMap API response format
⋮----
// biome-ignore lint/style/useNamingConvention: match OpenWeatherMap API response format
⋮----
// biome-ignore lint/style/useNamingConvention: match OpenWeatherMap API response format
⋮----
// US State Department Travel Advisories API
⋮----
// biome-ignore lint/style/useNamingConvention: match State Department API response format
⋮----
// biome-ignore lint/style/useNamingConvention: match State Department API response format
⋮----
// biome-ignore lint/style/useNamingConvention: match State Department API response format
⋮----
// biome-ignore lint/style/useNamingConvention: match State Department API response format
⋮----
// biome-ignore lint/style/useNamingConvention: match State Department API response format
⋮----
// biome-ignore lint/style/useNamingConvention: match State Department API response format
⋮----
// Firecrawl API - Web Search
⋮----
// Firecrawl API - Scrape
````

## File: src/test/msw/handlers/google-places.ts
````typescript
/**
 * @fileoverview MSW handlers for Google Places (New) API endpoints used in tests.
 */
⋮----
import type { HttpHandler } from "msw";
import { HttpResponse, http } from "msw";
⋮----
/** Shared 404 error response for invalid resources. */
⋮----
/** MSW handlers for Google Places (New) API endpoints used in tests. */
⋮----
// ignore parse errors; use defaults
⋮----
// Handle activity searches differently
⋮----
// Handle invalid place ID
⋮----
// Handle requests to an invalid activity path explicitly
⋮----
// Backward compatibility: generic invalid path
````

## File: src/test/msw/handlers/providers.ts
````typescript
/**
 * @fileoverview MSW handlers for AI provider endpoints.
 *
 * Provides default mock responses for AI provider integrations.
 */
⋮----
import { HttpResponse, http } from "msw";
⋮----
/**
 * Default AI provider handlers providing happy-path responses.
 *
 * Note: These are placeholder handlers. Actual AI SDK streaming
 * should be mocked using official AI SDK test utilities (MockLanguageModelV3).
 */
⋮----
// OpenAI API mock (for direct API calls, not AI SDK)
⋮----
// biome-ignore lint/style/useNamingConvention: match OpenAI payload shape
⋮----
// biome-ignore lint/style/useNamingConvention: match OpenAI payload shape
⋮----
// biome-ignore lint/style/useNamingConvention: match OpenAI payload shape
⋮----
// biome-ignore lint/style/useNamingConvention: match OpenAI payload shape
⋮----
// Anthropic API mock (for direct API calls, not AI SDK)
⋮----
// biome-ignore lint/style/useNamingConvention: match Anthropic payload shape
⋮----
// biome-ignore lint/style/useNamingConvention: match Anthropic payload shape
⋮----
// biome-ignore lint/style/useNamingConvention: match Anthropic payload shape
````

## File: src/test/msw/handlers/stripe.ts
````typescript
/**
 * @fileoverview MSW handlers for Stripe API calls used in tests.
 */
⋮----
import type { HttpHandler } from "msw";
import { HttpResponse, http } from "msw";
````

## File: src/test/msw/handlers/supabase.ts
````typescript
/**
 * @fileoverview MSW handlers for Supabase REST API endpoints.
 *
 * Provides default mock responses for Supabase REST API patterns.
 * For most tests, use the type-safe Supabase mock helpers from @/test/helpers/mock.ts
 * These handlers are for tests that need to mock HTTP-level Supabase interactions.
 */
⋮----
import { HttpResponse, http } from "msw";
⋮----
/**
 * Default Supabase handlers providing happy-path responses.
 */
⋮----
// Supabase Auth endpoints
⋮----
// biome-ignore lint/style/useNamingConvention: match Supabase auth payload
⋮----
// biome-ignore lint/style/useNamingConvention: match Supabase auth payload
⋮----
// biome-ignore lint/style/useNamingConvention: match Supabase auth payload
⋮----
// Supabase REST API - Generic table query pattern
// This is a catch-all for REST queries - override in specific tests
⋮----
// biome-ignore lint/style/useNamingConvention: match Supabase row payload
⋮----
// Supabase RPC endpoint pattern
⋮----
// Supabase Realtime - Channel subscription
````

## File: src/test/msw/handlers/telemetry.ts
````typescript
/**
 * @fileoverview MSW handlers for telemetry endpoints used in tests.
 */
⋮----
import { HttpResponse, http } from "msw";
````

## File: src/test/msw/handlers/upstash.ts
````typescript
/**
 * @fileoverview MSW handlers for Upstash REST endpoints used in tests.
 * Provides deterministic in-memory behavior backed by the shared Upstash
 * store used by redis mocks. Keeps tests thread-safe under `--pool=threads`.
 */
⋮----
import type { HttpHandler } from "msw";
import { HttpResponse, http } from "msw";
import { createRatelimitMock } from "@/test/upstash/ratelimit-mock";
import {
  resetRedisStore,
  runUpstashPipeline,
  sharedUpstashStore,
} from "@/test/upstash/redis-mock";
⋮----
// Create mock module and limiter instance
⋮----
export function resetUpstashHandlers(): void
````

## File: src/test/msw/handlers/utils.ts
````typescript
/**
 * @fileoverview Small helpers for composing MSW handler sets in tests.
 */
⋮----
import type { HttpHandler } from "msw";
⋮----
/**
 * Flatten multiple handler groups into a single array for `server.use(...)`.
 */
export const composeHandlers = (...groups: HttpHandler[][]): HttpHandler[]
````

## File: src/test/msw/server.ts
````typescript
/**
 * @fileoverview MSW server instance for Node.js test environment.
 *
 * This server intercepts HTTP requests during test execution, providing
 * predictable mock responses without requiring real network calls.
 *
 * The server is integrated into the Vitest setup (setup-node / setup-jsdom) and is
 * active for all tests. Individual tests can override default handlers using
 * server.use() for specific scenarios.
 */
⋮----
import { setupServer } from "msw/node";
import { amadeusHandlers } from "./handlers/amadeus";
import { apiRouteHandlers } from "./handlers/api-routes";
import { authHandlers } from "./handlers/auth";
import { authRouteHandlers } from "./handlers/auth-routes";
import { chatHandlers } from "./handlers/chat";
import { errorReportingHandlers } from "./handlers/error-reporting";
import { externalApiHandlers } from "./handlers/external-apis";
import { googlePlacesHandlers } from "./handlers/google-places";
import { providersHandlers } from "./handlers/providers";
import { stripeHandlers } from "./handlers/stripe";
import { supabaseHandlers } from "./handlers/supabase";
import { telemetryHandlers } from "./handlers/telemetry";
import { upstashHandlers } from "./handlers/upstash";
⋮----
/**
 * MSW server instance configured with default request handlers.
 *
 * Lifecycle:
 * - beforeAll: server.listen() starts request interception
 * - afterEach: server.resetHandlers() removes test-specific overrides
 * - afterAll: server.close() stops interception and cleanup
 *
 * @example
 * ```typescript
 * import { server } from '@/test/msw/server';
 * import { http, HttpResponse } from 'msw';
 *
 * test('handles API error', () => {
 *   server.use(
 *     http.post('/api/endpoint', () => {
 *       return new HttpResponse(null, { status: 500 });
 *     })
 *   );
 *   // Test code that expects 500 error
 * });
 * ```
 */
````

## File: src/test/upstash/constants.ts
````typescript
/**
 * @fileoverview Test constants for Upstash mocks.
 *
 * Use these instead of hardcoded strings for clarity and maintainability.
 * These tokens are only used in test environments and have no production value.
 */
````

## File: src/test/upstash/emulator.ts
````typescript
/**
 * @fileoverview Optional Upstash emulator helpers.
 *
 * Reads and validates Upstash emulator config from env vars. No-op unless
 * UPSTASH_USE_EMULATOR=1. When enabled, requires UPSTASH_EMULATOR_URL and
 * UPSTASH_QSTASH_DEV_URL to be set; throws if missing.
 */
⋮----
type EmulatorConfig = {
  enabled: boolean;
  redisUrl?: string;
  qstashUrl?: string;
};
⋮----
export function getEmulatorConfig(): EmulatorConfig
⋮----
export function startUpstashEmulators(): EmulatorConfig
⋮----
// Real container orchestration is handled externally or by CI; this helper
// simply validates configuration to avoid silent misconfigurations.
⋮----
export function stopUpstashEmulators(): void
⋮----
// No-op placeholder for symmetry; actual emulator lifecycle is managed
// externally (docker-compose/testcontainers) when enabled.
````

## File: src/test/upstash/index.ts
````typescript
/**
 * @fileoverview Unified Upstash testing harness public API.
 *
 * Provides a single entry point for all Upstash mock modules (Redis, Ratelimit, QStash)
 * with lifecycle helpers for test setup, reset, and teardown.
 *
 * @example
 * ```ts
 * import {
 *   installUpstashMocks,
 *   resetUpstashMocks,
 *   getPublishedQStashMessages,
 * } from "@/test/upstash";
 *
 * const mocks = installUpstashMocks();
 *
 * beforeEach(() => resetUpstashMocks());
 *
 * it("tracks QStash messages", async () => {
 *   // ... code that calls publishJSON
 *   expect(getPublishedQStashMessages()).toHaveLength(1);
 * });
 * ```
 */
⋮----
// Imports for unified API
import {
  createQStashMock,
  type QStashMessage,
  type QStashMockModule,
} from "./qstash-mock";
import { createRatelimitMock, type RatelimitMockModule } from "./ratelimit-mock";
import {
  createRedisMock,
  type RedisMockModule,
  sharedUpstashStore,
} from "./redis-mock";
⋮----
// Re-export test constants
⋮----
// Re-export QStash mock factory only
⋮----
// Re-export Ratelimit mock
⋮----
// Re-export Redis mock
⋮----
/**
 * Unified state type for all Upstash mocks.
 */
export type UpstashMocksState = {
  redis: RedisMockModule;
  ratelimit: RatelimitMockModule;
  qstash: QStashMockModule;
  installed: boolean;
};
⋮----
/**
 * Install all Upstash mocks. Call once at test suite setup.
 * Returns mock modules for vi.doMock() registration.
 *
 * @example
 * ```ts
 * const mocks = installUpstashMocks();
 *
 * vi.doMock("@upstash/redis", () => ({ Redis: mocks.redis.Redis }));
 * vi.doMock("@upstash/ratelimit", () => ({ Ratelimit: mocks.ratelimit.Ratelimit }));
 * vi.doMock("@upstash/qstash", () => ({
 *   Client: mocks.qstash.Client,
 *   Receiver: mocks.qstash.Receiver,
 * }));
 * ```
 */
export function installUpstashMocks(): UpstashMocksState
⋮----
/**
 * Reset all mock state between tests. Call in beforeEach().
 */
export function resetUpstashMocks(): void
⋮----
/**
 * Teardown mocks after test suite. Call in afterAll().
 */
export function teardownUpstashMocks(): void
⋮----
/**
 * Get published QStash messages for assertions.
 */
// biome-ignore lint/style/useNamingConvention: mirrors QStash naming
export function getPublishedQStashMessages(): QStashMessage[]
⋮----
/**
 * Force QStash signature verification outcome.
 * @param outcome - true/false for verify result, or Error to throw
 */
// biome-ignore lint/style/useNamingConvention: mirrors QStash naming
export function forceQStashVerifyOutcome(outcome: boolean | Error): void
⋮----
/**
 * Get current mock state (for advanced use cases).
 * Returns null if installUpstashMocks() has not been called.
 */
export function getUpstashMocksState(): UpstashMocksState | null
````

## File: src/test/upstash/qstash-mock.ts
````typescript
/**
 * @fileoverview Mock implementation of Upstash QStash for testing.
 *
 * Provides Client and Receiver mocks with message tracking for assertions.
 * Compatible with vi.doMock() for thread-safe testing with --pool=threads.
 */
⋮----
// Types matching official @upstash/qstash API
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash API naming
export type QStashPublishOptions = {
  url: string;
  body: unknown;
  headers?: Record<string, string>;
  retries?: number;
  delay?: number;
  deduplicationId?: string;
  callback?: string;
};
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash API naming
export type QStashPublishResult = {
  messageId: string;
  url?: string;
  scheduled?: boolean;
};
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash API naming
export type QStashMessage = QStashPublishOptions & {
  publishedAt: number;
  messageId: string;
};
⋮----
/**
 * QStash mock module type for vi.doMock registration.
 */
// biome-ignore lint/style/useNamingConvention: mirrors QStash naming
type QStashClientConstructor = new (opts: {
  token: string;
  enableTelemetry?: boolean;
}) => {
  // biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash API naming
  publishJSON: (opts: QStashPublishOptions) => Promise<QStashPublishResult>;
};
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash API naming
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash API naming
type QStashReceiverConstructor = new (opts: {
  currentSigningKey: string;
  nextSigningKey: string;
}) => {
  verify: (opts: {
    signature: string;
    body: string;
    url?: string;
    clockTolerance?: number;
  }) => Promise<boolean>;
};
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash API naming
export type QStashMockModule = {
  // biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash export
  Client: QStashClientConstructor;
  // biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash export
  Receiver: QStashReceiverConstructor;
  __reset: () => void;
  __getMessages: () => QStashMessage[];
  __forceVerify: (outcome: boolean | Error) => void;
};
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash export
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash export
⋮----
/**
 * Create QStash mock module for vi.doMock() registration.
 *
 * @example
 * ```ts
 * const qstash = createQStashMock();
 * vi.doMock("@upstash/qstash", () => ({
 *   Client: qstash.Client,
 *   Receiver: qstash.Receiver,
 * }));
 *
 * beforeEach(() => qstash.__reset());
 * ```
 */
// biome-ignore lint/style/useNamingConvention: mirrors QStash naming
export function createQStashMock(): QStashMockModule
⋮----
// Shared state for this mock instance
⋮----
// Mock QStash Client for testing (per-instance state)
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash Client class
class QStashClientMock
⋮----
constructor(opts:
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash method name
publishJSON(opts: QStashPublishOptions): Promise<QStashPublishResult>
⋮----
// Mock QStash Receiver for testing signature verification (per-instance state)
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash Receiver class
class QStashReceiverMock
⋮----
verify(_opts: {
      signature: string;
      body: string;
      url?: string;
      clockTolerance?: number;
}): Promise<boolean>
⋮----
const getPublishedMessages = (): QStashMessage[]
⋮----
const forceVerifyOutcome = (outcome: boolean | Error): void =>
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors QStash naming
const resetQStashMock = (): void =>
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash export
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/qstash export
````

## File: src/test/upstash/ratelimit-mock.ts
````typescript
/**
 * @fileoverview Mock implementation of Upstash Ratelimit for testing.
 *
 * Provides a shared in-memory store for Ratelimit operations, simulating
 * Ratelimit behavior with sliding/fixed window support and forced outcomes.
 * Compatible with vi.doMock() for thread-safe testing with --pool=threads.
 */
⋮----
type LimiterConfig = {
  limit: number;
  intervalMs: number;
  type: "sliding" | "fixed";
};
⋮----
type CounterState = {
  remaining: number;
  resetAt: number;
  windowStart?: number;
};
⋮----
type ForcedOverrides = Partial<{
  success: boolean;
  remaining: number;
  limit: number;
  reset: number;
  retryAfter: number;
}>;
⋮----
function parseWindow(window: string): number
⋮----
export type RatelimitMockModule = {
  // biome-ignore lint/style/useNamingConvention: mirrors @upstash/ratelimit export shape
  Ratelimit: RatelimitMockClass & {
    slidingWindow: (limit: number, window: string) => LimiterConfig;
    fixedWindow: (limit: number, window: string) => LimiterConfig;
  };
  __getRecordedIdentifiers: () => string[];
  __getLimitCallCount: () => number;
  __reset: () => void;
  __force: (
    result: Partial<{
      success: boolean;
      remaining: number;
      limit: number;
      reset: number;
      retryAfter: number;
    }>
  ) => void;
};
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/ratelimit export shape
⋮----
type RatelimitMockClass = new (config: {
  limiter: LimiterConfig;
  prefix?: string;
}) => RatelimitMockInstance;
⋮----
type RatelimitMockInstance = {
  limit: (identifier: string) => Promise<{
    success: boolean;
    limit: number;
    remaining: number;
    reset: number;
    retryAfter: number;
  }>;
  force: (
    result: Partial<{
      success: boolean;
      remaining: number;
      limit: number;
      reset: number;
      retryAfter: number;
    }>
  ) => void;
};
⋮----
/**
 * Create Ratelimit mock module for vi.doMock() registration.
 * Each call creates an isolated mock with its own shared state.
 *
 * @example
 * ```ts
 * const ratelimit = createRatelimitMock();
 *
 * vi.doMock("@upstash/ratelimit", () => ({
 *   Ratelimit: ratelimit.Ratelimit,
 * }));
 *
 * beforeEach(() => ratelimit.__reset());
 * ```
 */
export function createRatelimitMock(): RatelimitMockModule
⋮----
// Shared state for all limiter instances created by this mock
⋮----
const resolveForcedOutcome = (
    forced: ForcedOverrides | undefined,
    limiter: LimiterConfig
) =>
⋮----
/**
   * Ratelimit limiter instance with proper state isolation.
   */
class RatelimitInstance
⋮----
constructor(config:
⋮----
force(
      result: Partial<{
        success: boolean;
        remaining: number;
        limit: number;
        reset: number;
        retryAfter: number;
      }>
): void
⋮----
limit(identifier: string): Promise<
⋮----
// Check for forced outcome first
⋮----
// Fixed window: count resets on aligned window boundaries
⋮----
// Sliding window: reset relative to first request after expiry
⋮----
// Add static methods to the constructor while keeping typing explicit
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/ratelimit export shape
⋮----
// Legacy export for backwards compatibility
// biome-ignore lint/complexity/noStaticOnlyClass: maintains backwards-compatible class API
export class RatelimitMock
⋮----
static slidingWindow(limit: number, window: string): LimiterConfig
⋮----
static fixedWindow(limit: number, window: string): LimiterConfig
````

## File: src/test/upstash/redis-mock.ts
````typescript
/**
 * @fileoverview Mock implementation of Upstash Redis for testing.
 *
 * Provides a shared in-memory store for Redis operations, simulating Redis
 * behavior with TTL tracking and pipeline support.
 */
⋮----
type StoredValue = {
  value: string;
  expiresAt?: number;
};
⋮----
export type UpstashMemoryStore = Map<string, StoredValue>;
⋮----
export function createUpstashMemoryStore(): UpstashMemoryStore
⋮----
function serialize(value: unknown): string
⋮----
function deserialize(raw: string | undefined): unknown
⋮----
function isExpired(entry: StoredValue | undefined, now: number): boolean
⋮----
function touch(
  store: UpstashMemoryStore,
  key: string,
  now: number
): StoredValue | undefined
⋮----
export class RedisMockClient
⋮----
constructor(private readonly store: UpstashMemoryStore = sharedUpstashStore)
⋮----
get<T = unknown>(key: string): Promise<T | null>
⋮----
set(
    key: string,
    value: unknown,
    opts?: { ex?: number; px?: number }
): Promise<string>
⋮----
mset(pairs: Record<string, unknown> | Array<[string, unknown]>): Promise<string>
⋮----
del(...keys: string[]): Promise<number>
⋮----
expire(key: string, ttlSeconds: number): Promise<number>
⋮----
ttl(key: string): Promise<number>
⋮----
incr(key: string): Promise<number>
⋮----
mget<T extends unknown[]>(...keys: string[]): Promise<T>
⋮----
exists(...keys: string[]): Promise<number>
⋮----
// List operations ---------------------------------------------------------
⋮----
private getList(key: string, now: number): string[]
⋮----
private setList(key: string, list: string[], expiresAt?: number): void
⋮----
lpush(key: string, ...values: string[]): Promise<number>
⋮----
// Redis LPUSH inserts each value from left to right so the last argument ends up at the head.
⋮----
rpush(key: string, ...values: string[]): Promise<number>
⋮----
lrange(key: string, start: number, stop: number): Promise<string[]>
⋮----
ltrim(key: string, start: number, stop: number): Promise<"OK">
⋮----
lrem(key: string, count: number, value: string): Promise<number>
⋮----
// Remove all matches
⋮----
// Remove first N matches from start
⋮----
// count < 0: remove from end, up to |count| matches
⋮----
llen(key: string): Promise<number>
⋮----
scan(
    cursor: number,
    opts?: { match?: string; count?: number }
): Promise<[number, string[]]>
⋮----
// Lua eval support for simple atomic operations
async eval(
    script: string,
    keys: string[],
    args: Array<string | number>
): Promise<unknown>
⋮----
// Support circuit-breaker script: INCR + EXPIRE
⋮----
// Support DLQ script: LRANGE + LREM by entry id
⋮----
// ignore parse errors
⋮----
export class RedisMock
⋮----
static fromEnv(): RedisMockClient
⋮----
constructor(options?:
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/redis export shape
export type RedisMockModule = { Redis: typeof RedisMock } & {
  __reset: () => void;
  store: UpstashMemoryStore;
};
⋮----
export function createRedisMock(
  store: UpstashMemoryStore = sharedUpstashStore
): RedisMockModule
⋮----
const reset = ()
⋮----
// biome-ignore lint/style/useNamingConvention: mirrors @upstash/redis export shape
⋮----
export function resetRedisStore(store: UpstashMemoryStore = sharedUpstashStore): void
⋮----
export async function runUpstashCommand(
  store: UpstashMemoryStore,
  command: string[]
): Promise<unknown>
⋮----
export async function runUpstashPipeline(
  store: UpstashMemoryStore,
  commands: unknown
): Promise<unknown[]>
⋮----
function objectFromTuples(args: string[]): Record<string, string>
⋮----
// Re-export ratelimit mock for convenience
⋮----
// Lazy import to avoid require() which doesn't work in vitest ESM context
import { createRatelimitMock as createRl } from "./ratelimit-mock";
⋮----
export type UpstashMocks = {
  redis: RedisMockModule;
  ratelimit: import("./ratelimit-mock").RatelimitMockModule;
};
⋮----
/**
 * Creates Upstash mock instances (Redis + Ratelimit).
 * Use with vi.mock() at module scope, NOT inside beforeEach.
 *
 * @example
 * ```ts
 * import { vi } from "vitest";
 * import { setupUpstashMocks } from "@/test/upstash/redis-mock";
 *
 * const { redis, ratelimit } = setupUpstashMocks();
 * vi.mock("@upstash/redis", () => redis);
 * vi.mock("@upstash/ratelimit", () => ratelimit);
 *
 * beforeEach(() => {
 *   redis.__reset();
 *   ratelimit.__reset();
 * });
 * ```
 */
export function setupUpstashMocks(): UpstashMocks
````

## File: src/test/upstash/setup.ts
````typescript
/**
 * @fileoverview Vitest setup helpers for Upstash mocks.
 *
 * Provides vi.doMock registration that works with --pool=threads.
 * Use these helpers instead of vi.mock() for thread-safe testing.
 */
⋮----
import { vi } from "vitest";
import {
  installUpstashMocks,
  resetUpstashMocks,
  teardownUpstashMocks,
  type UpstashMocksState,
} from "./index";
⋮----
/**
 * Register Upstash mocks with Vitest using vi.doMock.
 * Call at module scope before tests.
 *
 * @example
 * ```ts
 * import { registerUpstashMocksWithVitest } from "@/test/upstash/setup";
 *
 * const mocks = registerUpstashMocksWithVitest();
 *
 * beforeEach(() => {
 *   mocks.redis.__reset();
 *   mocks.ratelimit.__reset();
 *   mocks.qstash.__reset();
 * });
 * ```
 */
export function registerUpstashMocksWithVitest(): UpstashMocksState
⋮----
// Use vi.doMock for thread-safety (not vi.mock which hoists)
⋮----
// biome-ignore lint/style/useNamingConvention: matches @upstash/redis export
⋮----
// biome-ignore lint/style/useNamingConvention: matches @upstash/ratelimit export
⋮----
// biome-ignore lint/style/useNamingConvention: matches @upstash/qstash export
⋮----
// biome-ignore lint/style/useNamingConvention: matches @upstash/qstash export
⋮----
/**
 * Create lifecycle hooks for Upstash test isolation (direct/mock-first tests).
 *
 * Returns mock state without registering vi.doMock. Use this when:
 * - Testing directly against mock instances (mock-first approach)
 * - Manually injecting mocks via factory setters or dependency injection
 * - You don't need module-level import replacement
 *
 * For tests that require module-level mock replacement (importing the real module
 * and having it transparently use mocks), use setupUpstashTestEnvironment() instead.
 *
 * @example
 * ```ts
 * import { createUpstashTestHooks } from "@/test/upstash/setup";
 * import { beforeEach, afterAll } from "vitest";
 *
 * const { beforeEachHook, afterAllHook, mocks } = createUpstashTestHooks();
 * beforeEach(beforeEachHook);
 * afterAll(afterAllHook);
 *
 * // Use mocks directly or inject via factories:
 * setQStashClientFactoryForTests(() => new mocks.qstash.Client({ token: "test" }));
 * // ... tests that call getQStashClient() will use the mock
 * ```
 */
export function createUpstashTestHooks():
⋮----
/**
 * Full setup helper that registers mocks AND returns lifecycle hooks.
 * Combines registerUpstashMocksWithVitest() and createUpstashTestHooks().
 *
 * @example
 * ```ts
 * import { setupUpstashTestEnvironment } from "@/test/upstash/setup";
 * import { beforeEach, afterAll } from "vitest";
 *
 * const { beforeEachHook, afterAllHook, mocks } = setupUpstashTestEnvironment();
 * beforeEach(beforeEachHook);
 * afterAll(afterAllHook);
 * ```
 */
export function setupUpstashTestEnvironment():
````

## File: src/test/utils/with-fake-timers.ts
````typescript
/**
 * @fileoverview Selective fake timer utility for Vitest tests.
 *
 * This utility provides opt-in fake timer support for tests that need to control time.
 * Unlike global fake timers, this approach only applies timers to tests that explicitly
 * need them, reducing overhead for tests that don't manipulate time.
 *
 * @example
 * ```typescript
 * import { withFakeTimers } from '@/test/utils/with-fake-timers';
 *
 * test('handles debounced input', withFakeTimers(async () => {
 *   const { getByRole } = render(<SearchInput />);
 *   const input = getByRole('textbox');
 *
 *   fireEvent.change(input, { target: { value: 'test' } });
 *   vi.advanceTimersByTime(300); // Advance debounce timer
 *
 *   await waitFor(() => {
 *     expect(mockSearch).toHaveBeenCalled();
 *   });
 * }));
 * ```
 */
⋮----
import { vi } from "vitest";
⋮----
/**
 * Wraps a test function with fake timer setup and cleanup.
 *
 * This utility automatically:
 * - Enables fake timers before the test
 * - Runs pending timers after the test
 * - Clears all timers
 * - Restores real timers
 *
 * @param testFn The test function to wrap with fake timers
 * @returns A wrapped test function that uses fake timers
 */
export const withFakeTimers = (
  testFn: () => void | Promise<void>
): (() => Promise<void>) =>
⋮----
/**
 * Options for fake timer configuration.
 */
export interface FakeTimersOptions {
  /**
   * When true, time advances automatically during await expressions.
   * Essential for tests that combine fake timers with async operations like MSW.
   * @default false
   */
  shouldAdvanceTime?: boolean;
}
⋮----
/**
   * When true, time advances automatically during await expressions.
   * Essential for tests that combine fake timers with async operations like MSW.
   * @default false
   */
⋮----
/**
 * Creates a test context with fake timers enabled.
 * Use this in beforeEach/afterEach when multiple tests in a suite need fake timers.
 *
 * @param options - Configuration for fake timers
 * @example
 * ```typescript
 * import { createFakeTimersContext } from '@/test/utils/with-fake-timers';
 *
 * describe('Time-dependent suite', () => {
 *   // Use shouldAdvanceTime when combining with async operations (MSW, fetch)
 *   const timers = createFakeTimersContext({ shouldAdvanceTime: true });
 *
 *   beforeEach(timers.setup);
 *   afterEach(timers.teardown);
 *
 *   test('debounced search', async () => {
 *     fireEvent.change(input, { target: { value: 'test' } });
 *     await act(async () => {
 *       vi.advanceTimersByTime(350);
 *       await vi.runAllTimersAsync();
 *     });
 *     expect(mockSearch).toHaveBeenCalled();
 *   });
 * });
 * ```
 */
export const createFakeTimersContext = (options: FakeTimersOptions =
````

## File: src/test/setup.ts
````typescript
/**
 * @fileoverview Shared DOM shims used across Vitest projects.
 *
 * Some component libraries assume these DOM APIs exist; jsdom omits them.
 * Guarded so non-DOM test projects (e.g. node) can still load this file.
 */
````

## File: src/test/test-utils.tsx
````typescript
import type { QueryClient } from "@tanstack/react-query";
import { QueryClientProvider } from "@tanstack/react-query";
import type { RenderOptions } from "@testing-library/react";
import { render } from "@testing-library/react";
import type { ComponentProps, ReactElement, ReactNode } from "react";
import { ThemeProvider } from "@/components/providers/theme-provider";
import { getTestQueryClient, resetTestQueryClient } from "./helpers/query-client";
⋮----
type ThemeProviderProps = ComponentProps<typeof ThemeProvider>;
⋮----
// Props for the AllTheProviders component.
export interface ProvidersProps {
  // The child components to render.
  children: ReactNode;
  // Optional theme configuration.
  theme?: ThemeProviderProps;
  // Optional QueryClient instance.
  queryClient?: QueryClient;
}
⋮----
// The child components to render.
⋮----
// Optional theme configuration.
⋮----
// Optional QueryClient instance.
⋮----
// Options for renderWithProviders function.
export interface RenderWithProvidersOptions extends Omit<RenderOptions, "wrapper"> {
  /** Optional theme configuration. */
  theme?: ProvidersProps["theme"];
  /** Optional QueryClient instance. */
  queryClient?: ProvidersProps["queryClient"];
}
⋮----
/** Optional theme configuration. */
⋮----
/** Optional QueryClient instance. */
⋮----
// biome-ignore lint/style/useNamingConvention: React components should be PascalCase
export const AllTheProviders = ({
  children,
  theme = DEFAULT_THEME,
  queryClient,
}: ProvidersProps): ReactElement =>
⋮----
export const renderWithProviders = (
  ui: ReactElement,
  { theme, queryClient, ...options }: RenderWithProvidersOptions = {}
) =>
⋮----
const wrapper = ({ children }: { children: ReactNode }) => (
    <AllTheProviders theme={theme} queryClient={queryClient}>
      {children}
    </AllTheProviders>
  );
⋮----
// Explicit re-exports from testing-library (commonly used across tests)
````

## File: src/instrumentation.ts
````typescript
/**
 * @fileoverview Next.js instrumentation hook for OpenTelemetry server-side tracing.
 *
 * This file is automatically executed by Next.js before the application starts.
 * It initializes @vercel/otel to enable automatic instrumentation of Route Handlers,
 * Server Components, and Middleware.
 */
⋮----
import { registerOTel } from "@vercel/otel";
import { TELEMETRY_SERVICE_NAME } from "@/lib/telemetry/constants";
⋮----
/**
 * Registers OpenTelemetry instrumentation for the Next.js application.
 *
 * This function is called by Next.js during application startup to enable
 * server-side tracing. The @vercel/otel wrapper handles all the complexity
 * of setting up NodeSDK, resource detection, and Next.js-specific instrumentation.
 */
export async function register()
⋮----
// Initialize security modules on server runtime only
````

## File: playwright.config.ts
````typescript
/**
 * @fileoverview Playwright E2E test configuration.
 */
⋮----
import { defineConfig, devices } from "@playwright/test";
⋮----
// Default to 1 worker for test stability (tests may share state via mocked APIs).
// Set E2E_WORKERS=50% for CI parallel execution when tests are fully isolated.
⋮----
// Enable full parallelism only when workers > 1 and tests are isolated.
// Set E2E_FULLY_PARALLEL=true to enable after ensuring test isolation.
⋮----
// Allow dev server to boot in local/e2e without real Supabase credentials.
⋮----
// Workers accepts number, percentage string ("50%"), or undefined for auto.
````

## File: tsconfig.json
````json
{
  "compilerOptions": {
    "allowJs": true,
    "esModuleInterop": true,
    "incremental": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "lib": ["dom", "dom.iterable", "esnext"],
    "module": "esnext",
    "moduleResolution": "bundler",
    "noEmit": true,
    "paths": {
      "@/*": ["./src/*"],
      "@schemas/*": ["./src/domain/schemas/*"],
      "@domain/*": ["./src/domain/*"],
      "@ai/*": ["./src/ai/*"]
    },
    "typeRoots": ["./@types", "./node_modules/@types"],
    "plugins": [
      {
        "name": "next"
      }
    ],
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true,
    "target": "ES2017"
  },
  "exclude": ["node_modules"],
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ]
}
````

## File: src/ai/agents/agent-factory.ts
````typescript
/**
 * @fileoverview Factory for creating TripSage agents using AI SDK v6 ToolLoopAgent.
 *
 * Provides a centralized factory function for instantiating ToolLoopAgent
 * instances with consistent configuration, telemetry, and error handling.
 * Agents created through this factory automatically receive:
 *
 * - Telemetry spans for observability
 * - Token budget clamping
 * - Tool call repair for invalid inputs
 * - Consistent stop conditions
 */
⋮----
import type { LanguageModel, StopCondition, SystemModelMessage, ToolSet } from "ai";
import {
  asSchema,
  generateText,
  InvalidToolInputError,
  NoSuchToolError,
  Output,
  stepCountIs,
  ToolLoopAgent,
} from "ai";
import {
  hasInjectionRisk,
  isFilteredValue,
  sanitizeWithInjectionDetection,
} from "@/lib/security/prompt-sanitizer";
import { secureUuid } from "@/lib/security/random";
import { createServerLogger } from "@/lib/telemetry/logger";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
⋮----
import { normalizeInstructions } from "./instructions";
import type {
  AgentDependencies,
  StructuredOutput,
  TripSageAgentConfig,
  TripSageAgentResult,
} from "./types";
⋮----
/**
 * Default maximum tool execution steps for agents.
 * Allows complex multi-tool workflows while preventing infinite loops.
 */
⋮----
/** Maximum number of tool repair attempts to avoid runaway costs. */
⋮----
/**
 * Default temperature for agent generation.
 * Slightly lower than default for more consistent planning outputs.
 */
⋮----
/**
 * Creates a TripSage agent using AI SDK v6 ToolLoopAgent.
 *
 * Instantiates a reusable agent for autonomous multi-step reasoning with tool calling.
 * Runs until a stop condition is met (default: stepCountIs(maxSteps)).
 *
 * Supports dynamic configuration via callOptionsSchema/prepareCall, per-step
 * tool/model selection via prepareStep, step-level telemetry via onStepFinish,
 * structured output, tool filtering, and custom stop conditions.
 *
 * @template TTools - Tool set type for the agent.
 * @template CallOptionsType - Call options type from callOptionsSchema.
 * @template OutputType - Output type for structured results.
 * @param deps - Runtime dependencies including model and identifiers.
 * @param config - Agent configuration including tools and instructions.
 * @returns Configured ToolLoopAgent instance with metadata.
 *
 * @example
 * ```typescript
 * const { agent, agentType, modelId } = createTripSageAgent(deps, {
 *   agentType: "budgetPlanning",
 *   name: "Budget Agent",
 *   instructions: buildBudgetPrompt(input),
 *   tools: buildBudgetTools(deps.identifier),
 *   maxSteps: 10,
 *   prepareStep: async ({ stepNumber }) => {
 *     if (stepNumber <= 2) return { activeTools: ['webSearch'] };
 *     return {};
 *   },
 * });
 *
 * // Stream the agent response
 * const stream = agent.stream({ prompt: userMessage });
 * ```
 */
export function createTripSageAgent<
  TagentTools extends ToolSet,
  CallOptionsType = never,
  OutputType = unknown,
>(
  deps: AgentDependencies,
  config: TripSageAgentConfig<TagentTools, CallOptionsType, OutputType>
): TripSageAgentResult<TagentTools, CallOptionsType, OutputType>
⋮----
// Note: output is NOT passed to ToolLoopAgent constructor.
// It should be passed when calling agent.generate() or agent.stream().
⋮----
// Build stop conditions: combine default step count with custom conditions
const buildStopConditions = ():
    | StopCondition<TagentTools>
    | StopCondition<TagentTools>[] => {
    const defaultCondition = stepCountIs(maxSteps);
⋮----
// Wrap onStepFinish to add telemetry
⋮----
// Record telemetry event for step completion
⋮----
// Call options schema for type-safe runtime configuration
⋮----
// Prepare call function for dynamic configuration
// Note: prepareCall must return the full settings object, not partial
⋮----
// Normalize instructions to handle potential array input
type InstructionValue = string | SystemModelMessage;
const normalizeInstructionInput = (
              input: InstructionValue | Array<InstructionValue | undefined> | undefined
): string =>
⋮----
// Sanitize instructions to prevent prompt injection attacks
⋮----
5000 // Reasonable limit for agent instructions
⋮----
// Security monitoring: log if injection patterns were detected
⋮----
// Return merged settings - prepareCall can override any setting
⋮----
// Prepare step function for per-step configuration
⋮----
// Step finish callback with telemetry
⋮----
// Active tools subset
⋮----
// Experimental: Automatic tool call repair for malformed inputs
// biome-ignore lint/style/useNamingConvention: AI SDK property name
⋮----
// Don't attempt to fix invalid tool names
⋮----
// Only repair invalid input errors
⋮----
// Get the tool definition
⋮----
const parseRawInput = () =>
⋮----
const attemptLocalRepair = async () =>
⋮----
// Without a validator, we can only return a stringified version of the raw input.
⋮----
const attemptModelRepair = async (modelId: string, model: LanguageModel) =>
⋮----
// Telemetry settings
// biome-ignore lint/style/useNamingConvention: AI SDK API uses snake_case
⋮----
// Core configuration
⋮----
// Generation parameters
⋮----
/**
 * Type guard to check if an error is a tool-related error.
 *
 * @param error - The error to check.
 * @returns True if the error is a NoSuchToolError or InvalidToolInputError.
 */
export function isToolError(
  error: unknown
): error is NoSuchToolError | InvalidToolInputError
````

## File: src/ai/agents/chat-agent.ts
````typescript
/**
 * @fileoverview Chat agent for travel planning conversations.
 *
 * Reusable AI SDK v6 ToolLoopAgent that provides autonomous multi-step reasoning
 * over all travel planning tools. Supports dynamic memory injection, context window
 * management, and type-safe runtime configuration via callOptionsSchema/prepareCall/prepareStep.
 */
⋮----
import { CHAT_DEFAULT_SYSTEM_PROMPT } from "@ai/constants";
import { toolRegistry } from "@ai/tools";
import { wrapToolsWithUserId } from "@ai/tools/server/injection";
import type { ModelMessage, ToolSet, UIMessage } from "ai";
import { convertToModelMessages } from "ai";
import { z } from "zod";
import { extractTexts, validateImageAttachments } from "@/app/api/_helpers/attachments";
import { createServerLogger } from "@/lib/telemetry/logger";
import type { ChatMessage } from "@/lib/tokens/budget";
import { clampMaxTokens, countTokens } from "@/lib/tokens/budget";
import { getModelContextLimit } from "@/lib/tokens/limits";
⋮----
import { createTripSageAgent } from "./agent-factory";
import { extractTextFromContent, normalizeInstructions } from "./instructions";
import type { AgentDependencies, TripSageAgentResult } from "./types";
⋮----
/**
 * Call options schema for the chat agent (AI SDK v6).
 *
 * Enables type-safe runtime configuration when calling agent.generate() or agent.stream().
 * These options are passed through prepareCall to dynamically configure the agent.
 */
⋮----
/** Optional memory summary to inject into system prompt. */
⋮----
/** Optional session ID for context tracking. */
⋮----
/** User ID for user-scoped tool operations. */
⋮----
/** TypeScript type for chat agent call options. */
export type ChatCallOptions = z.infer<typeof chatCallOptionsSchema>;
⋮----
/**
 * Configuration for creating the chat agent.
 */
export interface ChatAgentConfig {
  /** System prompt, can be extended with memory context. */
  systemPrompt?: string;

  /** Optional memory summary to append to system prompt. */
  memorySummary?: string;

  /** Desired max output tokens before clamping. */
  desiredMaxTokens?: number;

  /** Maximum tool execution steps. */
  maxSteps?: number;

  /** Tools that require user ID injection for user-scoped operations. */
  userScopedTools?: string[];

  /** Enable call options schema for dynamic configuration. */
  useCallOptions?: boolean;
}
⋮----
/** System prompt, can be extended with memory context. */
⋮----
/** Optional memory summary to append to system prompt. */
⋮----
/** Desired max output tokens before clamping. */
⋮----
/** Maximum tool execution steps. */
⋮----
/** Tools that require user ID injection for user-scoped operations. */
⋮----
/** Enable call options schema for dynamic configuration. */
⋮----
/**
 * Validation result for chat messages.
 */
export interface ChatValidationResult {
  valid: boolean;
  error?: string;
  reason?: string;
}
⋮----
/**
 * Validates chat messages for the chat agent.
 *
 * Checks for valid attachment types and message structure.
 *
 * @param messages - UI messages to validate.
 * @returns Validation result with error details if invalid.
 */
export function validateChatMessages(messages: UIMessage[]): ChatValidationResult
⋮----
/**
 * Creates the main chat agent for conversational travel planning.
 *
 * Returns a reusable ToolLoopAgent instance supporting dynamic configuration
 * via callOptionsSchema, memory/context injection, and context window management.
 *
 * @param deps - Runtime dependencies including model and identifiers.
 * @param messages - UI messages for context.
 * @param config - Chat agent configuration.
 * @returns Configured ToolLoopAgent for chat.
 *
 * @example
 * ```typescript
 * const { agent } = createChatAgent(deps, messages, {
 *   memorySummary: "User prefers boutique hotels.",
 * });
 * const stream = agent.stream({ prompt: userMessage });
 * ```
 *
 * @example With dynamic call options
 * ```typescript
 * const { agent } = createChatAgent(deps, messages, { useCallOptions: true });
 * const stream = agent.stream({
 *   prompt: userMessage,
 *   options: { userId: "user_123", memorySummary: "..." },
 * });
 * ```
 */
export function createChatAgent(
  deps: AgentDependencies,
  messages: UIMessage[],
  config: ChatAgentConfig = {}
): TripSageAgentResult<ToolSet, ChatCallOptions>
⋮----
// Build base system prompt with optional memory context
⋮----
// Extract text parts for token counting
⋮----
// Token budgeting: clamp max output tokens based on prompt length
⋮----
// Build tools with user ID injection for user-scoped operations
⋮----
// Use the centralized agent factory with AI SDK v6 features
⋮----
agentType: "router", // Chat agent acts as the main router
// AI SDK v6: Call options schema for dynamic configuration
⋮----
// AI SDK v6: Prepare call function for dynamic memory injection
⋮----
// Inject memory summary into instructions at runtime
⋮----
// AI SDK v6: Prepare step for context management in long conversations
⋮----
// Compress conversation history for longer loops to stay within context limits
⋮----
// Preserve earliest message to maintain conversational continuity
⋮----
...stepMessages.slice(-15), // Keep last 15 messages
⋮----
// Re-export default system prompt for external consumers (e.g., API handlers)
⋮----
/**
 * Converts UI messages to model messages for agent context.
 *
 * @param messages - UI messages to convert.
 * @returns Model messages for agent prompt.
 */
export function toModelMessages(messages: UIMessage[]): ModelMessage[]
````

## File: src/ai/agents/index.ts
````typescript
/**
 * @fileoverview Registry and helpers for constructing TripSage ToolLoopAgent workflows.
 */
⋮----
import type { AgentWorkflowKind } from "@schemas/agents";
import type { AgentConfig } from "@schemas/configuration";
⋮----
import { createAccommodationAgent } from "./accommodation-agent";
import { createBudgetAgent } from "./budget-agent";
import { createDestinationAgent } from "./destination-agent";
import { createFlightAgent } from "./flight-agent";
import { createItineraryAgent } from "./itinerary-agent";
import type { AgentDependencies } from "./types";
⋮----
// Re-export all agent creators for direct imports
⋮----
// Re-export factory and types
⋮----
// Memory agent (uses streamText, not ToolLoopAgent)
⋮----
// Router agent (uses generateText with Output.object, not ToolLoopAgent)
⋮----
type AgentRegistry = {
  accommodationSearch: typeof createAccommodationAgent;
  budgetPlanning: typeof createBudgetAgent;
  destinationResearch: typeof createDestinationAgent;
  flightSearch: typeof createFlightAgent;
  itineraryPlanning: typeof createItineraryAgent;
};
⋮----
/** Registry of agent factory functions. */
⋮----
/** Agent workflow kinds supported by the registry. Excludes 'memoryUpdate' and 'router'. */
export type SupportedAgentKind = keyof AgentRegistry;
⋮----
/**
 * Checks if an agent workflow kind is supported by the registry.
 *
 * @param kind - Agent workflow kind to check.
 * @returns True if the kind is supported.
 */
export function isSupportedAgentKind(
  kind: AgentWorkflowKind
): kind is SupportedAgentKind
⋮----
/**
 * Creates an agent for the specified workflow kind.
 *
 * @param kind - Agent workflow kind.
 * @param deps - Runtime dependencies.
 * @param config - Agent configuration.
 * @param input - Workflow-specific input.
 * @returns Configured ToolLoopAgent instance.
 * @throws Error if the agent kind is not supported.
 */
export function createAgentForWorkflow(
  kind: "accommodationSearch",
  deps: AgentDependencies,
  config: AgentConfig,
  input: Parameters<typeof createAccommodationAgent>[2]
): ReturnType<typeof createAccommodationAgent>;
export function createAgentForWorkflow(
  kind: "budgetPlanning",
  deps: AgentDependencies,
  config: AgentConfig,
  input: Parameters<typeof createBudgetAgent>[2]
): ReturnType<typeof createBudgetAgent>;
export function createAgentForWorkflow(
  kind: "destinationResearch",
  deps: AgentDependencies,
  config: AgentConfig,
  input: Parameters<typeof createDestinationAgent>[2]
): ReturnType<typeof createDestinationAgent>;
export function createAgentForWorkflow(
  kind: "flightSearch",
  deps: AgentDependencies,
  config: AgentConfig,
  input: Parameters<typeof createFlightAgent>[2]
): ReturnType<typeof createFlightAgent>;
export function createAgentForWorkflow(
  kind: "itineraryPlanning",
  deps: AgentDependencies,
  config: AgentConfig,
  input: Parameters<typeof createItineraryAgent>[2]
): ReturnType<typeof createItineraryAgent>;
export function createAgentForWorkflow(
  kind: SupportedAgentKind,
  deps: AgentDependencies,
  config: AgentConfig,
  input: Parameters<AgentRegistry[SupportedAgentKind]>[2]
): ReturnType<AgentRegistry[SupportedAgentKind]>
⋮----
/**
 * Gets the human-readable name for an agent workflow kind.
 *
 * @param kind - Agent workflow kind.
 * @returns Human-readable agent name.
 */
export function getAgentName(kind: AgentWorkflowKind): string
⋮----
/**
 * Gets the minimum max-step floor for an agent workflow kind.
 *
 * @param kind - Agent workflow kind.
 * @returns Minimum max steps enforced by the agent.
 */
export function getMinimumMaxSteps(kind: AgentWorkflowKind): number
````

## File: src/ai/lib/registry-utils.ts
````typescript
/**
 * @fileoverview Registry utilities for AI tools with telemetry and validation.
 *
 * Provides strongly-typed helpers for accessing and executing tools from
 * the shared tool registry with validation and telemetry integration.
 */
⋮----
import type { toolRegistry } from "@ai/tools";
import type { Tool, ToolCallOptions } from "ai";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/** Strongly typed view of a tool from the shared registry; enforces execute presence. */
export type RegisteredTool<Params = unknown, Result = unknown> = Tool<
  Params,
  Result
> & {
  name?: string;
  description?: string;
  inputSchema?: unknown;
  execute: (params: Params, callOptions?: ToolCallOptions) => Promise<Result> | Result;
};
⋮----
/** Validate a registry entry is present and executable. @throws Error if missing or lacks execute. */
export const requireTool = <Params, Result>(
  tool: unknown,
  name: string
): RegisteredTool<Params, Result> =>
⋮----
/** Fetch a named tool from the registry with validation and typing. */
export const getRegistryTool = <Params, Result>(
  registry: typeof toolRegistry,
  name: keyof typeof registry
): RegisteredTool<Params, Result>
⋮----
/** Execute a registry tool and normalize to a Promise-based result. */
export const invokeTool = <Params, Result>(
  tool: RegisteredTool<Params, Result>,
  params: Params,
  callOptions?: ToolCallOptions
): Promise<Result> =>
````

## File: src/ai/tools/schemas/flights.ts
````typescript
/**
 * @fileoverview Flight tool model output schemas.
 */
⋮----
import { z } from "zod";
⋮----
// ===== MODEL OUTPUT SCHEMAS =====
⋮----
/** Segment within a flight itinerary for model consumption. */
⋮----
/** Itinerary entry for model consumption. */
⋮----
/** Slice within an offer for model consumption. */
⋮----
/** Offer entry for model consumption. */
⋮----
/** Flight search result output schema for model consumption. */
⋮----
export type FlightModelOutput = z.infer<typeof flightModelOutputSchema>;
````

## File: src/ai/tools/schemas/maps.ts
````typescript
/**
 * @fileoverview Zod schemas for maps API responses and maps tool inputs.
 *
 * Core schemas: Maps/geocoding API parameters and data structures
 * Tool schemas: Input validation for maps tools (geocode, distance matrix)
 */
⋮----
import { upstreamGeocodeResultSchema } from "@schemas/api";
import { z } from "zod";
⋮----
/** Schema for geocode tool input. */
⋮----
/** Schema for distance matrix tool input. */
⋮----
// ===== TOOL OUTPUT SCHEMAS =====
⋮----
/** Schema for geocode tool output. */
⋮----
/** Schema for distance matrix tool output. */
````

## File: src/ai/tools/schemas/planning.ts
````typescript
/**
 * @fileoverview Zod schemas for travel planning API responses and travel planning tool inputs.
 *
 * Core schemas: Travel planning API parameters and data structures
 * Tool schemas: Input validation for travel planning tools (create plan, combine results, save plan)
 */
⋮----
import { z } from "zod";
⋮----
/** Schema for combineSearchResults tool input. */
⋮----
/** Schema for createTravelPlan tool input. */
⋮----
/** Schema for saveTravelPlan tool input. */
⋮----
/** Schema for updateTravelPlan tool input. */
⋮----
// ===== TOOL OUTPUT SCHEMAS =====
⋮----
/**
 * Schema for createTravelPlan tool response.
 *
 * Represents either an error response or a successful plan creation result.
 */
⋮----
/** TypeScript type for createTravelPlan tool response. */
export type CreateTravelPlanResponse = z.infer<typeof createTravelPlanResponseSchema>;
⋮----
/**
 * Schema for saveTravelPlan tool response.
 *
 * Represents either an error response or a successful plan save result.
 */
⋮----
/** TypeScript type for saveTravelPlan tool response. */
export type SaveTravelPlanResponse = z.infer<typeof saveTravelPlanResponseSchema>;
⋮----
/**
 * Schema for updateTravelPlan tool response.
 *
 * Represents either an error response or a successful plan update result.
 */
⋮----
/** TypeScript type for updateTravelPlan tool response. */
export type UpdateTravelPlanResponse = z.infer<typeof updateTravelPlanResponseSchema>;
⋮----
/**
 * Schema for combineSearchResults tool response.
 *
 * Represents either an error response or a successful combine result.
 */
⋮----
/** TypeScript type for combineSearchResults tool response. */
export type CombineSearchResultsResponse = z.infer<
  typeof combineSearchResultsResponseSchema
>;
⋮----
/**
 * Schema for deleteTravelPlan tool response.
 */
⋮----
/** TypeScript type for deleteTravelPlan tool response. */
export type DeleteTravelPlanResponse = z.infer<typeof deleteTravelPlanResponseSchema>;
````

## File: src/ai/tools/schemas/tools.ts
````typescript
/**
 * @fileoverview Zod v4 schemas for tool execution, travel advisory, and error handling.
 */
⋮----
import { z } from "zod";
⋮----
/** Zod schema for travel advisory safety category. */
⋮----
/** TypeScript type for safety category. */
export type SafetyCategory = z.infer<typeof safetyCategorySchema>;
⋮----
/** Zod schema for travel advisory safety result. */
⋮----
/** TypeScript type for safety result. */
export type SafetyResult = z.infer<typeof safetyResultSchema>;
⋮----
/** Zod schema for tool execution user context. */
⋮----
/** TypeScript type for user context. */
export type UserContext = z.infer<typeof userContextSchema>;
⋮----
/** Zod schema for tool execution dependencies. */
⋮----
now: z.function().optional(), // Function returning number (not serializable)
redis: z.unknown().optional(), // Redis client (not serializable)
⋮----
/** TypeScript type for execution dependencies. */
export type ExecutionDeps = z.infer<typeof executionDepsSchema>;
⋮----
/** Zod schema for approval context. */
⋮----
requireApproval: z.function().optional(), // Function (not serializable)
⋮----
/** TypeScript type for approval context. */
export type ApprovalContext = z.infer<typeof approvalContextSchema>;
⋮----
/** Zod schema for tool execution context (combines user, deps, and approval). */
⋮----
/** TypeScript type for tool execution context. */
export type ToolExecutionContext = z.infer<typeof toolExecutionContextSchema>;
⋮----
/** Zod schema for rate limit result. */
⋮----
/** TypeScript type for rate limit result. */
export type RateLimitResult = z.infer<typeof rateLimitResultSchema>;
⋮----
/** Zod schema for tool error codes (matches TOOL_ERROR_CODES constant). */
⋮----
/** TypeScript type for tool error codes. */
export type ToolErrorCode = z.infer<typeof toolErrorCodeSchema>;
⋮----
/** Zod schema for tool error details. */
⋮----
/** TypeScript type for tool error (extends Error at runtime). */
export type ToolError = z.infer<typeof toolErrorSchema> & Error;
⋮----
/** Zod schema for approval status. */
⋮----
/** TypeScript type for approval status. */
export type ApprovalStatus = z.infer<typeof approvalStatusSchema>;
````

## File: src/ai/tools/schemas/travel-advisory.ts
````typescript
/**
 * @fileoverview Centralized Zod schemas for travel advisory tools.
 *
 * Contains input validation schemas for getTravelAdvisory tool.
 */
⋮----
import { safetyResultSchema } from "@ai/tools/schemas/tools";
import { z } from "zod";
⋮----
/** Schema for travel advisory tool input. */
⋮----
// ===== TOOL OUTPUT SCHEMAS =====
⋮----
/** Schema for travel advisory tool output. */
⋮----
/** TypeScript type for travel advisory tool output. */
export type TravelAdvisoryOutput = z.infer<typeof travelAdvisoryOutputSchema>;
````

## File: src/ai/tools/schemas/web-crawl.ts
````typescript
/**
 * @fileoverview Zod schemas for web crawl API responses and web crawl tool inputs.
 *
 * Core schemas: Web crawl API parameters and data structures
 * Tool schemas: Input validation for web crawl tools (site crawling)
 */
⋮----
import { z } from "zod";
⋮----
/** Schema for crawl URL tool input. */
⋮----
/** Schema for crawl site tool input. */
⋮----
// ===== TOOL OUTPUT SCHEMAS =====
⋮----
/** Schema for crawl URL tool output. */
⋮----
/** Schema for crawl site tool output. */
````

## File: src/ai/tools/schemas/web-search-batch.ts
````typescript
/**
 * @fileoverview Zod schemas for web search batch API responses and web search batch tool inputs.
 *
 * Core schemas: Web search batch API parameters and data structures
 * Tool schemas: Input validation for web search batch tools (batch search)
 */
⋮----
import { z } from "zod";
⋮----
/** Schema for web search batch tool input. */
⋮----
// ===== MODEL OUTPUT SCHEMAS =====
⋮----
/** Individual search result for model consumption. */
⋮----
/** Per-query result value for model consumption. */
⋮----
/** Per-query result entry for model consumption. */
⋮----
/** Web search batch result output schema for model consumption. */
⋮----
export type WebSearchBatchModelOutput = z.infer<typeof webSearchBatchModelOutputSchema>;
````

## File: src/ai/tools/server/activities.ts
````typescript
/**
 * @fileoverview AI SDK v6 tools for activity search and details.
 *
 * Provides searchActivities and getActivityDetails tools for use in chat/agents.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import type { ActivityModelOutput } from "@ai/tools/schemas/activities";
import { createToolError, TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import { getActivitiesService } from "@domain/activities/container";
import { activitySchema, activitySearchParamsSchema } from "@schemas/search";
import { z } from "zod";
⋮----
/**
 * Output schema for activity search tool.
 */
⋮----
/**
 * Search for activities using Google Places API (New) with optional AI fallback.
 *
 * Supports searching by destination, category, date, and other filters.
 * Returns activities from Google Places, with AI/web suggestions when Places
 * results are insufficient.
 */
⋮----
// userId will be extracted from request context if available
⋮----
/**
   * Simplifies activity search results for model consumption to reduce token usage.
   * Strips images array, coordinates, and limits to essential identifying/decision info.
   */
⋮----
/**
 * Input schema for getActivityDetails tool.
 */
⋮----
/**
 * Retrieve detailed information for a specific activity by Google Place ID.
 *
 * Returns comprehensive activity details including photos, ratings, descriptions,
 * and location information.
 */
⋮----
// userId will be extracted from request context if available
````

## File: src/ai/tools/server/errors.ts
````typescript
/**
 * @fileoverview Canonical tool error helpers for AI tools.
 *
 * Centralizes error codes and constructors to ensure consistent error handling
 * across all AI tools and agents. Runtime-only; schemas live under
 * `@ai/tools/schemas/tools`.
 */
⋮----
import type { ToolError, ToolErrorCode } from "@ai/tools/schemas/tools";
import { toolErrorSchema } from "@ai/tools/schemas/tools";
⋮----
// Re-export types from schemas so callers only depend on this runtime module.
⋮----
/**
 * Tool error codes organized by category.
 *
 * Each tool namespace has its own error codes for clarity and observability.
 * Property names use camelCase per TypeScript conventions; string values use
 * snake_case for API/log compatibility.
 */
⋮----
// Accommodation errors
⋮----
// Approval errors
⋮----
// General tool errors
⋮----
// Web search errors
⋮----
/**
 * Create a standardized tool error.
 *
 * @param code Error code from TOOL_ERROR_CODES.
 * @param message Optional error message (defaults to code).
 * @param meta Optional metadata for observability.
 * @returns ToolError instance (validated via Zod schema).
 */
export function createToolError(
  code: ToolErrorCode,
  message?: string,
  meta?: Record<string, unknown>
): ToolError
⋮----
// Normalize name to satisfy tooling/schema expectations.
⋮----
// Validate error structure using Zod schema for early feedback.
⋮----
/**
 * Check if an error is a ToolError.
 *
 * @param err Error to check.
 * @returns True if error has a recognized tool error code.
 */
export function isToolError(err: unknown): err is ToolError
````

## File: src/ai/tools/server/flights.ts
````typescript
/**
 * @fileoverview Flight search tool using Duffel API v2 (offers request).
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import type { FlightModelOutput } from "@ai/tools/schemas/flights";
import {
  createToolError,
  isToolError,
  TOOL_ERROR_CODES,
} from "@ai/tools/server/errors";
import { searchFlightsService } from "@domain/flights/service";
import type { FlightSearchRequest, FlightSearchResult } from "@schemas/flights";
import { flightSearchRequestSchema, flightSearchResultSchema } from "@schemas/flights";
import { hashInputForCache } from "@/lib/cache/hash";
import { canonicalizeParamsForCache } from "@/lib/cache/keys";
⋮----
type SearchFlightsInput = FlightSearchRequest;
type SearchFlightsResult = FlightSearchResult;
⋮----
// Map provider errors to canonical ToolErrors for consistency and observability
⋮----
/**
   * Simplifies flight results for model consumption to reduce token usage.
   * Strips sources, bookingUrl, schemaVersion, and simplifies segment details.
   */
````

## File: src/ai/tools/server/google-places.ts
````typescript
/**
 * @fileoverview Google Places API POI lookup tool.
 *
 * Provides point-of-interest lookup using Google Places API (New) Text Search
 * with caching and rate limiting. Uses Google Maps Geocoding API for
 * destination-based lookups. Complies with Google Maps Platform policies:
 * - place_id can be stored indefinitely
 * - lat/lng cached for max 30 days
 * - Field masks used to minimize costs
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import {
  lookupPoiInputSchema,
  lookupPoiResponseSchema,
} from "@ai/tools/schemas/google-places";
import { TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import { upstreamPlacesSearchResponseSchema } from "@schemas/api";
import { hashInputForCache } from "@/lib/cache/hash";
import { canonicalizeParamsForCache } from "@/lib/cache/keys";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import { postPlacesSearch } from "@/lib/google/client";
import { resolveLocationToLatLng } from "@/lib/google/places-geocoding";
⋮----
/** Normalized POI result structure matching Google Places API (New) fields. */
type NormalizedPoi = {
  placeId: string;
  name: string;
  lat: number;
  lon: number;
  types?: string[];
  rating?: number;
  userRatingCount?: number;
  formattedAddress?: string;
  photoName?: string;
  url?: string;
};
⋮----
/**
 * Fetch POIs from Google Places API (New) Text Search.
 *
 * Uses centralized client with retry logic and Zod validation.
 * Returns normalized POI array with place_id, location, and essential fields.
 *
 * @param query Search query (e.g., "restaurants in Tokyo").
 * @param locationBias Optional location bias circle.
 * @param apiKey Google Maps server API key.
 * @returns Promise resolving to normalized POI array.
 */
async function fetchPoisFromPlacesApi(
  query: string,
  locationBias: { lat: number; lon: number; radiusMeters: number } | null,
  apiKey: string
): Promise<NormalizedPoi[]>
⋮----
// Filter and map places with valid coordinates
⋮----
/**
 * Tool for looking up points of interest near a destination or coordinate.
 *
 * Uses Google Places API (New) Text Search with field mask to minimize costs.
 * Returns normalized POI array with place_id, location, and essential fields only.
 *
 * @param params Input parameters (destination, query, lat/lon, radius).
 * @returns Promise resolving to lookup results.
 */
⋮----
/**
   * Simplifies POI results for model consumption to reduce token usage.
   * Strips photoName, url, formattedAddress, inputs echo, and limits types.
   */
````

## File: src/ai/tools/server/maps.ts
````typescript
/**
 * @fileoverview Google Maps tools: geocode, distance matrix.
 *
 * Uses centralized client functions with retry logic and Zod validation.
 * Distance matrix uses Google Routes API computeRouteMatrix.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import {
  distanceMatrixInputSchema,
  distanceMatrixOutputSchema,
  geocodeInputSchema,
  geocodeOutputSchema,
} from "@ai/tools/schemas/maps";
import { TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import {
  upstreamGeocodeResponseSchema,
  upstreamRouteMatrixResponseSchema,
} from "@schemas/api";
import { hashInputForCache } from "@/lib/cache/hash";
import { canonicalizeParamsForCache } from "@/lib/cache/keys";
import { getGoogleMapsServerKey } from "@/lib/env/server";
import {
  getGeocode,
  parseNdjsonResponse,
  postComputeRouteMatrix,
} from "@/lib/google/client";
⋮----
/** Get Google Maps server API key or null if not configured. */
function getGmapsKeyOrNull(): string | null
⋮----
function normalizeLocationString(value: string): string
⋮----
/**
 * Tool for geocoding a location using Google Maps Geocoding API.
 *
 * Uses centralized client with retry logic and Zod validation.
 * Returns array of geocoding results with address, latitude, and longitude.
 *
 * @param address Location address to geocode.
 * @returns Promise resolving to geocoding results.
 */
⋮----
/**
 * Geocode an address to lat/lng coordinates.
 * Helper for distanceMatrix tool to convert addresses to waypoints.
 */
async function geocodeAddress(
  address: string,
  apiKey: string
): Promise<
⋮----
// Check API status - "OK" means successful geocoding
⋮----
// Check for results
⋮----
/**
 * Format duration from "Xs" string to human-readable format.
 */
function formatDuration(durationStr: string | undefined):
⋮----
// Use singular "min" for 0 and 1, plural "mins" for 2+
⋮----
/**
 * Format distance to human-readable format.
 */
function formatDistance(
  meters: number | undefined,
  units: string
):
⋮----
// 3.28084 is the precise conversion factor for meters to feet
⋮----
/**
 * Tool for computing distances between origins and destinations.
 *
 * Uses Google Routes API computeRouteMatrix.
 * Geocodes addresses to coordinates and returns normalized route matrix entries.
 *
 * @param origins Array of origin addresses.
 * @param destinations Array of destination addresses.
 * @param units Distance units ("metric" or "imperial").
 * @returns Promise resolving to distance matrix entries.
 */
⋮----
// Geocode all origins and destinations to coordinates
⋮----
// Check for geocoding failures - collect ALL failures
⋮----
// Type guard for coordinate objects - safer than type assertion
const isCoord = (x: unknown): x is
⋮----
// Type-narrow using type guard filter (safer than type assertion)
⋮----
// Build Routes API waypoints
⋮----
// Call Routes API computeRouteMatrix
⋮----
// Parse NDJSON stream: computeRouteMatrix returns newline-delimited JSON
````

## File: src/ai/tools/server/memory.ts
````typescript
/**
 * @fileoverview Memory tools backed by Supabase memories schema (server-only).
 *
 * Uses the canonical `memories.*` schema (memories.sessions, memories.turns)
 * for storing and retrieving conversational memory.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import { TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import {
  addConversationMemoryInputSchema,
  addConversationMemoryOutputSchema,
  searchUserMemoriesInputSchema,
  searchUserMemoriesOutputSchema,
} from "@schemas/memory";
import { handleMemoryIntent } from "@/lib/memory/orchestrator";
import { nowIso, secureUuid } from "@/lib/security/random";
import type { Database, Json } from "@/lib/supabase/database.types";
import { createServerSupabase } from "@/lib/supabase/server";
⋮----
/**
 * Tool for adding a conversation memory snippet to the user's memory.
 *
 * Stores a short memory snippet in the user's memory for later retrieval.
 * Returns the memory ID and creation timestamp.
 *
 * @param content Memory snippet content.
 * @param category Memory category (user preference, trip history, search pattern, conversation context, other).
 * @returns Promise resolving to memory ID and creation timestamp.
 */
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
/**
 * Tool for searching the user's recent memories by keyword.
 *
 * Searches the user's recent memories for items containing the specified keyword.
 * Returns a list of matching memory items with content, creation timestamp, and source.
 *
 * @param query Search keyword.
 * @param limit Maximum number of memories to return.
 * @returns Promise resolving to list of matching memory items.
 */
⋮----
// Prefer canonical timestamps/ids when present
// biome-ignore lint/style/useNamingConvention: Database field name
````

## File: src/ai/tools/server/planning.ts
````typescript
/**
 * @fileoverview Travel planning tools implemented with AI SDK v6.
 * Server-only execution with Redis persistence and optional memory logging.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import {
  combineSearchResultsInputSchema,
  combineSearchResultsResponseSchema,
  createTravelPlanInputSchema,
  createTravelPlanResponseSchema,
  deleteTravelPlanResponseSchema,
  saveTravelPlanInputSchema,
  saveTravelPlanResponseSchema,
  updateTravelPlanInputSchema,
  updateTravelPlanResponseSchema,
} from "@ai/tools/schemas/planning";
import { TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import { z } from "zod";
import { getRedis } from "@/lib/redis";
import { nowIso, secureUuid } from "@/lib/security/random";
import type { Database, Json } from "@/lib/supabase/database.types";
import { createServerSupabase } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
import { requireApproval } from "./approvals";
import {
  RATE_CREATE_PER_DAY,
  RATE_UPDATE_PER_MIN,
  TTL_DRAFT_SECONDS,
  TTL_FINAL_SECONDS,
} from "./constants";
import { type Plan, planSchema } from "./planning.schema";
⋮----
async function withPlannerSessionLock<T>(
  userId: string,
  fn: () => Promise<T>
): Promise<T>
⋮----
/** Generate Redis key for travel plan. */
function redisKeyForPlan(planId: string): string
⋮----
/** Coerce value to float. */
function coerceFloat(value: unknown): number
⋮----
/** Read value from object. */
function read<T = unknown>(obj: unknown, key: string): T | undefined
⋮----
/** Record travel plan memory.
 *
 * @param opts Options for recording the travel plan memory.
 * @param opts.userId User ID.
 * @param opts.content Content of the travel plan memory.
 * @param opts.metadata Metadata of the travel plan memory.
 * @returns Promise resolving to void.
 */
async function recordPlanMemory(opts: {
  userId: string;
  content: string;
  metadata?: Record<string, unknown>;
}): Promise<void>
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
/**
 * Convert travel plan to markdown summary.
 *
 * @param plan Travel plan to convert to markdown summary.
 * @returns Markdown summary of the travel plan.
 */
function toMarkdownSummary(plan: Plan): string
⋮----
/**
 * Tool for creating a new travel plan with destinations, dates, and budget.
 *
 * Creates a new travel plan with destinations, dates, and budget.
 * Returns the travel plan, plan ID, and success message.
 *
 * @param args Input parameters (budget, destinations, endDate, preferences, startDate, title, travelers, userId).
 * @returns Promise resolving to travel plan creation results.
 */
⋮----
/**
 * Tool for updating fields of an existing travel plan.
 *
 * Updates fields of an existing travel plan.
 * Returns the updated travel plan, plan ID, and success message.
 *
 * @param args Input parameters (planId, updates, userId).
 * @returns Promise resolving to travel plan update results.
 */
⋮----
identifier: (params) => params.planId, // Rate limit per plan
⋮----
/**
 * Tool for combining flights, accommodations, activities, and destination info.
 *
 * Combines flights, accommodations, activities, and destination info.
 * Returns the combined results and success message.
 *
 * @param args Input parameters (flightResults, accommodationResults, activityResults, destinationInfo, startDate, endDate, userPreferences).
 * @returns Promise resolving to combined search results.
 */
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Complex result structure
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Complex result structure
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Flight data structure from API
⋮----
/**
 * Tool for persisting a travel plan and optionally finalizing it.
 *
 * Persists a travel plan and optionally finalizes it.
 * Returns the success message, plan ID, status, and summary markdown.
 *
 * @param args Input parameters (planId, finalize).
 * @returns Promise resolving to travel plan persistence results.
 */
⋮----
/**
 * Tool for deleting an existing travel plan owned by the session user.
 *
 * Deletes an existing travel plan owned by the session user.
 * Requires user approval before deletion to prevent accidental data loss.
 * Returns the success message and plan ID.
 *
 * @param args Input parameters (planId, sessionId).
 * @returns Promise resolving to travel plan deletion results.
 */
⋮----
// Require user approval before deleting travel plan
// Uses Redis-backed approval flow - throws "approval_required" if not approved
⋮----
// Convert approval exception to graceful error response for AI tool interface
⋮----
/** Plan ID to delete (required) */
⋮----
/** Session ID for approval flow (optional, defaults to user ID) */
````

## File: src/ai/tools/server/rag.ts
````typescript
/**
 * @fileoverview RAG search tool for AI agents (server-only).
 *
 * Provides semantic search with hybrid scoring and reranking
 * for knowledge base queries.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import { TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import { ragSearchInputSchema, ragSearchToolOutputSchema } from "@schemas/rag";
import { hashInputForCache } from "@/lib/cache/hash";
import { createReranker } from "@/lib/rag/reranker";
import { retrieveDocuments } from "@/lib/rag/retriever";
import { createServerSupabase } from "@/lib/supabase/server";
⋮----
/**
 * RAG search tool for knowledge base queries.
 *
 * Combines vector similarity, lexical search, and cross-encoder reranking
 * to retrieve relevant documents from the knowledge base.
 *
 * @param query - Natural language search query.
 * @param namespace - Optional document namespace to filter.
 * @param limit - Maximum results to return (1-20, default 5).
 * @param threshold - Minimum similarity threshold (0-1, default 0.7).
 * @returns Matching documents with content and relevance scores.
 *
 * @example
 * ```typescript
 * const results = await ragSearch.execute({
 *   query: "best hotels in Paris with pool",
 *   namespace: "accommodations",
 *   limit: 5
 * });
 * ```
 */
⋮----
// Create reranker with Together.ai/Mixedbread
⋮----
// Return simplified results for the agent
⋮----
ttlSeconds: 300, // 5 minute cache
````

## File: src/ai/tools/server/travel-advisory.ts
````typescript
/**
 * @fileoverview Travel advisory and safety scoring tool.
 *
 * Provides safety scores and travel advisories for destinations using
 * US State Department Travel Advisories API with caching (7d TTL).
 * Falls back to stub if API unavailable.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import {
  travelAdvisoryInputSchema,
  travelAdvisoryOutputSchema,
} from "@ai/tools/schemas/travel-advisory";
import { TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import type { SafetyResult } from "@ai/tools/server/travel-advisory/providers";
import {
  getDefaultProvider,
  registerProvider,
} from "@ai/tools/server/travel-advisory/providers";
import { createStateDepartmentProvider } from "@ai/tools/server/travel-advisory/providers/state-department";
import { mapToCountryCode } from "@ai/tools/server/travel-advisory/utils";
import type { z } from "zod";
import { hashInputForCache } from "@/lib/cache/hash";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
// Initialize and register the State Department provider
⋮----
// Create logger first (used in fetchSafetyScores below)
⋮----
/**
 * Fetch safety scores from State Department API or similar service.
 *
 * @param destination Destination name or country code.
 * @param precomputedCountryCode Optional pre-computed country code to avoid redundant mapping.
 * @returns Promise resolving to safety result or null if unavailable.
 */
async function fetchSafetyScores(
  destination: string,
  precomputedCountryCode?: string | null
): Promise<SafetyResult | null>
⋮----
// Use pre-computed country code if provided, otherwise map destination
⋮----
// If destination doesn't map to a country code, return null
// (caller will handle fallback)
⋮----
// Update destination to match the input (preserve user's query)
⋮----
// Log error but don't throw - let caller handle fallback
⋮----
/**
 * Get travel advisory and safety scores for a destination.
 *
 * Uses US State Department Travel Advisories API with caching (7d TTL).
 * Falls back to stub if API unavailable or country not found.
 *
 * @returns Safety scores and advisory information.
 */
⋮----
type TravelAdvisoryInput = z.infer<typeof travelAdvisoryInputSchema>;
⋮----
type TravelAdvisoryResult = z.infer<typeof travelAdvisoryOutputSchema>;
⋮----
// Validate input at boundary (AI SDK validates, but ensure for direct calls)
⋮----
// Fetch from API (pass pre-computed country code to avoid redundant mapping)
⋮----
// Fallback to stub if API unavailable or country not found
````

## File: src/app/api/accommodations/search/route.ts
````typescript
/**
 * @fileoverview POST /api/accommodations/search route handler.
 */
⋮----
import { getAccommodationsService } from "@domain/accommodations/container";
import { accommodationSearchInputSchema } from "@schemas/accommodations";
import { withApiGuards } from "@/lib/api/factory";
import { getCurrentUser } from "@/lib/supabase/server";
⋮----
auth: false, // Allow anonymous searches
````

## File: src/app/api/activities/[id]/route.ts
````typescript
/**
 * @fileoverview GET /api/activities/[id] route handler.
 */
⋮----
import { getActivitiesService } from "@domain/activities/container";
import { isNotFoundError } from "@domain/activities/errors";
import type { RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, parseStringId } from "@/lib/api/route-helpers";
import { getCurrentUser } from "@/lib/supabase/server";
⋮----
/**
 * Determines whether the request contains Supabase authentication cookies.
 *
 * @param req - The incoming HTTP request.
 * @returns `true` if Supabase auth cookies (`sb-access-token` or `sb-refresh-token`) are present.
 */
function hasAuthCookies(req: Request): boolean
⋮----
// Check for Supabase auth cookies
⋮----
/**
 * GET /api/activities/[id]
 *
 * Retrieves detailed information for a specific activity by Google Place ID.
 *
 * Supports both authenticated and anonymous access. When authentication cookies
 * are present, the user ID is included in the request context for personalized
 * results.
 *
 * @param req - The incoming HTTP request.
 * @param supabase - Supabase client instance (from `withApiGuards`).
 * @param _body - Request body (unused for GET requests).
 * @param routeContext - Route context containing dynamic route parameters.
 * @returns JSON response with activity details, or an error response.
 *
 * **Response codes:**
 * - `200`: Activity found and returned.
 * - `400`: Missing or invalid Place ID.
 * - `404`: Activity not found.
 * - `429`: Rate limit exceeded.
 * - `500`: Internal server error.
 */
⋮----
auth: false, // Allow anonymous access
⋮----
// Only call getCurrentUser if auth cookies are present to avoid unnecessary Supabase calls
````

## File: src/app/api/activities/search/route.ts
````typescript
/**
 * @fileoverview POST /api/activities/search route handler.
 */
⋮----
import { getActivitiesService } from "@domain/activities/container";
import { activitySearchParamsSchema } from "@schemas/search";
import { withApiGuards } from "@/lib/api/factory";
import { getCurrentUser } from "@/lib/supabase/server";
⋮----
auth: false, // Allow anonymous searches
⋮----
// IP and locale can be extracted from request headers if needed
````

## File: src/app/api/auth/login/route.ts
````typescript
/**
 * @fileoverview Login API route.
 *
 * Handles email/password login authentication using Supabase SSR.
 * Uses withApiGuards for rate limiting, validation, and telemetry.
 */
⋮----
import { loginFormSchema } from "@schemas/auth";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { isMfaRequiredError } from "@/lib/auth/supabase-errors";
⋮----
/**
 * POST /api/auth/login
 *
 * Authenticates a user with email and password.
 * Returns success/error status without redirects (client handles navigation).
 *
 * Rate limited to 5 requests/minute per IP.
 */
````

## File: src/app/api/auth/mfa/backup/regenerate/route.ts
````typescript
/**
 * @fileoverview API route for regenerating MFA backup codes.
 */
⋮----
import { backupCodeRegenerateInputSchema } from "@schemas/mfa";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import {
  errorResponse,
  forbiddenResponse,
  getClientIpFromHeaders,
  unauthorizedResponse,
} from "@/lib/api/route-helpers";
import { isMfaRequiredError } from "@/lib/auth/supabase-errors";
import { regenerateBackupCodes, requireAal2 } from "@/lib/security/mfa";
import { getAdminSupabase } from "@/lib/supabase/admin";
⋮----
/** The POST handler for the MFA backup code regenerate API. */
````

## File: src/app/api/auth/mfa/sessions/revoke/route.ts
````typescript
/**
 * @fileoverview The API route handler for revoking MFA sessions.
 */
⋮----
import { mfaSessionRevokeInputSchema } from "@schemas/mfa";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { isMfaRequiredError } from "@/lib/auth/supabase-errors";
import { requireAal2, revokeSessions } from "@/lib/security/mfa";
import { classifyMfaError, logMfaError } from "@/lib/security/mfa-error";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** The POST handler for the MFA sessions revoke API. */
````

## File: src/app/api/itineraries/_handler.ts
````typescript
/**
 * @fileoverview Dependency-injected handlers for itinerary CRUD routes.
 */
⋮----
import { itineraryItemCreateSchema } from "@schemas/trips";
import { NextResponse } from "next/server";
import { errorResponse, validateSchema } from "@/lib/api/route-helpers";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { hashTelemetryIdentifier } from "@/lib/telemetry/identifiers";
import type { ServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
import { mapItineraryItemCreateToDbInsert } from "@/lib/trips/mappers";
⋮----
export interface ItinerariesDeps {
  logger: ServerLogger;
  supabase: TypedServerSupabase;
}
⋮----
export function handleListItineraryItems(
  deps: ItinerariesDeps,
  params: { userId: string; tripId?: number }
): Promise<Response>
⋮----
export async function handleCreateItineraryItem(
  deps: ItinerariesDeps,
  params: { userId: string; body: unknown }
): Promise<Response>
⋮----
// PGRST116: PostgREST error code for "no rows returned" from .single()
````

## File: src/app/api/keys/validate/route.ts
````typescript
/**
 * @fileoverview POST /api/keys/validate verifies a user-supplied provider API key without persisting it.
 */
⋮----
// Security: Prevent caching of sensitive API key data per ADR-0024.
// With Cache Components enabled, route handlers are dynamic by default.
// Using withApiGuards({ auth: true }) ensures this route uses cookies/headers,
// making it dynamic and preventing caching. No 'use cache' directives are present.
⋮----
import { createAnthropic } from "@ai-sdk/anthropic";
import { createOpenAI } from "@ai-sdk/openai";
import { createGateway } from "ai";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, parseJsonBody } from "@/lib/api/route-helpers";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
import { mapProviderExceptionToCode, mapProviderStatusToCode } from "../_error-mapping";
⋮----
type ValidateResult = { isValid: boolean; reason?: string };
⋮----
type ProviderRequest = {
  fetchImpl: typeof fetch;
  headers: HeadersInit;
  url: string;
};
⋮----
type ProviderRequestBuilder = (apiKey: string) => ProviderRequest;
⋮----
type SDKCreator = (options: {
  apiKey: string;
  baseURL?: string;
  headers?: Record<string, string>;
}) => (modelId: string) => unknown;
⋮----
type ConfigurableModel = {
  config: {
    baseURL?: string;
    fetch?: typeof fetch;
    headers: () => HeadersInit;
  };
};
⋮----
type BuildSDKRequestOptions = {
  apiKey: string;
  baseURL?: string;
  defaultBaseURL: string;
  headers?: Record<string, string>;
  modelId: string;
  sdkCreator: SDKCreator;
};
⋮----
function buildSDKRequest(options: BuildSDKRequestOptions): ProviderRequest
⋮----
function normalizeErrorReason(error: unknown): string
⋮----
/**
 * Generic validator using provider configuration map.
 *
 * @param service Provider identifier (openai|openrouter|anthropic|xai).
 * @param apiKey The plaintext API key to check.
 * @returns Validation result with is_valid and optional reason.
 */
async function validateProviderKey(
  service: string,
  apiKey: string
): Promise<ValidateResult>
⋮----
/**
 * Handle POST /api/keys/validate to verify a user-supplied API key.
 *
 * Orchestrates rate limiting, authentication, and provider validation.
 *
 * @param req Next.js request containing JSON body with { service, apiKey }.
 * @param routeContext Route context from withApiGuards
 * @returns 200 with validation result; 400/401/429/500 on error.
 */
⋮----
// Custom telemetry handled below
````

## File: src/app/api/keys/_telemetry.ts
````typescript
/**
 * @fileoverview Helpers for generating BYOK telemetry span attributes.
 */
⋮----
import { hashTelemetryIdentifier } from "@/lib/telemetry/identifiers";
import type { TelemetrySpanAttributes } from "@/lib/telemetry/span";
import type { RateLimitResult } from "./_rate-limiter";
⋮----
type Operation = "insert" | "delete";
type IdentifierType = "user" | "ip";
⋮----
export type BuildKeySpanAttributesInput = {
  identifierType: IdentifierType;
  operation: Operation;
  rateLimit?: RateLimitResult;
  service: string;
  userId?: string;
};
⋮----
/**
 * Produce normalized span attributes shared by BYOK RPC spans.
 *
 * @param input Context for the RPC call.
 * @returns Attribute map safe for telemetry export.
 */
export function buildKeySpanAttributes(
  input: BuildKeySpanAttributesInput
): TelemetrySpanAttributes
````

## File: src/app/api/keys/route.ts
````typescript
/**
 * @fileoverview BYOK upsert route. Stores user-provided API keys in Supabase Vault via RPC.
 * Route: POST /api/keys
 */
⋮----
import { type PostKeyBody, postKeyBodySchema } from "@schemas/api";
import type { NextRequest } from "next/server";
import type { RateLimitResult } from "@/app/api/keys/_rate-limiter";
import { buildKeySpanAttributes } from "@/app/api/keys/_telemetry";
import { withApiGuards } from "@/lib/api/factory";
import { requireUserId } from "@/lib/api/route-helpers";
import { insertUserApiKey, upsertUserGatewayBaseUrl } from "@/lib/supabase/rpc";
import { withTelemetrySpan } from "@/lib/telemetry/span";
import { getKeys, postKey } from "./_handlers";
⋮----
type IdentifierType = "user" | "ip";
⋮----
/**
 * Handle POST /api/keys to insert or replace a user's provider API key.
 *
 * @param req Next.js request containing JSON body with { service, apiKey }.
 * @param routeContext Route context from withApiGuards
 * @returns 204 No Content on success; 400/401/429/500 on error.
 */
⋮----
// Custom telemetry handled below, factory telemetry disabled
⋮----
// Rate limit metadata not available from factory, using undefined for custom telemetry
⋮----
const instrumentedInsert = (u: string, s: string, k: string)
⋮----
// postKey normalizes and validates service identifiers before hitting Supabase RPCs.
⋮----
// Store per-user Gateway base URL when provided.
⋮----
/**
 * Return metadata for the authenticated user's stored API keys.
 *
 * This endpoint returns only non-secret fields: service, created_at, last_used.
 *
 * @param req Next.js request object
 * @param routeContext Route context from withApiGuards
 * @returns 200 with a list of key summaries; 401/500 on error.
 */
⋮----
rateLimit: "keys:create", // Reuse create limit for GET
// Custom telemetry handled in handler
````

## File: src/app/api/user-settings/route.ts
````typescript
/**
 * @fileoverview API route for reading/writing per-user gateway fallback settings.
 */
⋮----
// Security: Prevent caching of user-specific settings per ADR-0024.
// With Cache Components enabled, route handlers are dynamic by default.
// Using withApiGuards({ auth: true }) ensures this route uses cookies/headers,
// making it dynamic and preventing caching. No 'use cache' directives are present.
⋮----
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, parseJsonBody, requireUserId } from "@/lib/api/route-helpers";
import type { InsertTables } from "@/lib/supabase/database.types";
import { getUserAllowGatewayFallback } from "@/lib/supabase/rpc";
⋮----
/**
 * Retrieves the user's gateway fallback preference setting.
 *
 * Requires authentication.
 *
 * @returns Promise resolving to NextResponse with allowGatewayFallback boolean.
 */
⋮----
/**
 * Updates the user's gateway fallback preference setting.
 *
 * Requires authentication. Body must contain `allowGatewayFallback` boolean.
 *
 * @param req NextRequest containing allowGatewayFallback boolean in body.
 * @returns Promise resolving to NextResponse with success confirmation or error.
 */
⋮----
// Upsert row with owner RLS via SSR client
type UserSettingsInsert = InsertTables<"user_settings">;
// DB column names use snake_case by convention
````

## File: src/app/auth/callback/route.ts
````typescript
/**
 * @fileoverview Supabase authentication callback route handler.
 *
 * Handles OAuth callback, exchanges authorization code for session, and redirects users.
 * Uses hardened redirect utilities to prevent open-redirect attacks.
 */
⋮----
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { resolveServerRedirectUrl, safeNextPath } from "@/lib/auth/redirect-server";
import { createServerSupabase } from "@/lib/supabase/server";
import { getOriginFromRequest } from "@/lib/url/server-origin";
⋮----
/**
 * Handles OAuth callback from Supabase Auth.
 *
 * Exchanges authorization code for session and redirects. Uses safe redirect
 * utilities to prevent open-redirect attacks and correctly handle proxied requests.
 *
 * @param request - Incoming request with auth callback
 * @returns Redirect response to dashboard or specified URL
 */
export async function GET(request: NextRequest)
⋮----
// Preserve safe next path for post-login redirect after error resolution
````

## File: src/app/auth/confirm/route.ts
````typescript
/**
 * @fileoverview Supabase email confirmation route.
 * Exchanges a token_hash for a session using Supabase SSR and redirects.
 * Reference: Supabase SSR Next.js guide (Auth confirmation).
 */
⋮----
import type { EmailOtpType } from "@supabase/supabase-js";
import { redirect } from "next/navigation";
import type { NextRequest } from "next/server";
import { sanitizeAuthConfirmNextParam } from "@/lib/auth/confirm-next";
import { createServerSupabase } from "@/lib/supabase/server";
⋮----
function parseEmailOtpType(value: string | null): EmailOtpType | null
⋮----
export async function GET(request: NextRequest)
⋮----
// On error, redirect to a friendly error page or home
````

## File: src/app/auth/password/reset-request/route.ts
````typescript
/**
 * @fileoverview Password reset request route handler.
 *
 * Sends Supabase password reset emails using SSR Supabase client. This route is
 * public and does not require authentication.
 */
⋮----
import { resetPasswordFormSchema } from "@schemas/auth";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { type RouteParamsContext, withApiGuards } from "@/lib/api/factory";
import { parseJsonBody } from "@/lib/api/route-helpers";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
import { getClientIpFromHeaders } from "@/lib/http/ip";
import { emitOperationalAlertOncePerWindow } from "@/lib/telemetry/degraded-mode";
import {
  hashTelemetryFingerprint,
  hashTelemetryIdentifier,
} from "@/lib/telemetry/identifiers";
import { createServerLogger } from "@/lib/telemetry/logger";
import { getRequiredServerOrigin } from "@/lib/url/server-origin";
import { isPlainObject } from "@/lib/utils/type-guards";
⋮----
interface ResetRequestPayload {
  email?: unknown;
}
⋮----
function getAllowedOrigins(primaryOrigin: string): Set<string>
⋮----
// Ignore malformed env values.
⋮----
function normalizeBasePath(path: string | undefined): string
⋮----
/**
 * Handles POST /auth/password/reset-request.
 *
 * Validates the email address and calls Supabase Auth
 * resetPasswordForEmail with a redirect URL pointing back to the app.
 */
⋮----
export const POST = async (req: NextRequest, routeContext: RouteParamsContext)
````

## File: src/app/dashboard/search/activities/actions.ts
````typescript
/**
 * @fileoverview Server Actions for trip planning integration.
 * Handles fetching user trips and adding activities to trips.
 */
⋮----
import { type ActivitySearchParams, activitySearchParamsSchema } from "@schemas/search";
import { type TripsRow, tripsRowSchema } from "@schemas/supabase";
import {
  type ItineraryItemCreateInput,
  itineraryItemCreateSchema,
  type UiTrip,
} from "@schemas/trips";
import { z } from "zod";
import { bumpTag } from "@/lib/cache/tags";
import { createServerSupabase } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
import { mapDbTripToUi, mapItineraryItemCreateToDbInsert } from "@/lib/trips/mappers";
⋮----
/**
 * Validates/normalizes activity search parameters inside a server-side telemetry span.
 *
 * Note: this action does not execute the activity search itself.
 */
// biome-ignore lint/suspicious/useAwait: withTelemetrySpan returns a Promise synchronously
export async function submitActivitySearch(
  params: ActivitySearchParams
): Promise<ActivitySearchParams>
⋮----
/**
 * Fetches the authenticated user's active and planning trips.
 *
 * Retrieves trips with "planning" or "active" status from Supabase.
 * Results are mapped to the UI trip format.
 *
 * @returns A list of UI-formatted trips.
 * @throws Error if unauthorized or fetch fails.
 */
export async function getPlanningTrips(): Promise<UiTrip[]>
⋮----
/**
 * Adds an activity to a specific trip.
 *
 * Validates trip ownership and activity data before inserting into Supabase.
 * Invalidates "trips" cache tag upon success.
 *
 * @param tripId - The ID of the trip to add the activity to.
 * @param activityData - The activity details including title, price, etc.
 * @throws Error if unauthorized, trip not found, or validation fails.
 */
export async function addActivityToTrip(
  tripId: number | string,
  activityData: {
    title: string;
    description?: string;
    location?: string;
    price?: number;
    currency?: string;
    startTime?: string;
    endTime?: string;
    externalId?: string;
    metadata?: Record<string, unknown>;
  }
): Promise<void>
⋮----
// Validate trip ownership
````

## File: src/app/dashboard/search/hotels/hotels-search-client.tsx
````typescript
/**
 * @fileoverview Client-side hotel search experience (renders within RSC shell).
 */
⋮----
import type { HotelResult, SearchAccommodationParams } from "@schemas/search";
import {
  AlertCircleIcon,
  Building2Icon,
  FilterIcon,
  LightbulbIcon,
  MapPinIcon,
  SearchIcon,
  SortAscIcon,
  StarIcon,
} from "lucide-react";
import { useEffect, useMemo, useRef, useState } from "react";
import { buildHotelApiPayload } from "@/components/features/search/filters/api-payload";
import { FilterPanel } from "@/components/features/search/filters/filter-panel";
import { HotelSearchForm } from "@/components/features/search/forms/hotel-search-form";
import { HotelResults } from "@/components/features/search/results/hotel-results";
import { SearchLayout } from "@/components/layouts/search-layout";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Separator } from "@/components/ui/separator";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { HotelSkeleton } from "@/components/ui/travel-skeletons";
import { useToast } from "@/components/ui/use-toast";
import { useSearchOrchestration } from "@/hooks/search/use-search-orchestration";
import { getErrorMessage } from "@/lib/api/error-types";
import { useCurrencyStore } from "@/stores/currency-store";
import { useSearchFiltersStore } from "@/stores/search-filters-store";
import { useSearchResultsStore } from "@/stores/search-results-store";
import { mapAccommodationToHotelResult } from "./hotel-mapping";
⋮----
/** Hotel search client component props. */
interface HotelsSearchClientProps {
  onSubmitServer: (
    params: SearchAccommodationParams
  ) => Promise<SearchAccommodationParams>;
}
⋮----
type PopularDestinationApiResponse = {
  city: string;
  country?: string;
  avgPrice?: string;
  imageUrl?: string;
};
⋮----
function parseAvgPrice(value: string | undefined): number | null
⋮----
function readCachedPopularDestinations(): PopularDestinationProps[] | null
⋮----
function writeCachedPopularDestinations(destinations: PopularDestinationProps[]): void
⋮----
// ignore
⋮----
/** Hotel search client component. */
⋮----
// Initialize accommodation search type on mount
⋮----
// ignore
⋮----
const handleHotelSelect = (hotel: HotelResult): Promise<void> =>
⋮----
const updateWishlist = (hotelId: string): void =>
⋮----
// ignore
⋮----
const handleSaveToWishlist = (hotelId: string) =>
⋮----
const handleSortClick = () =>
⋮----
/** Scroll to filter panel in sidebar (useful on mobile where sidebar is below content) */
const handleFilterClick = () =>
⋮----
const handleSearch = async (params: SearchAccommodationParams) =>
⋮----
// Merge form params with active filter payload
⋮----
const validatedParams = await onSubmitServer(searchWithFilters); // server-side telemetry and validation
⋮----
await executeSearch(validatedParams, controller.signal); // client fetch/store update via orchestration
⋮----
{/* Main content - 3 columns */}
⋮----
{/* Search Form */}
⋮----
{/* Error State */}
⋮----
{/* Loading State */}
⋮----
{/* Results State */}
⋮----
{/* Initial State - Popular Destinations & Tips */}
⋮----
{/* TODO: Fetch personalized tips from AI service or content management system based on user context */}
⋮----
{/* Empty State */}
⋮----
{/* Sidebar - 1 column */}
⋮----
/**
 * Present a highlighted destination card with pricing and rating metadata.
 */
⋮----
/**
 * Display a single accommodation planning tip.
 */
````

## File: src/app/dashboard/security/page.tsx
````typescript
/**
 * @fileoverview Dashboard security page (MFA settings).
 */
⋮----
import type { MfaFactor } from "@schemas/mfa";
import { redirect } from "next/navigation";
import { MfaPanel } from "@/components/features/security/mfa-panel";
import { getUnknownErrorMessage } from "@/lib/errors/get-unknown-error-message";
import { ROUTES } from "@/lib/routes";
import { listFactors, refreshAal } from "@/lib/security/mfa";
import { createServerSupabase, getCurrentUser } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** The security page for the dashboard. */
export default async function SecurityPage()
````

## File: src/app/error.tsx
````typescript
/**
 * @fileoverview Root-level error boundary for the Next.js app router.
 */
⋮----
import { useEffect } from "react";
import { PageErrorFallback } from "@/components/error/error-fallback";
import { getSessionId } from "@/lib/client/session";
import { errorService } from "@/lib/error-service";
import { fireAndForget } from "@/lib/utils";
⋮----
/**
 * Root-level error boundary for the app directory
 * This catches errors in the root layout and pages
 */
export default function RootErrorBoundary({
  error,
  reset,
}: {
  error: Error & { digest?: string };
reset: ()
⋮----
// Report the error
⋮----
// Log error in development
⋮----
/**
 * Gets the current user ID from the user store.
 *
 * @returns User ID or undefined if not available
 */
function getUserId(): string | undefined
````

## File: src/components/ai-elements/budget-chart.tsx
````typescript
/**
 * @fileoverview Budget plan chart component for AI Elements.
 */
⋮----
import type { BudgetPlanResult } from "@schemas/agents";
import type { ComponentProps } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { clampProgress } from "@/lib/utils";
import { Source, Sources, SourcesContent, SourcesTrigger } from "./sources";
⋮----
/**
 * Props for BudgetChart component.
 */
export type BudgetChartProps = ComponentProps<typeof Card> & {
  /** Budget plan result to render. */
  result: BudgetPlanResult;
};
⋮----
/** Budget plan result to render. */
⋮----
type BudgetAllocation = BudgetPlanResult["allocations"][number];
⋮----
/**
 * Render a budget plan with category allocations and tips.
 */
````

## File: src/components/auth/register-form.tsx
````typescript
/**
 * @fileoverview The register form component.
 */
⋮----
import { SiGithub, SiGoogle } from "@icons-pack/react-simple-icons";
import { Loader2Icon, MailIcon } from "lucide-react";
import Link from "next/link";
import { useMemo, useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { resolveRedirectUrl } from "@/lib/auth/redirect";
import { nowIso } from "@/lib/security/random";
import { useSupabaseRequired } from "@/lib/supabase/client";
⋮----
/** The register form props. */
type RegisterFormProps = {
  redirectTo?: string;
};
⋮----
/**
 * The register form component.
 *
 * @param redirectTo - The redirect URL.
 * @returns The register form component.
 */
⋮----
/** Handles the signup. */
const handleSignup = async (event: React.FormEvent) =>
⋮----
// Validate required fields
⋮----
// Build emailRedirectTo with next parameter for post-confirmation redirect
⋮----
// When email confirmation is required, data.session is null
// Redirect to check_email page instead of dashboard
⋮----
// Only redirect to targetUrl if session exists (email confirmation disabled)
⋮----
/** Handles the OAuth login. */
const handleOAuth = async (provider: "github" | "google") =>
⋮----
onCheckedChange=
````

## File: src/components/charts/chart-wrapper.tsx
````typescript
/**
 * @fileoverview Chart wrapper component for dynamically importing Recharts components to reduce initial bundle size.
 */
⋮----
import dynamic from "next/dynamic";
import type { ComponentProps, ComponentType } from "react";
import type {
  AreaProps as RechartsAreaProps,
  LineProps as RechartsLineProps,
  TooltipProps as RechartsTooltipProps,
  XAxisProps as RechartsXAxisProps,
  YAxisProps as RechartsYAxisProps,
} from "recharts";
import { LoadingSpinner } from "@/components/ui/loading-spinner";
⋮----
function CreateDynamicComponent<P extends object>(
  loader: () => Promise<ComponentType<P>>
)
⋮----
/** Dynamically import chart components to reduce initial bundle size */
⋮----
/**
 * Dynamically import the AreaChart component.
 *
 * @returns The AreaChart component.
 */
⋮----
/**
 * Dynamically import the LineChart component.
 *
 * @returns The LineChart component.
 */
⋮----
/**
 * Dynamically import the Area component.
 *
 * @returns The Area component.
 */
⋮----
/**
 * Dynamically import the Line component.
 *
 * @returns The Line component.
 */
⋮----
/**
 * Dynamically import the CartesianGrid component.
 *
 * @returns The CartesianGrid component.
 */
⋮----
/**
 * Dynamically import the XAxis component.
 *
 * @returns The XAxis component.
 */
⋮----
/**
 * Dynamically import the YAxis component.
 *
 * @returns The YAxis component.
 */
⋮----
/**
 * Dynamically import the Tooltip component.
 *
 * @returns The Tooltip component.
 */
⋮----
/** Export types for better TypeScript support */
export type ResponsiveContainerProps = ComponentProps<typeof ResponsiveContainer>;
export type AreaChartProps = ComponentProps<typeof AreaChart>;
export type LineChartProps = ComponentProps<typeof LineChart>;
export type AreaProps = ComponentProps<typeof Area>;
export type LineProps = ComponentProps<typeof Line>;
export type CartesianGridProps = ComponentProps<typeof CartesianGrid>;
export type XAxisProps = ComponentProps<typeof XAxis>;
export type YAxisProps = ComponentProps<typeof YAxis>;
export type TooltipProps = ComponentProps<typeof Tooltip>;
````

## File: src/components/error/error-boundary.tsx
````typescript
/**
 * @fileoverview Client error boundary wrapper with error reporting and user/session context.
 */
⋮----
import type { ErrorBoundaryProps, ErrorInfo } from "@schemas/errors";
import type React from "react";
import { useCallback } from "react";
import {
  type FallbackProps,
  ErrorBoundary as ReactErrorBoundary,
} from "react-error-boundary";
import { getSessionId } from "@/lib/client/session";
import { errorService } from "@/lib/error-service";
import { fireAndForget } from "@/lib/utils";
import { ErrorFallback } from "./error-fallback";
⋮----
type ErrorWithDigest = Error & { digest?: string };
⋮----
/**
 * Extract the user ID from the global window.userStore.
 *
 * `window.userStore` is initialized by the Zustand auth store during app bootstrap
 * (see src/stores/auth-store.ts). This function is defensive: the try-catch guards
 * against environments or timings where the global may not yet be available.
 *
 * @returns The current user ID if available, or undefined if not set or inaccessible.
 */
function GetUserId(): string | undefined
⋮----
function ToSchemaErrorInfo(
  info: { componentStack?: string | null } | undefined
): ErrorInfo
⋮----
function GetFallbackComponent(
  fallback: ErrorBoundaryProps["fallback"] | undefined
): React.ComponentType<
⋮----
/**
 * Higher-order component to wrap components with error boundary
 */
⋮----
const WrappedComponent = (props: P) => (
    <ErrorBoundary {...errorBoundaryProps}>
      <Component {...props} />
    </ErrorBoundary>
  );
````

## File: src/components/features/search/search-analytics.tsx
````typescript
/**
 * @fileoverview Search analytics component showing user search patterns and trends.
 */
⋮----
import {
  BarChart3Icon,
  CalendarIcon,
  ClockIcon,
  MapPinIcon,
  PlaneIcon,
  TrendingUpIcon,
} from "lucide-react";
import { useMemo, useState } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { clampProgress } from "@/lib/utils";
import { useSearchHistoryStore } from "@/stores/search-history";
⋮----
/** Props for the search analytics component */
interface SearchAnalyticsProps {
  className?: string;
  dateRange?: { start: string; end: string };
}
⋮----
/** Search analytics component showing user search patterns and trends. */
⋮----
/** Get search analytics and trends from store */
⋮----
/** Get search analytics and trends from store */
⋮----
/** Calculate peak search hours */
⋮----
/** Format hour for display */
const formatHour = (hour: number) =>
⋮----
/** Get search type icon */
const getSearchTypeIcon = (type: string) =>
⋮----
/** No recent searches */
⋮----
/** Render search analytics */
⋮----
{/* Total Searches */}
⋮----
{/* Search Types Breakdown */}
⋮----
value=
⋮----
{/* 24-hour distribution mini chart */}
````

## File: src/components/features/shared/connection-status.tsx
````typescript
/**
 * @fileoverview Connection status component with real-time network metrics and analytics.
 */
⋮----
import {
  ActivityIcon,
  AlertTriangleIcon,
  CheckCircle2Icon,
  InfoIcon,
  Loader2Icon,
  MonitorIcon,
  RefreshCwIcon,
  RouterIcon,
  SignalHighIcon,
  SignalIcon,
  SignalLowIcon,
  SignalMediumIcon,
  TrendingDownIcon,
  TrendingUpIcon,
  WifiIcon,
  WifiOffIcon,
  ZapIcon,
} from "lucide-react";
import { AnimatePresence, motion } from "motion/react";
import type React from "react";
import { useEffect, useMemo, useState } from "react";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { clampProgress, cn } from "@/lib/utils";
import { getToneColors, type ToneVariant } from "@/lib/variants/status";
⋮----
/**
 * Maps connection status to statusVariants tones for consistent styling.
 */
⋮----
connected: "active", // green
connecting: "info", // blue
disconnected: "unknown", // slate
error: "error", // red
reconnecting: "pending", // amber
⋮----
/**
 * Get colors for a connection status from the tone system.
 * Uses getToneColors to derive colors from the single source of truth (TONE_CLASSES).
 */
const GetStatusColors = (status: ConnectionStatus) =>
⋮----
// Type for the connection status
export type ConnectionStatus =
  | "connecting"
  | "connected"
  | "disconnected"
  | "reconnecting"
  | "error";
⋮----
// Type for the network metrics interface
export interface NetworkMetrics {
  latency: number;
  bandwidth: number;
  packetLoss: number;
  jitter: number;
  quality: "excellent" | "good" | "fair" | "poor";
  signalStrength: number; // 0-100
}
⋮----
signalStrength: number; // 0-100
⋮----
// Type for the connection analytics interface
export interface ConnectionAnalytics {
  connectionTime: number;
  reconnectCount: number;
  totalMessages: number;
  failedMessages: number;
  avgResponseTime: number;
  lastDisconnection?: Date;
  uptime: number; // in seconds
}
⋮----
uptime: number; // in seconds
⋮----
// Type for the connection status props
interface ConnectionStatusProps {
  status: ConnectionStatus;
  metrics?: NetworkMetrics;
  analytics?: ConnectionAnalytics;
  onReconnect?: () => void;
  onOptimize?: () => void;
  className?: string;
  variant?: "default" | "compact" | "minimal" | "detailed";
  showMetrics?: boolean;
  showOptimizations?: boolean;
}
⋮----
// Default metrics for the connection status
⋮----
// Default analytics for the connection status
⋮----
/**
 * Get the quality color for the connection status
 *
 * @param quality - The quality of the connection
 * @returns The quality color
 */
const GetQualityColor = (quality: NetworkMetrics["quality"]) =>
/**
 * Get the signal icon for the connection status
 *
 * @param strength - The signal strength
 * @returns The signal icon
 */
const GetSignalIcon = (strength: number) =>
⋮----
/**
 * Format the latency for the connection status
 *
 * @param ms - The latency in milliseconds
 * @returns The formatted latency
 */
const FormatLatency = (ms: number) =>
⋮----
/**
 * Format the bandwidth for the connection status
 *
 * @param bps - The bandwidth in bits per second
 * @returns The formatted bandwidth
 */
const FormatBandwidth = (bps: number) =>
⋮----
/**
 * Format the uptime for the connection status
 *
 * @param seconds - The uptime in seconds
 * @returns The formatted uptime
 */
const FormatUptime = (seconds: number) =>
⋮----
/**
 * Connection quality indicator component
 *
 * @param metrics - The network metrics
 * @returns The connection quality indicator
 */
⋮----
// Calculate quality score based on multiple factors
const latencyScore = Math.max(0, 100 - metrics.latency / 10); // Good latency < 100ms
const bandwidthScore = Math.min(100, (metrics.bandwidth / 1000000) * 20); // Good bandwidth > 5MB/s
const lossScore = Math.max(0, 100 - metrics.packetLoss * 20); // Good loss < 5%
const jitterScore = Math.max(0, 100 - metrics.jitter / 2); // Good jitter < 10ms
⋮----
<span className=
⋮----
/**
 * Network optimization suggestions component
 *
 * @param metrics - The network metrics
 * @param onOptimize - The function to optimize the network
 * @returns The network optimization suggestions
 */
⋮----
/**
 * Connection status component
 *
 * @param props - The connection status props
 * @returns The connection status component
 */
⋮----
const getStatusConfig = () =>
⋮----
// Minimal variant - just icon and status for status bars
⋮----
<div className=
⋮----
// Compact variant - badge format
⋮----
// Don't show when connected unless there's an issue
⋮----
className=
⋮----
<div>Latency:
⋮----
// Default variant - alert format for chat/messaging
⋮----
// Don't show when connected
if (status === "connected")
⋮----
// Detailed variant - full card with metrics
⋮----
<Card className=
⋮----
Last connected:
⋮----
{/* Signal Strength Indicator */}
⋮----
value=
⋮----
{/* Network Optimization Suggestions */}
````

## File: src/components/layouts/chat-layout.tsx
````typescript
/**
 * @fileoverview ChatLayout components providing the main chat interface structure
 * including collapsible sidebar, agent status panel, and responsive layout
 * management for the chat experience.
 */
⋮----
import type { AgentStatusType } from "@schemas/agent-status";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { Progress } from "@/components/ui/progress";
import { clampProgress, cn } from "@/lib/utils";
import { statusVariants, type ToneVariant } from "@/lib/variants/status";
import { useAgentStatusStore } from "@/stores/agent-status-store";
import { useChatMessages, useSessions } from "@/stores/chat/chat-messages";
⋮----
/** Maps agent status types to tone variants for consistent styling. */
// biome-ignore lint/style/useNamingConvention: Review requested camelCase naming
⋮----
/**
 * Props interface for the ChatSidebar component.
 */
interface ChatSidebarProps extends React.HTMLAttributes<HTMLElement> {
  /** Callback function called when new chat button is clicked. */
  onNewChat?: () => void;
  /** Optional recent sessions to display (injected by caller/tests). */
  sessions?: Array<{
    id: string;
    title: string;
    lastMessage: string;
    updatedAt: string;
  }>;
}
⋮----
/** Callback function called when new chat button is clicked. */
⋮----
/** Optional recent sessions to display (injected by caller/tests). */
⋮----
// Note: No hard-coded sessions. Tests or callers may inject lightweight fixtures.
⋮----
/**
 * Sidebar component for chat navigation with recent conversations and new chat button.
 *
 * @param className - Additional CSS classes to apply.
 * @param onNewChat - Callback for new chat creation.
 * @param props - Additional HTML attributes.
 * @returns The ChatSidebar component.
 */
function ChatSidebar({
  className,
  onNewChat,
  sessions: injectedSessions,
  ...props
}: ChatSidebarProps)
⋮----
// Use injected sessions for tests, otherwise use store sessions
⋮----
const handleNewChat = () =>
⋮----
className=
⋮----
{/* New Chat Button */}
⋮----
{/* Chat Sessions List */}
⋮----
{/* Chat Settings */}
⋮----
/**
 * Props interface for the AgentStatusPanel component.
 */
interface AgentStatusPanelProps extends React.HTMLAttributes<HTMLElement> {}
⋮----
/**
 * Panel displaying active agent status, progress, and recent activity.
 *
 * @param className - Additional CSS classes to apply.
 * @param props - Additional HTML attributes.
 * @returns The AgentStatusPanel component.
 */
⋮----
{/* Header */}
⋮----
{/* Active Agents */}
⋮----
<Progress value=
⋮----
{/* Recent Activity */}
⋮----
/**
 * Props interface for the ChatLayout component.
 */
⋮----
/** Child components to render in the main chat area. */
⋮----
/** Whether to show the agent status panel. */
⋮----
/** Callback for new chat creation. */
⋮----
/** Whether the sidebar is collapsed. */
⋮----
/**
 * Main chat layout component providing sidebar, content area, and agent panel.
 *
 * Arranges the chat interface with collapsible sidebar navigation, main content
 * area, and optional agent status monitoring panel.
 *
 * @param children - Content to render in the main chat area.
 * @param showAgentPanel - Whether to display the agent status panel.
 * @param onNewChat - Callback for new chat creation.
 * @param sidebarCollapsed - Whether the sidebar is collapsed.
 * @returns The ChatLayout component.
 */
⋮----
{/* Chat Sidebar */}
⋮----
{/* Main Chat Area */}
⋮----
{/* Agent Status Panel */}
⋮----
// Export individual components for flexibility
````

## File: src/domain/accommodations/providers/amadeus-adapter.ts
````typescript
/**
 * @fileoverview Amadeus provider adapter with retry and telemetry.
 */
⋮----
import { ProviderError } from "@domain/accommodations/errors";
import {
  bookHotelOffer,
  listHotelsByGeocode,
  searchHotelOffers,
} from "@domain/amadeus/client";
import { mapHotelsToListings } from "@domain/amadeus/mappers";
import {
  amadeusHotelBookingSchema,
  amadeusHotelOfferContainerSchema,
  amadeusHotelSchema,
} from "@domain/amadeus/schemas";
import type {
  AccommodationBookingRequest,
  AccommodationCheckAvailabilityParams,
  AccommodationDetailsParams,
  AccommodationSearchParams,
} from "@schemas/accommodations";
import { retryWithBackoff } from "@/lib/http/retry";
import { hashTelemetryIdentifier } from "@/lib/telemetry/identifiers";
import { withTelemetrySpan } from "@/lib/telemetry/span";
import type {
  AccommodationProviderAdapter,
  ProviderAvailabilityResult,
  ProviderBookingPayload,
  ProviderBookingResult,
  ProviderContext,
  ProviderDetailsResult,
  ProviderResult,
  ProviderSearchResult,
} from "./types";
⋮----
/** Adapter configuration options. */
type AdapterConfig = {
  maxDelayMs: number;
  retryAttempts: number;
  timeoutMs: number;
};
⋮----
/**
 * Maps HTTP status code to provider error code.
 *
 * @param statusCode - HTTP status code.
 * @returns Provider error code.
 */
export function mapStatusToProviderCode(statusCode?: number): ProviderError["code"]
⋮----
export class AmadeusProviderAdapter implements AccommodationProviderAdapter
⋮----
constructor(config?: Partial<AdapterConfig>)
⋮----
/**
   * Searches hotels by coordinates and dates.
   *
   * @param params - Search parameters.
   * @param ctx - Optional provider context.
   * @returns Search results with listings.
   */
search(
    params: AccommodationSearchParams,
    ctx?: ProviderContext
): Promise<ProviderResult<ProviderSearchResult>>
⋮----
/**
   * Fetches hotel details and offers for a listing.
   *
   * @param params - Details parameters.
   * @param ctx - Optional provider context.
   * @returns Hotel details with offers.
   */
getDetails(
    params: AccommodationDetailsParams,
    ctx?: ProviderContext
): Promise<ProviderResult<ProviderDetailsResult>>
⋮----
/**
   * Checks room availability and returns booking token.
   *
   * @param params - Availability parameters.
   * @param ctx - Optional provider context.
   * @returns Availability result with booking token and price.
   */
checkAvailability(
    params: AccommodationCheckAvailabilityParams,
    ctx?: ProviderContext
): Promise<ProviderResult<ProviderAvailabilityResult>>
⋮----
// Amadeus hotelOffersSearch response already contains final price; reuse as availability lock.
⋮----
/**
   * Creates booking reservation.
   *
   * @param payload - Booking payload.
   * @param ctx - Optional provider context.
   * @returns Booking result with confirmation number.
   */
createBooking(
    payload: ProviderBookingPayload,
    ctx?: ProviderContext
): Promise<ProviderResult<ProviderBookingResult>>
⋮----
/**
   * Builds Amadeus-specific booking payload.
   *
   * @param params - Booking request parameters.
   * @param options - Optional payment and currency options.
   * @returns Amadeus booking payload.
   */
buildBookingPayload(
    params: AccommodationBookingRequest,
    options?: {
      currency?: string;
      paymentIntentId?: string;
      title?: string;
      totalCents?: number;
    }
): ProviderBookingPayload
⋮----
/**
   * Executes provider operation with telemetry and retry.
   *
   * @param operation - Operation name for telemetry.
   * @param ctx - Optional provider context.
   * @param fn - Operation function to execute.
   * @returns Provider result with success/error status.
   */
private execute<T>(
    operation: string,
    ctx: ProviderContext | undefined,
    fn: () => Promise<T>
): Promise<ProviderResult<T>>
⋮----
/**
   * Determines if error is retryable based on HTTP status codes.
   *
   * @param error - Error to check.
   * @param operation - Operation name.
   * @returns True if error is retryable.
   */
private isRetryable(error: unknown, operation: string): boolean
⋮----
// Avoid retrying non-idempotent booking calls; only retry on clear server failures.
⋮----
/**
   * Extracts HTTP status code from error.
   *
   * @param error - Error object.
   * @returns HTTP status code or undefined.
   */
private getStatusCode(error: unknown): number | undefined
⋮----
/**
 * Wraps async operation with timeout.
 *
 * @param operation - Operation to execute.
 * @param timeoutMs - Timeout in milliseconds.
 * @param onTimeout - Error factory for timeout.
 * @returns Operation result or timeout error.
 */
async function withTimeout<T>(
  operation: () => Promise<T>,
  timeoutMs: number,
  onTimeout: () => Error
): Promise<T>
````

## File: src/domain/schemas/ui/theme-provider.ts
````typescript
/**
 * @fileoverview Zod schema for next-themes ThemeProvider props.
 */
⋮----
import { z } from "zod";
⋮----
/** Zod schema for ThemeProvider props aligned with next-themes. */
⋮----
export type ValidatedThemeProviderProps = z.infer<typeof themeProviderPropsSchema>;
⋮----
export const validateThemeProviderProps = (props: unknown)
⋮----
export const parseThemeProviderProps = (
  props: unknown
): ValidatedThemeProviderProps =>
````

## File: src/domain/schemas/auth.ts
````typescript
/**
 * @fileoverview Authentication form validation schemas.
 * Includes login, registration, password reset, and password change form schemas.
 */
⋮----
import { z } from "zod";
import { EMAIL_SCHEMA, NAME_SCHEMA, PASSWORD_SCHEMA } from "./shared/person";
⋮----
// ===== FORM SCHEMAS =====
// UI form validation schemas with user-friendly error messages
⋮----
/**
 * Zod schema for login form validation.
 * Validates email and password credentials with user-friendly error messages.
 */
⋮----
/** TypeScript type for login form data. */
export type LoginFormData = z.infer<typeof loginFormSchema>;
⋮----
/**
 * Zod schema for registration form validation.
 * Validates user registration data including password confirmation and terms acceptance.
 */
⋮----
/** TypeScript type for registration form data. */
export type RegisterFormData = z.infer<typeof registerFormSchema>;
⋮----
/**
 * Zod schema for password reset form validation.
 * Validates email address for password reset initiation.
 */
⋮----
/** TypeScript type for password reset form data. */
export type ResetPasswordFormData = z.infer<typeof resetPasswordFormSchema>;
⋮----
/**
 * Zod schema for password reset confirmation form validation.
 * Validates new password, confirmation, and reset token.
 */
⋮----
/** TypeScript type for password reset confirmation form data. */
export type ConfirmResetPasswordFormData = z.infer<
  typeof confirmResetPasswordFormSchema
>;
⋮----
/**
 * Zod schema for password reset payloads.
 * Validates the reset token and new password for API requests.
 */
⋮----
/** TypeScript type for password reset payloads. */
export type PasswordResetPayload = z.infer<typeof passwordResetPayloadSchema>;
⋮----
/**
 * Zod schema for password change form validation.
 * Validates current password, new password, and confirmation with business rules.
 */
⋮----
/** TypeScript type for password change form data. */
export type ChangePasswordFormData = z.infer<typeof changePasswordFormSchema>;
````

## File: src/domain/schemas/embeddings.ts
````typescript
/**
 * @fileoverview Schemas for embeddings-related API boundaries.
 */
⋮----
import { z } from "zod";
⋮----
// ===== API REQUEST SCHEMAS =====
⋮----
export type EmbeddingsProperty = z.infer<typeof embeddingsPropertySchema>;
⋮----
export type EmbeddingsRequest = z.infer<typeof embeddingsRequestSchema>;
⋮----
export type PersistableEmbeddingsProperty = z.infer<
  typeof persistableEmbeddingsPropertySchema
>;
````

## File: src/domain/schemas/memory.ts
````typescript
/**
 * @fileoverview Memory-related schemas with validation.
 * Includes memory entities, user preferences, API requests/responses, and tool input validation.
 */
⋮----
import { z } from "zod";
import { messageRoleSchema } from "./chat";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for memory management
⋮----
/**
 * Zod schema for memory entities.
 * Validates memory content, metadata, and temporal tracking.
 */
⋮----
/** TypeScript type for memory entities. */
export type Memory = z.infer<typeof MEMORY_SCHEMA>;
⋮----
/**
 * Zod schema for user travel preferences.
 * Captures user preferences for destinations, activities, budget, and travel style.
 */
⋮----
/** TypeScript type for user preferences. */
export type UserPreferences = z.infer<typeof USER_PREFERENCES_SCHEMA>;
⋮----
/**
 * Zod schema for memory insights.
 * Validates extracted insights with confidence scores and related memories.
 */
⋮----
/** TypeScript type for memory insights. */
export type MemoryInsight = z.infer<typeof MEMORY_INSIGHT_SCHEMA>;
⋮----
/**
 * Zod schema for conversation messages used in memory context.
 * Validates message content, role, and metadata.
 */
⋮----
/** TypeScript type for conversation messages. */
export type ConversationMessage = z.infer<typeof CONVERSATION_MESSAGE_SCHEMA>;
⋮----
// ===== API SCHEMAS =====
// Request/response schemas for memory API endpoints
⋮----
/**
 * Zod schema for search memories request filters.
 * Validates filter criteria including date ranges and metadata.
 */
⋮----
/** TypeScript type for search memories filters. */
export type SearchMemoriesFilters = z.infer<typeof SEARCH_MEMORIES_FILTERS_SCHEMA>;
⋮----
/**
 * Zod schema for search memories API requests.
 * Validates search parameters including query, filters, and similarity threshold.
 */
⋮----
/** TypeScript type for search memories requests. */
export type SearchMemoriesRequest = z.infer<typeof SEARCH_MEMORIES_REQUEST_SCHEMA>;
⋮----
/**
 * Zod schema for search memories API responses.
 * Includes matched memories with relevance scores and search metadata.
 */
⋮----
/** TypeScript type for search memories responses. */
export type SearchMemoriesResponse = z.infer<typeof SEARCH_MEMORIES_RESPONSE_SCHEMA>;
⋮----
/**
 * Zod schema for memory context API responses.
 * Includes insights, recent memories, travel patterns, and user preferences.
 */
⋮----
/** TypeScript type for memory context responses. */
export type MemoryContextResponse = z.infer<typeof MEMORY_CONTEXT_RESPONSE_SCHEMA>;
⋮----
/**
 * Zod schema for update preferences API requests.
 * Validates preference updates with merge strategy options.
 */
⋮----
/** TypeScript type for update preferences requests. */
export type UpdatePreferencesRequest = z.infer<
  typeof UPDATE_PREFERENCES_REQUEST_SCHEMA
>;
⋮----
/**
 * Zod schema for update preferences API responses.
 * Includes updated preferences and change tracking metadata.
 */
⋮----
/** TypeScript type for update preferences responses. */
export type UpdatePreferencesResponse = z.infer<
  typeof UPDATE_PREFERENCES_RESPONSE_SCHEMA
>;
⋮----
/**
 * Zod schema for add conversation memory API requests.
 * Validates conversation messages and context for memory storage.
 */
⋮----
/** TypeScript type for add conversation memory requests. */
export type AddConversationMemoryRequest = z.infer<
  typeof ADD_CONVERSATION_MEMORY_REQUEST_SCHEMA
>;
⋮----
/**
 * Zod schema for add conversation memory API responses.
 * Includes created memories, generated insights, and processing metadata.
 */
⋮----
/** TypeScript type for add conversation memory responses. */
export type AddConversationMemoryResponse = z.infer<
  typeof ADD_CONVERSATION_MEMORY_RESPONSE_SCHEMA
>;
⋮----
/**
 * Zod schema for memory insights API responses.
 * Includes comprehensive insights about budget patterns, destinations, and travel personality.
 */
⋮----
/** TypeScript type for memory insights responses. */
export type MemoryInsightsResponse = z.infer<typeof MEMORY_INSIGHTS_RESPONSE_SCHEMA>;
⋮----
/**
 * Zod schema for delete user memories API responses.
 * Includes deletion count and backup information.
 */
⋮----
/** TypeScript type for delete user memories responses. */
export type DeleteUserMemoriesResponse = z.infer<
  typeof DELETE_USER_MEMORIES_RESPONSE_SCHEMA
>;
⋮----
/**
 * Zod schema for POST /api/memory/search request body.
 * Validates memory search request parameters for route handlers.
 */
⋮----
/** TypeScript type for memory search requests. */
export type MemorySearchRequest = z.infer<typeof memorySearchRequestSchema>;
⋮----
/**
 * Zod schema for POST /api/memory/preferences/[userId] request body.
 * Validates memory preferences update request parameters for route handlers.
 */
⋮----
/** TypeScript type for memory update preferences requests. */
export type MemoryUpdatePreferencesRequest = z.infer<
  typeof memoryUpdatePreferencesSchema
>;
⋮----
/**
 * Zod schema for POST /api/memory/conversations request body.
 * Validates add conversation memory request parameters for route handlers.
 */
⋮----
/** TypeScript type for memory add conversation requests. */
export type MemoryAddConversationRequest = z.infer<typeof memoryAddConversationSchema>;
⋮----
// ===== TOOL INPUT SCHEMAS =====
// Schemas for memory tool input validation and processing
⋮----
/**
 * Schema for addConversationMemory tool input.
 * Validates conversation memory creation parameters for AI tools.
 */
⋮----
/**
 * Schema for searchUserMemories tool input.
 * Validates memory search parameters for AI tools.
 */
⋮----
// ===== TOOL OUTPUT SCHEMAS =====
// Schemas for memory tool output validation
⋮----
/**
 * Schema for addConversationMemory tool output.
 * Returns the memory ID and creation timestamp.
 */
⋮----
/**
 * Schema for searchUserMemories tool output.
 * Returns normalized memory entries matching the query.
 */
````

## File: src/domain/schemas/security.ts
````typescript
/**
 * @fileoverview Security domain schemas for security dashboard APIs.
 */
⋮----
import { z } from "zod";
⋮----
// ===== CORE SCHEMAS =====
⋮----
/** Zod schema for security event. */
⋮----
/** Type for security event. */
export type SecurityEvent = z.infer<typeof securityEventSchema>;
⋮----
/** Zod schema for active session. */
⋮----
/** Type for active session. */
export type ActiveSession = z.infer<typeof activeSessionSchema>;
⋮----
/** Zod schema for security metrics. */
⋮----
/** Type for security metrics. */
export type SecurityMetrics = z.infer<typeof securityMetricsSchema>;
⋮----
/** Default security metrics used as a safe fallback when data is unavailable. */
````

## File: src/domain/schemas/supabase.ts
````typescript
/**
 * @fileoverview Supabase database table schemas.
 * Generated from database.types.ts for runtime validation of database operations.
 * Includes table row, insert, and update schemas for all Supabase tables.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for Supabase database tables
⋮----
/** Zod schema for JSON values (matches Supabase Json type). */
⋮----
/** TypeScript type for JSON (matches Supabase Json type). */
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];
⋮----
/**
 * Zod schema for trip status enum.
 * Defines possible states for trip entities.
 */
⋮----
/** TypeScript type for trip status. */
export type TripStatus = z.infer<typeof tripStatusSchema>;
⋮----
/**
 * Zod schema for trip type enum.
 * Defines categories for trip entities.
 */
⋮----
/** TypeScript type for trip type. */
export type TripType = z.infer<typeof tripTypeSchema>;
⋮----
/**
 * Zod schema for user_settings table Row.
 * Note: All user_id fields use z.uuid() because Supabase Auth generates UUIDs
 * for all user accounts. This is guaranteed by Supabase's authentication system.
 */
⋮----
/** TypeScript type for user_settings Row. */
export type UserSettingsRow = z.infer<typeof userSettingsRowSchema>;
⋮----
/**
 * Zod schema for user_settings table Insert.
 * Validates insert parameters for user_settings table.
 */
⋮----
/** TypeScript type for user_settings Insert. */
export type UserSettingsInsert = z.infer<typeof userSettingsInsertSchema>;
⋮----
/**
 * Zod schema for user_settings table Update.
 * Validates update parameters for user_settings table.
 */
⋮----
/** TypeScript type for user_settings Update. */
export type UserSettingsUpdate = z.infer<typeof userSettingsUpdateSchema>;
⋮----
/**
 * Zod schema for trips table Row.
 * Validates complete trip row data from database.
 */
⋮----
/** TypeScript type for trips Row. */
export type TripsRow = z.infer<typeof tripsRowSchema>;
⋮----
/**
 * Zod schema for trips table Insert.
 * Validates insert parameters for trips table.
 */
⋮----
/** TypeScript type for trips Insert. */
export type TripsInsert = z.infer<typeof tripsInsertSchema>;
⋮----
/**
 * Zod schema for trips table Update.
 * Validates update parameters for trips table.
 */
⋮----
/** TypeScript type for trips Update. */
export type TripsUpdate = z.infer<typeof tripsUpdateSchema>;
⋮----
/**
 * Zod schema for flight class enum.
 * Defines available flight classes.
 */
⋮----
/** TypeScript type for flight class. */
export type FlightClass = z.infer<typeof flightClassSchema>;
⋮----
/**
 * Zod schema for booking status enum.
 * Defines possible states for booking entities.
 */
⋮----
/** TypeScript type for booking status. */
export type BookingStatus = z.infer<typeof bookingStatusSchema>;
⋮----
/**
 * Zod schema for flights table Row.
 * Validates complete flight row data from database.
 */
⋮----
/** TypeScript type for flights Row. */
export type FlightsRow = z.infer<typeof flightsRowSchema>;
⋮----
/**
 * Zod schema for flights table Insert.
 * Validates insert parameters for flights table.
 */
⋮----
/** TypeScript type for flights Insert. */
export type FlightsInsert = z.infer<typeof flightsInsertSchema>;
⋮----
/**
 * Zod schema for flights table Update.
 * Validates update parameters for flights table.
 */
⋮----
/** TypeScript type for flights Update. */
export type FlightsUpdate = z.infer<typeof flightsUpdateSchema>;
⋮----
/**
 * Zod schema for accommodation source enum.
 * Defines available accommodation sources.
 */
⋮----
/** TypeScript type for accommodation source. */
export type AccommodationSource = z.infer<typeof accommodationSourceSchema>;
⋮----
/**
 * Zod schema for accommodations table Row.
 * Validates complete accommodation row data from database.
 */
⋮----
/** TypeScript type for accommodations Row. */
export type AccommodationsRow = z.infer<typeof accommodationsRowSchema>;
⋮----
/**
 * Zod schema for accommodations table Insert.
 * Validates insert parameters for accommodations table.
 */
⋮----
/** TypeScript type for accommodations Insert. */
export type AccommodationsInsert = z.infer<typeof accommodationsInsertSchema>;
⋮----
/**
 * Zod schema for accommodations table Update.
 * Validates update parameters for accommodations table.
 */
⋮----
/** TypeScript type for accommodations Update. */
export type AccommodationsUpdate = z.infer<typeof accommodationsUpdateSchema>;
⋮----
/**
 * Zod schema for HTTP method enum.
 * Defines allowed HTTP methods for API metrics.
 */
⋮----
/** TypeScript type for HTTP method. */
export type HttpMethod = z.infer<typeof httpMethodSchema>;
⋮----
/**
 * Zod schema for api_metrics table Row.
 * Validates complete api_metrics row data from database.
 */
⋮----
/** TypeScript type for api_metrics Row. */
export type ApiMetricsRow = z.infer<typeof apiMetricsRowSchema>;
⋮----
/**
 * Zod schema for api_metrics table Insert.
 * Validates insert parameters for api_metrics table.
 */
⋮----
/** TypeScript type for api_metrics Insert. */
export type ApiMetricsInsert = z.infer<typeof apiMetricsInsertSchema>;
⋮----
/**
 * Zod schema for api_metrics table Update.
 * Validates update parameters for api_metrics table.
 */
⋮----
/** TypeScript type for api_metrics Update. */
export type ApiMetricsUpdate = z.infer<typeof apiMetricsUpdateSchema>;
⋮----
// ===== UTILITY FUNCTIONS =====
// Schema registry and helper functions
⋮----
/**
 * Schema registry for all Supabase tables.
 * Provides centralized access to table schemas for row, insert, and update operations.
 */
⋮----
/**
 * Helper to get schema for a table name.
 * Retrieves table schemas from the registry for validation operations.
 *
 * @param table - Table name to get schemas for
 * @returns Table schemas (row, insert, update) or undefined if not found
 */
export function getSupabaseSchema<T extends keyof typeof supabaseSchemas>(
  table: T
): (typeof supabaseSchemas)[T] | undefined
````

## File: src/domain/schemas/telemetry.ts
````typescript
/**
 * @fileoverview Schemas for telemetry-related API boundaries.
 */
⋮----
import { z } from "zod";
⋮----
// ===== API REQUEST SCHEMAS =====
⋮----
export type TelemetryAiDemoRequest = z.infer<typeof telemetryAiDemoRequestSchema>;
````

## File: src/hooks/supabase/use-supabase-chat.ts
````typescript
/**
 * @fileoverview Client hooks for Supabase chat sessions, messages, and tool calls.
 */
⋮----
import { jsonSchema } from "@schemas/supabase";
import {
  useInfiniteQuery,
  useMutation,
  useQuery,
  useQueryClient,
} from "@tanstack/react-query";
import { useCallback, useEffect, useMemo, useState } from "react";
import { z } from "zod";
import { useSupabase, useSupabaseRequired } from "@/lib/supabase";
import type {
  ChatMessage,
  ChatRole,
  ChatSession,
  ChatSessionInsert,
  ChatToolCall,
  ChatToolCallInsert,
  UpdateTables,
} from "@/lib/supabase/database.types";
import { insertSingle, updateSingle } from "@/lib/supabase/typed-helpers";
import { useChatRealtime } from "./use-supabase-realtime";
⋮----
function useUserId(): string | null
⋮----
// During SSR, supabase is null - skip auth setup
⋮----
// Zod schemas for validation
⋮----
// Align with DB enum ChatRole (no "tool" role in chat_messages)
⋮----
.enum(["pending", "running", "completed", "failed"]) // matches DB enum
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
/** Hook for managing chat sessions and messages with Supabase. */
export function useSupabaseChat()
⋮----
// Fetch user's chat sessions
⋮----
// Validate input with Zod
⋮----
const queryFn = async () =>
⋮----
// Fetch single chat session
⋮----
// Fetch messages for a session with pagination
const useChatMessages = (sessionId: string | null) =>
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
staleTime: 1000 * 30, // 30 seconds for fresh messages
⋮----
// Create new chat session
⋮----
// Validate input with Zod
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// Send message with optimistic updates
⋮----
// Validate inputs with Zod
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// Update session's updated_at timestamp
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// Rollback optimistic update on error
⋮----
// Cancel outgoing refetches
⋮----
// Snapshot the previous value
⋮----
// Optimistically update the cache
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
id: -Date.now(), // temporary negative ID
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// Always refetch after mutation
⋮----
// Add tool call
⋮----
// Invalidate related message queries
⋮----
// Update tool call status
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// Validate inputs with Zod
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// Delete chat session and all messages
⋮----
// Delete all messages first (if needed) could be cascaded in DB
⋮----
// End chat session
⋮----
// Validate input with Zod
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// Create wrapper functions for the query hooks
const useChatSessions = (tripId?: number | null) =>
⋮----
const useChatSession = (sessionId: string | null) =>
⋮----
// Mutations
⋮----
// Query hooks
⋮----
// biome-ignore lint/correctness/useExhaustiveDependencies: Query hook functions are stable and don't need to be in dependencies
⋮----
// biome-ignore lint/correctness/useExhaustiveDependencies: Query hook functions are stable and don't need to be in dependencies
⋮----
// biome-ignore lint/correctness/useExhaustiveDependencies: Query hook functions are stable and don't need to be in dependencies
⋮----
/**
 * Hook that combines chat functionality with real-time updates.
 *
 * @param sessionId - Chat session ID to monitor
 */
export function useChatWithRealtime(sessionId: string | null)
⋮----
// Get chat data
⋮----
// Real-time status
⋮----
// Chat actions
⋮----
// Chat data
⋮----
/**
 * Hook for chat session statistics.
 */
export function useChatStats()
⋮----
// Get session counts
⋮----
// Get total message count
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database field names use snake_case
⋮----
staleTime: 1000 * 60 * 15, // 15 minutes
````

## File: src/lib/auth/confirm-next.ts
````typescript
/**
 * @fileoverview Hardened sanitizer for the auth confirm `next` query parameter.
 *
 * Prevents open redirect by allowlisting internal, app-relative paths.
 */
⋮----
// Intentionally restrictive allowlist: auth confirm links are user-controlled inputs and a common
// open-redirect vector. Start with the primary post-auth landing area only; expand via explicit
// allowlisted prefixes (and tests) as new flows require it. Never allow external URLs or /auth/*.
⋮----
function decodeOnce(value: string): string
⋮----
function isAllowedNextPath(pathname: string): boolean
⋮----
export function sanitizeAuthConfirmNextParam(rawNext: string | null): string
⋮----
// Only allow internal, app-relative paths.
⋮----
// URL parsing defends against tricky values like "/\\evil", etc.
````

## File: src/lib/auth/supabase-errors.ts
````typescript
/**
 * @fileoverview Supabase auth error helpers.
 */
⋮----
export type SupabaseAuthError = {
  code?: string;
  message?: string;
  status?: number;
};
⋮----
export function isMfaRequiredError(err: unknown): err is SupabaseAuthError
⋮----
export function getAuthErrorStatus(err: unknown): number | null
⋮----
export function getAuthErrorCode(err: unknown): string | null
````

## File: src/lib/calendar/auth.ts
````typescript
/**
 * @fileoverview Server-only helpers for reading Google OAuth tokens from the Supabase session.
 */
⋮----
import { createServerSupabase } from "@/lib/supabase/server";
⋮----
/**
 * Error thrown when Google OAuth token is not available.
 */
export class GoogleTokenError extends Error
⋮----
constructor(message: string)
⋮----
/**
 * Get Google OAuth provider token from Supabase session.
 *
 * Retrieves the Google provider token from the current user's Supabase session.
 * The token is stored in session.provider_token when the user authenticates
 * via Google OAuth.
 *
 * @returns Promise resolving to Google OAuth access token
 * @throws GoogleTokenError if token is not available or user is not authenticated
 */
export async function getGoogleProviderToken(): Promise<string>
⋮----
// Check if provider_token exists in session
// Supabase stores provider tokens in session.provider_token for OAuth providers
⋮----
// Attempt to refresh session in case token expired
⋮----
/**
 * Check if user has Google Calendar OAuth scopes.
 *
 * Validates that the user's session includes the required Google Calendar
 * scopes for read/write access.
 *
 * @param requiredScopes - Array of required OAuth scopes (default: calendar.events)
 * @returns Promise resolving to true if scopes are available, false otherwise
 */
export async function hasGoogleCalendarScopes(
  _requiredScopes: string[] = ["https://www.googleapis.com/auth/calendar.events"]
): Promise<boolean>
⋮----
// If provider tokens exist, assume scopes are granted. For stricter checks,
// decode the provider token and validate scopes against required scopes.
````

## File: src/lib/env/server.ts
````typescript
/**
 * @fileoverview Server-only validated environment access with per-process caching and build-phase fail-fast guard.
 */
⋮----
import type { ServerEnv } from "@schemas/env";
import { envSchema } from "@schemas/env";
import { isBuildPhase } from "@/lib/utils/build-phase";
⋮----
// Single cached validated environment
⋮----
function createBuildPhaseServerEnvProxy(): ServerEnv
⋮----
get(_target, prop)
⋮----
/** Test-only helper to clear cached env between runs. */
export function __resetServerEnvCacheForTest()
⋮----
function parseServerEnv(): ServerEnv
⋮----
// During build phase, always return a Proxy that fails fast on access.
⋮----
/**
 * Get validated server environment variables.
 *
 * @returns Validated server environment object
 * @throws Error if validation fails or called on client
 */
export function getServerEnv(): ServerEnv
⋮----
/**
 * Get a specific server environment variable by key.
 *
 * @param key - Environment variable key
 * @returns Environment variable value
 * @throws Error if key is missing or invalid
 */
export function getServerEnvVar<T extends keyof ServerEnv>(
  key: T
): Exclude<ServerEnv[T], undefined>
⋮----
/**
 * Get server environment variable with fallback.
 *
 * @param key - Environment variable key
 * @param fallback - Fallback value if key is missing
 * @returns Environment variable value or fallback
 */
export function getServerEnvVarWithFallback<T extends keyof ServerEnv>(
  key: T,
  fallback: ServerEnv[T]
): ServerEnv[T]
⋮----
// Google Maps Platform helpers (server-only)
/**
 * Get Google Maps Platform server API key.
 *
 * Server key must be IP+API restricted for Places, Routes, Geocoding, Time Zone.
 *
 * @returns Server API key
 * @throws Error if key is missing or invalid
 */
export function getGoogleMapsServerKey(): string
⋮----
// When the env var is missing entirely, preserve original 'not defined' message
⋮----
/**
 * Get the public Google Maps browser key from a server context.
 *
 * This key is safe to embed in client-consumed URLs and should be referrer-restricted.
 *
 * @returns Public browser key or undefined if unavailable (or during build phase)
 */
export function getGoogleMapsBrowserKey(): string | undefined
⋮----
// Export validated env object for advanced use cases (lazy getter)
⋮----
getOwnPropertyDescriptor(_target, prop)
ownKeys()
````

## File: src/lib/http/body.ts
````typescript
/**
 * @fileoverview Bounded request body readers to enforce hard size limits before parsing.
 */
⋮----
export class PayloadTooLargeError extends Error
⋮----
constructor(maxBytes: number)
⋮----
export class RequestBodyAlreadyReadError extends Error
⋮----
constructor()
⋮----
function parseContentLength(headers: Headers): number | null
⋮----
export async function readRequestBodyBytesWithLimit(
  req: Request,
  maxBytes: number
): Promise<Uint8Array>
⋮----
// Best-effort cancel; do not await (can hang depending on stream impl).
⋮----
// ignore cancel errors
````

## File: src/lib/http/ip.ts
````typescript
/**
 * @fileoverview Client IP extraction helpers for server-side requests.
 *
 * This module is intentionally header-only (accepts `Headers`) so it can be
 * reused from NextRequest, standard Request, and Next.js `headers()` calls.
 */
⋮----
/**
 * Validate a string as an IPv4 or IPv6 address.
 *
 * Note: This is intentionally strict to avoid treating arbitrary strings from
 * spoofed headers as a "client IP" for security-sensitive operations.
 */
function isValidIpAddress(ip: string): boolean
⋮----
// IPv6 regex supports full, compressed, and IPv4-mapped forms.
⋮----
/**
 * Extract the client IP from trusted sources with deterministic fallback.
 *
 * Priority order:
 * 1) `x-real-ip` (Vercel's canonical client IP header)
 * 2) `x-forwarded-for` (first IP)
 * 3) `cf-connecting-ip` (Cloudflare deployments)
 * 4) `"unknown"`
 */
export function getClientIpFromHeaders(headers: Pick<Headers, "get">): string
````

## File: src/lib/memory/orchestrator.ts
````typescript
/**
 * @fileoverview Supabase-centric memory orchestrator.
 *
 * Defines MemoryIntent, adapter interfaces, and the orchestrator pipeline
 * that fans out to Supabase, Upstash, and Mem0 adapters with telemetry and
 * basic PII redaction for non-canonical providers.
 */
⋮----
import type { MemoryContextResponse, Message } from "@schemas/chat";
import { hashTelemetryIdentifier } from "@/lib/telemetry/identifiers";
import { withTelemetrySpan } from "@/lib/telemetry/span";
import { createMem0Adapter } from "./mem0-adapter";
import { createSupabaseMemoryAdapter } from "./supabase-adapter";
import { createUpstashMemoryAdapter } from "./upstash-adapter";
⋮----
/** Supported memory intent types. */
export type MemoryIntentType =
  | "onTurnCommitted"
  | "syncSession"
  | "backfillSession"
  | "fetchContext";
⋮----
/** Memory orchestrator intent payloads. */
export type MemoryIntent =
  | {
      type: "onTurnCommitted";
      sessionId: string;
      userId: string;
      turn: Message;
    }
  | {
      type: "syncSession";
      sessionId: string;
      userId: string;
    }
  | {
      type: "backfillSession";
      sessionId: string;
      userId: string;
    }
  | {
      type: "fetchContext";
      sessionId: string;
      userId: string;
      limit?: number;
    };
⋮----
/** Execution context passed to adapters. */
export interface MemoryAdapterContext {
  /** Monotonic clock in milliseconds. */
  now: () => number;
}
⋮----
/** Monotonic clock in milliseconds. */
⋮----
/** Per-adapter execution status. */
export type MemoryAdapterExecutionStatus = "ok" | "skipped" | "error";
⋮----
/** Minimal result shape returned by adapters. */
export interface MemoryAdapterExecutionResult {
  status: MemoryAdapterExecutionStatus;
  error?: string;
  /**
   * Optional context items produced by adapters for fetchContext intents.
   * Supabase canonical adapter should populate this from the primary store;
   * Mem0 adapter may append enriched context snippets.
   */
  contextItems?: MemoryContextResponse[];
}
⋮----
/**
   * Optional context items produced by adapters for fetchContext intents.
   * Supabase canonical adapter should populate this from the primary store;
   * Mem0 adapter may append enriched context snippets.
   */
⋮----
/** Adapter interface for memory backends. */
export interface MemoryAdapter {
  /** Stable adapter identifier (e.g., "supabase", "upstash", "mem0"). */
  id: string;
  /** Intents this adapter can handle. */
  supportedIntents: MemoryIntentType[];
  /**
   * Handle a memory intent.
   *
   * Implementations should treat errors as localized and return status "error"
   * rather than throwing, except for truly unexpected failures.
   */
  handle(
    intent: MemoryIntent,
    ctx: MemoryAdapterContext
  ): Promise<MemoryAdapterExecutionResult>;
}
⋮----
/** Stable adapter identifier (e.g., "supabase", "upstash", "mem0"). */
⋮----
/** Intents this adapter can handle. */
⋮----
/**
   * Handle a memory intent.
   *
   * Implementations should treat errors as localized and return status "error"
   * rather than throwing, except for truly unexpected failures.
   */
handle(
    intent: MemoryIntent,
    ctx: MemoryAdapterContext
  ): Promise<MemoryAdapterExecutionResult>;
⋮----
/** Result for a single adapter after orchestration. */
export interface MemoryAdapterResult extends MemoryAdapterExecutionResult {
  adapterId: string;
  intentType: MemoryIntentType;
  durationMs?: number;
}
⋮----
/** Aggregate orchestrator result across all adapters. */
export interface MemoryOrchestratorResult {
  intent: MemoryIntent;
  status: "ok" | "partial" | "error";
  results: MemoryAdapterResult[];
  /**
   * Aggregated context items merged from all adapters for fetchContext intents.
   * For non-fetch intents this will be undefined.
   */
  context?: MemoryContextResponse[];
}
⋮----
/**
   * Aggregated context items merged from all adapters for fetchContext intents.
   * For non-fetch intents this will be undefined.
   */
⋮----
/** Orchestrator configuration. */
export interface MemoryOrchestratorOptions {
  adapters: MemoryAdapter[];
  /** Optional clock implementation for testing. Defaults to Date.now. */
  clock?: () => number;
}
⋮----
/** Optional clock implementation for testing. Defaults to Date.now. */
⋮----
/** Simple PII redaction result. */
type PiiRedactionResult = {
  hadPii: boolean;
  redacted: string;
};
⋮----
/**
 * Redact basic PII patterns (emails, phone numbers, card-like numbers) from text.
 * Intended for non-canonical adapters (Mem0, Upstash) where content leaves
 * the primary datastore.
 */
function redactPii(text: string): PiiRedactionResult
⋮----
const replace = () =>
⋮----
// Email addresses
⋮----
// Phone numbers (basic)
⋮----
// Card-like digit sequences
⋮----
/**
 * Derive a sanitized version of the intent for non-Supabase adapters.
 * Currently only redacts `turn.content` for `onTurnCommitted` intents.
 */
function buildSanitizedIntent(intent: MemoryIntent):
⋮----
/**
 * Run the memory orchestrator for a given intent with explicit configuration.
 *
 * @param intent Memory intent to handle.
 * @param options Orchestrator configuration (adapters and optional clock).
 * @returns Aggregated orchestrator result.
 */
export function runMemoryOrchestrator(
  intent: MemoryIntent,
  options: MemoryOrchestratorOptions
): Promise<MemoryOrchestratorResult>
⋮----
/**
 * Build the default orchestrator configuration using Supabase, Upstash, and Mem0 adapters.
 *
 * Mem0 adapter is included only when environment/configuration allows it
 * (e.g., MEM0_API_KEY or equivalent is present).
 */
export function createDefaultMemoryOrchestratorOptions(): MemoryOrchestratorOptions
⋮----
/**
 * Convenience helper for running the orchestrator with default adapters.
 *
 * @param intent Memory intent to handle.
 * @returns Aggregated orchestrator result.
 */
export function handleMemoryIntent(
  intent: MemoryIntent
): Promise<MemoryOrchestratorResult>
````

## File: src/lib/memory/supabase-adapter.ts
````typescript
/**
 * @fileoverview Memory adapter backed by Supabase `memories.*` tables.
 */
⋮----
import type { MemoryContextResponse } from "@schemas/chat";
import { jsonSchema } from "@schemas/supabase";
import type { SupabaseClient } from "@supabase/supabase-js";
import { createAdminSupabase } from "@/lib/supabase/admin";
import type { Database } from "@/lib/supabase/database.types";
import type {
  MemoryAdapter,
  MemoryAdapterContext,
  MemoryAdapterExecutionResult,
  MemoryIntent,
} from "./orchestrator";
⋮----
type AdminClient = SupabaseClient<Database>;
type MemoryTurnRow = Database["memories"]["Tables"]["turns"]["Row"];
⋮----
async function handleFetchContext(
  supabase: AdminClient,
  intent: Extract<MemoryIntent, { type: "fetchContext" }>
): Promise<MemoryAdapterExecutionResult>
⋮----
// Fetch recent turns for this user (and session when available).
⋮----
// Filter by session when present to keep context scoped.
⋮----
// Extract text content from JSONB content field
⋮----
// Handle JSONB content - extract text if it's a structured object
⋮----
async function handleOnTurnCommitted(
  supabase: AdminClient,
  intent: Extract<MemoryIntent, { type: "onTurnCommitted" }>
): Promise<MemoryAdapterExecutionResult>
⋮----
// Ensure session exists
⋮----
// PGRST116 is "not found" - we'll create the session below
⋮----
// Create session if it doesn't exist
⋮----
// biome-ignore lint/style/useNamingConvention: database column uses snake_case
⋮----
// Insert turn
⋮----
// Convert string content to JSONB format: { text: string }
⋮----
// biome-ignore lint/style/useNamingConvention: database column uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database column uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database column uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database column uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: database column uses snake_case
⋮----
// Update session last_synced_at
⋮----
// biome-ignore lint/style/useNamingConvention: database column uses snake_case
⋮----
async function handleSyncSession(
  supabase: AdminClient,
  intent: Extract<MemoryIntent, { type: "syncSession" }>
): Promise<MemoryAdapterExecutionResult>
⋮----
// Update session last_synced_at
⋮----
// biome-ignore lint/style/useNamingConvention: database column uses snake_case
⋮----
/**
 * Create Supabase memory adapter.
 *
 * Uses the service-role client for robust background-friendly writes while
 * still enforcing per-user scoping in queries. Handles all memory intents
 * against the canonical memories schema.
 */
export function createSupabaseMemoryAdapter(): MemoryAdapter
⋮----
async handle(
      intent: MemoryIntent,
      ctx: MemoryAdapterContext
): Promise<MemoryAdapterExecutionResult>
⋮----
// backfillSession can be handled similarly to syncSession
````

## File: src/lib/metrics/aggregate.ts
````typescript
/**
 * @fileoverview Dashboard metrics aggregation.
 *
 * Aggregates API metrics and trip statistics for the dashboard.
 * Implements cache-aside pattern with Upstash Redis.
 * Uses OpenTelemetry for tracing.
 */
⋮----
import { type DashboardMetrics, dashboardMetricsSchema } from "@schemas/dashboard";
import { getRedis } from "@/lib/redis";
import type { ApiMetric } from "@/lib/supabase/database.types";
import { createServerSupabase } from "@/lib/supabase/server";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/** Metric row shape for api_metrics queries (subset of columns needed). */
type ApiMetricRow = Pick<ApiMetric, "duration_ms" | "status_code">;
⋮----
/**
 * Aggregates dashboard metrics from Supabase with Redis caching.
 *
 * Implements cache-aside pattern:
 * 1. Check Redis cache first
 * 2. If miss, query Supabase and cache result
 * 3. Cache TTL: 5 minutes (300 seconds)
 *
 * @param windowHours - Time window in hours (0 = all time)
 * @returns Aggregated dashboard metrics
 */
export function aggregateDashboardMetrics(
  windowHours: number = 24
): Promise<DashboardMetrics>
⋮----
// 1. Check cache first
⋮----
// Validate cached data against schema
⋮----
// Invalid cache data, continue to fetch fresh
⋮----
// 2. Query Supabase for fresh data
⋮----
// Calculate time filter
⋮----
// Parallel queries for trips and API metrics
⋮----
// Query api_metrics table (will fail gracefully if table doesn't exist yet)
⋮----
// Process trip statistics
⋮----
// Process API metrics
⋮----
// 3. Cache result (5-minute TTL)
⋮----
/**
 * Fetches API metrics from Supabase.
 *
 * Gracefully handles missing table (returns empty array).
 *
 * @param supabase - Supabase client
 * @param since - ISO timestamp filter (null for all time)
 * @returns Array of metric rows
 */
async function fetchApiMetrics(
  supabase: Awaited<ReturnType<typeof createServerSupabase>>,
  since: string | null
): Promise<ApiMetricRow[]>
⋮----
// Table might not exist yet, return empty
⋮----
/**
 * Invalidates the dashboard metrics cache.
 *
 * Call this when metrics data changes significantly (e.g., after data cleanup).
 *
 * @param windowHours - Specific window to invalidate, or undefined for all windows
 */
export async function invalidateDashboardCache(windowHours?: number): Promise<void>
⋮----
// Invalidate all common windows
````

## File: src/lib/notifications/collaborators.ts
````typescript
/**
 * @fileoverview Trip collaborator notification utilities with email and webhook support.
 */
⋮----
import { Resend } from "resend";
import { withCircuitBreaker } from "@/lib/circuit-breaker";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
import { createAdminSupabase } from "@/lib/supabase/admin";
import type { Database } from "@/lib/supabase/database.types";
import { withTelemetrySpan } from "@/lib/telemetry/span";
import type { WebhookPayload } from "@/lib/webhooks/payload";
⋮----
type TripCollaboratorRow = Database["public"]["Tables"]["trip_collaborators"]["Row"];
/**
 * Extracted collaborator record fields from webhook payload.
 */
type CollaboratorRecord = {
  role?: string;
  tripId?: number;
  userId?: string;
};
⋮----
/**
 * Looks up a user's email address by their user ID.
 *
 * @param userId - The user's unique identifier.
 * @return User's email address or null if not found.
 */
async function lookupUserEmail(userId: string): Promise<string | null>
⋮----
/**
 * Sends notifications for trip collaborator changes via email and webhooks.
 *
 * @param event - The webhook payload containing the collaborator change.
 * @param eventKey - Unique identifier for the event to prevent duplicates.
 * @return Object indicating which notification methods succeeded.
 */
export async function sendCollaboratorNotifications(
  event: WebhookPayload,
  eventKey: string
): Promise<
⋮----
// Email via Resend (if configured and user email is resolvable)
// Uses circuit breaker to prevent DLQ flood during Resend outages
⋮----
// Optional downstream webhook
⋮----
/**
 * Builds email subject line for collaborator notifications.
 *
 * @param event - The webhook payload.
 * @return Appropriate subject line for the event type.
 */
function buildSubject(event: WebhookPayload): string
⋮----
/**
 * Builds email body content for collaborator notifications.
 *
 * @param event - The webhook payload.
 * @param eventKey - Unique event identifier.
 * @return Email body content.
 */
function buildBody(event: WebhookPayload, eventKey: string): string
⋮----
/**
 * Extracts collaborator record fields from webhook payload.
 *
 * @param event - The webhook payload.
 * @return Extracted collaborator record or null if no relevant fields.
 */
function extractCollaboratorRecord(event: WebhookPayload): CollaboratorRecord | null
````

## File: src/lib/qstash/receiver.ts
````typescript
/**
 * @fileoverview QStash Receiver utilities for signature verification.
 *
 * Centralizes creation and verification logic to keep job route handlers
 * consistent and reduce security-critical duplication.
 */
⋮----
import { createHash } from "node:crypto";
import { Receiver } from "@upstash/qstash";
import type { NextResponse } from "next/server";
import { errorResponse } from "@/lib/api/route-helpers";
import { getServerEnvVar, getServerEnvVarWithFallback } from "@/lib/env/server";
import { PayloadTooLargeError, readRequestBodyBytesWithLimit } from "@/lib/http/body";
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { createServerLogger } from "@/lib/telemetry/logger";
import { QSTASH_SIGNATURE_HEADER } from "./config";
⋮----
export type QstashVerifyFailureReason =
  | "body_read_error"
  | "invalid_signature"
  | "missing_signature"
  | "payload_too_large";
⋮----
export type VerifyQstashRequestResult =
  | {
      ok: true;
      body: string;
    }
  | {
      ok: false;
      reason: QstashVerifyFailureReason;
      response: NextResponse;
    };
⋮----
/**
 * Create a QStash Receiver for signature verification.
 *
 * Uses `QSTASH_CURRENT_SIGNING_KEY` and `QSTASH_NEXT_SIGNING_KEY` (fallback to current).
 * Emits an operational alert when the next signing key is missing/empty, which can
 * cause issues during key rotation.
 */
export function getQstashReceiver(): Receiver
⋮----
/**
 * Verify that a request originated from QStash, and return the raw body string.
 *
 * Reads the request body exactly once. Callers should parse JSON from `body`.
 */
export async function verifyQstashRequest(
  req: Request,
  receiver: Receiver,
  options: { maxBytes?: number } = {}
): Promise<VerifyQstashRequestResult>
````

## File: src/lib/rag/indexer.ts
````typescript
/**
 * @fileoverview Server-only RAG indexing (chunking + embeddings + storage).
 */
⋮----
import { openai } from "@ai-sdk/openai";
import type {
  IndexerConfig,
  RagDocument,
  RagIndexFailedDoc,
  RagIndexResponse,
  RagNamespace,
} from "@schemas/rag";
import { indexerConfigSchema } from "@schemas/rag";
import type { SupabaseClient } from "@supabase/supabase-js";
import { embedMany } from "ai";
import { secureUuid } from "@/lib/security/random";
import type { Database } from "@/lib/supabase/database.types";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
import { toPgvector } from "./pgvector";
⋮----
/** Token to character ratio approximation (conservative). */
⋮----
/**
 * Chunk document text with overlap.
 *
 * Uses character-based chunking with configurable size and overlap.
 * Attempts to break at sentence boundaries when possible.
 *
 * @param text - Document text to chunk.
 * @param chunkSize - Target chunk size in tokens (converted to chars).
 * @param chunkOverlap - Overlap between chunks in tokens.
 * @returns Array of text chunks.
 */
export function chunkText(
  text: string,
  chunkSize: number = 512,
  chunkOverlap: number = 100
): string[]
⋮----
// Try to break at sentence boundary if not at end
⋮----
// Find last sentence boundary in search window
⋮----
// Move start forward with overlap
// Ensure start always advances to prevent infinite loop
⋮----
// If overlap would cause us to go backwards or stay in place, just advance to end
⋮----
/**
 * Index parameters for the core indexing function.
 */
export interface IndexDocumentsParams {
  /** Documents to index. */
  documents: RagDocument[];
  /** Supabase client instance. */
  supabase: SupabaseClient<Database>;
  /** Indexer configuration. */
  config?: Partial<IndexerConfig>;
}
⋮----
/** Documents to index. */
⋮----
/** Supabase client instance. */
⋮----
/** Indexer configuration. */
⋮----
/**
 * Index documents into the RAG store.
 *
 * Process:
 * 1. Chunk each document based on config
 * 2. Generate embeddings in batches via embedMany()
 * 3. Upsert chunks to rag_documents table
 * 4. Track failures per document
 *
 * @param params - Indexing parameters.
 * @returns Index operation result with counts and failures.
 *
 * @example
 * ```typescript
 * const result = await indexDocuments({
 *   documents: [{ content: "Travel guide...", metadata: { type: "guide" } }],
 *   supabase,
 *   config: { namespace: "travel_tips", chunkSize: 512 }
 * });
 * ```
 */
// biome-ignore lint/suspicious/useAwait: Returns withTelemetrySpan promise which is async
export async function indexDocuments(
  params: IndexDocumentsParams
): Promise<RagIndexResponse>
⋮----
// Process documents in batches to control memory
⋮----
// If entire batch fails, mark all documents in batch as failed
⋮----
/**
 * Internal batch indexing parameters.
 */
interface IndexBatchParams {
  batch: RagDocument[];
  batchStartIndex: number;
  config: IndexerConfig;
  supabase: SupabaseClient<Database>;
}
⋮----
/**
 * Internal batch indexing result.
 */
interface IndexBatchResult {
  chunksCreated: number;
  failed: RagIndexFailedDoc[];
  indexed: number;
}
⋮----
/**
 * Index a batch of documents.
 *
 * @internal
 */
async function indexBatch(params: IndexBatchParams): Promise<IndexBatchResult>
⋮----
// Prepare all chunks with document index tracking
⋮----
// Generate embeddings for all chunks in batch
⋮----
// Prepare rows for upsert
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// biome-ignore lint/style/useNamingConvention: Database field name
⋮----
// Upsert to database
⋮----
// Count successful documents (unique doc indices)
⋮----
/**
 * Delete all documents in a namespace.
 *
 * @param supabase - Supabase client instance.
 * @param namespace - Namespace to clear.
 * @returns Count of deleted documents.
 */
export async function deleteNamespace(
  supabase: SupabaseClient<Database>,
  namespace: RagNamespace
): Promise<number>
````

## File: src/lib/rag/pgvector.ts
````typescript
/**
 * @fileoverview pgvector serialization helpers (number[] -> string literal).
 */
⋮----
export function toPgvector(embedding: readonly number[]): string
⋮----
// Intentionally preserve JavaScript numeric string formatting (including scientific
// notation) to avoid rounding/precision changes; pgvector accepts this input form.
````

## File: src/lib/rag/retriever.ts
````typescript
/**
 * @fileoverview Server-only RAG retrieval (hybrid/semantic) and optional reranking.
 */
⋮----
import { openai } from "@ai-sdk/openai";
import type { RagSearchResponse, RagSearchResult, RetrieverConfig } from "@schemas/rag";
import { retrieverConfigSchema } from "@schemas/rag";
import type { SupabaseClient } from "@supabase/supabase-js";
import { embed } from "ai";
import type { Database } from "@/lib/supabase/database.types";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
import { toPgvector } from "./pgvector";
import { createReranker, type Reranker } from "./reranker";
⋮----
/**
 * Retrieve parameters for the core retrieval function.
 */
export interface RetrieveDocumentsParams {
  /** Search query. */
  query: string;
  /** Supabase client instance. */
  supabase: SupabaseClient<Database>;
  /** Retriever configuration. */
  config?: Partial<RetrieverConfig>;
  /** Custom reranker instance. */
  reranker?: Reranker;
}
⋮----
/** Search query. */
⋮----
/** Supabase client instance. */
⋮----
/** Retriever configuration. */
⋮----
/** Custom reranker instance. */
⋮----
/**
 * Retrieve documents using hybrid search with optional reranking.
 *
 * Process:
 * 1. Generate query embedding via embed()
 * 2. Execute hybrid_rag_search RPC (vector + lexical)
 * 3. Optionally rerank results via Together.ai
 * 4. Return scored results with latency tracking
 *
 * @param params - Retrieval parameters.
 * @returns Search results with scores and metadata.
 *
 * @example
 * ```typescript
 * const result = await retrieveDocuments({
 *   query: "best hotels in Paris",
 *   supabase,
 *   config: { namespace: "accommodations", limit: 10 }
 * });
 * ```
 */
// biome-ignore lint/suspicious/useAwait: Returns withTelemetrySpan promise which is async
export async function retrieveDocuments(
  params: RetrieveDocumentsParams
): Promise<RagSearchResponse>
⋮----
// Generate query embedding
⋮----
// Execute hybrid search RPC
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// Map RPC results to search result schema
⋮----
// Apply reranking if enabled and we have results
⋮----
// Graceful fallback: use original results
⋮----
// No reranking: just limit results
⋮----
/**
 * Simple semantic search without hybrid or reranking.
 *
 * For cases where pure vector similarity is sufficient.
 *
 * @param params - Search parameters.
 * @returns Search results.
 */
export async function semanticSearch(params: {
  query: string;
  supabase: SupabaseClient<Database>;
  namespace?: string;
  limit?: number;
  threshold?: number;
}): Promise<RagSearchResult[]>
⋮----
// Generate query embedding
⋮----
// Call simpler match function
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameter name
````

## File: src/lib/ratelimit/headers.ts
````typescript
/**
 * @fileoverview Helpers for attaching standard rate limit response headers.
 */
⋮----
export type RateLimitHeaderMeta = {
  limit?: number;
  remaining?: number;
  reset?: number;
  success?: boolean;
};
⋮----
/**
 * Normalize a Unix timestamp to milliseconds.
 *
 * Upstash Ratelimit (TS) documents `reset` as a Unix timestamp in milliseconds,
 * but some call sites/tests may provide seconds. This helper converts values
 * that look like Unix seconds (10-digit epoch seconds) to milliseconds.
 */
export function normalizeRateLimitResetToMs(reset: number): number
⋮----
// Seconds since epoch are ~1_7xx_...; milliseconds are ~1_7xx_..._000.
⋮----
function computeRetryAfterSeconds(resetMs: number, nowMs: number): number
⋮----
/**
 * Create standardized HTTP rate limit headers (X-RateLimit-* + Retry-After).
 *
 * `reset` is expected to be a Unix timestamp in milliseconds.
 * `Retry-After` is only included when `success === false` and `reset` is present.
 */
export function createRateLimitHeaders(
  meta: RateLimitHeaderMeta,
  options?: { nowMs?: number }
): Record<string, string>
⋮----
/**
 * Apply standardized rate limit headers to an existing Headers object.
 */
export function applyRateLimitHeaders(
  target: Headers,
  meta: RateLimitHeaderMeta,
  options?: { nowMs?: number }
): void
````

## File: src/lib/ratelimit/routes.ts
````typescript
/**
 * @fileoverview Centralized rate limit registry for API routes.
 *
 * Single source of truth for route-level rate limit configurations across all
 * API routes. Used by withApiGuards factory. Per ADR-0032.
 *
 * Note: Agent tool-level rate limiting (within agent execution) is handled by
 * lib/ratelimit/config.ts. This registry is for HTTP route-level limits only.
 */
⋮----
/**
 * Rate limit configuration.
 *
 * @property limit Maximum number of requests allowed per window.
 * @property window Time window string (e.g., "1 m", "1 h", "1 d").
 */
export interface RouteRateLimitDefinition {
  limit: number;
  window: string;
}
⋮----
/**
 * Rate limit registry for all API routes.
 *
 * Key format: `{namespace}:{resource}:{action}` (e.g., `agents:flight`,
 * `chat:sessions:list`, `calendar:events:read`).
 */
⋮----
// Accommodations
⋮----
// Activities
⋮----
// Agent routes
⋮----
// AI routes
⋮----
// Attachments
⋮----
// Auth (security-sensitive - tighter limits aligned with security best practices)
⋮----
// Calendar routes
⋮----
// Chat routes
⋮----
// Configuration
⋮----
// Dashboard
⋮----
// Embeddings and geocoding
⋮----
// Flights
⋮----
// Itineraries
⋮----
// Keys (BYOK routes - security sensitive)
⋮----
// Memory
⋮----
// Places
⋮----
// RAG (Retrieval-Augmented Generation)
"rag:index": { limit: 10, window: "1 m" }, // Batch indexing
"rag:search": { limit: 100, window: "1 m" }, // Hybrid search
⋮----
// Routes and directions
⋮----
// Security
⋮----
// Telemetry
⋮----
// Timezone
⋮----
// Trips
⋮----
// User settings
⋮----
/** Type for rate limit registry keys. */
export type RouteRateLimitKey = keyof typeof ROUTE_RATE_LIMITS;
````

## File: src/lib/security/internal-key.ts
````typescript
/**
 * @fileoverview Timing-safe comparison helpers for internal service keys.
 */
⋮----
import { timingSafeEqual } from "node:crypto";
⋮----
/**
 * Compares a provided internal key against an expected value using
 * `timingSafeEqual` (defense-in-depth against subtle timing leaks).
 *
 * Note: length mismatches return false early (timingSafeEqual requires equal length).
 *
 * @param provided - Key from request header (may be null).
 * @param expected - Key from server env (must be non-empty to be meaningful).
 * @returns True when keys are equal, false otherwise.
 */
export function isValidInternalKey(provided: string | null, expected: string): boolean
````

## File: src/lib/security/mfa.ts
````typescript
/**
 * @fileoverview Supabase MFA service helpers (TOTP + backup codes).
 */
⋮----
import { createHash } from "node:crypto";
⋮----
import {
  type BackupCodeList,
  backupCodeRegenerateInputSchema,
  backupCodeSchema,
  backupCodeVerifyInputSchema,
  type MfaEnrollment,
  type MfaFactor,
  type MfaVerificationInput,
  mfaChallengeInputSchema,
  mfaEnrollmentSchema,
  mfaFactorSchema,
  mfaVerificationInputSchema,
} from "@schemas/mfa";
import type { SupabaseClient } from "@supabase/supabase-js";
import { getServerEnv } from "@/lib/env/server";
import { incrCounter } from "@/lib/redis";
import { nowIso, secureId } from "@/lib/security/random";
import { getAdminSupabase, type TypedAdminSupabase } from "@/lib/supabase/admin";
import type { Database } from "@/lib/supabase/database.types";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
type TypedSupabase = SupabaseClient<Database>;
type BackupAuditMeta = { ip?: string; userAgent?: string };
⋮----
/** A custom error class for invalid backup codes. */
export class InvalidBackupCodeError extends Error
⋮----
constructor(message = "invalid_backup_code")
⋮----
/** A custom error class for user lookup errors. */
class UserLookupError extends Error
⋮----
constructor(message = "user_not_found")
⋮----
/** A custom error class for AAL2 enforcement failures. */
export class MfaRequiredError extends Error
⋮----
/** Stable machine-readable error code for step-up MFA requirements. */
⋮----
constructor(message = "mfa_required")
⋮----
/** Indicates a client-visible TOTP validation failure (bad/expired code). */
export class InvalidTotpError extends Error
⋮----
constructor(message = "invalid_or_expired_code")
⋮----
/** Indicates an internal failure verifying TOTP (DB/network). */
export class TotpVerificationInternalError extends Error
⋮----
constructor(message = "mfa_verify_failed")
⋮----
/** The cache of the backup code pepper. */
⋮----
/** Tracks whether MFA module has been initialized. */
⋮----
/**
 * Initializes the MFA module by validating configuration.
 * Must be called explicitly during application bootstrap.
 * Safe to call multiple times (idempotent).
 */
export function initMfa(): void
⋮----
/**
 * Resets MFA initialization state for testing.
 * @internal Test-only export.
 */
export function resetMfaInitForTest(): void
⋮----
/** Gets the backup code pepper. */
function getBackupCodePepper(): string
⋮----
/** Validates MFA configuration; throws if required secrets are missing. */
export function validateMfaConfig(): void
⋮----
/**
 * Gets the authenticated user ID.
 *
 * @param supabase - The Supabase client.
 * @returns The authenticated user ID.
 */
async function getAuthenticatedUserId(supabase: TypedSupabase): Promise<string>
⋮----
/**
 * Generates a list of backup codes.
 *
 * @param count - The number of backup codes to generate.
 * @returns A list of backup codes.
 */
function generateBackupCodes(count: number): string[]
⋮----
/**
 * Starts a TOTP enrollment.
 *
 * @param supabase - The Supabase client.
 * @returns The enrollment result.
 */
export async function startTotpEnrollment(
  supabase: TypedSupabase,
  deps?: { adminSupabase?: TypedAdminSupabase }
): Promise<MfaEnrollment>
⋮----
// biome-ignore lint/style/useNamingConvention: snake_case columns
⋮----
// biome-ignore lint/style/useNamingConvention: snake_case columns
⋮----
// biome-ignore lint/style/useNamingConvention: snake_case columns
⋮----
// biome-ignore lint/style/useNamingConvention: snake_case columns
⋮----
// biome-ignore lint/style/useNamingConvention: snake_case columns
⋮----
/**
 * Challenges a TOTP factor.
 *
 * @param supabase - The Supabase client.
 * @param input - The input to challenge the TOTP factor.
 * @returns The challenge result.
 */
export async function challengeTotp(
  supabase: TypedSupabase,
  input: { factorId: string }
): Promise<
⋮----
/** Result of TOTP verification indicating enrollment state. */
export interface TotpVerificationResult {
  /** True if this verification consumed an initial enrollment (first-time setup). */
  isInitialEnrollment: boolean;
}
⋮----
/** True if this verification consumed an initial enrollment (first-time setup). */
⋮----
/**
 * Verifies a TOTP code.
 *
 * Handles both initial enrollment verification (pending enrollment exists) and
 * ongoing MFA challenge verification (no enrollment). Backup codes should only
 * be generated when `isInitialEnrollment` is true.
 *
 * @param supabase - The Supabase client.
 * @param input - The input to verify the TOTP code.
 * @returns Verification result with enrollment state.
 */
export async function verifyTotp(
  supabase: TypedSupabase,
  input: MfaVerificationInput,
  deps?: { adminSupabase?: TypedAdminSupabase }
): Promise<TotpVerificationResult>
⋮----
// Check for pending enrollment (initial setup flow)
⋮----
// If this is initial enrollment, validate expiration
⋮----
// Verify TOTP code with Supabase Auth (works for both enrollment and challenges)
⋮----
// Mark enrollment consumed if this was initial enrollment
⋮----
// biome-ignore lint/style/useNamingConvention: snake_case columns
⋮----
/**
 * Lists the factors for a user.
 *
 * @param supabase - The Supabase client.
 * @returns The list of factors.
 */
export async function listFactors(supabase: TypedSupabase): Promise<MfaFactor[]>
⋮----
/**
 * Unenrolls a factor.
 *
 * @param supabase - The Supabase client.
 * @param factorId - The ID of the factor to unenroll.
 * @returns The unenrollment result.
 */
export async function unenrollFactor(
  supabase: TypedSupabase,
  factorId: string
): Promise<void>
⋮----
/**
 * Creates backup codes.
 *
 * @param adminSupabase - The Admin Supabase client.
 * @param userId - The ID of the user to create backup codes for.
 * @param count - The number of backup codes to create.
 * @returns The backup codes.
 */
export async function createBackupCodes(
  adminSupabase: TypedAdminSupabase,
  userId: string,
  count = 10,
  meta: BackupAuditMeta = {}
): Promise<BackupCodeList>
⋮----
// biome-ignore lint/style/useNamingConvention: DB column naming
⋮----
// biome-ignore lint/style/useNamingConvention: DB column naming
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameters must match SQL function names
⋮----
// biome-ignore lint/style/useNamingConvention: RPC parameters must match SQL function names
⋮----
/**
 * Verifies a backup code.
 *
 * @param adminSupabase - The Admin Supabase client.
 * @param userId - The ID of the user to verify the backup code for.
 * @param code - The code to verify.
 * @returns The verification result.
 */
export async function verifyBackupCode(
  adminSupabase: TypedAdminSupabase,
  userId: string,
  code: string,
  meta: BackupAuditMeta = {}
): Promise<BackupCodeList>
⋮----
// biome-ignore lint/style/useNamingConvention: DB column naming
⋮----
// Best-effort metadata; do not fail the request if counting fails.
⋮----
/**
 * Refreshes the AAL for a user.
 *
 * @param supabase - The Supabase client.
 * @returns The AAL.
 */
export async function refreshAal(supabase: TypedSupabase): Promise<"aal1" | "aal2">
⋮----
export async function requireAal2(supabase: TypedSupabase): Promise<void>
⋮----
/**
 * Regenerates backup codes.
 *
 * @param adminSupabase - The Admin Supabase client.
 * @param userId - The ID of the user to regenerate backup codes for.
 * @param count - The number of backup codes to regenerate.
 * @returns The regenerated backup codes.
 */
export async function regenerateBackupCodes(
  adminSupabase: TypedAdminSupabase,
  userId: string,
  count: number,
  meta: BackupAuditMeta = {}
): Promise<BackupCodeList>
⋮----
/**
 * Revokes sessions.
 *
 * @param supabase - The Supabase client.
 * @param scope - The scope of the sessions to revoke.
 * @returns The revocation result.
 */
export async function revokeSessions(
  supabase: TypedSupabase,
  scope: "others" | "global" | "local" = "others"
): Promise<void>
⋮----
async function logBackupCodeAudit(
  adminSupabase: TypedAdminSupabase,
  userId: string,
  event: "regenerated" | "consumed",
  count: number,
  meta: BackupAuditMeta
)
⋮----
// biome-ignore lint/style/useNamingConvention: DB column naming
⋮----
// biome-ignore lint/style/useNamingConvention: DB column naming
⋮----
/**
 * Hashes a backup code.
 *
 * @param code - The code to hash.
 * @returns The hashed code.
 */
function hashBackupCode(code: string): string
⋮----
// Lightweight pepper to avoid plain deterministic hash reuse
````

## File: src/lib/security/random.ts
````typescript
/**
 * @fileoverview Secure ID and timestamp helpers that avoid Math.random().
 */
⋮----
/**
 * Generate a RFC4122 v4 UUID using Web Crypto when available.
 * Falls back to a getRandomValues-based implementation when randomUUID is unavailable.
 * As a last resort where crypto is unavailable (non-secure context), returns a
 * monotonic identifier derived from timestamp and an in-memory counter.
 *
 * Note: We intentionally avoid Math.random() to satisfy security scanning rules.
 *
 * @returns A UUID v4 string.
 */
export function secureUuid(): string
⋮----
// Per RFC 4122 §4.4 set version and variant bits
bytes[6] = (bytes[6] & 0x0f) | 0x40; // Version 4
bytes[8] = (bytes[8] & 0x3f) | 0x80; // Variant 10
const toHex = (n: number)
⋮----
// Monotonic fallback (non-secure environments only)
⋮----
// biome-ignore lint/style/useNamingConvention: Global counter property uses snake_case
⋮----
/**
 * Generate a compact, URL-safe identifier using secureUUID as the source.
 * @param length Desired length of the ID (default 12)
 * @returns A compact identifier string.
 */
export function secureId(length = 12): string
⋮----
/**
 * Generate a random float in the range [0, 1).
 *
 * Uses Web Crypto when available. If Web Crypto is unavailable, falls back to a
 * deterministic pseudo-random generator (NOT cryptographically secure) that
 * avoids Math.random().
 */
export function secureRandomFloat(): number
⋮----
// Deterministic xorshift32 fallback for environments without Web Crypto.
⋮----
/**
 * Get current timestamp in ISO 8601 format.
 * @returns ISO timestamp string.
 */
export function nowIso(): string
````

## File: src/lib/security/webhook.ts
````typescript
/**
 * @fileoverview HMAC signature utilities for webhook verification.
 */
⋮----
import { createHmac, timingSafeEqual } from "node:crypto";
import { readRequestBodyBytesWithLimit } from "@/lib/http/body";
⋮----
/**
 * Computes hex-encoded HMAC-SHA256 for a payload using a secret.
 *
 * @param payload - The data to hash.
 * @param secret - The secret key for HMAC.
 * @return Hex-encoded HMAC digest.
 */
export function computeHmacSha256Hex(
  payload: string | Uint8Array,
  secret: string
): string
⋮----
/**
 * Performs timing-safe comparison of two hex strings.
 *
 * @param a - First hex string to compare.
 * @param b - Second hex string to compare.
 * @return True if strings are equal, false otherwise.
 */
export function timingSafeEqualHex(a: string, b: string): boolean
⋮----
const isHex = (value: string)
⋮----
/**
 * Verifies X-Signature-HMAC header for an incoming request.
 * The body must be read as raw text to ensure exact bytes are hashed.
 *
 * @param req - The incoming request to verify.
 * @param secret - The secret key for HMAC verification.
 * @return True if signature is valid, false otherwise.
 */
export async function verifyRequestHmac(
  req: Request,
  secret: string,
  options: { maxBytes?: number } = {}
): Promise<boolean>
````

## File: src/lib/supabase/database.types.ts
````typescript
/**
 * @fileoverview Supabase generated types with manual patch notes.
 */
⋮----
// MANUAL PATCH 2025-11-29: trips.notes removed; trips.tags text[]|null added.
// After Supabase DB migration, regenerate via `supabase gen types typescript --local` and remove this notice.
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];
⋮----
export type Database = {
  auth: {
    Tables: {
      audit_log_entries: {
        Row: {
          created_at: string | null;
          id: string;
          instance_id: string | null;
          ip_address: string;
          payload: Json | null;
        };
        Insert: {
          created_at?: string | null;
          id: string;
          instance_id?: string | null;
          ip_address?: string;
          payload?: Json | null;
        };
        Update: {
          created_at?: string | null;
          id?: string;
          instance_id?: string | null;
          ip_address?: string;
          payload?: Json | null;
        };
        Relationships: [];
      };
      flow_state: {
        Row: {
          auth_code: string;
          auth_code_issued_at: string | null;
          authentication_method: string;
          code_challenge: string;
          code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"];
          created_at: string | null;
          id: string;
          provider_access_token: string | null;
          provider_refresh_token: string | null;
          provider_type: string;
          updated_at: string | null;
          user_id: string | null;
        };
        Insert: {
          auth_code: string;
          auth_code_issued_at?: string | null;
          authentication_method: string;
          code_challenge: string;
          code_challenge_method: Database["auth"]["Enums"]["code_challenge_method"];
          created_at?: string | null;
          id: string;
          provider_access_token?: string | null;
          provider_refresh_token?: string | null;
          provider_type: string;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Update: {
          auth_code?: string;
          auth_code_issued_at?: string | null;
          authentication_method?: string;
          code_challenge?: string;
          code_challenge_method?: Database["auth"]["Enums"]["code_challenge_method"];
          created_at?: string | null;
          id?: string;
          provider_access_token?: string | null;
          provider_refresh_token?: string | null;
          provider_type?: string;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Relationships: [];
      };
      identities: {
        Row: {
          created_at: string | null;
          email: string | null;
          id: string;
          identity_data: Json;
          last_sign_in_at: string | null;
          provider: string;
          provider_id: string;
          updated_at: string | null;
          user_id: string;
        };
        Insert: {
          created_at?: string | null;
          email?: string | null;
          id?: string;
          identity_data: Json;
          last_sign_in_at?: string | null;
          provider: string;
          provider_id: string;
          updated_at?: string | null;
          user_id: string;
        };
        Update: {
          created_at?: string | null;
          email?: string | null;
          id?: string;
          identity_data?: Json;
          last_sign_in_at?: string | null;
          provider?: string;
          provider_id?: string;
          updated_at?: string | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "identities_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      instances: {
        Row: {
          created_at: string | null;
          id: string;
          raw_base_config: string | null;
          updated_at: string | null;
          uuid: string | null;
        };
        Insert: {
          created_at?: string | null;
          id: string;
          raw_base_config?: string | null;
          updated_at?: string | null;
          uuid?: string | null;
        };
        Update: {
          created_at?: string | null;
          id?: string;
          raw_base_config?: string | null;
          updated_at?: string | null;
          uuid?: string | null;
        };
        Relationships: [];
      };
      mfa_amr_claims: {
        Row: {
          authentication_method: string;
          created_at: string;
          id: string;
          session_id: string;
          updated_at: string;
        };
        Insert: {
          authentication_method: string;
          created_at: string;
          id: string;
          session_id: string;
          updated_at: string;
        };
        Update: {
          authentication_method?: string;
          created_at?: string;
          id?: string;
          session_id?: string;
          updated_at?: string;
        };
        Relationships: [
          {
            foreignKeyName: "mfa_amr_claims_session_id_fkey";
            columns: ["session_id"];
            isOneToOne: false;
            referencedRelation: "sessions";
            referencedColumns: ["id"];
          },
        ];
      };
      mfa_challenges: {
        Row: {
          created_at: string;
          factor_id: string;
          id: string;
          ip_address: unknown;
          otp_code: string | null;
          verified_at: string | null;
          web_authn_session_data: Json | null;
        };
        Insert: {
          created_at: string;
          factor_id: string;
          id: string;
          ip_address: unknown;
          otp_code?: string | null;
          verified_at?: string | null;
          web_authn_session_data?: Json | null;
        };
        Update: {
          created_at?: string;
          factor_id?: string;
          id?: string;
          ip_address?: unknown;
          otp_code?: string | null;
          verified_at?: string | null;
          web_authn_session_data?: Json | null;
        };
        Relationships: [
          {
            foreignKeyName: "mfa_challenges_auth_factor_id_fkey";
            columns: ["factor_id"];
            isOneToOne: false;
            referencedRelation: "mfa_factors";
            referencedColumns: ["id"];
          },
        ];
      };
      mfa_factors: {
        Row: {
          created_at: string;
          factor_type: Database["auth"]["Enums"]["factor_type"];
          friendly_name: string | null;
          id: string;
          last_challenged_at: string | null;
          phone: string | null;
          secret: string | null;
          status: Database["auth"]["Enums"]["factor_status"];
          updated_at: string;
          user_id: string;
          web_authn_aaguid: string | null;
          web_authn_credential: Json | null;
        };
        Insert: {
          created_at: string;
          factor_type: Database["auth"]["Enums"]["factor_type"];
          friendly_name?: string | null;
          id: string;
          last_challenged_at?: string | null;
          phone?: string | null;
          secret?: string | null;
          status: Database["auth"]["Enums"]["factor_status"];
          updated_at: string;
          user_id: string;
          web_authn_aaguid?: string | null;
          web_authn_credential?: Json | null;
        };
        Update: {
          created_at?: string;
          factor_type?: Database["auth"]["Enums"]["factor_type"];
          friendly_name?: string | null;
          id?: string;
          last_challenged_at?: string | null;
          phone?: string | null;
          secret?: string | null;
          status?: Database["auth"]["Enums"]["factor_status"];
          updated_at?: string;
          user_id?: string;
          web_authn_aaguid?: string | null;
          web_authn_credential?: Json | null;
        };
        Relationships: [
          {
            foreignKeyName: "mfa_factors_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      oauth_authorizations: {
        Row: {
          approved_at: string | null;
          authorization_code: string | null;
          authorization_id: string;
          client_id: string;
          code_challenge: string | null;
          code_challenge_method:
            | Database["auth"]["Enums"]["code_challenge_method"]
            | null;
          created_at: string;
          expires_at: string;
          id: string;
          redirect_uri: string;
          resource: string | null;
          response_type: Database["auth"]["Enums"]["oauth_response_type"];
          scope: string;
          state: string | null;
          status: Database["auth"]["Enums"]["oauth_authorization_status"];
          user_id: string | null;
        };
        Insert: {
          approved_at?: string | null;
          authorization_code?: string | null;
          authorization_id: string;
          client_id: string;
          code_challenge?: string | null;
          code_challenge_method?:
            | Database["auth"]["Enums"]["code_challenge_method"]
            | null;
          created_at?: string;
          expires_at?: string;
          id: string;
          redirect_uri: string;
          resource?: string | null;
          response_type?: Database["auth"]["Enums"]["oauth_response_type"];
          scope: string;
          state?: string | null;
          status?: Database["auth"]["Enums"]["oauth_authorization_status"];
          user_id?: string | null;
        };
        Update: {
          approved_at?: string | null;
          authorization_code?: string | null;
          authorization_id?: string;
          client_id?: string;
          code_challenge?: string | null;
          code_challenge_method?:
            | Database["auth"]["Enums"]["code_challenge_method"]
            | null;
          created_at?: string;
          expires_at?: string;
          id?: string;
          redirect_uri?: string;
          resource?: string | null;
          response_type?: Database["auth"]["Enums"]["oauth_response_type"];
          scope?: string;
          state?: string | null;
          status?: Database["auth"]["Enums"]["oauth_authorization_status"];
          user_id?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "oauth_authorizations_client_id_fkey";
            columns: ["client_id"];
            isOneToOne: false;
            referencedRelation: "oauth_clients";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "oauth_authorizations_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      oauth_clients: {
        Row: {
          client_name: string | null;
          client_secret_hash: string | null;
          client_type: Database["auth"]["Enums"]["oauth_client_type"];
          client_uri: string | null;
          created_at: string;
          deleted_at: string | null;
          grant_types: string;
          id: string;
          logo_uri: string | null;
          redirect_uris: string;
          registration_type: Database["auth"]["Enums"]["oauth_registration_type"];
          updated_at: string;
        };
        Insert: {
          client_name?: string | null;
          client_secret_hash?: string | null;
          client_type?: Database["auth"]["Enums"]["oauth_client_type"];
          client_uri?: string | null;
          created_at?: string;
          deleted_at?: string | null;
          grant_types: string;
          id: string;
          logo_uri?: string | null;
          redirect_uris: string;
          registration_type: Database["auth"]["Enums"]["oauth_registration_type"];
          updated_at?: string;
        };
        Update: {
          client_name?: string | null;
          client_secret_hash?: string | null;
          client_type?: Database["auth"]["Enums"]["oauth_client_type"];
          client_uri?: string | null;
          created_at?: string;
          deleted_at?: string | null;
          grant_types?: string;
          id?: string;
          logo_uri?: string | null;
          redirect_uris?: string;
          registration_type?: Database["auth"]["Enums"]["oauth_registration_type"];
          updated_at?: string;
        };
        Relationships: [];
      };
      oauth_consents: {
        Row: {
          client_id: string;
          granted_at: string;
          id: string;
          revoked_at: string | null;
          scopes: string;
          user_id: string;
        };
        Insert: {
          client_id: string;
          granted_at?: string;
          id: string;
          revoked_at?: string | null;
          scopes: string;
          user_id: string;
        };
        Update: {
          client_id?: string;
          granted_at?: string;
          id?: string;
          revoked_at?: string | null;
          scopes?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "oauth_consents_client_id_fkey";
            columns: ["client_id"];
            isOneToOne: false;
            referencedRelation: "oauth_clients";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "oauth_consents_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      one_time_tokens: {
        Row: {
          created_at: string;
          id: string;
          relates_to: string;
          token_hash: string;
          token_type: Database["auth"]["Enums"]["one_time_token_type"];
          updated_at: string;
          user_id: string;
        };
        Insert: {
          created_at?: string;
          id: string;
          relates_to: string;
          token_hash: string;
          token_type: Database["auth"]["Enums"]["one_time_token_type"];
          updated_at?: string;
          user_id: string;
        };
        Update: {
          created_at?: string;
          id?: string;
          relates_to?: string;
          token_hash?: string;
          token_type?: Database["auth"]["Enums"]["one_time_token_type"];
          updated_at?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "one_time_tokens_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      refresh_tokens: {
        Row: {
          created_at: string | null;
          id: number;
          instance_id: string | null;
          parent: string | null;
          revoked: boolean | null;
          session_id: string | null;
          token: string | null;
          updated_at: string | null;
          user_id: string | null;
        };
        Insert: {
          created_at?: string | null;
          id?: number;
          instance_id?: string | null;
          parent?: string | null;
          revoked?: boolean | null;
          session_id?: string | null;
          token?: string | null;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Update: {
          created_at?: string | null;
          id?: number;
          instance_id?: string | null;
          parent?: string | null;
          revoked?: boolean | null;
          session_id?: string | null;
          token?: string | null;
          updated_at?: string | null;
          user_id?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "refresh_tokens_session_id_fkey";
            columns: ["session_id"];
            isOneToOne: false;
            referencedRelation: "sessions";
            referencedColumns: ["id"];
          },
        ];
      };
      saml_providers: {
        Row: {
          attribute_mapping: Json | null;
          created_at: string | null;
          entity_id: string;
          id: string;
          metadata_url: string | null;
          metadata_xml: string;
          name_id_format: string | null;
          sso_provider_id: string;
          updated_at: string | null;
        };
        Insert: {
          attribute_mapping?: Json | null;
          created_at?: string | null;
          entity_id: string;
          id: string;
          metadata_url?: string | null;
          metadata_xml: string;
          name_id_format?: string | null;
          sso_provider_id: string;
          updated_at?: string | null;
        };
        Update: {
          attribute_mapping?: Json | null;
          created_at?: string | null;
          entity_id?: string;
          id?: string;
          metadata_url?: string | null;
          metadata_xml?: string;
          name_id_format?: string | null;
          sso_provider_id?: string;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "saml_providers_sso_provider_id_fkey";
            columns: ["sso_provider_id"];
            isOneToOne: false;
            referencedRelation: "sso_providers";
            referencedColumns: ["id"];
          },
        ];
      };
      saml_relay_states: {
        Row: {
          created_at: string | null;
          flow_state_id: string | null;
          for_email: string | null;
          id: string;
          redirect_to: string | null;
          request_id: string;
          sso_provider_id: string;
          updated_at: string | null;
        };
        Insert: {
          created_at?: string | null;
          flow_state_id?: string | null;
          for_email?: string | null;
          id: string;
          redirect_to?: string | null;
          request_id: string;
          sso_provider_id: string;
          updated_at?: string | null;
        };
        Update: {
          created_at?: string | null;
          flow_state_id?: string | null;
          for_email?: string | null;
          id?: string;
          redirect_to?: string | null;
          request_id?: string;
          sso_provider_id?: string;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "saml_relay_states_flow_state_id_fkey";
            columns: ["flow_state_id"];
            isOneToOne: false;
            referencedRelation: "flow_state";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "saml_relay_states_sso_provider_id_fkey";
            columns: ["sso_provider_id"];
            isOneToOne: false;
            referencedRelation: "sso_providers";
            referencedColumns: ["id"];
          },
        ];
      };
      schema_migrations: {
        Row: {
          version: string;
        };
        Insert: {
          version: string;
        };
        Update: {
          version?: string;
        };
        Relationships: [];
      };
      sessions: {
        Row: {
          aal: Database["auth"]["Enums"]["aal_level"] | null;
          created_at: string | null;
          factor_id: string | null;
          id: string;
          ip: unknown;
          not_after: string | null;
          oauth_client_id: string | null;
          refreshed_at: string | null;
          tag: string | null;
          updated_at: string | null;
          user_agent: string | null;
          user_id: string;
        };
        Insert: {
          aal?: Database["auth"]["Enums"]["aal_level"] | null;
          created_at?: string | null;
          factor_id?: string | null;
          id: string;
          ip?: unknown;
          not_after?: string | null;
          oauth_client_id?: string | null;
          refreshed_at?: string | null;
          tag?: string | null;
          updated_at?: string | null;
          user_agent?: string | null;
          user_id: string;
        };
        Update: {
          aal?: Database["auth"]["Enums"]["aal_level"] | null;
          created_at?: string | null;
          factor_id?: string | null;
          id?: string;
          ip?: unknown;
          not_after?: string | null;
          oauth_client_id?: string | null;
          refreshed_at?: string | null;
          tag?: string | null;
          updated_at?: string | null;
          user_agent?: string | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "sessions_oauth_client_id_fkey";
            columns: ["oauth_client_id"];
            isOneToOne: false;
            referencedRelation: "oauth_clients";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "sessions_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      sso_domains: {
        Row: {
          created_at: string | null;
          domain: string;
          id: string;
          sso_provider_id: string;
          updated_at: string | null;
        };
        Insert: {
          created_at?: string | null;
          domain: string;
          id: string;
          sso_provider_id: string;
          updated_at?: string | null;
        };
        Update: {
          created_at?: string | null;
          domain?: string;
          id?: string;
          sso_provider_id?: string;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "sso_domains_sso_provider_id_fkey";
            columns: ["sso_provider_id"];
            isOneToOne: false;
            referencedRelation: "sso_providers";
            referencedColumns: ["id"];
          },
        ];
      };
      sso_providers: {
        Row: {
          created_at: string | null;
          disabled: boolean | null;
          id: string;
          resource_id: string | null;
          updated_at: string | null;
        };
        Insert: {
          created_at?: string | null;
          disabled?: boolean | null;
          id: string;
          resource_id?: string | null;
          updated_at?: string | null;
        };
        Update: {
          created_at?: string | null;
          disabled?: boolean | null;
          id?: string;
          resource_id?: string | null;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      users: {
        Row: {
          aud: string | null;
          banned_until: string | null;
          confirmation_sent_at: string | null;
          confirmation_token: string | null;
          confirmed_at: string | null;
          created_at: string | null;
          deleted_at: string | null;
          email: string | null;
          email_change: string | null;
          email_change_confirm_status: number | null;
          email_change_sent_at: string | null;
          email_change_token_current: string | null;
          email_change_token_new: string | null;
          email_confirmed_at: string | null;
          encrypted_password: string | null;
          id: string;
          instance_id: string | null;
          invited_at: string | null;
          is_anonymous: boolean;
          is_sso_user: boolean;
          is_super_admin: boolean | null;
          last_sign_in_at: string | null;
          phone: string | null;
          phone_change: string | null;
          phone_change_sent_at: string | null;
          phone_change_token: string | null;
          phone_confirmed_at: string | null;
          raw_app_meta_data: Json | null;
          raw_user_meta_data: Json | null;
          reauthentication_sent_at: string | null;
          reauthentication_token: string | null;
          recovery_sent_at: string | null;
          recovery_token: string | null;
          role: string | null;
          updated_at: string | null;
        };
        Insert: {
          aud?: string | null;
          banned_until?: string | null;
          confirmation_sent_at?: string | null;
          confirmation_token?: string | null;
          confirmed_at?: string | null;
          created_at?: string | null;
          deleted_at?: string | null;
          email?: string | null;
          email_change?: string | null;
          email_change_confirm_status?: number | null;
          email_change_sent_at?: string | null;
          email_change_token_current?: string | null;
          email_change_token_new?: string | null;
          email_confirmed_at?: string | null;
          encrypted_password?: string | null;
          id: string;
          instance_id?: string | null;
          invited_at?: string | null;
          is_anonymous?: boolean;
          is_sso_user?: boolean;
          is_super_admin?: boolean | null;
          last_sign_in_at?: string | null;
          phone?: string | null;
          phone_change?: string | null;
          phone_change_sent_at?: string | null;
          phone_change_token?: string | null;
          phone_confirmed_at?: string | null;
          raw_app_meta_data?: Json | null;
          raw_user_meta_data?: Json | null;
          reauthentication_sent_at?: string | null;
          reauthentication_token?: string | null;
          recovery_sent_at?: string | null;
          recovery_token?: string | null;
          role?: string | null;
          updated_at?: string | null;
        };
        Update: {
          aud?: string | null;
          banned_until?: string | null;
          confirmation_sent_at?: string | null;
          confirmation_token?: string | null;
          confirmed_at?: string | null;
          created_at?: string | null;
          deleted_at?: string | null;
          email?: string | null;
          email_change?: string | null;
          email_change_confirm_status?: number | null;
          email_change_sent_at?: string | null;
          email_change_token_current?: string | null;
          email_change_token_new?: string | null;
          email_confirmed_at?: string | null;
          encrypted_password?: string | null;
          id?: string;
          instance_id?: string | null;
          invited_at?: string | null;
          is_anonymous?: boolean;
          is_sso_user?: boolean;
          is_super_admin?: boolean | null;
          last_sign_in_at?: string | null;
          phone?: string | null;
          phone_change?: string | null;
          phone_change_sent_at?: string | null;
          phone_change_token?: string | null;
          phone_confirmed_at?: string | null;
          raw_app_meta_data?: Json | null;
          raw_user_meta_data?: Json | null;
          reauthentication_sent_at?: string | null;
          reauthentication_token?: string | null;
          recovery_sent_at?: string | null;
          recovery_token?: string | null;
          role?: string | null;
          updated_at?: string | null;
        };
        Relationships: [];
      };
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      email: { Args: never; Returns: string };
      jwt: { Args: never; Returns: Json };
      role: { Args: never; Returns: string };
      uid: { Args: never; Returns: string };
    };
    Enums: {
      aal_level: "aal1" | "aal2" | "aal3";
      code_challenge_method: "s256" | "plain";
      factor_status: "unverified" | "verified";
      factor_type: "totp" | "webauthn" | "phone";
      oauth_authorization_status: "pending" | "approved" | "denied" | "expired";
      oauth_client_type: "public" | "confidential";
      oauth_registration_type: "dynamic" | "manual";
      oauth_response_type: "code";
      one_time_token_type:
        | "confirmation_token"
        | "reauthentication_token"
        | "recovery_token"
        | "email_change_token_new"
        | "email_change_token_current"
        | "phone_change_token";
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
  memories: {
    Tables: {
      sessions: {
        Row: {
          created_at: string;
          id: string;
          last_synced_at: string | null;
          metadata: Json;
          title: string;
          updated_at: string;
          user_id: string;
        };
        Insert: {
          created_at?: string;
          id?: string;
          last_synced_at?: string | null;
          metadata?: Json;
          title: string;
          updated_at?: string;
          user_id: string;
        };
        Update: {
          created_at?: string;
          id?: string;
          last_synced_at?: string | null;
          metadata?: Json;
          title?: string;
          updated_at?: string;
          user_id?: string;
        };
        Relationships: [];
      };
      turn_embeddings: {
        Row: {
          created_at: string;
          embedding: string;
          model: string;
          turn_id: string;
        };
        Insert: {
          created_at?: string;
          embedding: string;
          model: string;
          turn_id: string;
        };
        Update: {
          created_at?: string;
          embedding?: string;
          model?: string;
          turn_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "turn_embeddings_turn_id_fkey";
            columns: ["turn_id"];
            isOneToOne: true;
            referencedRelation: "turns";
            referencedColumns: ["id"];
          },
        ];
      };
      turns: {
        Row: {
          attachments: Json;
          content: Json;
          created_at: string;
          id: string;
          pii_scrubbed: boolean;
          role: string;
          session_id: string;
          tool_calls: Json;
          tool_results: Json;
          user_id: string;
        };
        Insert: {
          attachments?: Json;
          content: Json;
          created_at?: string;
          id?: string;
          pii_scrubbed?: boolean;
          role: string;
          session_id: string;
          tool_calls?: Json;
          tool_results?: Json;
          user_id: string;
        };
        Update: {
          attachments?: Json;
          content?: Json;
          created_at?: string;
          id?: string;
          pii_scrubbed?: boolean;
          role?: string;
          session_id?: string;
          tool_calls?: Json;
          tool_results?: Json;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "turns_session_id_fkey";
            columns: ["session_id"];
            isOneToOne: false;
            referencedRelation: "sessions";
            referencedColumns: ["id"];
          },
        ];
      };
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      [_ in never]: never;
    };
    Enums: {
      [_ in never]: never;
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
  public: {
    Tables: {
      api_metrics: {
        Row: {
          id: string;
          endpoint: string;
          method: string;
          status_code: number;
          duration_ms: number;
          user_id: string | null;
          created_at: string;
          error_type: string | null;
          rate_limit_key: string | null;
        };
        Insert: {
          id?: string;
          endpoint: string;
          method: string;
          status_code: number;
          duration_ms: number;
          user_id?: string | null;
          created_at?: string;
          error_type?: string | null;
          rate_limit_key?: string | null;
        };
        Update: {
          id?: string;
          endpoint?: string;
          method?: string;
          status_code?: number;
          duration_ms?: number;
          user_id?: string | null;
          created_at?: string;
          error_type?: string | null;
          rate_limit_key?: string | null;
        };
        Relationships: [];
      };
      auth_backup_codes: {
        Row: {
          code_hash: string;
          consumed_at: string | null;
          id: string;
          issued_at: string;
          label: string | null;
          user_id: string;
        };
        Insert: {
          code_hash: string;
          consumed_at?: string | null;
          id?: string;
          issued_at?: string;
          label?: string | null;
          user_id: string;
        };
        Update: {
          code_hash?: string;
          consumed_at?: string | null;
          id?: string;
          issued_at?: string;
          label?: string | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "auth_backup_codes_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      accommodation_embeddings: {
        Row: {
          amenities: string | null;
          created_at: string | null;
          description: string | null;
          embedding: string | null;
          id: string;
          name: string | null;
          source: string;
          updated_at: string | null;
        };
        Insert: {
          amenities?: string | null;
          created_at?: string | null;
          description?: string | null;
          embedding?: string | null;
          id: string;
          name?: string | null;
          source: string;
          updated_at?: string | null;
        };
        Update: {
          amenities?: string | null;
          created_at?: string | null;
          description?: string | null;
          embedding?: string | null;
          id?: string;
          name?: string | null;
          source?: string;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      rag_documents: {
        Row: {
          chunk_index: number;
          content: string;
          created_at: string;
          embedding: string | null;
          fts: unknown | null;
          id: string;
          metadata: Json;
          namespace: string;
          source_id: string | null;
          updated_at: string;
        };
        Insert: {
          chunk_index?: number;
          content: string;
          created_at?: string;
          embedding?: string | null;
          id?: string;
          metadata?: Json;
          namespace?: string;
          source_id?: string | null;
          updated_at?: string;
        };
        Update: {
          chunk_index?: number;
          content?: string;
          created_at?: string;
          embedding?: string | null;
          id?: string;
          metadata?: Json;
          namespace?: string;
          source_id?: string | null;
          updated_at?: string;
        };
        Relationships: [];
      };
      accommodations: {
        Row: {
          address: string | null;
          amenities: string[] | null;
          booking_status: string;
          check_in_date: string;
          check_out_date: string;
          created_at: string | null;
          currency: string;
          external_id: string | null;
          id: number;
          metadata: Json | null;
          name: string;
          price_per_night: number;
          rating: number | null;
          room_type: string | null;
          total_price: number;
          trip_id: number;
          updated_at: string | null;
        };
        Insert: {
          address?: string | null;
          amenities?: string[] | null;
          booking_status?: string;
          check_in_date: string;
          check_out_date: string;
          created_at?: string | null;
          currency?: string;
          external_id?: string | null;
          id?: never;
          metadata?: Json | null;
          name: string;
          price_per_night: number;
          rating?: number | null;
          room_type?: string | null;
          total_price: number;
          trip_id: number;
          updated_at?: string | null;
        };
        Update: {
          address?: string | null;
          amenities?: string[] | null;
          booking_status?: string;
          check_in_date?: string;
          check_out_date?: string;
          created_at?: string | null;
          currency?: string;
          external_id?: string | null;
          id?: never;
          metadata?: Json | null;
          name?: string;
          price_per_night?: number;
          rating?: number | null;
          room_type?: string | null;
          total_price?: number;
          trip_id?: number;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "accommodations_trip_id_fkey";
            columns: ["trip_id"];
            isOneToOne: false;
            referencedRelation: "trips";
            referencedColumns: ["id"];
          },
        ];
      };
      agent_config: {
        Row: {
          agent_type: string;
          config: Json;
          created_at: string;
          id: string;
          scope: string;
          updated_at: string;
          version_id: string;
        };
        Insert: {
          agent_type: string;
          config: Json;
          created_at?: string;
          id?: string;
          scope?: string;
          updated_at?: string;
          version_id: string;
        };
        Update: {
          agent_type?: string;
          config?: Json;
          created_at?: string;
          id?: string;
          scope?: string;
          updated_at?: string;
          version_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "agent_config_version_id_fkey";
            columns: ["version_id"];
            isOneToOne: false;
            referencedRelation: "agent_config_versions";
            referencedColumns: ["id"];
          },
        ];
      };
      agent_config_versions: {
        Row: {
          agent_type: string;
          config: Json;
          created_at: string;
          created_by: string | null;
          id: string;
          scope: string;
          summary: string | null;
        };
        Insert: {
          agent_type: string;
          config: Json;
          created_at?: string;
          created_by?: string | null;
          id?: string;
          scope?: string;
          summary?: string | null;
        };
        Update: {
          agent_type?: string;
          config?: Json;
          created_at?: string;
          created_by?: string | null;
          id?: string;
          scope?: string;
          summary?: string | null;
        };
        Relationships: [];
      };
      api_gateway_configs: {
        Row: {
          base_url: string | null;
          user_id: string;
        };
        Insert: {
          base_url?: string | null;
          user_id: string;
        };
        Update: {
          base_url?: string | null;
          user_id?: string;
        };
        Relationships: [];
      };
      api_keys: {
        Row: {
          created_at: string | null;
          id: number;
          last_used: string | null;
          service: string;
          user_id: string;
          vault_secret_name: string;
        };
        Insert: {
          created_at?: string | null;
          id?: never;
          last_used?: string | null;
          service: string;
          user_id: string;
          vault_secret_name: string;
        };
        Update: {
          created_at?: string | null;
          id?: never;
          last_used?: string | null;
          service?: string;
          user_id?: string;
          vault_secret_name?: string;
        };
        Relationships: [];
      };
      bookings: {
        Row: {
          booking_token: string | null;
          checkin: string;
          checkout: string;
          created_at: string | null;
          guest_email: string;
          guest_name: string;
          guest_phone: string | null;
          guests: number;
          id: string;
          property_id: string;
          provider_booking_id: string;
          special_requests: string | null;
          status: string;
          stripe_payment_intent_id: string | null;
          trip_id: number | null;
          updated_at: string | null;
          user_id: string;
        };
        Insert: {
          booking_token?: string | null;
          checkin: string;
          checkout: string;
          created_at?: string | null;
          guest_email: string;
          guest_name: string;
          guest_phone?: string | null;
          guests: number;
          id: string;
          property_id: string;
          provider_booking_id: string;
          special_requests?: string | null;
          status: string;
          stripe_payment_intent_id?: string | null;
          trip_id?: number | null;
          updated_at?: string | null;
          user_id: string;
        };
        Update: {
          booking_token?: string | null;
          checkin?: string;
          checkout?: string;
          created_at?: string | null;
          guest_email?: string;
          guest_name?: string;
          guest_phone?: string | null;
          guests?: number;
          id?: string;
          property_id?: string;
          provider_booking_id?: string;
          special_requests?: string | null;
          status?: string;
          stripe_payment_intent_id?: string | null;
          trip_id?: number | null;
          updated_at?: string | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "bookings_trip_id_fkey";
            columns: ["trip_id"];
            isOneToOne: false;
            referencedRelation: "trips";
            referencedColumns: ["id"];
          },
        ];
      };
      chat_messages: {
        Row: {
          content: string;
          created_at: string | null;
          id: number;
          metadata: Json | null;
          role: string;
          session_id: string;
          user_id: string;
        };
        Insert: {
          content: string;
          created_at?: string | null;
          id?: never;
          metadata?: Json | null;
          role: string;
          session_id: string;
          user_id: string;
        };
        Update: {
          content?: string;
          created_at?: string | null;
          id?: never;
          metadata?: Json | null;
          role?: string;
          session_id?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "chat_messages_session_id_fkey";
            columns: ["session_id"];
            isOneToOne: false;
            referencedRelation: "chat_sessions";
            referencedColumns: ["id"];
          },
        ];
      };
      chat_sessions: {
        Row: {
          created_at: string | null;
          id: string;
          metadata: Json | null;
          trip_id: number | null;
          updated_at: string | null;
          user_id: string;
        };
        Insert: {
          created_at?: string | null;
          id?: string;
          metadata?: Json | null;
          trip_id?: number | null;
          updated_at?: string | null;
          user_id: string;
        };
        Update: {
          created_at?: string | null;
          id?: string;
          metadata?: Json | null;
          trip_id?: number | null;
          updated_at?: string | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "chat_sessions_trip_id_fkey";
            columns: ["trip_id"];
            isOneToOne: false;
            referencedRelation: "trips";
            referencedColumns: ["id"];
          },
        ];
      };
      chat_tool_calls: {
        Row: {
          arguments: Json;
          completed_at: string | null;
          created_at: string | null;
          error_message: string | null;
          id: number;
          message_id: number;
          result: Json | null;
          status: string;
          tool_id: string;
          tool_name: string;
        };
        Insert: {
          arguments?: Json;
          completed_at?: string | null;
          created_at?: string | null;
          error_message?: string | null;
          id?: never;
          message_id: number;
          result?: Json | null;
          status?: string;
          tool_id: string;
          tool_name: string;
        };
        Update: {
          arguments?: Json;
          completed_at?: string | null;
          created_at?: string | null;
          error_message?: string | null;
          id?: never;
          message_id?: number;
          result?: Json | null;
          status?: string;
          tool_id?: string;
          tool_name?: string;
        };
        Relationships: [
          {
            foreignKeyName: "chat_tool_calls_message_id_fkey";
            columns: ["message_id"];
            isOneToOne: false;
            referencedRelation: "chat_messages";
            referencedColumns: ["id"];
          },
        ];
      };
      file_attachments: {
        Row: {
          bucket_name: string;
          chat_message_id: number | null;
          created_at: string | null;
          file_path: string;
          file_size: number;
          filename: string;
          id: string;
          metadata: Json;
          mime_type: string;
          original_filename: string;
          trip_id: number | null;
          updated_at: string | null;
          upload_status: string;
          user_id: string;
          virus_scan_result: Json;
          virus_scan_status: string;
        };
        Insert: {
          bucket_name?: string;
          chat_message_id?: number | null;
          created_at?: string | null;
          file_path: string;
          file_size: number;
          filename: string;
          id?: string;
          metadata?: Json;
          mime_type: string;
          original_filename: string;
          trip_id?: number | null;
          updated_at?: string | null;
          upload_status?: string;
          user_id: string;
          virus_scan_result?: Json;
          virus_scan_status?: string;
        };
        Update: {
          bucket_name?: string;
          chat_message_id?: number | null;
          created_at?: string | null;
          file_path?: string;
          file_size?: number;
          filename?: string;
          id?: string;
          metadata?: Json;
          mime_type?: string;
          original_filename?: string;
          trip_id?: number | null;
          updated_at?: string | null;
          upload_status?: string;
          user_id?: string;
          virus_scan_result?: Json;
          virus_scan_status?: string;
        };
        Relationships: [
          {
            foreignKeyName: "file_attachments_chat_message_id_fkey";
            columns: ["chat_message_id"];
            isOneToOne: false;
            referencedRelation: "chat_messages";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "file_attachments_trip_id_fkey";
            columns: ["trip_id"];
            isOneToOne: false;
            referencedRelation: "trips";
            referencedColumns: ["id"];
          },
        ];
      };
      file_processing_queue: {
        Row: {
          attempts: number;
          completed_at: string | null;
          created_at: string | null;
          error_message: string | null;
          file_attachment_id: string;
          id: number;
          max_attempts: number;
          metadata: Json | null;
          operation: string;
          priority: number;
          scheduled_at: string | null;
          started_at: string | null;
          status: string;
          updated_at: string | null;
        };
        Insert: {
          attempts?: number;
          completed_at?: string | null;
          created_at?: string | null;
          error_message?: string | null;
          file_attachment_id: string;
          id?: never;
          max_attempts?: number;
          metadata?: Json | null;
          operation: string;
          priority?: number;
          scheduled_at?: string | null;
          started_at?: string | null;
          status?: string;
          updated_at?: string | null;
        };
        Update: {
          attempts?: number;
          completed_at?: string | null;
          created_at?: string | null;
          error_message?: string | null;
          file_attachment_id?: string;
          id?: never;
          max_attempts?: number;
          metadata?: Json | null;
          operation?: string;
          priority?: number;
          scheduled_at?: string | null;
          started_at?: string | null;
          status?: string;
          updated_at?: string | null;
        };
        Relationships: [];
      };
      file_versions: {
        Row: {
          change_description: string | null;
          checksum: string;
          created_at: string | null;
          created_by: string;
          file_attachment_id: string;
          file_path: string;
          file_size: number;
          id: number;
          is_current: boolean;
          version_number: number;
        };
        Insert: {
          change_description?: string | null;
          checksum: string;
          created_at?: string | null;
          created_by: string;
          file_attachment_id: string;
          file_path: string;
          file_size: number;
          id?: never;
          is_current?: boolean;
          version_number: number;
        };
        Update: {
          change_description?: string | null;
          checksum?: string;
          created_at?: string | null;
          created_by?: string;
          file_attachment_id?: string;
          file_path?: string;
          file_size?: number;
          id?: never;
          is_current?: boolean;
          version_number?: number;
        };
        Relationships: [];
      };
      flights: {
        Row: {
          airline: string | null;
          booking_status: string;
          created_at: string | null;
          currency: string;
          departure_date: string;
          destination: string;
          external_id: string | null;
          flight_class: string;
          flight_number: string | null;
          id: number;
          metadata: Json | null;
          origin: string;
          price: number;
          return_date: string | null;
          trip_id: number;
          updated_at: string | null;
          user_id: string;
        };
        Insert: {
          airline?: string | null;
          booking_status?: string;
          created_at?: string | null;
          currency?: string;
          departure_date: string;
          destination: string;
          external_id?: string | null;
          flight_class?: string;
          flight_number?: string | null;
          id?: never;
          metadata?: Json | null;
          origin: string;
          price: number;
          return_date?: string | null;
          trip_id: number;
          updated_at?: string | null;
          user_id: string;
        };
        Update: {
          airline?: string | null;
          booking_status?: string;
          created_at?: string | null;
          currency?: string;
          departure_date?: string;
          destination?: string;
          external_id?: string | null;
          flight_class?: string;
          flight_number?: string | null;
          id?: never;
          metadata?: Json | null;
          origin?: string;
          price?: number;
          return_date?: string | null;
          trip_id?: number;
          updated_at?: string | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "flights_trip_id_fkey";
            columns: ["trip_id"];
            isOneToOne: false;
            referencedRelation: "trips";
            referencedColumns: ["id"];
          },
        ];
      };
      gateway_user_keys: {
        Row: {
          created_at: string | null;
          encrypted_key: string;
          id: number;
          provider: string;
          user_id: string;
        };
        Insert: {
          created_at?: string | null;
          encrypted_key: string;
          id?: never;
          provider: string;
          user_id: string;
        };
        Update: {
          created_at?: string | null;
          encrypted_key?: string;
          id?: never;
          provider?: string;
          user_id?: string;
        };
        Relationships: [];
      };
      itinerary_items: {
        Row: {
          booking_status: string | null;
          created_at: string | null;
          currency: string | null;
          description: string | null;
          end_time: string | null;
          external_id: string | null;
          id: number;
          item_type: string;
          location: string | null;
          metadata: Json | null;
          price: number | null;
          start_time: string | null;
          title: string;
          trip_id: number;
          updated_at: string | null;
          user_id: string;
        };
        Insert: {
          booking_status?: string | null;
          created_at?: string | null;
          currency?: string | null;
          description?: string | null;
          end_time?: string | null;
          external_id?: string | null;
          id?: never;
          item_type: string;
          location?: string | null;
          metadata?: Json | null;
          price?: number | null;
          start_time?: string | null;
          title: string;
          trip_id: number;
          updated_at?: string | null;
          user_id: string;
        };
        Update: {
          booking_status?: string | null;
          created_at?: string | null;
          currency?: string | null;
          description?: string | null;
          end_time?: string | null;
          external_id?: string | null;
          id?: never;
          item_type?: string;
          location?: string | null;
          metadata?: Json | null;
          price?: number | null;
          start_time?: string | null;
          title?: string;
          trip_id?: number;
          updated_at?: string | null;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "itinerary_items_trip_id_fkey";
            columns: ["trip_id"];
            isOneToOne: false;
            referencedRelation: "trips";
            referencedColumns: ["id"];
          },
        ];
      };
      search_activities: {
        Row: {
          activity_type: string | null;
          created_at: string | null;
          destination: string;
          expires_at: string;
          id: number;
          query_hash: string;
          query_parameters: Json;
          results: Json;
          search_metadata: Json;
          source: string;
          user_id: string;
        };
        Insert: {
          activity_type?: string | null;
          created_at?: string | null;
          destination: string;
          expires_at: string;
          id?: never;
          query_hash: string;
          query_parameters: Json;
          results: Json;
          search_metadata?: Json;
          source: string;
          user_id: string;
        };
        Update: {
          activity_type?: string | null;
          created_at?: string | null;
          destination?: string;
          expires_at?: string;
          id?: never;
          query_hash?: string;
          query_parameters?: Json;
          results?: Json;
          search_metadata?: Json;
          source?: string;
          user_id?: string;
        };
        Relationships: [];
      };
      mfa_enrollments: {
        Row: {
          challenge_id: string;
          consumed_at: string | null;
          expires_at: string;
          factor_id: string;
          id: string;
          issued_at: string;
          status: string;
          user_id: string;
        };
        Insert: {
          challenge_id: string;
          consumed_at?: string | null;
          expires_at: string;
          factor_id: string;
          id?: string;
          issued_at?: string;
          status: string;
          user_id: string;
        };
        Update: {
          challenge_id?: string;
          consumed_at?: string | null;
          expires_at?: string;
          factor_id?: string;
          id?: string;
          issued_at?: string;
          status?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "mfa_enrollments_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      search_destinations: {
        Row: {
          created_at: string | null;
          expires_at: string;
          id: number;
          query: string;
          query_hash: string;
          results: Json;
          search_metadata: Json;
          source: string;
          user_id: string;
        };
        Insert: {
          created_at?: string | null;
          expires_at: string;
          id?: never;
          query: string;
          query_hash: string;
          results: Json;
          search_metadata?: Json;
          source: string;
          user_id: string;
        };
        Update: {
          created_at?: string | null;
          expires_at?: string;
          id?: never;
          query?: string;
          query_hash?: string;
          results?: Json;
          search_metadata?: Json;
          source?: string;
          user_id?: string;
        };
        Relationships: [];
      };
      search_flights: {
        Row: {
          cabin_class: string;
          created_at: string | null;
          departure_date: string;
          destination: string;
          expires_at: string;
          id: number;
          origin: string;
          passengers: number;
          query_hash: string;
          query_parameters: Json;
          results: Json;
          return_date: string | null;
          search_metadata: Json;
          source: string;
          user_id: string;
        };
        Insert: {
          cabin_class?: string;
          created_at?: string | null;
          departure_date: string;
          destination: string;
          expires_at: string;
          id?: never;
          origin: string;
          passengers?: number;
          query_hash: string;
          query_parameters: Json;
          results: Json;
          return_date?: string | null;
          search_metadata?: Json;
          source: string;
          user_id: string;
        };
        Update: {
          cabin_class?: string;
          created_at?: string | null;
          departure_date?: string;
          destination?: string;
          expires_at?: string;
          id?: never;
          origin?: string;
          passengers?: number;
          query_hash?: string;
          query_parameters?: Json;
          results?: Json;
          return_date?: string | null;
          search_metadata?: Json;
          source?: string;
          user_id?: string;
        };
        Relationships: [];
      };
      search_hotels: {
        Row: {
          check_in_date: string;
          check_out_date: string;
          created_at: string | null;
          destination: string;
          expires_at: string;
          guests: number;
          id: number;
          query_hash: string;
          query_parameters: Json;
          results: Json;
          rooms: number;
          search_metadata: Json;
          source: string;
          user_id: string;
        };
        Insert: {
          check_in_date: string;
          check_out_date: string;
          created_at?: string | null;
          destination: string;
          expires_at: string;
          guests?: number;
          id?: never;
          query_hash: string;
          query_parameters: Json;
          results: Json;
          rooms?: number;
          search_metadata?: Json;
          source: string;
          user_id: string;
        };
        Update: {
          check_in_date?: string;
          check_out_date?: string;
          created_at?: string | null;
          destination?: string;
          expires_at?: string;
          guests?: number;
          id?: never;
          query_hash?: string;
          query_parameters?: Json;
          results?: Json;
          rooms?: number;
          search_metadata?: Json;
          source?: string;
          user_id?: string;
        };
        Relationships: [];
      };
      trip_collaborators: {
        Row: {
          created_at: string | null;
          id: number;
          role: string;
          trip_id: number;
          user_id: string;
        };
        Insert: {
          created_at?: string | null;
          id?: never;
          role?: string;
          trip_id: number;
          user_id: string;
        };
        Update: {
          created_at?: string | null;
          id?: never;
          role?: string;
          trip_id?: number;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "trip_collaborators_trip_id_fkey";
            columns: ["trip_id"];
            isOneToOne: false;
            referencedRelation: "trips";
            referencedColumns: ["id"];
          },
        ];
      };
      trips: {
        Row: {
          budget: number;
          created_at: string | null;
          currency: string;
          destination: string;
          end_date: string;
          flexibility: Json | null;
          id: number;
          name: string;
          tags: string[] | null;
          search_metadata: Json | null;
          start_date: string;
          status: string;
          travelers: number;
          trip_type: string;
          updated_at: string | null;
          user_id: string;
        };
        Insert: {
          budget: number;
          created_at?: string | null;
          currency?: string;
          destination: string;
          end_date: string;
          flexibility?: Json | null;
          id?: never;
          name: string;
          tags?: string[] | null;
          search_metadata?: Json | null;
          start_date: string;
          status?: string;
          travelers: number;
          trip_type?: string;
          updated_at?: string | null;
          user_id: string;
        };
        Update: {
          budget?: number;
          created_at?: string | null;
          currency?: string;
          destination?: string;
          end_date?: string;
          flexibility?: Json | null;
          id?: never;
          name?: string;
          tags?: string[] | null;
          search_metadata?: Json | null;
          start_date?: string;
          status?: string;
          travelers?: number;
          trip_type?: string;
          updated_at?: string | null;
          user_id?: string;
        };
        Relationships: [];
      };
      user_settings: {
        Row: {
          allow_gateway_fallback: boolean;
          user_id: string;
        };
        Insert: {
          allow_gateway_fallback?: boolean;
          user_id: string;
        };
        Update: {
          allow_gateway_fallback?: boolean;
          user_id?: string;
        };
        Relationships: [];
      };
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      agent_config_upsert: {
        Args: {
          p_agent_type: string;
          p_config: Json;
          p_created_by: string;
          p_scope: string;
          p_summary?: string;
        };
        Returns: {
          config: Json;
          version_id: string;
        }[];
      };
      delete_user_api_key: {
        Args: { p_service: string; p_user_id: string };
        Returns: undefined;
      };
      delete_user_gateway_config: {
        Args: { p_user_id: string };
        Returns: undefined;
      };
      extract_trip_id_from_path: {
        Args: { file_path: string };
        Returns: number;
      };
      get_user_allow_gateway_fallback: {
        Args: { p_user_id: string };
        Returns: boolean;
      };
      get_user_api_key: {
        Args: { p_service: string; p_user_id: string };
        Returns: string;
      };
      get_user_gateway_base_url: {
        Args: { p_user_id: string };
        Returns: string;
      };
      insert_user_api_key: {
        Args: { p_api_key: string; p_service: string; p_user_id: string };
        Returns: string;
      };
      is_admin: { Args: never; Returns: boolean };
      match_accommodation_embeddings: {
        Args: {
          ef_search_override?: number | null;
          match_count?: number;
          match_threshold?: number;
          query_embedding: string;
        };
        Returns: {
          id: string;
          similarity: number;
        }[];
      };
      match_rag_documents: {
        Args: {
          query_embedding: string;
          filter_namespace?: string | null;
          match_threshold?: number;
          match_count?: number;
        };
        Returns: {
          id: string;
          content: string;
          metadata: Json;
          namespace: string;
          source_id: string | null;
          chunk_index: number;
          similarity: number;
        }[];
      };
      hybrid_rag_search: {
        Args: {
          query_text: string;
          query_embedding: string;
          filter_namespace?: string | null;
          match_count?: number;
          match_threshold?: number;
          keyword_weight?: number;
          semantic_weight?: number;
        };
        Returns: {
          id: string;
          content: string;
          metadata: Json;
          namespace: string;
          source_id: string | null;
          chunk_index: number;
          similarity: number;
          keyword_rank: number;
          combined_score: number;
        }[];
      };
      replace_backup_codes: {
        Args: { p_code_hashes: string[]; p_user_id: string };
        Returns: number;
      };
      rt_is_session_member: { Args: never; Returns: boolean };
      rt_topic_prefix: { Args: never; Returns: string };
      rt_topic_suffix: { Args: never; Returns: string };
      touch_user_api_key: {
        Args: { p_service: string; p_user_id: string };
        Returns: undefined;
      };
      upsert_user_gateway_config: {
        Args: { p_base_url: string; p_user_id: string };
        Returns: undefined;
      };
      user_has_trip_access: {
        Args: { trip_id: number; user_id: string };
        Returns: boolean;
      };
    };
    Enums: {
      [_ in never]: never;
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
  storage: {
    Tables: {
      buckets: {
        Row: {
          allowed_mime_types: string[] | null;
          avif_autodetection: boolean | null;
          created_at: string | null;
          file_size_limit: number | null;
          id: string;
          name: string;
          owner: string | null;
          owner_id: string | null;
          public: boolean | null;
          type: Database["storage"]["Enums"]["buckettype"];
          updated_at: string | null;
        };
        Insert: {
          allowed_mime_types?: string[] | null;
          avif_autodetection?: boolean | null;
          created_at?: string | null;
          file_size_limit?: number | null;
          id: string;
          name: string;
          owner?: string | null;
          owner_id?: string | null;
          public?: boolean | null;
          type?: Database["storage"]["Enums"]["buckettype"];
          updated_at?: string | null;
        };
        Update: {
          allowed_mime_types?: string[] | null;
          avif_autodetection?: boolean | null;
          created_at?: string | null;
          file_size_limit?: number | null;
          id?: string;
          name?: string;
          owner?: string | null;
          owner_id?: string | null;
          public?: boolean | null;
          type?: Database["storage"]["Enums"]["buckettype"];
          updated_at?: string | null;
        };
        Relationships: [];
      };
      buckets_analytics: {
        Row: {
          created_at: string;
          format: string;
          id: string;
          type: Database["storage"]["Enums"]["buckettype"];
          updated_at: string;
        };
        Insert: {
          created_at?: string;
          format?: string;
          id: string;
          type?: Database["storage"]["Enums"]["buckettype"];
          updated_at?: string;
        };
        Update: {
          created_at?: string;
          format?: string;
          id?: string;
          type?: Database["storage"]["Enums"]["buckettype"];
          updated_at?: string;
        };
        Relationships: [];
      };
      iceberg_namespaces: {
        Row: {
          bucket_id: string;
          created_at: string;
          id: string;
          name: string;
          updated_at: string;
        };
        Insert: {
          bucket_id: string;
          created_at?: string;
          id?: string;
          name: string;
          updated_at?: string;
        };
        Update: {
          bucket_id?: string;
          created_at?: string;
          id?: string;
          name?: string;
          updated_at?: string;
        };
        Relationships: [
          {
            foreignKeyName: "iceberg_namespaces_bucket_id_fkey";
            columns: ["bucket_id"];
            isOneToOne: false;
            referencedRelation: "buckets_analytics";
            referencedColumns: ["id"];
          },
        ];
      };
      iceberg_tables: {
        Row: {
          bucket_id: string;
          created_at: string;
          id: string;
          location: string;
          name: string;
          namespace_id: string;
          updated_at: string;
        };
        Insert: {
          bucket_id: string;
          created_at?: string;
          id?: string;
          location: string;
          name: string;
          namespace_id: string;
          updated_at?: string;
        };
        Update: {
          bucket_id?: string;
          created_at?: string;
          id?: string;
          location?: string;
          name?: string;
          namespace_id?: string;
          updated_at?: string;
        };
        Relationships: [
          {
            foreignKeyName: "iceberg_tables_bucket_id_fkey";
            columns: ["bucket_id"];
            isOneToOne: false;
            referencedRelation: "buckets_analytics";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "iceberg_tables_namespace_id_fkey";
            columns: ["namespace_id"];
            isOneToOne: false;
            referencedRelation: "iceberg_namespaces";
            referencedColumns: ["id"];
          },
        ];
      };
      migrations: {
        Row: {
          executed_at: string | null;
          hash: string;
          id: number;
          name: string;
        };
        Insert: {
          executed_at?: string | null;
          hash: string;
          id: number;
          name: string;
        };
        Update: {
          executed_at?: string | null;
          hash?: string;
          id?: number;
          name?: string;
        };
        Relationships: [];
      };
      objects: {
        Row: {
          bucket_id: string | null;
          created_at: string | null;
          id: string;
          last_accessed_at: string | null;
          level: number | null;
          metadata: Json | null;
          name: string | null;
          owner: string | null;
          owner_id: string | null;
          path_tokens: string[] | null;
          updated_at: string | null;
          user_metadata: Json | null;
          version: string | null;
        };
        Insert: {
          bucket_id?: string | null;
          created_at?: string | null;
          id?: string;
          last_accessed_at?: string | null;
          level?: number | null;
          metadata?: Json | null;
          name?: string | null;
          owner?: string | null;
          owner_id?: string | null;
          path_tokens?: string[] | null;
          updated_at?: string | null;
          user_metadata?: Json | null;
          version?: string | null;
        };
        Update: {
          bucket_id?: string | null;
          created_at?: string | null;
          id?: string;
          last_accessed_at?: string | null;
          level?: number | null;
          metadata?: Json | null;
          name?: string | null;
          owner?: string | null;
          owner_id?: string | null;
          path_tokens?: string[] | null;
          updated_at?: string | null;
          user_metadata?: Json | null;
          version?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "objects_bucketId_fkey";
            columns: ["bucket_id"];
            isOneToOne: false;
            referencedRelation: "buckets";
            referencedColumns: ["id"];
          },
        ];
      };
      prefixes: {
        Row: {
          bucket_id: string;
          created_at: string | null;
          level: number;
          name: string;
          updated_at: string | null;
        };
        Insert: {
          bucket_id: string;
          created_at?: string | null;
          level?: number;
          name: string;
          updated_at?: string | null;
        };
        Update: {
          bucket_id?: string;
          created_at?: string | null;
          level?: number;
          name?: string;
          updated_at?: string | null;
        };
        Relationships: [
          {
            foreignKeyName: "prefixes_bucketId_fkey";
            columns: ["bucket_id"];
            isOneToOne: false;
            referencedRelation: "buckets";
            referencedColumns: ["id"];
          },
        ];
      };
      s3_multipart_uploads: {
        Row: {
          bucket_id: string;
          created_at: string;
          id: string;
          in_progress_size: number;
          key: string;
          owner_id: string | null;
          upload_signature: string;
          user_metadata: Json | null;
          version: string;
        };
        Insert: {
          bucket_id: string;
          created_at?: string;
          id: string;
          in_progress_size?: number;
          key: string;
          owner_id?: string | null;
          upload_signature: string;
          user_metadata?: Json | null;
          version: string;
        };
        Update: {
          bucket_id?: string;
          created_at?: string;
          id?: string;
          in_progress_size?: number;
          key?: string;
          owner_id?: string | null;
          upload_signature?: string;
          user_metadata?: Json | null;
          version?: string;
        };
        Relationships: [
          {
            foreignKeyName: "s3_multipart_uploads_bucket_id_fkey";
            columns: ["bucket_id"];
            isOneToOne: false;
            referencedRelation: "buckets";
            referencedColumns: ["id"];
          },
        ];
      };
      s3_multipart_uploads_parts: {
        Row: {
          bucket_id: string;
          created_at: string;
          etag: string;
          id: string;
          key: string;
          owner_id: string | null;
          part_number: number;
          size: number;
          upload_id: string;
          version: string;
        };
        Insert: {
          bucket_id: string;
          created_at?: string;
          etag: string;
          id?: string;
          key: string;
          owner_id?: string | null;
          part_number: number;
          size?: number;
          upload_id: string;
          version: string;
        };
        Update: {
          bucket_id?: string;
          created_at?: string;
          etag?: string;
          id?: string;
          key?: string;
          owner_id?: string | null;
          part_number?: number;
          size?: number;
          upload_id?: string;
          version?: string;
        };
        Relationships: [
          {
            foreignKeyName: "s3_multipart_uploads_parts_bucket_id_fkey";
            columns: ["bucket_id"];
            isOneToOne: false;
            referencedRelation: "buckets";
            referencedColumns: ["id"];
          },
          {
            foreignKeyName: "s3_multipart_uploads_parts_upload_id_fkey";
            columns: ["upload_id"];
            isOneToOne: false;
            referencedRelation: "s3_multipart_uploads";
            referencedColumns: ["id"];
          },
        ];
      };
    };
    Views: {
      [_ in never]: never;
    };
    Functions: {
      add_prefixes: {
        Args: { _bucket_id: string; _name: string };
        Returns: undefined;
      };
      can_insert_object: {
        Args: { bucketid: string; metadata: Json; name: string; owner: string };
        Returns: undefined;
      };
      delete_leaf_prefixes: {
        Args: { bucket_ids: string[]; names: string[] };
        Returns: undefined;
      };
      delete_prefix: {
        Args: { _bucket_id: string; _name: string };
        Returns: boolean;
      };
      extension: { Args: { name: string }; Returns: string };
      filename: { Args: { name: string }; Returns: string };
      foldername: { Args: { name: string }; Returns: string[] };
      get_level: { Args: { name: string }; Returns: number };
      get_prefix: { Args: { name: string }; Returns: string };
      get_prefixes: { Args: { name: string }; Returns: string[] };
      get_size_by_bucket: {
        Args: never;
        Returns: {
          bucket_id: string;
          size: number;
        }[];
      };
      list_multipart_uploads_with_delimiter: {
        Args: {
          bucket_id: string;
          delimiter_param: string;
          max_keys?: number;
          next_key_token?: string;
          next_upload_token?: string;
          prefix_param: string;
        };
        Returns: {
          created_at: string;
          id: string;
          key: string;
        }[];
      };
      list_objects_with_delimiter: {
        Args: {
          bucket_id: string;
          delimiter_param: string;
          max_keys?: number;
          next_token?: string;
          prefix_param: string;
          start_after?: string;
        };
        Returns: {
          id: string;
          metadata: Json;
          name: string;
          updated_at: string;
        }[];
      };
      lock_top_prefixes: {
        Args: { bucket_ids: string[]; names: string[] };
        Returns: undefined;
      };
      operation: { Args: never; Returns: string };
      search: {
        Args: {
          bucketname: string;
          levels?: number;
          limits?: number;
          offsets?: number;
          prefix: string;
          search?: string;
          sortcolumn?: string;
          sortorder?: string;
        };
        Returns: {
          created_at: string;
          id: string;
          last_accessed_at: string;
          metadata: Json;
          name: string;
          updated_at: string;
        }[];
      };
      search_legacy_v1: {
        Args: {
          bucketname: string;
          levels?: number;
          limits?: number;
          offsets?: number;
          prefix: string;
          search?: string;
          sortcolumn?: string;
          sortorder?: string;
        };
        Returns: {
          created_at: string;
          id: string;
          last_accessed_at: string;
          metadata: Json;
          name: string;
          updated_at: string;
        }[];
      };
      search_v1_optimised: {
        Args: {
          bucketname: string;
          levels?: number;
          limits?: number;
          offsets?: number;
          prefix: string;
          search?: string;
          sortcolumn?: string;
          sortorder?: string;
        };
        Returns: {
          created_at: string;
          id: string;
          last_accessed_at: string;
          metadata: Json;
          name: string;
          updated_at: string;
        }[];
      };
      search_v2: {
        Args: {
          bucket_name: string;
          levels?: number;
          limits?: number;
          prefix: string;
          sort_column?: string;
          sort_column_after?: string;
          sort_order?: string;
          start_after?: string;
        };
        Returns: {
          created_at: string;
          id: string;
          key: string;
          last_accessed_at: string;
          metadata: Json;
          name: string;
          updated_at: string;
        }[];
      };
    };
    Enums: {
      buckettype: "STANDARD" | "ANALYTICS";
    };
    CompositeTypes: {
      [_ in never]: never;
    };
  };
};
⋮----
type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">;
⋮----
type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">];
⋮----
export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R;
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R;
      }
      ? R
      : never
    : never;
⋮----
export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I;
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I;
      }
      ? I
      : never
    : never;
⋮----
export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U;
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U;
      }
      ? U
      : never
    : never;
⋮----
export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never;
⋮----
export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals;
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals;
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never;
⋮----
// Helper type aliases for ergonomic access to generated helpers
type PublicTables = keyof DefaultSchema["Tables"];
type SchemaName = keyof DatabaseWithoutInternals;
⋮----
export type InsertTables<TableName extends PublicTables> =
  DefaultSchema["Tables"][TableName] extends { Insert: infer I } ? I : never;
export type InsertTablesInSchema<
  Schema extends SchemaName,
  TableName extends keyof DatabaseWithoutInternals[Schema]["Tables"],
> = DatabaseWithoutInternals[Schema]["Tables"][TableName] extends { Insert: infer I }
  ? I
  : never;
⋮----
export type UpdateTables<TableName extends PublicTables> =
  DefaultSchema["Tables"][TableName] extends { Update: infer U } ? U : never;
export type UpdateTablesInSchema<
  Schema extends SchemaName,
  TableName extends keyof DatabaseWithoutInternals[Schema]["Tables"],
> = DatabaseWithoutInternals[Schema]["Tables"][TableName] extends { Update: infer U }
  ? U
  : never;
⋮----
// Convenience aliases for common tables
export type Trip = Tables<"trips">;
export type TripInsert = InsertTables<"trips">;
export type TripUpdate = UpdateTables<"trips">;
⋮----
export type Accommodation = Tables<"accommodations">;
export type AccommodationInsert = InsertTables<"accommodations">;
export type AccommodationUpdate = UpdateTables<"accommodations">;
⋮----
export type ApiMetric = Tables<"api_metrics">;
export type ApiMetricInsert = InsertTables<"api_metrics">;
export type ApiMetricUpdate = UpdateTables<"api_metrics">;
⋮----
export type FileAttachment = Tables<"file_attachments">;
export type FileAttachmentInsert = InsertTables<"file_attachments">;
export type FileAttachmentUpdate = UpdateTables<"file_attachments">;
export type UploadStatus = FileAttachment["upload_status"];
export type VirusScanStatus = FileAttachment["virus_scan_status"];
⋮----
export type ChatSession = Tables<"chat_sessions">;
export type ChatSessionInsert = InsertTables<"chat_sessions">;
export type ChatMessage = Tables<"chat_messages">;
export type ChatMessageInsert = InsertTables<"chat_messages">;
export type ChatToolCall = Tables<"chat_tool_calls">;
export type ChatToolCallInsert = InsertTables<"chat_tool_calls">;
export type ChatRole = ChatMessage["role"];
⋮----
export type MemorySession = Tables<{ schema: "memories" }, "sessions">;
export type MemorySessionInsert = InsertTablesInSchema<"memories", "sessions">;
export type MemorySessionUpdate = UpdateTablesInSchema<"memories", "sessions">;
export type MemoryTurn = Tables<{ schema: "memories" }, "turns">;
export type MemoryTurnInsert = InsertTablesInSchema<"memories", "turns">;
export type MemoryTurnUpdate = UpdateTablesInSchema<"memories", "turns">;
````

## File: src/lib/supabase/index.ts
````typescript
/**
 * @fileoverview Browser/client-safe Supabase exports.
 *
 * Server entrypoints live in `./server` (Route Handlers / Server Components) and
 * `./factory` (middleware/proxy cookie adapters).
 */
⋮----
// Browser client helpers
⋮----
// Shared types (type-only exports are safe - they don't cause server-only imports)
⋮----
// Runtime guards
````

## File: src/lib/supabase/rpc.ts
````typescript
/**
 * @fileoverview Supabase RPC wrappers for Vault and gateway user settings.
 */
⋮----
import type { TypedAdminSupabase } from "./admin";
import { createAdminSupabase } from "./admin";
⋮----
export type SupportedService =
  | "openai"
  | "openrouter"
  | "anthropic"
  | "xai"
  | "gateway";
⋮----
function normalizeService(service: string): SupportedService
⋮----
/**
 * Insert or replace a user's API key for a given provider using Vault RPC.
 *
 * @param userId The Supabase auth user id owning the key.
 * @param service Provider identifier (openai|openrouter|anthropic|xai).
 * @param apiKey Plaintext API key to store in Vault.
 * @param client Optional preconfigured admin Supabase client for testing.
 * @returns Resolves when the RPC succeeds.
 * @throws Error when RPC execution fails or service is invalid.
 */
export async function insertUserApiKey(
  userId: string,
  service: string,
  apiKey: string,
  client?: TypedAdminSupabase
): Promise<void>
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
/**
 * Delete a user's API key for a given provider and remove its Vault secret.
 *
 * @param userId The Supabase auth user id owning the key.
 * @param service Provider identifier (openai|openrouter|anthropic|xai).
 * @param client Optional preconfigured admin Supabase client for testing.
 * @returns Resolves when the RPC succeeds.
 * @throws Error when RPC execution fails or service is invalid.
 */
export async function deleteUserApiKey(
  userId: string,
  service: string,
  client?: TypedAdminSupabase
): Promise<void>
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
/**
 * Retrieve a user's API key plaintext from Vault for the given provider.
 *
 * Note: Only use server-side and avoid logging the returned value.
 *
 * @param userId The Supabase auth user id owning the key.
 * @param service Provider identifier (openai|openrouter|anthropic|xai).
 * @param client Optional preconfigured admin Supabase client for testing.
 * @returns The plaintext API key or null if not found.
 * @throws Error when RPC execution fails or service is invalid.
 */
export async function getUserApiKey(
  userId: string,
  service: string,
  client?: TypedAdminSupabase
): Promise<string | null>
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
/**
 * Update `last_used` timestamp for a user's API key metadata.
 *
 * @param userId The Supabase auth user id owning the key.
 * @param service Provider identifier (openai|openrouter|anthropic|xai).
 * @param client Optional preconfigured admin Supabase client for testing.
 * @returns Resolves when the RPC succeeds.
 * @throws Error when RPC execution fails or service is invalid.
 */
export async function touchUserApiKey(
  userId: string,
  service: string,
  client?: TypedAdminSupabase
): Promise<void>
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
/** Gateway config (base URL) helpers **/
⋮----
export async function upsertUserGatewayBaseUrl(
  userId: string,
  baseUrl: string,
  client?: TypedAdminSupabase
): Promise<void>
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
export async function getUserGatewayBaseUrl(
  userId: string,
  client?: TypedAdminSupabase
): Promise<string | null>
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
export async function deleteUserGatewayBaseUrl(
  userId: string,
  client?: TypedAdminSupabase
): Promise<void>
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
⋮----
export async function getUserAllowGatewayFallback(
  userId: string,
  client?: TypedAdminSupabase
): Promise<boolean | null>
⋮----
// biome-ignore lint/style/useNamingConvention: Database RPC parameter names use snake_case
````

## File: src/lib/supabase/server.ts
````typescript
/**
 * @fileoverview Server-only Supabase client entrypoint wired to Next.js cookies().
 */
⋮----
import type { SupabaseClient } from "@supabase/supabase-js";
import { cookies } from "next/headers";
import type { Database } from "./database.types";
import { createCookieAdapter, createServerSupabaseClient } from "./factory";
⋮----
export type TypedServerSupabase = SupabaseClient<Database>;
⋮----
/**
 * Creates server Supabase client with Next.js cookies.
 * @returns Promise resolving to typed Supabase server client
 */
export async function createServerSupabase(): Promise<TypedServerSupabase>
⋮----
// Re-export factory utilities
````

## File: src/lib/telemetry/redis.ts
````typescript
/**
 * @fileoverview Telemetry helpers for Redis availability warnings.
 */
⋮----
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { recordErrorOnSpan, withTelemetrySpanSync } from "@/lib/telemetry/span";
⋮----
/**
 * Emits a telemetry span once per feature when Redis is not configured or encounters an error.
 *
 * @param feature - Feature name for categorization
 * @param errorDetails - Optional error details for debugging (logged with telemetry)
 */
export function warnRedisUnavailable(
  feature: string,
  errorDetails?: { errorName?: string; errorMessage?: string }
): void
⋮----
/**
 * Resets warning state (intended for unit tests).
 */
export function resetRedisWarningStateForTests(): void
````

## File: src/lib/telemetry/route-key.ts
````typescript
/**
 * @fileoverview Low-cardinality route key helpers for telemetry and alerts.
 */
⋮----
function isUuidLike(value: string): boolean
⋮----
// Basic UUID v4-ish matcher (case-insensitive); sufficient for telemetry normalization.
⋮----
function isNumericId(value: string): boolean
⋮----
/**
 * Sanitizes a URL pathname into a low-cardinality telemetry route key.
 *
 * Behavior:
 * - Empty/root pathnames normalize to `"/"`.
 * - Trailing slashes are removed via segment normalization (e.g. `"/foo/"` → `"/foo"`).
 * - UUID-like segments become `":uuid"` and numeric segments become `":id"`.
 *
 * Callers must pass a pathname only (no query string or hash); those are not parsed here.
 */
export function sanitizePathnameForTelemetry(pathname: string): string
````

## File: src/lib/utils/type-guards.ts
````typescript
/**
 * @fileoverview Shared type-guard utilities.
 */
⋮----
/**
 * Determines whether a value is a plain object (object literal or Object.create(null)),
 * excluding arrays, null, and class instances like Date.
 *
 * @param {unknown} value - The value to evaluate.
 * @returns {value is Record<string, unknown>} True when the value is a plain object.
 * @example isPlainObject({ a: 1 }) // true
 * @example isPlainObject([1]) // false
 * @example isPlainObject(new Date()) // false
 */
export function isPlainObject(value: unknown): value is Record<string, unknown>
````

## File: src/lib/webhooks/errors.ts
````typescript
/**
 * @fileoverview Typed webhook errors with explicit HTTP status mapping.
 */
⋮----
/**
 * Stable, public webhook error codes.
 *
 * Note: not every code is produced by the shared handler today; some are reserved
 * for webhook-specific implementations that throw a more precise typed error.
 *
 * `DUPLICATE` is used for internal classification/telemetry. HTTP responses for
 * duplicate events return `{ ok: true, duplicate: true }` with status 200 and no
 * explicit `code` field.
 */
export type WebhookErrorCode =
  | "VALIDATION_ERROR"
  | "UNAUTHORIZED"
  | "NOT_FOUND"
  | "CONFLICT"
  | "DUPLICATE"
  | "RATE_LIMITED"
  | "SERVICE_UNAVAILABLE"
  | "UPSTREAM_ERROR"
  | "TIMEOUT"
  | "UNKNOWN";
⋮----
export class WebhookError extends Error
⋮----
constructor(
    message: string,
    options: {
      code: WebhookErrorCode;
      status: number;
      retryAfterSeconds?: number | null;
      cause?: unknown;
    }
)
⋮----
export class WebhookValidationError extends WebhookError
⋮----
constructor(message: string = "invalid_request", options?:
⋮----
export class WebhookUnauthorizedError extends WebhookError
⋮----
constructor(message: string = "unauthorized", options?:
⋮----
export class WebhookNotFoundError extends WebhookError
⋮----
constructor(message: string = "not_found", options?:
⋮----
export class WebhookConflictError extends WebhookError
⋮----
constructor(message: string = "conflict", options?:
⋮----
export class WebhookDuplicateError extends WebhookError
⋮----
constructor(message: string = "duplicate", options?:
⋮----
export class WebhookRateLimitedError extends WebhookError
⋮----
constructor(
    message: string = "rate_limit_exceeded",
    options?: { cause?: unknown; retryAfterSeconds?: number | null }
)
⋮----
export class WebhookServiceUnavailableError extends WebhookError
⋮----
constructor(message: string = "service_unavailable", options?:
⋮----
export class WebhookUpstreamError extends WebhookError
⋮----
constructor(message: string = "upstream_error", options?:
⋮----
export class WebhookTimeoutError extends WebhookError
⋮----
constructor(message: string = "timeout", options?:
````

## File: src/lib/redis.ts
````typescript
/**
 * @fileoverview Upstash Redis REST client helper with an optional test factory override.
 */
import { Redis } from "@upstash/redis";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
⋮----
// Test injection point (follows factory.ts pattern)
⋮----
/**
 * Override Redis client factory for tests.
 * Pass null to reset to production behavior.
 *
 * Also clears the cached singleton to force fresh client creation on the next
 * getRedis() call. This ensures test isolation—setting a new factory or null
 * will result in a fresh client from the new factory or production code.
 *
 * @example
 * ```ts
 * import { setRedisFactoryForTests } from "@/lib/redis";
 * import { RedisMockClient } from "@/test/upstash/redis-mock";
 *
 * setRedisFactoryForTests(() => new RedisMockClient() as never);
 *
 * // After tests
 * setRedisFactoryForTests(null);
 * ```
 */
export function setRedisFactoryForTests(
  factory: (() => Redis | undefined) | null
): void
⋮----
redisSingleton = undefined; // Clear cache to force factory usage
⋮----
/**
 * Returns the Redis client for server code.
 * - Production path: returns a cached singleton (constructed once per process).
 * - Test path: if setRedisFactoryForTests() is configured, returns the factory
 *   result per call (may or may not be singleton depending on the factory).
 *
 * setRedisFactoryForTests() clears the cached singleton so the next call uses
 * the test factory or recreates the production client with fresh credentials.
 * @returns The Redis client or undefined if env is missing.
 */
export function getRedis(): Redis | undefined
⋮----
// Test override takes precedence
⋮----
/**
 * Increment a counter by key with an optional TTL (seconds).
 * @param key Counter key
 * @param [ttlSeconds] Optional TTL in seconds to set after increment
 * @returns New counter value or null if redis unavailable
 */
export async function incrCounter(
  key: string,
  ttlSeconds?: number
): Promise<number | null>
````

## File: src/stores/middleware/computed.ts
````typescript
/**
 * @fileoverview Zustand middleware that recomputes derived state on every update.
 */
⋮----
import type { StateCreator, StoreMutatorIdentifier } from "zustand";
⋮----
/**
 * Configuration for computed state middleware.
 *
 * @template T - The store state type.
 */
export interface ComputedConfig<T> {
  /**
   * Function that computes derived values from current state.
   * Should return only the computed properties, not the full state.
   */
  compute: (state: T) => Partial<T>;
}
⋮----
/**
   * Function that computes derived values from current state.
   * Should return only the computed properties, not the full state.
   */
⋮----
/**
 * Zustand middleware that automatically updates computed properties on state changes.
 *
 * @template T - Store state type (must include both base and computed properties)
 * @template Mps - Mutator parameters (for middleware composition)
 * @template Mcs - Mutator constraints
 *
 * @param config - Configuration object with compute function
 * @param stateCreator - Zustand state creator to wrap
 * @returns Middleware-wrapped state creator
 *
 * @example
 * ```ts
 * const useStore = create<State>()(
 *   withComputed(
 *     { compute: (state) => ({ total: state.price * state.qty }) },
 *     (set) => ({
 *       price: 0,
 *       qty: 1,
 *       total: 0,
 *       setPrice: (price) => set({ price }),
 *     })
 *   )
 * );
 * ```
 *
 * @remarks
 * Compute functions run on **every state update**. Keep them pure, synchronous,
 * and efficient (O(1) or O(n) with small n). See the Zustand Computed Middleware
 * Guide for patterns, performance tips, and when to use vs. selectors.
 */
export function withComputed<
  T extends object,
  Mps extends [StoreMutatorIdentifier, unknown][] = [],
  Mcs extends [StoreMutatorIdentifier, unknown][] = [],
>(
  config: ComputedConfig<T>,
  stateCreator: StateCreator<T, Mps, Mcs>
): StateCreator<T, Mps, Mcs>
⋮----
const applyComputed = (
      nextState: Parameters<typeof set>[0],
      replace?: Parameters<typeof set>[1]
) =>
⋮----
/**
 * Helper to create a compute function from individual computed properties.
 *
 * @template T - The store state type.
 * @param computedProps - Object mapping property names to compute functions.
 * @returns Combined compute function.
 */
export function createComputeFn<T>(
  computedProps: { [K in keyof Partial<T>]: (state: T) => T[K] }
): (state: T) => Partial<T>
````

## File: src/stores/budget-store.ts
````typescript
/**
 * @fileoverview Zustand store for budget state and actions.
 */
⋮----
import type {
  Budget,
  BudgetAlert,
  BudgetCategory,
  BudgetSummary,
  CurrencyRate,
  Expense,
  ExpenseCategory,
} from "@schemas/budget";
import type { CurrencyCode } from "@schemas/currency";
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { nowIso, secureId } from "@/lib/security/random";
⋮----
// Helper functions
const GENERATE_ID = ()
const GET_CURRENT_TIMESTAMP = ()
⋮----
/**
 * Interface for the budget state.
 */
interface BudgetState {
  // Budgets
  budgets: Record<string, Budget>;
  activeBudgetId: string | null;

  // Expenses
  expenses: Record<string, Expense[]>;

  // Currency
  baseCurrency: CurrencyCode;
  currencies: Record<CurrencyCode, CurrencyRate>;

  // Alerts
  alerts: Record<string, BudgetAlert[]>;

  // Computed properties
  activeBudget: Budget | null;
  budgetSummary: BudgetSummary | null;
  budgetsByTrip: Record<string, string[]>;
  recentExpenses: Expense[];

  // Budget actions
  setBudgets: (budgets: Record<string, Budget>) => void;
  addBudget: (budget: Budget) => void;
  updateBudget: (id: string, updates: Partial<Budget>) => void;
  removeBudget: (id: string) => void;
  setActiveBudget: (id: string | null) => void;

  // Budget category actions
  updateBudgetCategory: (
    budgetId: string,
    categoryId: string,
    updates: Partial<BudgetCategory>
  ) => void;
  addBudgetCategory: (budgetId: string, category: BudgetCategory) => void;
  removeBudgetCategory: (budgetId: string, categoryId: string) => void;

  // Expense actions
  setExpenses: (budgetId: string, expenses: Expense[]) => void;
  addExpense: (expense: Expense) => void;
  updateExpense: (id: string, budgetId: string, updates: Partial<Expense>) => void;
  removeExpense: (id: string, budgetId: string) => void;

  // Currency actions
  setBaseCurrency: (currency: CurrencyCode) => void;
  setCurrencies: (currencies: Record<CurrencyCode, CurrencyRate>) => void;
  updateCurrencyRate: (code: CurrencyCode, rate: number) => void;

  // Alert actions
  setAlerts: (budgetId: string, alerts: BudgetAlert[]) => void;
  addAlert: (alert: BudgetAlert) => void;
  markAlertAsRead: (id: string, budgetId: string) => void;
  clearAlerts: (budgetId: string) => void;
}
⋮----
// Budgets
⋮----
// Expenses
⋮----
// Currency
⋮----
// Alerts
⋮----
// Computed properties
⋮----
// Budget actions
⋮----
// Budget category actions
⋮----
// Expense actions
⋮----
// Currency actions
⋮----
// Alert actions
⋮----
/**
 * Calculate the budget summary.
 *
 * @param budget - The budget to calculate the summary for.
 * @param expenses - The expenses to calculate the summary for.
 * @returns The budget summary.
 */
const CALCULATE_BUDGET_SUMMARY = (
  budget: Budget,
  expenses: Expense[]
): BudgetSummary =>
⋮----
// Calculate spent by category
⋮----
// Calculate days remaining if dates are provided
⋮----
// Calculate daily metrics
⋮----
/**
 * The budget store.
 */
⋮----
// Computed properties
/**
       * The currently active budget, or null if none is active.
       */
get activeBudget(): Budget | null
⋮----
/**
       * Add an alert to the budget.
       *
       * @param alert - The alert to add.
       * @returns The updated state.
       */
⋮----
/**
       * Add a budget to the budget.
       *
       * @param budget - The budget to add.
       * @returns The updated state.
       */
⋮----
// If this is the first budget, set it as active
⋮----
/**
       * Add a budget category to the budget.
       *
       * @param budgetId - The ID of the budget to add the category to.
       * @param category - The category to add.
       * @returns The updated state.
       */
⋮----
/**
       * Add an expense to the budget.
       *
       * @param expense - The expense to add.
       * @returns The updated state.
       */
⋮----
/**
       * Summary metrics for the active budget (totals, percentages, categories).
       * Returns null when there is no active budget.
       */
get budgetSummary(): BudgetSummary | null
// Initial state
⋮----
/**
       * Map of tripId to a list of budget IDs belonging to that trip.
       */
get budgetsByTrip(): Record<string, string[]>
⋮----
/**
       * Clear the alerts for a budget.
       *
       * @param budgetId - The ID of the budget to clear the alerts for.
       * @returns The updated state.
       */
⋮----
/**
       * Mark an alert as read.
       *
       * @param id - The ID of the alert to mark as read.
       * @param budgetId - The ID of the budget to mark the alert for.
       * @returns The updated state.
       */
⋮----
/**
       * The 10 most recent expenses across all budgets, newest first.
       */
get recentExpenses(): Expense[]
⋮----
/**
       * Remove a budget.
       *
       * @param id - The ID of the budget to remove.
       * @returns The updated state.
       */
⋮----
// If the active budget is removed, set the active budget to null
⋮----
/**
       * Remove a budget category.
       *
       * @param budgetId - The ID of the budget to remove the category from.
       * @param categoryId - The ID of the category to remove.
       * @returns The updated state.
       */
⋮----
/**
       * Remove an expense.
       *
       * @param id - The ID of the expense to remove.
       * @param budgetId - The ID of the budget to remove the expense from.
       * @returns The updated state.
       */
⋮----
/**
       * Set the active budget.
       *
       * @param id - The ID of the budget to set as active.
       * @returns The updated state.
       */
⋮----
// Alert actions
/**
       * Set the alerts for a budget.
       *
       * @param budgetId - The ID of the budget to set the alerts for.
       * @param alerts - The alerts to set.
       * @returns The updated state.
       */
⋮----
// Currency actions
⋮----
// Budget actions
⋮----
/**
       * Set the currencies.
       *
       * @param currencies - The currencies to set.
       * @returns The updated state.
       */
⋮----
// Expense actions
/**
       * Set the expenses for a budget.
       *
       * @param budgetId - The ID of the budget to set the expenses for.
       * @param expenses - The expenses to set.
       * @returns The updated state.
       */
⋮----
/**
       * Update a budget.
       *
       * @param id - The ID of the budget to update.
       * @param updates - The updates to apply to the budget.
       * @returns The updated state.
       */
⋮----
// Budget category actions
/**
       * Update a budget category.
       *
       * @param budgetId - The ID of the budget to update the category for.
       * @param categoryId - The ID of the category to update.
       * @param updates - The updates to apply to the category.
       * @returns The updated state.
       */
⋮----
/**
       * Update a currency rate.
       *
       * @param code - The code of the currency to update.
       * @param rate - The rate to set for the currency.
       * @returns The updated state.
       */
⋮----
/**
       * Update an expense.
       *
       * @param id - The ID of the expense to update.
       * @param budgetId - The ID of the budget to update the expense for.
       * @param updates - The updates to apply to the expense.
       * @returns The updated state.
       */
⋮----
// Only persist certain parts of the state
⋮----
// Do not persist computed properties
⋮----
// Selector hooks for computed properties
export const useActiveBudget = ()
export const useBudgetSummary = ()
export const useBudgetsByTrip = ()
export const useRecentExpenses = ()
⋮----
/**
 * Compute the active budget from a given budget state.
 *
 * @param state - The budget store state snapshot.
 * @returns The active budget or null.
 */
export const selectActiveBudgetFrom = (state: BudgetState): Budget | null =>
⋮----
/**
 * Compute the budget summary for the current active budget.
 *
 * @param state - The budget store state snapshot.
 * @returns The summary or null when no active budget exists.
 */
export const selectBudgetSummaryFrom = (state: BudgetState): BudgetSummary | null =>
⋮----
/**
 * Compute a map of tripId to the list of budget IDs belonging to that trip.
 *
 * @param state - The budget store state snapshot.
 * @returns A map of trip IDs to budget ID arrays.
 */
export const selectBudgetsByTripFrom = (
  state: BudgetState
): Record<string, string[]> =>
⋮----
/**
 * Compute the 10 most recent expenses across all budgets.
 *
 * @param state - The budget store state snapshot.
 * @returns A list of recent expenses sorted by date descending.
 */
export const selectRecentExpensesFrom = (state: BudgetState): Expense[] =>
````

## File: src/test/factories/realtime-factory.ts
````typescript
/**
 * @fileoverview Factory for creating Supabase Realtime mocks for testing.
 */
⋮----
import type { RealtimePostgresChangesPayload } from "@supabase/supabase-js";
import { vi } from "vitest";
⋮----
/**
 * Realtime channel states.
 */
export type RealtimeChannelStates =
  | "SUBSCRIBED"
  | "CHANNEL_ERROR"
  | "TIMED_OUT"
  | "CLOSED";
⋮----
/**
 * Mock RealtimeChannel interface.
 */
export interface MockRealtimeChannel {
  on: ReturnType<typeof vi.fn>;
  subscribe: ReturnType<typeof vi.fn>;
  unsubscribe: ReturnType<typeof vi.fn>;
  send?: ReturnType<typeof vi.fn>;
  presenceState?: ReturnType<typeof vi.fn>;
  track?: ReturnType<typeof vi.fn>;
  untrack?: ReturnType<typeof vi.fn>;
  _callbacks?: {
    postgresChanges?: Array<{
      callback: (
        payload: RealtimePostgresChangesPayload<Record<string, unknown>>
      ) => void;
      event: string;
      filter?: string;
      schema: string;
      table: string;
    }>;
    system?: Array<{
      callback: (payload: { status: RealtimeChannelStates }) => void;
    }>;
  };
  _isSubscribed?: boolean;
}
⋮----
/**
 * Mock Realtime client interface.
 */
export interface MockRealtimeClient {
  channels: MockRealtimeChannel[];
  connect: ReturnType<typeof vi.fn>;
  disconnect: ReturnType<typeof vi.fn>;
}
⋮----
/**
 * Options for creating a mock Realtime channel.
 */
export interface RealtimeChannelOptions {
  initialState?: RealtimeChannelStates;
  onSubscribe?: (status: RealtimeChannelStates) => void;
}
⋮----
/**
 * Creates a mock RealtimeChannel with proper method chaining.
 *
 * @param options - Channel options
 * @returns Mock RealtimeChannel
 */
export function createMockRealtimeChannel(
  options: RealtimeChannelOptions = {}
): MockRealtimeChannel
⋮----
// Setup method chaining for `on`
⋮----
// Setup `subscribe` method
⋮----
// Setup `unsubscribe` method
⋮----
/**
 * Options for creating a mock Realtime client.
 */
export interface RealtimeClientOptions {
  channels?: MockRealtimeChannel[];
}
⋮----
/**
 * Creates a mock RealtimeClient.
 *
 * @param options - Client options
 * @returns Mock RealtimeClient
 */
export function createMockRealtimeClient(
  options: RealtimeClientOptions = {}
): MockRealtimeClient
⋮----
/**
 * Options for creating a mock Realtime subscription.
 */
export interface RealtimeSubscriptionOptions {
  channelName?: string;
  initialState?: RealtimeChannelStates;
}
⋮----
/**
 * Creates a mock Realtime subscription.
 *
 * @param options - Subscription options
 * @returns Mock subscription with channel
 */
export function createMockRealtimeSubscription(
  options: RealtimeSubscriptionOptions = {}
):
⋮----
// Call the mock unsubscribe function
````

## File: src/test/helpers/env.ts
````typescript
/**
 * @fileoverview Test helpers for stubbing environment variables and controlling module reloads.
 */
⋮----
import { vi } from "vitest";
⋮----
/**
 * Disables Upstash rate limiting by stubbing empty environment values.
 */
export function stubRateLimitDisabled(): void
⋮----
// Empty strings prevent ratelimiter construction in route modules
⋮----
// Provide minimal Supabase env to satisfy server env validation in routes
⋮----
/**
 * Enables Upstash rate limiting by stubbing placeholder environment values.
 */
export function stubRateLimitEnabled(): void
⋮----
// Provide minimal Supabase env to satisfy server env validation in routes
⋮----
/**
 * Resets modules to force module-scope code to re-run and then imports a path.
 *
 * @param path - Module path to import after resetting modules.
 * @returns Promise resolving to the imported module.
 */
export async function resetAndImport<T = unknown>(path: string): Promise<T>
⋮----
/**
 * Best-effort unstubbing of all environment variables for older/newer Vitest versions.
 */
export function unstubAllEnvs(): void
⋮----
// no-op on older versions
````

## File: src/test/helpers/make-request.ts
````typescript
/**
 * @fileoverview Shared test helper for creating minimal NextRequest mocks.
 *
 * Use this helper when testing route handlers that only need to access
 * request headers. For tests requiring full NextRequest functionality,
 * consider a more complete mock or integration tests.
 */
⋮----
import type { NextRequest } from "next/server";
import { unsafeCast } from "./unsafe-cast";
⋮----
/**
 * Creates a minimal NextRequest mock with only headers populated.
 *
 * @param headers - Optional headers to include in the mock request.
 * @returns A minimal NextRequest mock suitable for testing header-only access.
 *
 * @example
 * ```typescript
 * const req = makeRequest({ "x-real-ip": "192.168.1.1" });
 * expect(getClientIpFromHeaders(req)).toBe("192.168.1.1");
 * ```
 *
 * @internal Only use where headers are the sole accessed property.
 */
export function makeRequest(headers: HeadersInit =
````

## File: src/test/helpers/route.ts
````typescript
/**
 * @fileoverview Test helpers for Next.js Route Handlers.
 * Provides utilities to create mock requests with proper cookies/headers context
 * for testing route handlers that use `cookies()` from `next/headers`.
 */
⋮----
import {
  type ReadonlyRequestCookies,
  RequestCookiesAdapter,
} from "next/dist/server/web/spec-extension/adapters/request-cookies";
import { RequestCookies } from "next/dist/server/web/spec-extension/cookies";
import { NextRequest } from "next/server";
⋮----
/**
 * Creates a mock NextRequest with cookies and headers for testing.
 *
 * @param options Request configuration options.
 * @returns A NextRequest-like object suitable for route handler tests.
 */
export function createMockNextRequest(options: {
  body?: unknown;
  cookies?: Record<string, string>;
  headers?: Record<string, string>;
  method?: string;
  searchParams?: Record<string, string>;
  url?: string;
}): NextRequest
⋮----
// Build URL with search params if provided
⋮----
// Build cookie header string
⋮----
// Create headers with cookies
⋮----
// Create request with body if provided
type NextRequestInit = NonNullable<ConstructorParameters<typeof NextRequest>[1]>;
⋮----
/**
 * Mock implementation of Next.js cookies() that returns a ReadonlyRequestCookies
 * from the provided cookie map.
 *
 * This should be used with vi.mock() to replace the real cookies() function
 * in route handler tests.
 *
 * @param cookieMap Map of cookie name to value.
 * @returns Mock ReadonlyRequestCookies instance.
 */
export function createMockCookies(
  cookieMap: Record<string, string> = {}
): ReadonlyRequestCookies
⋮----
/**
 * Creates a setup function for mocking `next/headers` cookies() in route handler tests.
 *
 * Use this pattern in your test file:
 * ```ts
 * import { vi } from "vitest";
 * import { createMockCookies } from "@/test/helpers/route";
 *
 * vi.mock("next/headers", () => ({
 *   cookies: vi.fn(() => Promise.resolve(createMockCookies({ "sb-access-token": "test-token" }))),
 * }));
 * ```
 *
 * @param cookieMap Map of cookie name to value.
 * @returns Mock ReadonlyRequestCookies instance.
 */
export function getMockCookiesForTest(cookieMap: Record<string, string> =
⋮----
/**
 * Create a Next.js route params context matching app router handler signature.
 *
 * @param params Route params key/value map.
 * @returns Context with params promise.
 */
export function createRouteParamsContext(params: Record<string, string> =
⋮----
/**
 * Helper to run a route handler function with proper request context.
 *
 * @param handler Route handler function (POST, GET, etc.).
 * @param request Mock NextRequest.
 * @param context Route params context (defaults to empty params).
 * @returns Response from the handler.
 */
export function runRouteHandler(
  handler: (
    req: NextRequest,
    context: { params: Promise<Record<string, string>> }
  ) => Promise<Response>,
  request: NextRequest,
  context: { params: Promise<Record<string, string>> } = createRouteParamsContext()
): Promise<Response>
````

## File: src/test/helpers/store.ts
````typescript
/**
 * @fileoverview Centralized store test helpers.
 *
 * Provides reusable utilities for testing Zustand stores:
 * - Timeout/timer mocking for deterministic async flows
 * - Generic store reset helpers
 * - Store state waiting utilities
 */
⋮----
import { act } from "@testing-library/react";
import { vi } from "vitest";
⋮----
/**
 * Mock setTimeout to execute immediately in tests.
 * Returns cleanup function.
 *
 * @returns Object with mockRestore function
 */
export function setupTimeoutMock():
⋮----
/**
 * Generic store reset helper.
 * Usage: resetStore(useMyStore, { field1: value1, ... })
 *
 * @param useStore - Zustand store hook with setState method
 * @param initialState - Partial state to reset to
 */
export function resetStore<T extends object>(
  useStore: { setState: (state: Partial<T>) => void },
  initialState: Partial<T>
): void
⋮----
/**
 * Wait for store state to match condition.
 * Usage: await waitForStoreState(useMyStore, state => state.isLoading === false)
 *
 * @param useStore - Zustand store hook with getState method
 * @param condition - Function that returns true when condition is met
 * @param timeout - Maximum wait time in milliseconds (default: 5000)
 * @returns Promise that resolves when condition is met
 */
export async function waitForStoreState<T>(
  useStore: { getState: () => T },
  condition: (state: T) => boolean,
  timeout = 5000
): Promise<void>
⋮----
/**
 * Sets up beforeEach and afterEach hooks for store tests.
 * Includes timeout mocking and store reset.
 *
 * @param resetFn - Function to reset store state
 * @returns Cleanup function (can be called manually if needed)
 */
export function setupStoreTests(_resetFn: () => void): () => void
⋮----
// Note: This function should be called in a beforeEach/afterEach context
// For Vitest, import beforeEach/afterEach from vitest and call:
// beforeEach(() => { timeoutSpy = setupTimeoutMock(); resetFn(); });
// afterEach(() => { timeoutSpy?.mockRestore(); });
⋮----
// Return cleanup for manual use if needed
⋮----
// Cleanup handled by caller
````

## File: src/test/helpers/trip-store.ts
````typescript
/**
 * @fileoverview In-memory Supabase client mock for Trip store tests.
 */
⋮----
import { randomInt, randomUUID } from "node:crypto";
import { vi } from "vitest";
⋮----
type TripTableName = "trips";
⋮----
interface TripRow {
  id: number;
  // biome-ignore lint/style/useNamingConvention: Database column names use snake_case
  uuid_id: string;
  // biome-ignore lint/style/useNamingConvention: Database column names use snake_case
  user_id: string;
  title: string;
  name: string;
  description: string;
  // biome-ignore lint/style/useNamingConvention: Database column names use snake_case
  start_date: string | null;
  // biome-ignore lint/style/useNamingConvention: Database column names use snake_case
  end_date: string | null;
  destination: string | null;
  budget: number | null;
  currency: string;
  // biome-ignore lint/style/useNamingConvention: Database column names use snake_case
  spent_amount: number;
  visibility: "private" | "public";
  tags: string[];
  preferences: Record<string, unknown>;
  status: string;
  // biome-ignore lint/style/useNamingConvention: Database column names use snake_case
  budget_breakdown: Record<string, unknown> | null;
  // biome-ignore lint/style/useNamingConvention: Database column names use snake_case
  created_at: string;
  // biome-ignore lint/style/useNamingConvention: Database column names use snake_case
  updated_at: string;
}
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Database column names use snake_case
⋮----
type TripInsert = Partial<TripRow> & {
  title?: string;
  startDate?: string;
  endDate?: string;
  currency?: string;
  budget?: number;
  description?: string;
  destinations?: unknown;
  visibility?: "private" | "shared" | "public";
};
⋮----
interface TripFilter {
  column: keyof TripRow;
  value: TripRow[keyof TripRow] | null;
}
⋮----
const TO_TRIP_ROW = (input: TripInsert): TripRow =>
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase row columns use snake_case.
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase row columns use snake_case.
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase row columns use snake_case.
⋮----
name: input.title ?? "Untitled Trip", // Database uses 'name', frontend uses 'title'
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase row columns use snake_case.
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase row columns use snake_case.
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase row columns use snake_case.
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase row columns use snake_case.
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase row columns use snake_case.
⋮----
const APPLY_FILTERS = (rows: TripRow[], filters: TripFilter[]): TripRow[]
⋮----
class TripQueryBuilder
⋮----
constructor(private readonly table: TripTableName)
⋮----
select(): this
⋮----
insert(rows: TripInsert[]): this
⋮----
update(patch: Partial<TripRow>): this
⋮----
delete(): this
⋮----
eq(column: keyof TripRow, value: TripRow[keyof TripRow] | null): this
⋮----
order(): this
⋮----
range(): this
⋮----
single()
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase row columns use snake_case.
⋮----
maybeSingle()
⋮----
/**
 * Create a Supabase client mock tailored for trip store tests.
 * @returns Minimal Supabase-like mock with trip table helpers.
 */
export const createTripStoreMockClient = () => (
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase session payload fields use snake_case.
⋮----
export type TripStoreMockClient = ReturnType<typeof createTripStoreMockClient>;
⋮----
/** Reset the shared trip data between tests. */
export const resetTripStoreMockData = () =>
⋮----
/** Pre-populate the trip table with deterministic entries. */
export const populateTripStoreMockData = (rows: TripRow[]): void =>
````

## File: src/test/helpers/unsafe-cast.ts
````typescript
/**
 * @fileoverview Test-only unsafe type coercion helper for complex SDK mocks.
 *
 * Prefer real implementations or `satisfies` where practical. Use this when a
 * third-party type is too large to model for unit tests.
 */
⋮----
export function unsafeCast<T>(value: unknown): T
````

## File: src/test/mocks/observers.ts
````typescript
/**
 * @fileoverview Observer API mocks (ResizeObserver, IntersectionObserver) for tests.
 * Use these instead of global mocks to improve test boot time.
 *
 * Usage:
 *   import { createMockResizeObserver, installMockObservers } from "@/test/mocks/observers";
 *
 *   it("should observe element resize", () => {
 *     const observer = createMockResizeObserver();
 *     observer.observe(element);
 *     expect(observer.observe).toHaveBeenCalledWith(element);
 *   });
 */
⋮----
import { vi } from "vitest";
⋮----
/**
 * Creates a mock ResizeObserver with spy functions.
 *
 * @param callback - Optional callback to invoke on observe
 * @returns A ResizeObserver-compatible mock
 */
export const createMockResizeObserver = (
  callback?: ResizeObserverCallback
): ResizeObserver =>
⋮----
class MockResizeObserver implements ResizeObserver
⋮----
/**
 * Creates a mock IntersectionObserver with spy functions.
 *
 * @param callback - Optional callback to invoke on observe
 * @param options - Optional IntersectionObserver options
 * @returns An IntersectionObserver-compatible mock
 */
export const createMockIntersectionObserver = (
  callback?: IntersectionObserverCallback,
  options?: IntersectionObserverInit
): IntersectionObserver =>
⋮----
class MockIntersectionObserver implements IntersectionObserver
⋮----
/**
 * Installs mock observers on the global scope for tests.
 * Use sparingly - prefer createMock* functions for better isolation.
 *
 * @example
 * beforeEach(() => {
 *   installMockObservers();
 * });
 */
export const installMockObservers = (): void =>
⋮----
class MockGlobalResizeObserver implements ResizeObserver
⋮----
constructor(private readonly callback: ResizeObserverCallback = () => undefined)
⋮----
class MockGlobalIntersectionObserver implements IntersectionObserver
⋮----
constructor(
      private readonly callback: IntersectionObserverCallback = () => undefined,
      options?: IntersectionObserverInit
)
````

## File: src/test/mocks/supabase.ts
````typescript
/**
 * @fileoverview Canonical Supabase mock factory for tests.
 *
 * Consolidates all Supabase mock implementations into a single source of truth.
 * Supports both client-side and server-side Supabase mocks with rich auth capabilities
 * and optional insert capture for testing.
 */
⋮----
import type {
  Session,
  Subscription,
  SupabaseClient,
  User,
} from "@supabase/supabase-js";
import type { MockInstance } from "vitest";
import { vi } from "vitest";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { unsafeCast } from "@/test/helpers/unsafe-cast";
⋮----
/** Generic record type for unknown database row structures. */
type UnknownRecord = Record<string, unknown>;
⋮----
/** Type alias for Supabase auth client methods. */
type AuthClient = SupabaseClient<UnknownRecord>["auth"];
⋮----
/** Supported authentication methods that can be mocked. */
type SupportedAuthMethod =
  | "getSession"
  | "onAuthStateChange"
  | "signUp"
  | "signInWithPassword"
  | "signOut"
  | "resetPasswordForEmail"
  | "updateUser"
  | "getUser"
  | "signInWithOAuth"
  | "refreshSession";
⋮----
/**
 * Mock type that combines Vitest MockInstance with the original function type.
 * This allows mocks to be used as both spies and the original function signature.
 */
type AuthMethodMock<T extends (...args: never[]) => unknown> = MockInstance<T> & T;
⋮----
/**
 * Type definition for a complete Supabase auth client mock.
 * All supported auth methods are mocked with their original signatures.
 */
export type SupabaseAuthMock = {
  [K in SupportedAuthMethod]: AuthMethodMock<AuthClient[K]>;
};
⋮----
/**
 * Configuration for Supabase mock factory with insert capture support.
 */
export interface SupabaseMockConfig {
  /**
   * Array to capture insert payloads.
   * All insert operations will push their payloads to this array.
   */
  insertCapture?: unknown[];

  /**
   * Result to return from select queries.
   * Supports async single() queries that return { data, error }.
   */
  selectResult?: {
    data: unknown;
    error: unknown;
  };

  /**
   * Optional user to return from auth.getUser().
   */
  user?: User | null;
}
⋮----
/**
   * Array to capture insert payloads.
   * All insert operations will push their payloads to this array.
   */
⋮----
/**
   * Result to return from select queries.
   * Supports async single() queries that return { data, error }.
   */
⋮----
/**
   * Optional user to return from auth.getUser().
   */
⋮----
/**
 * Creates a mocked function that combines Vitest MockInstance with the original type.
 */
const CREATE_MOCK_FN = <T extends (...args: never[]) => unknown>(
  implementation: T
): AuthMethodMock<T>
⋮----
/**
 * Creates a mock User object with default test values.
 */
const CREATE_MOCK_USER = (): User
⋮----
/**
 * Creates a mock Session object for a given user.
 */
const CREATE_MOCK_SESSION = (user: User): Session
⋮----
/**
 * Creates a mock Subscription object with a callback function.
 */
const CREATE_MOCK_SUBSCRIPTION = (
  callback: Subscription["callback"]
): Subscription => (
⋮----
/**
 * Creates a complete Supabase auth client mock with all supported methods.
 * Each auth method returns sensible default values for testing purposes.
 *
 * @param user Optional user to return from getUser().
 * @returns A fully mocked Supabase auth client with type-safe method signatures
 */
export const createMockSupabaseAuthClient = (user?: User | null): SupabaseAuthMock =>
⋮----
/**
 * Mock implementation of Supabase's PostgrestFilterBuilder for testing.
 * Provides chainable query methods that return mock data.
 */
class MockQueryBuilder<T, S = T>
⋮----
/** Mock data returned by single() and maybeSingle() methods. */
⋮----
/** Mock error returned by query methods. */
⋮----
/** Optional insert capture array. */
⋮----
/** Mock select method - chains to allow further filtering. */
⋮----
/** Mock insert method - updates singleData with transformed input and captures payloads. */
⋮----
/** Mock update method - chains to allow further filtering. */
⋮----
/** Mock delete method - chains to allow further filtering. */
⋮----
/** Mock eq method - chains to allow further filtering. */
⋮----
/** Mock gte method - chains to allow further filtering. */
⋮----
/** Mock lte method - chains to allow further filtering. */
⋮----
/** Mock order method - chains to allow further filtering. */
⋮----
/** Mock limit method - chains to allow further filtering. */
⋮----
/** Mock range method - chains to allow further filtering. */
⋮----
/** Mock single method - returns single data result. */
⋮----
/** Mock maybeSingle method - returns single data result (nullable). */
⋮----
/**
   * Creates a new MockQueryBuilder instance.
   *
   * @param initialData Initial data for the mock
   * @param toSingle Function to transform array data to single result
   * @param error Optional error to return from queries
   * @param insertCapture Optional array to capture insert payloads
   */
constructor(
    initialData: T,
    readonly toSingle: (data: T) => S,
    error: unknown = null,
    insertCapture?: unknown[]
)
⋮----
/**
 * Creates a complete Supabase client mock with auth, database, and storage methods.
 * Useful for testing components that interact with the full Supabase API.
 *
 * @param config Optional configuration for insert capture and select results
 * @returns A fully mocked Supabase client with auth, database, and storage methods
 */
export const createMockSupabaseClient = (
  config?: SupabaseMockConfig
): SupabaseClient<UnknownRecord> =>
⋮----
// Override single() if selectResult is provided
⋮----
// Override single method using Object.defineProperty to bypass readonly
⋮----
/**
 * Creates a mock Supabase client factory for server-side testing.
 *
 * Returns a function that creates a mock TypedServerSupabase client with:
 * - `from(table)` method that returns insert/select builders
 * - `insert()` that captures payloads to insertCapture array (if provided)
 * - `select()` that returns a chainable query builder ending in single()
 *
 * @param config Configuration for insert capture and select results
 * @returns Async function that returns a mock TypedServerSupabase client
 *
 * @example
 * ```typescript
 * const insertCapture: unknown[] = [];
 * const supabase = createMockSupabaseFactory({
 *   insertCapture,
 *   selectResult: { data: { id: 1, user_id: "user-1" }, error: null }
 * });
 *
 * const client = await supabase();
 * const result = await client.from("trips").select().eq("id", 1).eq("user_id", "user-1").single();
 * // result.data === { id: 1, user_id: "user-1" }
 * // insertCapture contains all insert payloads
 * ```
 */
export function createMockSupabaseFactory(
  config: SupabaseMockConfig
): () => Promise<TypedServerSupabase>
⋮----
/**
 * Sets up Supabase client mocks for a test file using vi.mock().
 * Call this at the top level of test files that use Supabase.
 *
 * @example
 * ```ts
 * import { setupSupabaseMocks } from "@/test/mocks/supabase";
 * setupSupabaseMocks();
 * ```
 */
export function setupSupabaseMocks(): void
````

## File: src/test/setup-jsdom.ts
````typescript
/**
 * @fileoverview Vitest setup for JSDOM test projects (React/UI).
 *
 * This file layers on top of `src/test/setup-node.ts` and adds DOM mocks,
 * Next.js shims, and React Testing Library cleanup.
 */
⋮----
import { cleanup } from "@testing-library/react";
import React from "react";
import { afterAll, afterEach, vi } from "vitest";
import { resetTestQueryClient } from "./helpers/query-client";
⋮----
// Minimal toast mock (used by many components)
type UnknownRecord = Record<string, unknown>;
⋮----
// Zustand middleware mocks (used by stores)
⋮----
// React Query helpers live in @/test/helpers/query; Supabase helpers in @/test/mocks/supabase.
// Import per test as needed instead of global mocks.
⋮----
// Simplify Next/Image for tests to avoid overhead and ESM/DOM quirks
⋮----
/**
 * Create a mock MediaQueryList implementation for responsive tests.
 * @param defaultMatches Whether the media query should report a match by default.
 * @returns A function producing MediaQueryList mocks.
 */
const CREATE_MATCH_MEDIA_MOCK =
(defaultMatches = false)
⋮----
/**
 * Build a mock Storage implementation backed by a Map.
 * @returns A Storage-compatible mock object.
 */
const CREATE_MOCK_STORAGE = (): Storage =>
⋮----
get length()
⋮----
class MockResizeObserver implements ResizeObserver
⋮----
observe(): void
⋮----
/* noop */
⋮----
unobserve(): void
⋮----
/* noop */
⋮----
disconnect(): void
⋮----
/* noop */
⋮----
class MockIntersectionObserver implements IntersectionObserver
⋮----
/* noop */
⋮----
/* noop */
⋮----
/* noop */
⋮----
takeRecords(): IntersectionObserverEntry[]
⋮----
// Suppress React act() warnings during test runs to prevent console flooding.
````

## File: src/test/setup-node.ts
````typescript
/**
 * @fileoverview Vitest setup for Node.js test projects.
 *
 * Keep this file lightweight: it runs before every test file. Prefer per-test
 * helpers for feature-specific mocks. DOM/React-specific setup lives in
 * `src/test/setup-jsdom.ts`.
 */
⋮----
import {
  ReadableStream as NodeReadableStream,
  TransformStream as NodeTransformStream,
  WritableStream as NodeWritableStream,
} from "node:stream/web";
import { afterAll, afterEach, beforeAll, vi } from "vitest";
import { server } from "./msw/server";
⋮----
// Provide sane defaults for client-visible env used in some client components.
⋮----
// Provide Web Streams polyfills for environments missing them (used by
// eventsource-parser / AI SDK transport in tests).
⋮----
// Start MSW server to intercept HTTP requests.
⋮----
const summarize = (items: unknown[] | undefined) =>
⋮----
? // biome-ignore lint/suspicious/noExplicitAny: debug-only safe cast
⋮----
// Only restore timers if they were explicitly enabled in the test.
// Tests that need fake timers should use withFakeTimers() utility.
````

## File: src/proxy.ts
````typescript
/**
 * @fileoverview Next.js proxy that refreshes the Supabase auth session and syncs cookies.
 */
⋮----
import { type NextRequest, NextResponse } from "next/server";
import { createMiddlewareSupabase, getCurrentUser } from "@/lib/supabase/factory";
⋮----
/**
 * Proxy matcher configuration excluding static assets.
 */
⋮----
/**
 * Refreshes the Supabase auth session and propagates updated cookies.
 */
export async function proxy(request: NextRequest)
⋮----
// Create Supabase client for Node runtime with custom cookie handling
⋮----
getAll()
setAll(cookiesToSet)
⋮----
// Refresh session and sync cookies for React Server Components
// Using unified getCurrentUser to eliminate duplicate calls
````

## File: vitest.config.ts
````typescript
/**
 * @fileoverview Vitest configuration optimized for <1 minute test runtime.
 * Key optimizations:
 * - Extends Vitest default excludes (critical for fast discovery)
 * - Uses forks for deterministic worker teardown (avoids Node fetch/threads hangs)
 * - Enables dependency optimization for client only
 * - Disables CSS processing globally
 */
⋮----
import os from "node:os";
import path from "node:path";
import react from "@vitejs/plugin-react";
import { configDefaults, defineConfig } from "vitest/config";
⋮----
// Component tests (jsdom) use more memory - limit concurrency
⋮----
// Core settings
⋮----
// CRITICAL: Extend defaults, do not replace
⋮----
// Disable CSS processing globally
⋮----
// Timeouts (balanced for speed and reliability)
⋮----
// Prefer forks for compatibility and reliable shutdown across Node + jsdom.
⋮----
// Worker limit is pool-agnostic; keep this conservative for Node projects.
// JSDOM forks are memory-heavy, so that project overrides the worker cap.
⋮----
// Fixed dependency optimization
⋮----
// Reporters (blob only for sharding)
⋮----
// Global thresholds - set to current actual coverage + small buffer
// Actual: Statements ~49%, Branches ~36%, Functions ~55%, Lines ~49%
// Will be raised incrementally as coverage improves
⋮----
// Projects: schemas, integration, api, component, unit
⋮----
// Prevent overlap with component/ui tests and API route tests (these belong to other projects).
⋮----
// Forked workers are memory-heavy; keep this capped regardless of CPU count.
````

## File: src/ai/agents/instructions.ts
````typescript
/**
 * @fileoverview Instruction normalization helpers for AI agents.
 */
⋮----
import type { SystemModelMessage } from "ai";
⋮----
/** Type guard for message parts that may contain text or content strings. */
function isTextPart(part: unknown): part is
⋮----
/** Extracts text from the content of a system model message. */
export const extractTextFromContent = (
  content: SystemModelMessage["content"]
): string =>
⋮----
/** Normalizes the instructions for a system model message. */
export const normalizeInstructions = (input: string | SystemModelMessage): string =>
````

## File: src/ai/tools/schemas/activities.ts
````typescript
/**
 * @fileoverview Activity tool model output schemas.
 */
⋮----
import { z } from "zod";
⋮----
// ===== MODEL OUTPUT SCHEMAS =====
⋮----
/** Activity entry for model consumption. Fields match source activitySchema requirements. */
⋮----
/** Activity search result metadata for model consumption. */
⋮----
/** Activity search result output schema for model consumption. */
⋮----
export type ActivityModelOutput = z.infer<typeof activityModelOutputSchema>;
````

## File: src/ai/tools/server/weather.ts
````typescript
/**
 * @fileoverview OpenWeatherMap-backed weather tool with caching, retries, and standardized errors.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import {
  getCurrentWeatherInputSchema,
  WEATHER_RESULT_SCHEMA,
} from "@ai/tools/schemas/weather";
import type { z } from "zod";
import { hashInputForCache } from "@/lib/cache/hash";
import { canonicalizeParamsForCache } from "@/lib/cache/keys";
import { fetchWithRetry } from "@/lib/http/retry";
import { WEATHER_CACHE_TTL_SECONDS } from "./constants";
⋮----
/**
 * Execute weather query via HTTP GET to OpenWeatherMap API.
 *
 * Supports city name (q), coordinates (lat/lon), or ZIP code (zip).
 * Uses the standard Current Weather Data API endpoint.
 *
 * @param params - The weather query parameters (city, coordinates, or zip; units, lang).
 * @returns Promise resolving to weather data and provider identifier ("http_get").
 * @throws {Error} Error with `code` property indicating failure reason:
 *   - "weather_not_configured": No API key configured
 *   - "weather_timeout": Request timed out
 *   - "weather_failed": Network or API error
 *   - "weather_rate_limited": Rate limit exceeded (429)
 *   - "weather_unauthorized": Authentication failed (401)
 *   - "weather_not_found": City/location not found (404)
 */
async function executeWeatherQuery(
  params: Record<string, unknown>
): Promise<
⋮----
// Map generic fetch errors to domain-specific codes
⋮----
/**
 * Get current weather tool.
 *
 * Retrieves current weather conditions for a specified location (city,
 * coordinates, or ZIP code) using OpenWeatherMap API via direct HTTP GET.
 * Results are cached for performance (10 minute TTL). Returns comprehensive
 * weather data including temperature (with min/max), humidity, wind (with
 * gusts), pressure, visibility, clouds, precipitation (rain/snow), and
 * sunrise/sunset times. Includes weather icon ID for UI display.
 *
 * @returns WeatherResult with current conditions, metadata, and provider information.
 * @throws {Error} Error with `code` property indicating failure reason:
 *   - "weather_not_configured": No API key configured
 *   - "weather_timeout": Request timed out
 *   - "weather_failed": Network or API error
 *   - "weather_rate_limited": Rate limit exceeded (429)
 *   - "weather_unauthorized": Authentication failed (401)
 *   - "weather_not_found": City/location not found (404)
 */
type GetCurrentWeatherInput = z.infer<typeof getCurrentWeatherInputSchema>;
type WeatherResult = z.infer<typeof WEATHER_RESULT_SCHEMA>;
````

## File: src/ai/tools/server/web-search.ts
````typescript
/**
 * @fileoverview Web search tool backed by Firecrawl with caching, rate limiting, and telemetry guardrails.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import {
  WEB_SEARCH_OUTPUT_SCHEMA,
  webSearchInputSchema,
} from "@ai/tools/schemas/web-search";
import {
  createToolError,
  isToolError,
  TOOL_ERROR_CODES,
} from "@ai/tools/server/errors";
import { normalizeWebSearchResults } from "@ai/tools/server/web-search-normalize";
import type { ToolCallOptions } from "ai";
import { z } from "zod";
import { hashInputForCache } from "@/lib/cache/hash";
import { canonicalizeParamsForCache } from "@/lib/cache/keys";
import { getServerEnvVar, getServerEnvVarWithFallback } from "@/lib/env/server";
import { fetchWithRetry } from "@/lib/http/retry";
⋮----
type ScrapeOptions = z.infer<typeof scrapeOptionsSchema>;
⋮----
type WebSearchInput = z.infer<typeof webSearchInputSchema>;
type WebSearchResult = z.infer<typeof WEB_SEARCH_OUTPUT_SCHEMA>;
⋮----
/**
   * Simplifies search results for model consumption to reduce token usage.
   * Strips snippets, publishedAt dates, and limits results to top 10.
   */
⋮----
async function runWebSearch(
  params: WebSearchInput,
  _callOptions?: ToolCallOptions
): Promise<WebSearchResult>
⋮----
function resolveFirecrawlApiKey(): string
⋮----
async function handleHttpError(response: Response): Promise<never>
⋮----
function getTimeout(timeoutMs?: number): number
⋮----
function buildCacheKeySuffix(params: WebSearchInput): string
⋮----
function buildRequestBody(params: {
  query: string;
  limit: number;
  sources?: string[];
  categories?: string[];
  tbs?: string;
  location?: string;
  timeoutMs?: number;
  scrapeOptions?: ScrapeOptions;
  region?: string | undefined;
  freshness?: string | undefined;
}): Record<string, unknown>
⋮----
function inferTtlSeconds(query: string): number
````

## File: src/app/api/attachments/files/route.ts
````typescript
/**
 * @fileoverview Attachment files listing endpoint.
 *
 * Queries Supabase directly for attachment metadata with per-user Redis caching.
 * Generates signed URLs for private storage access. See ADR-0058 and SPEC-0036.
 */
⋮----
import type { AttachmentListQuery } from "@schemas/attachments";
import { attachmentListQuerySchema } from "@schemas/attachments";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, requireUserId } from "@/lib/api/route-helpers";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** Cache TTL for attachment listings (2 minutes). */
⋮----
/** Storage bucket name for attachments. */
⋮----
/** Signed URL expiration in seconds (1 hour). */
⋮----
/** Logger for attachments file listing operations. */
⋮----
/**
 * Builds normalized cache key for attachment file listings.
 *
 * Uses sorted parameter names to ensure cache hits regardless of
 * query string ordering (e.g., ?limit=20&offset=0 vs ?offset=0&limit=20).
 *
 * @param userId - Authenticated user ID.
 * @param params - Validated query parameters.
 * @returns Redis cache key with normalized parameters.
 */
function buildCacheKey(userId: string, params: AttachmentListQuery): string
⋮----
/**
 * GET /api/attachments/files
 *
 * Lists user attachment files with pagination support.
 * Response cached per-user in Redis with 2-minute TTL.
 * URLs are signed for secure private bucket access.
 *
 * @param req - Request with optional pagination query params.
 * @returns JSON array of attachment metadata or error.
 */
⋮----
// Parse and validate query parameters
⋮----
// Check cache first (with normalized key)
⋮----
// Build Supabase query - Zod already coerces to numbers
⋮----
// Filter by tripId if provided (Zod coercion ensures it's a number)
⋮----
// Filter by chatMessageId if provided (Zod coercion ensures it's a number)
⋮----
// Generate signed URLs for all file paths in a batch
⋮----
// Transform to response format, filtering out items without valid URLs
⋮----
// Skip items without valid signed URLs (schema requires url to be non-null)
⋮----
// Log if items were filtered due to missing URLs
⋮----
// Cache successful response
````

## File: src/app/api/embeddings/route.ts
````typescript
/**
 * @fileoverview API route that generates and optionally persists text embeddings.
 */
⋮----
import { openai } from "@ai-sdk/openai";
import {
  embeddingsRequestSchema,
  type PersistableEmbeddingsProperty,
  persistableEmbeddingsPropertySchema,
} from "@schemas/embeddings";
import { embed } from "ai";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, parseJsonBody, validateSchema } from "@/lib/api/route-helpers";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
import { toPgvector } from "@/lib/rag/pgvector";
import { isValidInternalKey } from "@/lib/security/internal-key";
import { createAdminSupabase } from "@/lib/supabase/admin";
import type { InsertTables } from "@/lib/supabase/database.types";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/**
 * Normalizes source string to "hotel" or "vrbo".
 *
 * @param source - Source string to normalize.
 * @returns Normalized source type.
 */
function normalizeSource(source?: string): "hotel" | "vrbo"
⋮----
/**
 * Normalizes amenities array or string to comma-separated string.
 *
 * @param amenities - Amenities array or string.
 * @returns Normalized amenities string or null.
 */
function normalizeAmenities(amenities?: string[] | string): string | null
⋮----
/**
 * Persists accommodation embedding to Supabase.
 *
 * @param property - Property data with required ID.
 * @param embedding - Embedding vector (1536 dimensions).
 * @throws Error if database operation fails.
 */
async function persistAccommodationEmbedding(
  property: PersistableEmbeddingsProperty,
  embedding: number[]
): Promise<void>
⋮----
/**
 * Generates text embeddings using OpenAI text-embedding-3-small model.
 *
 * @param req - Request containing text or property data.
 * @returns Response with embedding vector and metadata, or error.
 */
⋮----
// Generate embedding via AI SDK v6 using OpenAI text-embedding-3-small (1536-d)
````

## File: src/app/api/jobs/memory-sync/route.ts
````typescript
/**
 * @fileoverview QStash job route that validates and persists memory sync payloads.
 */
⋮----
import { jsonSchema } from "@schemas/supabase";
import { memorySyncJobSchema } from "@schemas/webhooks";
import { NextResponse } from "next/server";
import { errorResponse, validateSchema } from "@/lib/api/route-helpers";
import { tryReserveKey } from "@/lib/idempotency/redis";
import { getQstashReceiver, verifyQstashRequest } from "@/lib/qstash/receiver";
import { createAdminSupabase } from "@/lib/supabase/admin";
import type { Database } from "@/lib/supabase/database.types";
import { hashTelemetryIdentifier } from "@/lib/telemetry/identifiers";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Processes queued memory sync jobs with signature verification and deduplication.
 *
 * @param req - The incoming job request.
 * @return Response indicating success or error.
 */
export async function POST(req: Request)
⋮----
// De-duplicate at worker level to avoid double-processing on retries
⋮----
ttlSeconds: 600, // 10min TTL
⋮----
/**
 * Process a memory sync job by storing conversation memories and updating context.
 *
 * @param payload - Validated memory sync payload.
 * @return Processing result with counts and status.
 */
async function processMemorySync(payload: {
  sessionId: string;
  userId: string;
  syncType: "full" | "incremental" | "conversation";
  conversationMessages?: Array<{
    content: string;
    role: "user" | "assistant" | "system";
    timestamp: string;
    metadata?: Record<string, unknown>;
  }>;
})
⋮----
// Verify user has access to this session
⋮----
// Process conversation messages if provided
⋮----
const messagesToStore = payload.conversationMessages.slice(0, 50); // Limit batch size
⋮----
// Ensure memory session exists
⋮----
// Create session if it doesn't exist
⋮----
// Store conversation turns
⋮----
// Convert string content to JSONB format: { text: string }
⋮----
// Update session last_synced_at
⋮----
// Update memory context summary (simplified - could be enhanced with AI)
````

## File: src/app/api/jobs/notify-collaborators/route.ts
````typescript
/**
 * @fileoverview Durable job handler for sending collaborator notifications via QStash.
 */
⋮----
import { notifyJobSchema } from "@schemas/webhooks";
import { NextResponse } from "next/server";
import { errorResponse, validateSchema } from "@/lib/api/route-helpers";
import { tryReserveKey } from "@/lib/idempotency/redis";
import { sendCollaboratorNotifications } from "@/lib/notifications/collaborators";
import { pushToDLQ } from "@/lib/qstash/dlq";
import { getQstashReceiver, verifyQstashRequest } from "@/lib/qstash/receiver";
import { getTrustedRateLimitIdentifierFromHeaders } from "@/lib/ratelimit/identifier";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/** Max retries configured for QStash (per ADR-0048) */
⋮----
/**
 * Extract retry attempt information from QStash headers.
 *
 * @param req - Incoming request
 * @return Object with current attempt and max retries
 */
function getRetryInfo(req: Request):
⋮----
/**
 * Processes queued collaborator notification jobs with signature verification.
 *
 * @param req - The incoming job request.
 * @return Response indicating success or error.
 */
export async function POST(req: Request)
⋮----
// Store raw job payload for DLQ on failure
⋮----
jobPayload = json; // Store parsed form for DLQ/validation
⋮----
// De-duplicate at worker level as well to avoid double-send on retries
⋮----
// Check if this is the final retry attempt
⋮----
// Push to DLQ on final failure per ADR-0048
````

## File: src/app/api/keys/_rate-limiter.ts
````typescript
/**
 * @fileoverview Shared request-scoped rate limiter builder for BYOK key routes.
 */
⋮----
import { Ratelimit } from "@upstash/ratelimit";
import { getServerEnvVar, getServerEnvVarWithFallback } from "@/lib/env/server";
import { getRedis } from "@/lib/redis";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
⋮----
export type KeyRateLimiter = InstanceType<typeof Ratelimit>;
export type RateLimitResult = Awaited<ReturnType<KeyRateLimiter["limit"]>>;
⋮----
/**
 * Error thrown when rate limiter configuration is missing in production.
 */
export class RateLimiterConfigurationError extends Error
⋮----
constructor(message: string)
⋮----
/**
 * Builds a new Upstash rate limiter instance per request.
 *
 * Reading environment variables inside this function avoids module-scope state
 * so that tests and serverless runtimes stay isolated.
 *
 * In production, missing Upstash configuration causes a fatal error to enforce
 * fail-closed behavior. In development/test environments, returns undefined to
 * allow graceful degradation.
 *
 * @returns Rate limiter instance or undefined when Upstash is not configured
 *   (development/test only).
 * @throws {RateLimiterConfigurationError} When Upstash env vars are missing in
 *   production.
 */
export function buildRateLimiter(): KeyRateLimiter | undefined
````

## File: src/app/api/security/sessions/_handlers.ts
````typescript
/**
 * @fileoverview Security session handlers for terminating sessions.
 */
⋮----
import { NextResponse } from "next/server";
import { errorResponse, notFoundResponse } from "@/lib/api/route-helpers";
import type { TypedAdminSupabase } from "@/lib/supabase/admin";
import { hashTelemetryIdentifier } from "@/lib/telemetry/identifiers";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * Terminates a specific session owned by the user.
 *
 * @param params - The parameters for the terminate session handler.
 * @returns The terminate session response.
 */
export async function terminateSessionHandler(params: {
  adminSupabase: TypedAdminSupabase;
  sessionId: string;
  userId: string;
}): Promise<NextResponse>
````

## File: src/app/api/security/sessions/route.ts
````typescript
/**
 * @fileoverview Route for listing active sessions for the authenticated user.
 */
⋮----
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse, requireUserId } from "@/lib/api/route-helpers";
import { getCurrentSessionId, listActiveSessions } from "@/lib/security/sessions";
import { createAdminSupabase } from "@/lib/supabase/admin";
⋮----
/** Handles GET /api/security/sessions for the authenticated user. */
````

## File: src/app/api/telemetry/ai-demo/route.ts
````typescript
/**
 * @fileoverview Telemetry endpoint for AI demo events.
 */
⋮----
import type { TelemetryAiDemoRequest } from "@schemas/telemetry";
import { telemetryAiDemoRequestSchema } from "@schemas/telemetry";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import type { RouteContext, RouteParamsContext } from "@/lib/api/factory";
import { withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
import { isValidInternalKey } from "@/lib/security/internal-key";
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { hashTelemetryFingerprint } from "@/lib/telemetry/identifiers";
⋮----
/**
 * POST /api/telemetry/ai-demo
 *
 * Emit telemetry alert for AI demo events.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns JSON response with success status
 */
⋮----
export const POST = async (req: NextRequest, routeContext: RouteParamsContext) =>
⋮----
// Return consistent 404 to avoid leaking feature/config state
````

## File: src/app/auth/email/verify/route.ts
````typescript
/**
 * @fileoverview Email verification route handler using Supabase SSR.
 *
 * Accepts a token payload and verifies the user's email via Supabase Auth.
 * This is primarily intended for programmatic verification flows driven by
 * the AuthValidation store.
 */
⋮----
import type { EmailOtpType } from "@supabase/supabase-js";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { parseJsonBody } from "@/lib/api/route-helpers";
import { createServerSupabase } from "@/lib/supabase/server";
import { emitOperationalAlertOncePerWindow } from "@/lib/telemetry/degraded-mode";
import { createServerLogger } from "@/lib/telemetry/logger";
import { isPlainObject } from "@/lib/utils/type-guards";
⋮----
interface VerifyPayload {
  token?: unknown;
}
⋮----
export async function POST(request: NextRequest): Promise<NextResponse>
````

## File: src/app/auth/password/change/route.ts
````typescript
/**
 * @fileoverview Authenticated password change route handler.
 *
 * Allows a logged-in user to change their password using the Supabase SSR
 * client. Validates input and returns JSON responses suitable for the
 * AuthValidation store.
 */
⋮----
import { changePasswordFormSchema } from "@schemas/auth";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { parseJsonBody } from "@/lib/api/route-helpers";
import { requireUser } from "@/lib/auth/server";
import {
  getAuthErrorCode,
  getAuthErrorStatus,
  isMfaRequiredError,
} from "@/lib/auth/supabase-errors";
import { ROUTES } from "@/lib/routes";
import { emitOperationalAlertOncePerWindow } from "@/lib/telemetry/degraded-mode";
import { createServerLogger } from "@/lib/telemetry/logger";
import { isPlainObject } from "@/lib/utils/type-guards";
⋮----
interface ChangePasswordPayload {
  confirmPassword?: unknown;
  currentPassword?: unknown;
  newPassword?: unknown;
}
⋮----
// Password change payloads are tiny; keep a tight limit to reduce DoS surface.
⋮----
export async function POST(request: NextRequest): Promise<NextResponse>
⋮----
// Verify current password by attempting a sign-in with the provided credentials.
⋮----
// Distinguish upstream service errors from validation failures
````

## File: src/components/chat/message-item.tsx
````typescript
/**
 * @fileoverview Chat message renderer for AI/UI messages with safe tool output rendering.
 */
⋮----
import type { UIMessage } from "ai";
import { FileIcon } from "lucide-react";
import { BudgetChart } from "@/components/ai-elements/budget-chart";
import { DestinationCard } from "@/components/ai-elements/destination-card";
import { FlightOfferCard } from "@/components/ai-elements/flight-card";
import { ItineraryTimeline } from "@/components/ai-elements/itinerary-timeline";
import {
  Message,
  MessageAvatar,
  MessageContent,
} from "@/components/ai-elements/message";
import { Reasoning } from "@/components/ai-elements/reasoning";
import { Response } from "@/components/ai-elements/response";
import {
  Source,
  Sources,
  SourcesContent,
  SourcesTrigger,
} from "@/components/ai-elements/sources";
import { StayCard } from "@/components/ai-elements/stay-card";
import { Tool } from "@/components/ai-elements/tool";
import { parseSchemaCard } from "@/lib/ui/parse-schema-card";
import { safeHref } from "@/lib/url/safe-href";
⋮----
type SourceUrlPart = {
  type: "source-url";
  url: string;
  title?: string;
};
⋮----
type WebSearchUiResult = {
  results: Array<{
    url: string;
    title?: string;
    snippet?: string;
    publishedAt?: string;
  }>;
  fromCache?: boolean;
  tookMs?: number;
};
⋮----
function AsRecord(value: unknown): Record<string, unknown> | null
⋮----
// biome-ignore lint/style/useNamingConvention: Type guard helper for discriminated parts
function isSourceUrlPart(value: unknown): value is SourceUrlPart
⋮----
/** Keys that must be redacted from tool output. */
⋮----
/** Allowlist of safe MIME types for data URLs */
⋮----
// biome-ignore lint/style/useNamingConvention: Internal utility function, not a React component
function isValidBase64(value: string): boolean
⋮----
/**
 * Validates and normalizes a MIME type string.
 * Returns the MIME type if it's in the allowlist, otherwise returns a safe default.
 * Only explicit MIME types in SAFE_MIME_TYPES are allowed to prevent XSS vectors.
 */
// biome-ignore lint/style/useNamingConvention: Internal utility function, not a React component
function validateMimeType(mimeType?: string): string
⋮----
// Default to safe fallback for unknown types
⋮----
// biome-ignore lint/style/useNamingConvention: Internal utility function, not a React component
function sanitizeValue(value: unknown, depth: number): unknown
⋮----
/** Sanitize tool output for safe display - redacts sensitive keys and truncates long values. */
// biome-ignore lint/style/useNamingConvention: This is a utility function export, not a React component
export function sanitizeToolOutput(raw: unknown): unknown
⋮----
export interface ChatMessageItemProps {
  /** The message to render */
  message: UIMessage;
  /** When true, indicates the message is currently streaming (enables animation) */
  isStreaming?: boolean;
}
⋮----
/** The message to render */
⋮----
/** When true, indicates the message is currently streaming (enables animation) */
⋮----
// Extract source-url parts for citation display
⋮----
// Only animate the last text part of an assistant message during streaming
⋮----
// Animate Streamdown only for the last text part of assistant messages during streaming
⋮----
// Rendered separately in the Sources section below
⋮----
text=
⋮----
// AI SDK v6 standardized part types: tool-invocation, tool-result
⋮----
// File attachment part (includes images in AI SDK v6)
⋮----
// Render images inline
⋮----
{/* biome-ignore lint/performance/noImgElement: External URLs without known dimensions */}
⋮----
// Render other files as attachment
⋮----
// Fallback for unknown part types
````

## File: src/components/features/dashboard/recent-trips.tsx
````typescript
/**
 * @fileoverview Dashboard widget that renders a list of recently updated trips.
 */
⋮----
import type { UiTrip } from "@schemas/trips";
import { CalendarIcon, ClockIcon, MapPinIcon } from "lucide-react";
import Link from "next/link";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { useTrips } from "@/hooks/use-trips";
import { DateUtils } from "@/lib/dates/unified-date-utils";
⋮----
type Trip = UiTrip;
⋮----
interface RecentTripsProps {
  limit?: number;
  showEmpty?: boolean;
}
⋮----
function TripCardSkeleton()
⋮----
/**
 * Render a single trip card.
 * @param trip - Trip object to render.
 */
function TripCard(
⋮----
/**
   * Format an ISO date string to e.g. "Jun 15, 2024" in UTC to avoid TZ drift.
   */
const formatDate = (dateString?: string) =>
⋮----
/**
   * Build destination summary (e.g., "Paris (+1 more)").
   */
const getDestinationText = () =>
⋮----
/**
   * Compute duration in days from start/end.
   */
const getTripDuration = () =>
⋮----
/**
   * Compute trip status relative to now.
   */
const getTripStatus = () =>
⋮----

⋮----
/**
 * Renders a dashboard widget listing the most recently updated trips.
 *
 * @param props - Component configuration including list limit and whether to
 * show the empty state.
 * @returns Recent trip grid with skeleton fallback.
 */
⋮----
// Extract trips from the response and sort by updatedAt/createdAt, take the most recent ones
````

## File: src/components/providers/query-error-boundary.tsx
````typescript
/**
 * @fileoverview Query error boundary with OTEL-backed telemetry.
 * Refer to docs/development/observability.md for tracing and alerting standards.
 */
⋮----
import { useQueryErrorResetBoundary } from "@tanstack/react-query";
import { AlertTriangleIcon, RefreshCwIcon, WifiOffIcon } from "lucide-react";
import type { ComponentType, ErrorInfo, JSX, ReactNode } from "react";
import { useRef } from "react";
import { ErrorBoundary, type FallbackProps } from "react-error-boundary";
import { Button } from "@/components/ui/button";
import { getErrorMessage, handleApiError } from "@/lib/api/error-types";
import { getSessionId } from "@/lib/client/session";
import { errorService } from "@/lib/error-service";
import { cn, fireAndForget } from "@/lib/utils";
⋮----
type ErrorVariant = "network" | "server" | "auth" | "permission" | "default";
⋮----
/** Metadata extracted from an error for categorization and display. */
interface ErrorMeta {
  variant: ErrorVariant;
  isRetryable: boolean;
  statusCode?: number;
  errorCode?: string;
}
⋮----
/**
 * Props for the error fallback component.
 *
 * @param meta - Error metadata including variant and retryability.
 * @param onRetry - Callback to retry the failed operation.
 */
interface QueryErrorFallbackProps extends FallbackProps {
  meta: ErrorMeta;
  onRetry: () => void;
  loginHref?: string;
}
⋮----
/**
 * Optional async error handler that may be invoked when errors occur.
 *
 * @param error - The error that was caught.
 * @param info - React error info including component stack.
 * @param meta - Resolved error metadata.
 * @returns Promise or void - failures are swallowed to prevent boundary loops.
 */
type OptionalAsyncHandler = (
  error: Error,
  info?: ErrorInfo,
  meta?: ErrorMeta
) => void | Promise<void>;
⋮----
/**
 * Safely invokes an optional async handler, swallowing any errors to prevent
 * recursive boundary failures.
 *
 * @param handler - Optional handler to invoke; no-op if undefined.
 * @param error - Error to pass to the handler.
 * @param info - React error info to pass to the handler.
 * @param meta - Error metadata to pass to the handler.
 */
function SafeInvoke(
  handler: OptionalAsyncHandler | undefined,
  error: Error,
  info: ErrorInfo | undefined,
  meta: ErrorMeta
)
⋮----
// Swallow handler failures to avoid error boundary loops
⋮----
// Swallow handler errors to avoid recursive boundary failures
⋮----
/**
 * Resolves error metadata by normalizing the error and categorizing its variant.
 *
 * @param error - Unknown error value to analyze.
 * @returns Error metadata with variant, retryability, and status/error codes.
 */
function ResolveMeta(error: unknown): ErrorMeta
⋮----
// Use code-based checks since handleApiError always returns ApiError
⋮----
/**
 * Records error telemetry to the active OTEL span.
 * Failures are swallowed to ensure telemetry never breaks the UI.
 *
 * @param error - The error to record.
 * @param info - React error info including component stack.
 * @param meta - Resolved error metadata.
 */
function RecordTelemetry(error: Error, info: ErrorInfo, meta: ErrorMeta)
⋮----
// Telemetry failures must never break the UI
⋮----
/**
 * Default fallback component that renders error UI based on error variant.
 * Displays variant-specific icons, messages, and retry/login actions.
 *
 * @param error - The error that triggered the boundary.
 * @param meta - Resolved error metadata.
 * @param onRetry - Callback to retry the failed operation.
 * @returns Rendered error UI component.
 */
⋮----
className=
⋮----
/**
 * Props for the QueryErrorBoundary component.
 *
 * @param children - React children to wrap with error boundary.
 * @param fallback - Optional custom fallback component; defaults to QueryErrorFallback.
 * @param onError - Optional handler invoked when errors are caught.
 * @param onOperationalAlert - Optional handler for operational alerting; invoked before onError.
 */
⋮----
/**
 * React Query-aware error boundary that records OTEL telemetry and supports
 * optional error handlers.
 *
 * Integrates with React Query's error reset mechanism and provides variant-aware
 * error categorization (network, server, auth, permission, default).
 *
 * @param children - React children to wrap with error boundary.
 * @param fallback - Optional custom fallback component; defaults to QueryErrorFallback.
 * @param onError - Optional handler invoked when errors are caught.
 * @param onOperationalAlert - Optional handler for operational alerting; invoked before onError.
 * @returns ErrorBoundary component wrapping the children.
 */
⋮----
/**
   * Handles boundary errors by emitting telemetry and delegating to injected sinks.
   */
const handleError = (error: Error, info: ErrorInfo) =>
⋮----
const handleReset = () =>
⋮----
/**
 * Props for the InlineQueryError component.
 *
 * @param error - The error to display.
 * @param retry - Optional retry callback; button is shown if provided.
 * @param className - Additional CSS classes to apply.
 */
⋮----
/**
 * Inline, non-boundary rendering for query errors with retry affordance.
 *
 * Use this component to display query errors inline within the UI rather than
 * as a full-page boundary fallback. Automatically categorizes errors and shows
 * appropriate styling and retry controls.
 *
 * @param error - The error to display.
 * @param retry - Optional retry callback; button is shown if provided.
 * @param className - Additional CSS classes to apply.
 * @returns Inline error UI component.
 */
````

## File: src/components/ui/loading-states.tsx
````typescript
/**
 * @fileoverview Loading state components for full-screen, container, and button loading states.
 * Provides overlay, state wrapper, button loading, and container loading components with
 * customizable visual styles, progress indicators, and fallback content.
 */
⋮----
import { clampProgress, cn } from "@/lib/utils";
import { LoadingSpinner } from "./loading-spinner";
import { Progress } from "./progress";
⋮----
/**
 * Loading overlay component for full-screen or container loading
 */
export interface LoadingOverlayProps {
  isVisible: boolean;
  message?: string;
  progress?: number;
  spinnerProps?: React.ComponentProps<typeof LoadingSpinner>;
  className?: string;
  backdrop?: boolean;
  variant?: "overlay" | "page" | "fullscreen";
}
⋮----
/**
 * Loading overlay component for full-screen or container loading
 */
⋮----
className=
⋮----
<div className=
⋮----
<Progress value=
⋮----
/**
 * Loading state wrapper that shows skeleton or spinner while loading
 */
⋮----
/**
 * Loading state wrapper that shows skeleton or spinner while loading
 */
⋮----
/**
 * Button loading state component
 */
⋮----
/**
 * Button loading state component
 */
⋮----
/**
 * Container loading component for inline loading states
 */
export interface LoadingContainerProps {
  isLoading: boolean;
  children: React.ReactNode;
  loadingMessage?: string;
  spinnerProps?: React.ComponentProps<typeof LoadingSpinner>;
  className?: string;
  minHeight?: string | number;
}
⋮----
/**
 * Page loading component - convenience wrapper for full page loading
 */
⋮----
/**
 * Page loading component - convenience wrapper for full page loading
 */
````

## File: src/domain/schemas/env.ts
````typescript
/**
 * @fileoverview Shared environment variable schema definitions.
 *
 * Central Zod schema for all environment variables. This module contains
 * only schema definitions and types; no process.env access or runtime logic.
 */
⋮----
import { z } from "zod";
⋮----
// ===== FORMAT VALIDATORS =====
⋮----
/**
 * Creates a Zod schema for API keys with minimum length validation.
 * Ensures API keys meet basic format requirements to prevent unclear runtime failures.
 * Empty strings are allowed (treated as "not configured").
 */
const apiKeySchema = (name: string, minLength = 20)
⋮----
/**
 * Creates a Zod schema for cryptographic secrets with minimum length.
 * Empty strings are allowed (treated as "not configured").
 */
const secretSchema = (name: string, minLength = 32)
⋮----
/**
 * Resend API key format: starts with "re_".
 * Empty strings are allowed (treated as "not configured").
 */
⋮----
/**
 * Stripe secret key format: starts with "sk_test_" or "sk_live_".
 * Empty strings are allowed (treated as "not configured").
 */
⋮----
/**
 * Stripe publishable key format: starts with "pk_test_" or "pk_live_".
 * Empty strings are allowed (treated as "not configured").
 */
⋮----
/**
 * OpenAI API key format: starts with "sk-".
 * Empty strings are allowed (treated as "not configured").
 */
⋮----
/**
 * Anthropic API key format: starts with "sk-ant-".
 * Empty strings are allowed (treated as "not configured").
 */
⋮----
/**
 * Supabase JWT secret must be at least 32 chars for HS256.
 * Empty strings are allowed (treated as "not configured").
 */
⋮----
/**
 * HMAC secret must be at least 32 chars for secure signing.
 * Empty strings are allowed (treated as "not configured").
 */
⋮----
// Base environment schema for common variables
⋮----
// Next.js specific environment variables
⋮----
// Supabase configuration
⋮----
// Database configuration (minimal - only DATABASE_URL used)
⋮----
// Cache configuration (Upstash Redis REST only)
⋮----
// Authentication providers (empty - not used in frontend)
⋮----
// AI Service API Keys
⋮----
// Firecrawl & Exa search/crawl
⋮----
// OpenRouter API key (server-side fallback, not attribution)
⋮----
// Upstash QStash (durable notifications queue)
⋮----
// Resend (email notifications)
⋮----
// xAI API key (server-side fallback)
⋮----
// Travel & External API Keys
⋮----
// Amadeus Self-Service API
⋮----
// Duffel flights
⋮----
// Server routes/tools: Server key for Geocoding/Places/Routes/Time Zone (IP+API restricted)
⋮----
// Frontend: Browser key for Maps JS / Places (referrer-restricted)
⋮----
// Weather
⋮----
// Stripe payment processing
⋮----
// Monitoring and Analytics (minimal - only used vars)
⋮----
// Feature flags and configuration (empty - not used in frontend)
⋮----
// Coerce to boolean for type safety; avoids string comparison pitfalls ("true" vs "TRUE")
⋮----
// Security configuration
⋮----
// Optional downstream collaborator webhook URL (signed at app layer)
⋮----
// HMAC secret for verifying Supabase Database Webhooks
⋮----
// Development and debugging (minimal - only ANALYZE and DEBUG used)
⋮----
// Complete environment schema
⋮----
// Validation rules that depend on NODE_ENV
⋮----
// Required variables in production
⋮----
// Security requirements in production
⋮----
// Client-side environment schema (only NEXT_PUBLIC_ variables)
⋮----
// Type exports
export type ServerEnv = z.infer<typeof envSchema>;
export type ClientEnv = z.infer<typeof clientEnvSchema>;
````

## File: src/domain/schemas/rag.ts
````typescript
/**
 * @fileoverview RAG (Retrieval-Augmented Generation) schemas.
 * Includes document indexing, hybrid search, and reranking validation.
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for RAG operations
⋮----
/**
 * Supported namespaces for document organization.
 * Each namespace creates a logical partition of documents.
 */
⋮----
/** TypeScript type for RAG namespaces. */
export type RagNamespace = z.infer<typeof ragNamespaceSchema>;
⋮----
/**
 * Zod schema for document metadata.
 * Arbitrary key-value pairs for filtering and context.
 */
⋮----
/** TypeScript type for document metadata. */
export type RagMetadata = z.infer<typeof ragMetadataSchema>;
⋮----
/**
 * Zod schema for a single document to be indexed.
 * Contains content, optional ID, and metadata for filtering.
 */
⋮----
/** TypeScript type for documents to be indexed. */
export type RagDocument = z.infer<typeof ragDocumentSchema>;
⋮----
/**
 * Zod schema for a document chunk with embedding.
 * Represents a processed chunk ready for storage.
 */
⋮----
/** TypeScript type for document chunks. */
export type RagChunk = z.infer<typeof ragChunkSchema>;
⋮----
/**
 * Zod schema for search results before reranking.
 * Includes hybrid search scores.
 */
⋮----
/** TypeScript type for search results. */
export type RagSearchResult = z.infer<typeof ragSearchResultSchema>;
⋮----
// ===== API REQUEST SCHEMAS =====
// Request schemas for RAG API endpoints
⋮----
/**
 * Zod schema for POST /api/rag/index request body.
 * Validates batch document indexing parameters.
 */
⋮----
/** TypeScript type for index requests. */
export type RagIndexRequest = z.infer<typeof ragIndexRequestSchema>;
⋮----
/**
 * Zod schema for POST /api/rag/search request body.
 * Validates hybrid search with optional reranking.
 *
 * `keywordWeight` and `semanticWeight` are independent multipliers used directly
 * by the hybrid ranking function. Defaults are 0.3 and 0.7 respectively; they
 * do not need to sum to 1.0.
 */
⋮----
/** TypeScript type for search requests. */
export type RagSearchRequest = z.infer<typeof ragSearchRequestSchema>;
⋮----
// ===== API RESPONSE SCHEMAS =====
// Response schemas for RAG API endpoints
⋮----
/**
 * Zod schema for failed document in index response.
 * Tracks which documents failed and why.
 */
⋮----
/** TypeScript type for failed documents. */
export type RagIndexFailedDoc = z.infer<typeof ragIndexFailedDocSchema>;
⋮----
/**
 * Zod schema for POST /api/rag/index response.
 * Includes counts and failed document details.
 */
⋮----
/** TypeScript type for index responses. */
export type RagIndexResponse = z.infer<typeof ragIndexResponseSchema>;
⋮----
/**
 * Zod schema for POST /api/rag/search response.
 * Includes results and performance metadata.
 */
⋮----
/** TypeScript type for search responses. */
export type RagSearchResponse = z.infer<typeof ragSearchResponseSchema>;
⋮----
// ===== TOOL INPUT SCHEMAS =====
// Schemas for RAG tool input validation
⋮----
/**
 * Schema for ragSearch tool input.
 * Validates RAG search parameters for AI tools.
 */
⋮----
/** TypeScript type for RAG search tool input. */
export type RagSearchInput = z.infer<typeof ragSearchInputSchema>;
⋮----
// ===== TOOL OUTPUT SCHEMAS =====
// Schemas for RAG tool output validation
⋮----
export type RagSearchToolOutput = z.infer<typeof ragSearchToolOutputSchema>;
⋮----
// ===== INTERNAL SCHEMAS =====
// Schemas for internal RAG operations
⋮----
/**
 * Zod schema for reranker configuration.
 * Used to configure the pluggable reranker.
 */
⋮----
/** TypeScript type for reranker configuration. */
export type RerankerConfig = z.infer<typeof rerankerConfigSchema>;
⋮----
/**
 * Zod schema for rerank result.
 * Output from the reranking operation.
 */
⋮----
/** TypeScript type for rerank results. */
export type RerankResult = z.infer<typeof rerankResultSchema>;
⋮----
/**
 * Zod schema for indexer configuration.
 * Used to configure document chunking and embedding.
 */
⋮----
/** TypeScript type for indexer configuration. */
export type IndexerConfig = z.infer<typeof indexerConfigSchema>;
⋮----
/**
 * Zod schema for retriever configuration.
 * Used to configure hybrid search behavior.
 */
⋮----
/** TypeScript type for retriever configuration. */
export type RetrieverConfig = z.infer<typeof retrieverConfigSchema>;
````

## File: src/hooks/use-zod-form.ts
````typescript
/**
 * @fileoverview Form helpers that integrate Zod validation with React Hook Form.
 */
⋮----
import { zodResolver } from "@hookform/resolvers/zod";
import type { ValidationResult } from "@schemas/validation";
import { useCallback, useState } from "react";
import {
  type FieldErrors,
  type FieldValues,
  type UseFormProps,
  type UseFormReturn,
  useForm,
} from "react-hook-form";
import type { z } from "zod";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
⋮----
// Form options - using a data type parameter to avoid complex generic constraints
interface UseZodFormOptions<Data extends FieldValues>
  extends Omit<UseFormProps<Data>, "resolver"> {
  schema: z.ZodType<Data>;
  validateMode?: "onSubmit" | "onBlur" | "onChange" | "onTouched" | "all";
  transformSubmitData?: (data: Data) => Data | Promise<Data>;
  onValidationError?: (errors: ValidationResult<Data>) => void;
  onSubmitSuccess?: (data: Data) => void | Promise<void>;
  onSubmitError?: (error: Error) => void;
}
⋮----
// form return type
interface UseZodFormReturn<T extends FieldValues> extends UseFormReturn<T> {
  // Safe submit with validation
  handleSubmitSafe: (
    onValid: (data: T) => void | Promise<void>,
    onInvalid?: (errors: ValidationResult<T>) => void
  ) => (e?: React.BaseSyntheticEvent) => Promise<void>;

  isFormComplete: boolean;

  // Validation state
  validationState: {
    isValidating: boolean;
    lastValidation: Date | null;
    validationErrors: string[];
  };
}
⋮----
// Safe submit with validation
⋮----
// Validation state
⋮----
type FieldErrorLike = {
  message?: unknown;
  type?: unknown;
  types?: unknown;
};
⋮----
function isRecord(value: unknown): value is Record<string, unknown>
⋮----
function isFieldErrorLike(value: unknown): value is FieldErrorLike
⋮----
function collectRhfErrors(
  errors: unknown,
  path: string[],
  out: Array<{ path: string | undefined; message: string; code: string }>,
  depth = 0
)
⋮----
// Depth guard to prevent stack overflow on deeply-nested objects
⋮----
function validationResultFromFieldErrors<Data extends FieldValues>(
  fieldErrors: FieldErrors<Data>
): ValidationResult<Data>
⋮----
// Custom hook for enhanced Zod form handling
export function useZodForm<Data extends FieldValues>(
  options: UseZodFormOptions<Data>
): UseZodFormReturn<Data>
⋮----
// Initialize React Hook Form with Zod resolver
⋮----
// biome-ignore lint/suspicious/noExplicitAny: zodResolver requires flexible schema typing
⋮----
// Validation state management
⋮----
// Safe submit handler with enhanced error handling
⋮----
// Handle onSubmitSuccess errors separately - don't treat as submission failure
⋮----
// Subscribe to form validity via RHF's formState Proxy.
⋮----
// Export types for external use
````

## File: src/lib/api/api-client.ts
````typescript
/**
 * @fileoverview Simplified API client with Zod validation. Provides runtime
 * type safety for requests and responses with retry/timeout behavior.
 */
⋮----
import type { ValidationResult } from "@schemas/validation";
import type { z } from "zod";
import { getClientEnvVarWithFallback } from "../env/client";
import { getClientOrigin } from "../url/client-origin";
import { ApiError, type ApiErrorCode } from "./error-types";
⋮----
/**
 * Configuration options for individual API requests.
 */
// biome-ignore lint/style/useNamingConvention: Type name follows API convention
interface RequestConfig<TRequest = unknown, TResponse = unknown> {
  /** API endpoint path (relative to base URL). */
  endpoint: string;
  /** HTTP method for the request. */
  method?: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
  /** Request body data for POST/PUT/PATCH requests. */
  data?: TRequest;
  /** Query parameters to append to the URL. */
  params?: Record<string, string | number | boolean>;
  /** Additional headers to send with the request. */
  headers?: Record<string, string>;
  /** Request timeout in milliseconds. */
  timeout?: number;
  /** Number of retry attempts for failed requests. */
  retries?: number;
  /** Zod schema for validating request data. */
  requestSchema?: z.ZodType<TRequest>;
  /** Zod schema for validating response data. */
  responseSchema?: z.ZodType<TResponse>;
  /** Whether to validate the response against the schema. */
  validateResponse?: boolean;
  /** Whether to validate the request against the schema. */
  validateRequest?: boolean;
  /** AbortSignal for cancelling the request. */
  abortSignal?: AbortSignal;
}
⋮----
/** API endpoint path (relative to base URL). */
⋮----
/** HTTP method for the request. */
⋮----
/** Request body data for POST/PUT/PATCH requests. */
⋮----
/** Query parameters to append to the URL. */
⋮----
/** Additional headers to send with the request. */
⋮----
/** Request timeout in milliseconds. */
⋮----
/** Number of retry attempts for failed requests. */
⋮----
/** Zod schema for validating request data. */
⋮----
/** Zod schema for validating response data. */
⋮----
/** Whether to validate the response against the schema. */
⋮----
/** Whether to validate the request against the schema. */
⋮----
/** AbortSignal for cancelling the request. */
⋮----
/**
 * Configuration options for the ApiClient instance.
 */
interface ApiClientConfig {
  /** Base URL for all API requests. */
  baseUrl: string;
  /** Default timeout in milliseconds for requests. */
  timeout: number;
  /** Default number of retry attempts for failed requests. */
  retries: number;
  /** Whether to validate responses by default. */
  validateResponses: boolean;
  /** Whether to validate requests by default. */
  validateRequests: boolean;
  /** Name of the header used for authentication tokens. */
  authHeaderName: string;
  /** Default headers to include in all requests. */
  defaultHeaders: Record<string, string>;
}
⋮----
/** Base URL for all API requests. */
⋮----
/** Default timeout in milliseconds for requests. */
⋮----
/** Default number of retry attempts for failed requests. */
⋮----
/** Whether to validate responses by default. */
⋮----
/** Whether to validate requests by default. */
⋮----
/** Name of the header used for authentication tokens. */
⋮----
/** Default headers to include in all requests. */
⋮----
/**
 * HTTP client for making API requests with validation and retry logic.
 * Provides type-safe request methods with optional Zod schema validation.
 */
export class ApiClient
⋮----
/** Client configuration with defaults and user overrides. */
⋮----
/**
   * Creates a new ApiClient instance with the provided configuration.
   *
   * @param config Partial configuration to override defaults.
   */
constructor(config: Partial<ApiClientConfig> =
⋮----
/**
   * Sets the authentication token for all subsequent requests.
   *
   * @param token JWT or other authentication token to include in requests.
   */
public setAuthToken(token: string): void
⋮----
/**
   * Removes the authentication token from all subsequent requests.
   */
public clearAuthToken(): void
⋮----
/**
   * Internal method that handles the core request logic with validation and retries.
   *
   * @param config Request configuration including endpoint, method, data, and options.
   * @returns Promise that resolves with the validated response data.
   */
// biome-ignore lint/style/useNamingConvention: Method name follows API convention
private async request<TRequest, TResponse>(
    config: RequestConfig<TRequest, TResponse>
): Promise<TResponse>
⋮----
// Validate request data if schema provided
⋮----
// Build URL
⋮----
// Prepare headers
⋮----
// Add body for POST/PUT/PATCH requests
⋮----
// Remove content-type for FormData (browser will set it with boundary)
⋮----
// Prepare request options (signal is bound via internal controller below)
⋮----
// Add body for POST/PUT/PATCH requests
⋮----
// Setup timeout and retry logic
⋮----
// Track abort source to distinguish timeout vs external cancellation
⋮----
// Bridge external abort signals to our internal controller so timeout always applies
⋮----
// Handle HTTP errors
⋮----
// Parse response body
⋮----
// Validate response if schema provided
⋮----
// Don't retry on validation errors or 4xx errors
⋮----
// Don't retry on abort errors - distinguish timeout vs external cancellation
⋮----
// External cancellation (user/caller aborted)
⋮----
// If this is the last attempt, throw the error
⋮----
// Wait before retrying (exponential backoff)
⋮----
// If we get here, all retries failed
⋮----
/**
   * Parses the response body based on the Content-Type header.
   * Supports JSON, text, and binary data parsing.
   *
   * @param response Fetch Response object to parse.
   * @returns Parsed response data based on content type.
   */
private async parseResponseBody(response: Response): Promise<unknown>
⋮----
// Default to text
⋮----
/**
   * Makes a GET request to the specified endpoint.
   *
   * @param endpoint API endpoint path.
   * @param options Additional request options.
   * @returns Promise that resolves with the response data.
   */
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
// biome-ignore lint/style/useNamingConvention: TypeScript generic type parameter convention
public async get<TResponse = unknown>(
    endpoint: string,
    options: Omit<RequestConfig<never, TResponse>, "endpoint" | "method"> = {}
): Promise<TResponse>
⋮----
/**
   * Makes a POST request to the specified endpoint.
   *
   * @param endpoint API endpoint path.
   * @param data Request body data.
   * @param options Additional request options.
   * @returns Promise that resolves with the response data.
   */
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
// biome-ignore lint/style/useNamingConvention: TypeScript generic type parameter convention
public async post<TRequest = unknown, TResponse = unknown>(
    endpoint: string,
    data?: TRequest,
    options: Omit<
      RequestConfig<TRequest, TResponse>,
      "endpoint" | "method" | "data"
    > = {}
): Promise<TResponse>
⋮----
/**
   * Makes a PUT request to the specified endpoint.
   *
   * @param endpoint API endpoint path.
   * @param data Request body data.
   * @param options Additional request options.
   * @returns Promise that resolves with the response data.
   */
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
// biome-ignore lint/style/useNamingConvention: TypeScript generic type parameter convention
public async put<TRequest = unknown, TResponse = unknown>(
    endpoint: string,
    data?: TRequest,
    options: Omit<
      RequestConfig<TRequest, TResponse>,
      "endpoint" | "method" | "data"
    > = {}
): Promise<TResponse>
⋮----
/**
   * Makes a PATCH request to the specified endpoint.
   *
   * @param endpoint API endpoint path.
   * @param data Request body data.
   * @param options Additional request options.
   * @returns Promise that resolves with the response data.
   */
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
// biome-ignore lint/style/useNamingConvention: TypeScript generic type parameter convention
public async patch<TRequest = unknown, TResponse = unknown>(
    endpoint: string,
    data?: TRequest,
    options: Omit<
      RequestConfig<TRequest, TResponse>,
      "endpoint" | "method" | "data"
    > = {}
): Promise<TResponse>
⋮----
/**
   * Makes a DELETE request to the specified endpoint.
   *
   * @param endpoint API endpoint path.
   * @param options Additional request options.
   * @returns Promise that resolves with the response data.
   */
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
// biome-ignore lint/style/useNamingConvention: TypeScript generic type parameter convention
public async delete<TRequest = unknown, TResponse = unknown>(
    endpoint: string,
    options: Omit<RequestConfig<TRequest, TResponse>, "endpoint" | "method"> = {}
): Promise<TResponse>
⋮----
/**
   * Makes a GET request with automatic response validation using a Zod schema.
   *
   * @param endpoint API endpoint path.
   * @param responseSchema Zod schema for validating the response.
   * @param options Additional request options.
   * @returns Promise that resolves with validated response data.
   */
// biome-ignore lint/style/useNamingConvention: Method name follows API convention
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
public async getValidated<TResponse>(
    endpoint: string,
    responseSchema: z.ZodType<TResponse>,
    options: Omit<
      RequestConfig<never, TResponse>,
      "endpoint" | "method" | "responseSchema"
    > = {}
): Promise<TResponse>
⋮----
/**
   * Makes a POST request with automatic request and response validation using Zod schemas.
   *
   * @param endpoint API endpoint path.
   * @param data Request body data.
   * @param requestSchema Zod schema for validating the request.
   * @param responseSchema Zod schema for validating the response.
   * @param options Additional request options.
   * @returns Promise that resolves with validated response data.
   */
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
// biome-ignore lint/style/useNamingConvention: TypeScript generic type parameter convention
public async postValidated<TRequest, TResponse>(
    endpoint: string,
    data: TRequest,
    requestSchema: z.ZodType<TRequest>,
    responseSchema: z.ZodType<TResponse>,
    options: Omit<
      RequestConfig<TRequest, TResponse>,
      "endpoint" | "method" | "data" | "requestSchema" | "responseSchema"
    > = {}
): Promise<TResponse>
⋮----
/**
   * Makes a PUT request with automatic request and response validation using Zod schemas.
   *
   * @param endpoint API endpoint path.
   * @param data Request body data.
   * @param requestSchema Zod schema for validating the request.
   * @param responseSchema Zod schema for validating the response.
   * @param options Additional request options.
   * @returns Promise that resolves with validated response data.
   */
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
// biome-ignore lint/style/useNamingConvention: TypeScript generic type parameter convention
public async putValidated<TRequest, TResponse>(
    endpoint: string,
    data: TRequest,
    requestSchema: z.ZodType<TRequest>,
    responseSchema: z.ZodType<TResponse>,
    options: Omit<
      RequestConfig<TRequest, TResponse>,
      "endpoint" | "method" | "data" | "requestSchema" | "responseSchema"
    > = {}
): Promise<TResponse>
⋮----
/**
   * Makes a PATCH request with automatic request and response validation using Zod schemas.
   *
   * @param endpoint API endpoint path.
   * @param data Request body data.
   * @param requestSchema Zod schema for validating the request.
   * @param responseSchema Zod schema for validating the response.
   * @param options Additional request options.
   * @returns Promise that resolves with validated response data.
   */
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
// biome-ignore lint/style/useNamingConvention: TypeScript generic type parameter convention
public async patchValidated<TRequest, TResponse>(
    endpoint: string,
    data: TRequest,
    requestSchema: z.ZodType<TRequest>,
    responseSchema: z.ZodType<TResponse>,
    options: Omit<
      RequestConfig<TRequest, TResponse>,
      "endpoint" | "method" | "data" | "requestSchema" | "responseSchema"
    > = {}
): Promise<TResponse>
⋮----
/**
   * Makes a DELETE request with automatic response validation using a Zod schema.
   *
   * @param endpoint API endpoint path.
   * @param responseSchema Zod schema for validating the response.
   * @param options Additional request options.
   * @returns Promise that resolves with validated response data.
   */
// biome-ignore lint/suspicious/useAwait: Method delegates to async request method
// biome-ignore lint/style/useNamingConvention: TypeScript generic type parameter convention
public async deleteValidated<TResponse>(
    endpoint: string,
    responseSchema: z.ZodType<TResponse>,
    options: Omit<
      RequestConfig<never, TResponse>,
      "endpoint" | "method" | "responseSchema"
    > = {}
): Promise<TResponse>
⋮----
/**
 * Default API client instance with standard configuration.
 */
⋮----
/** Exported types for API client configuration. */
````

## File: src/lib/api/route-helpers.ts
````typescript
/**
 * @fileoverview Helpers for API route handlers (headers, rate limiting, validation, errors).
 *
 * Provides standardized utilities for Next.js API route handlers including:
 * - Request parsing and validation
 * - Error handling with redaction
 * - Authentication helpers
 * - Rate limiting identifiers
 * - Telemetry spans
 */
⋮----
import { type NextRequest, NextResponse } from "next/server";
import type { z } from "zod";
import {
  PayloadTooLargeError,
  RequestBodyAlreadyReadError,
  readRequestBodyBytesWithLimit,
} from "@/lib/http/body";
import { getClientIpFromHeaders as getClientIpFromHeaderValues } from "@/lib/http/ip";
import {
  getTrustedRateLimitIdentifierFromHeaders,
  hashIdentifier as hashRateLimitIdentifier,
} from "@/lib/ratelimit/identifier";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
type ValidationIssue = z.core.$ZodIssue;
⋮----
/**
 * Shared API constants used across route handlers.
 */
⋮----
/** Content-Type for JSON responses */
⋮----
/** Maximum request body size for API endpoints (64KB) */
⋮----
/**
 * Extract the client IP from trusted sources with deterministic fallback.
 *
 * Priority order (Vercel-compatible):
 * 1. x-real-ip header (Vercel's canonical client IP header, set by edge)
 * 2. x-forwarded-for header (first IP - trusted on Vercel, spoofable elsewhere)
 * 3. cf-connecting-ip header (Cloudflare deployments)
 * 4. "unknown" (fallback when no IP available)
 *
 * **Security notes:**
 * - On Vercel: Both headers are trusted. Vercel's edge network overwrites
 *   `x-forwarded-for` and sets `x-real-ip` to prevent IP spoofing.
 * - Self-hosted/local: These headers are caller-controlled and CAN BE SPOOFED
 *   to bypass rate limits. Configure your reverse proxy to strip incoming
 *   values and set them from the actual client connection.
 *
 * The fallback of "unknown" avoids undefined identifiers when rate limiting.
 *
 * @see https://vercel.com/docs/functions/functions-api-reference/vercel-functions-package#ipaddress
 * @see https://vercel.com/docs/headers/request-headers
 * @param req Next.js request object.
 * @returns Client IP string or "unknown".
 */
export function getClientIpFromHeaders(req: NextRequest): string
⋮----
/**
 * Hash an identifier for use in rate limiting to prevent enumeration attacks.
 *
 * Uses SHA-256 and returns a hex string. This prevents attackers from
 * enumerating rate limit buckets by guessing identifiers.
 *
 * @param identifier Raw identifier string.
 * @returns Hashed identifier as hex string.
 */
export function hashIdentifier(identifier: string): string
⋮----
/**
 * Get a trusted, hashed identifier for rate limiting.
 *
 * Extracts the client IP using trusted sources and hashes it to prevent
 * enumeration attacks. Falls back to "unknown" when no IP is available.
 *
 * @param req Next.js request object.
 * @returns Hashed identifier string.
 */
export function getTrustedRateLimitIdentifier(req: NextRequest): string
⋮----
/**
 * Redact sensitive fields from error messages and context objects.
 *
 * Prevents secrets from appearing in logs by replacing sensitive values
 * with "[REDACTED]".
 *
 * @param error Error object or message string.
 * @param context Optional context object to sanitize.
 * @returns Sanitized error message and context.
 */
export function redactErrorForLogging(
  error: unknown,
  context?: Record<string, unknown>
):
⋮----
// Redact common sensitive patterns in error messages
⋮----
/**
 * Return the Authorization header value if present.
 */
export function getAuthorization(req: NextRequest): string | null
⋮----
/**
 * Build a stable rate-limit identifier using bearer token (if any) and client IP.
 */
export function buildRateLimitKey(req: NextRequest): string
⋮----
/**
 * Result of authentication check.
 */
export interface AuthCheckResult {
  user: unknown; // Supabase User type
  error: unknown; // Supabase AuthError type
  isAuthenticated: boolean;
}
⋮----
user: unknown; // Supabase User type
error: unknown; // Supabase AuthError type
⋮----
/**
 * Perform standardized authentication check with Supabase.
 *
 * @param supabase - Supabase client instance
 * @returns Authentication check result
 */
export async function checkAuthentication(
  supabase: unknown // SupabaseClient type
): Promise<AuthCheckResult>
⋮----
supabase: unknown // SupabaseClient type
⋮----
/**
 * Wrap a function execution with a request span for observability.
 *
 * Records duration and attributes for telemetry. Uses high-resolution time
 * for accurate measurements.
 *
 * @param name - Span name for identification.
 * @param attrs - Attributes to include in the span log.
 * @param f - Function to execute and measure.
 * @returns Promise resolving to the function's return value.
 */
export async function withRequestSpan<T>(
  name: string,
  attrs: Record<string, string | number>,
  f: () => Promise<T>
): Promise<T>
⋮----
/**
 * Create a standardized error response for agent routes.
 *
 * Returns a NextResponse with consistent error shape and sanitized logging.
 * All errors are logged with redaction to prevent secrets leakage.
 *
 * @param opts - Error response options.
 * @param opts.status - HTTP status code.
 * @param opts.error - Error code string (e.g., "invalid_request", "rate_limit_exceeded").
 * @param opts.reason - Human-readable reason string.
 * @param opts.err - Optional error object to log (will be redacted).
 * @returns NextResponse with standardized error format.
 */
export function errorResponse({
  err,
  error,
  reason,
  status,
  issues,
}: {
  error: string;
  reason: string;
  status: number;
  err?: unknown;
  issues?: ValidationIssue[];
}): NextResponse
⋮----
/**
 * Parses JSON request body with error handling.
 *
 * Canonical helper for route handlers to safely parse JSON request bodies.
 * Returns a discriminated union to enable type-safe error handling.
 *
 * @param req Next.js request object.
 * @returns Parsed body or error response.
 *
 * @example
 * ```typescript
 * const parsed = await parseJsonBody(req);
 * if ("error" in parsed) {
 *   return parsed.error;
 * }
 * const body = parsed.body;
 * ```
 */
export async function parseJsonBody(
  req: NextRequest,
  options: { maxBytes?: number } = {}
): Promise<
⋮----
/**
 * Validates data against a Zod schema and returns error response if invalid.
 *
 * Canonical helper for route handlers to combine Zod validation with
 * consistent error responses. Uses safeParse to avoid throwing exceptions.
 *
 * @param schema Zod schema to validate against.
 * @param data Data to validate.
 * @returns Validation result with parsed data or error response.
 *
 * @example
 * ```typescript
 * const validation = validateSchema(createEventRequestSchema, body);
 * if ("error" in validation) {
 *   return validation.error;
 * }
 * const validated = validation.data;
 * ```
 */
export function validateSchema<T extends z.ZodType>(
  schema: T,
  data: unknown
):
⋮----
/**
 * Creates a standardized 404 Not Found response.
 *
 * Canonical helper for resource-not-found errors (Supabase PGRST116 or similar).
 *
 * @param entity - Name of the entity that was not found (e.g., "Trip", "User").
 * @returns NextResponse with 404 status and consistent error shape.
 *
 * @example
 * ```typescript
 * if (error?.code === "PGRST116") {
 *   return notFoundResponse("Trip");
 * }
 * ```
 */
export function notFoundResponse(entity: string): NextResponse
⋮----
/**
 * Parse and validate numeric ID from route params.
 *
 * Generic helper for `[id]/route.ts` handlers that need to extract
 * and validate a positive integer from dynamic route parameters.
 *
 * @param routeContext - Next.js route context with async params.
 * @param paramName - Name of the parameter to parse (default: "id").
 * @returns Parsed numeric ID or error response.
 *
 * @example
 * ```typescript
 * const result = await parseNumericId(routeContext);
 * if ("error" in result) return result.error;
 * const tripId = result.id;
 * ```
 */
export async function parseNumericId(
  routeContext: { params: Promise<Record<string, string>> },
  paramName = "id"
): Promise<
⋮----
/**
 * Creates a standardized 401 Unauthorized response.
 *
 * Canonical helper for authentication required errors.
 *
 * @returns NextResponse with 401 status and consistent error shape.
 *
 * @example
 * ```typescript
 * if (!user) {
 *   return unauthorizedResponse();
 * }
 * ```
 */
export function unauthorizedResponse(): NextResponse
⋮----
/**
 * Creates a standardized 403 Forbidden response.
 *
 * Canonical helper for authorization/permission errors.
 *
 * @param reason - Human-readable reason string.
 * @returns NextResponse with 403 status and consistent error shape.
 *
 * @example
 * ```typescript
 * if (!hasPermission) {
 *   return forbiddenResponse("You do not have access to this resource");
 * }
 * ```
 */
export function forbiddenResponse(reason: string): NextResponse
⋮----
/**
 * Parse and validate string ID from route params.
 *
 * Generic helper for `[id]/route.ts` handlers that need to extract
 * and validate a non-empty string from dynamic route parameters.
 *
 * @param routeContext - Next.js route context with async params.
 * @param paramName - Name of the parameter to parse (default: "id").
 * @returns Parsed string ID or error response.
 *
 * @example
 * ```typescript
 * const result = await parseStringId(routeContext, "sessionId");
 * if ("error" in result) return result.error;
 * const sessionId = result.id;
 * ```
 */
export async function parseStringId(
  routeContext: { params: Promise<Record<string, string>> },
  paramName = "id"
): Promise<
⋮----
/**
 * Extract and validate user ID from authenticated context.
 *
 * Canonical helper for routes with `auth: true` that need to fail fast
 * if the user is missing. Prevents unsafe `user?.id ?? ""` patterns that
 * could lead to authorization bypass.
 *
 * @param user - User object from RouteContext (may be null).
 * @returns User ID or error response.
 *
 * @example
 * ```typescript
 * const result = requireUserId(user);
 * if ("error" in result) return result.error;
 * const { userId } = result;
 * ```
 */
export function requireUserId(
  user: { id: string } | null | undefined
):
````

## File: src/lib/auth/redirect-server.ts
````typescript
/**
 * @fileoverview Server-side safe redirect URL resolver for auth flows.
 *
 * Prevents open-redirect attacks by validating redirect paths and
 * computing origins from configured environment variables or request context.
 */
⋮----
import type { NextRequest } from "next/server";
import { createServerLogger } from "@/lib/telemetry/logger";
import { getOriginFromRequest } from "@/lib/url/server-origin";
⋮----
/**
 * Logs a blocked redirect attempt and returns the fallback path.
 */
function rejectPath(reason: string, original: string): string
⋮----
/**
 * Validates and normalizes a redirect path to prevent open-redirect attacks.
 *
 * Only allows:
 * - Relative paths starting with "/" (e.g., "/dashboard", "/settings")
 *
 * Blocks:
 * - Protocol-relative URLs (e.g., "//evil.com")
 * - Absolute URLs with protocols (e.g., "https://evil.com")
 * - Paths with userinfo segments (e.g., "/@attacker.com")
 * - Paths with control characters (tabs, newlines, carriage returns)
 * - Empty or whitespace-only paths
 *
 * Normalizes:
 * - Backslashes to forward slashes (e.g., "\path" becomes "/path")
 *
 * @param nextParam - The "next" query parameter value
 * @returns A safe relative path (always starts with "/")
 */
export function safeNextPath(nextParam: string | null | undefined): string
⋮----
// Block control characters (tabs, newlines, carriage returns) that browsers
// may strip, potentially bypassing validation (e.g., "/\t/evil.com" -> "//evil.com")
⋮----
// Block protocol-relative URLs (//evil.com)
⋮----
// Block absolute URLs with protocols
⋮----
// Only allow paths starting with /
⋮----
// Normalize backslashes to forward slashes (Windows path injection)
⋮----
// Re-check after normalization for // patterns
⋮----
// Validate path doesn't contain encoded protocol patterns.
// Note: Only a single decode is intentional - double-encoded patterns like
// /%252F remain encoded after this check, and browsers won't double-decode,
// so they're safe. Infrastructure that double-decodes is a separate concern.
⋮----
// Invalid encoding - treat as safe since browser won't decode it either
⋮----
// Block paths containing unencoded "@" (userinfo segment).
// While prepending origin makes "/@attacker.com" safe (becomes
// "https://trusted.com/@attacker.com"), blocking @ explicitly guards
// against parser inconsistencies and clarifies intent.
⋮----
/**
 * Resolves a full redirect URL for auth callbacks.
 *
 * Combines origin detection (respecting x-forwarded-* headers) with
 * safe path validation to produce a secure redirect URL.
 *
 * @param request - The incoming NextRequest
 * @param nextParam - The "next" query parameter value
 * @returns A safe absolute redirect URL
 */
export function resolveServerRedirectUrl(
  request: NextRequest,
  nextParam: string | null | undefined
): string
⋮----
/** The fallback redirect path for invalid inputs. */
````

## File: src/lib/calendar/ics.ts
````typescript
/**
 * Pure ICS (iCalendar) generation utilities.
 *
 * Extracts calendar event data into RFC 5545 compliant ICS format.
 * Used by both the API route handler and AI tools to ensure consistent output.
 */
⋮----
import type { CalendarEvent } from "@schemas/calendar";
import ical, { ICalAlarmType, ICalAttendeeStatus } from "ical-generator";
import { RecurringDateGenerator } from "@/lib/dates/recurring-rules";
import { DateUtils } from "@/lib/dates/unified-date-utils";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/** Logger for ICS generation operations. */
⋮----
/**
 * Options for ICS generation.
 */
export interface GenerateIcsOptions {
  /** Name for the calendar in the ICS file. */
  calendarName: string;
  /** Events to include in the calendar. */
  events: CalendarEvent[];
  /** Timezone for the calendar (defaults to UTC). */
  timezone?: string;
}
⋮----
/** Name for the calendar in the ICS file. */
⋮----
/** Events to include in the calendar. */
⋮----
/** Timezone for the calendar (defaults to UTC). */
⋮----
/**
 * Result of ICS generation.
 */
export interface GenerateIcsResult {
  /** Generated ICS string content. */
  icsString: string;
  /** Number of events included. */
  eventCount: number;
}
⋮----
/** Generated ICS string content. */
⋮----
/** Number of events included. */
⋮----
/**
 * Converts an attendee response status to the canonical iCal constant.
 *
 * @param status - Google Calendar style attendee status.
 * @returns iCal attendee status enum value.
 */
function eventAttendeeStatusToIcal(status: string): ICalAttendeeStatus
⋮----
/**
 * Normalizes reminder methods to the subset supported by iCal alarms.
 *
 * @param method - Notification channel provided by Google events.
 * @returns Alarm type enum value accepted by ical-generator.
 */
function reminderMethodToIcal(method: string): ICalAlarmType
⋮----
/**
 * Generates an ICS (iCalendar) string from calendar events.
 *
 * This is a pure function with no side effects - it takes event data
 * and produces an ICS string. No authentication, HTTP calls, or I/O.
 *
 * @param options - Calendar name, events, and optional timezone.
 * @returns Generated ICS string and event count.
 *
 * @example
 * ```typescript
 * const { icsString, eventCount } = generateIcsFromEvents({
 *   calendarName: "My Trip",
 *   events: [{ summary: "Flight", start: {...}, end: {...} }],
 *   timezone: "America/New_York",
 * });
 * ```
 */
export function generateIcsFromEvents(options: GenerateIcsOptions): GenerateIcsResult
⋮----
// Create calendar
⋮----
// Add events
⋮----
: DateUtils.add(startDate, 1, "hours"); // Default 1 hour
⋮----
trigger: rem.minutes * 60, // seconds
⋮----
/** Default filename used when input produces empty result. */
⋮----
/** Maximum filename length for filesystem safety. */
⋮----
/**
 * Sanitizes a calendar name for use as a filename.
 *
 * Replaces non-alphanumeric characters with underscores, collapses consecutive
 * underscores, trims leading/trailing underscores, and enforces length limits.
 *
 * @param name - Calendar name to sanitize.
 * @returns Sanitized filename (without extension), or "calendar" if empty.
 */
export function sanitizeCalendarFilename(name: string): string
⋮----
.replace(/[^a-z0-9]/gi, "_") // Replace non-alphanumeric with underscores
.replace(/_+/g, "_") // Collapse consecutive underscores
.replace(/^_|_$/g, ""); // Trim leading/trailing underscores
⋮----
// Return default for empty/all-special-char names
⋮----
// Enforce length limit for filesystem safety
````

## File: src/lib/ratelimit/identifier.ts
````typescript
/**
 * @fileoverview Shared helpers for constructing rate limit identifiers.
 *
 * Identifiers are normalized and hashed to avoid storing raw IPs or other
 * sensitive identifiers in Redis keys.
 */
⋮----
import { createHash } from "node:crypto";
import { getClientIpFromHeaders } from "@/lib/http/ip";
⋮----
/**
 * Normalize a raw identifier.
 *
 * Intended for case-insensitive identifiers like IPs, user IDs, and short tags.
 * Do not apply this to secrets where case may be significant.
 */
export function normalizeIdentifier(raw: string): string
⋮----
/**
 * Hash an identifier for use in rate limiting to prevent enumeration attacks.
 *
 * Uses SHA-256 and returns a hex string.
 */
export function hashIdentifier(raw: string): string
⋮----
/**
 * Get a trusted, hashed identifier for rate limiting derived from request headers.
 *
 * Extracts the client IP using trusted sources and hashes it. Returns `"unknown"`
 * when no valid IP is available.
 */
export function getTrustedRateLimitIdentifierFromHeaders(
  headers: Pick<Headers, "get">
): string
````

## File: src/lib/supabase/typed-helpers.ts
````typescript
/**
 * @fileoverview Typed helper utilities for Supabase CRUD operations with Zod validation.
 * These helpers centralize runtime validation using Zod schemas while preserving
 * compile-time shapes using the generated `Database` types.
 */
⋮----
import { getSupabaseSchema } from "@schemas/supabase";
import type { SupabaseClient } from "@supabase/supabase-js";
import { recordErrorOnSpan, withTelemetrySpan } from "@/lib/telemetry/span";
import type { Database, InsertTables, Tables, UpdateTables } from "./database.types";
⋮----
export type TypedClient = SupabaseClient<Database>;
⋮----
type TableName = keyof Database["public"]["Tables"];
/**
 * Query builder type alias using `any` intentionally.
 * Supabase's query builder is any-based internally; precise generics cause
 * excessive complexity and type instability. Biome rule suppressed below.
 */
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing is any-based
export type TableFilterBuilder = any;
⋮----
type SupportedTable = (typeof SUPPORTED_TABLES)[number];
const isSupportedTable = (table: TableName): table is SupportedTable
⋮----
/**
 * Inserts a row into the specified table and returns the single selected row.
 * Uses `.select().single()` to fetch the inserted record in one roundtrip.
 * Validates input and output using Zod schemas when available.
 *
 * Note: When inserting multiple rows, `.single()` will error. For batches,
 * add a dedicated `insertMany` helper without `.single()` if needed.
 *
 * @template T Table name constrained to `Database['public']['Tables']` keys
 * @param client Typed supabase client
 * @param table Target table name
 * @param values Insert payload (validated via Zod schema)
 * @returns Selected row (validated) and error (if any)
 */
export function insertSingle<T extends keyof Database["public"]["Tables"]>(
  client: TypedClient,
  table: T,
  values: InsertTables<T> | InsertTables<T>[]
): Promise<
⋮----
// Validate input if schema exists
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// Some tests stub a very lightweight query builder without select/single methods.
// Gracefully handle those by treating the insert as fire-and-forget.
⋮----
// Validate output if schema exists
⋮----
/**
 * Updates rows in the specified table and returns a single selected row.
 * A `where` closure receives the fluent query builder to apply filters
 * (`eq`, `in`, etc.) prior to selecting the row. Callers must supply filters
 * that narrow the result to one row; this helper does not enforce uniqueness
 * and will update all matching rows before selecting `.single()`.
 * Validates input and output using Zod schemas when available.
 *
 * @template T Table name constrained to `Database['public']['Tables']` keys
 * @param client Typed supabase client
 * @param table Target table name
 * @param updates Partial update payload (validated via Zod schema)
 * @param where Closure to apply filters to the builder
 * @returns Selected row (validated) and error (if any)
 */
export function updateSingle<T extends TableName>(
  client: TypedClient,
  table: T,
  updates: Partial<UpdateTables<T>>,
  where: (qb: TableFilterBuilder) => TableFilterBuilder
): Promise<
⋮----
// Validate input if schema exists
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// Validate output if schema exists
⋮----
/**
 * Fetches a single row from the specified table.
 * A `where` closure receives the fluent query builder to apply filters
 * (`eq`, `in`, etc.) prior to selecting the row. The caller is responsible for
 * scoping the filter to a unique row; this helper does not add additional
 * constraints and will surface Supabase errors if multiple rows match.
 * Validates output using Zod schemas when available.
 *
 * @template T Table name constrained to `Database['public']['Tables']` keys
 * @param client Typed supabase client
 * @param table Target table name
 * @param where Closure to apply filters to the builder
 * @returns Selected row (validated) and error (if any)
 */
export function getSingle<T extends TableName>(
  client: TypedClient,
  table: T,
  where: (qb: TableFilterBuilder) => TableFilterBuilder
): Promise<
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// Validate output if schema exists
⋮----
/**
 * Deletes rows from the specified table matching the given criteria.
 * A `where` closure receives the fluent query builder to apply filters
 * (`eq`, `in`, etc.) prior to deletion. Naming follows getSingle/updateSingle;
 * callers must provide filters that target the intended row(s). This helper
 * does not enforce single-row deletion and will delete all rows matching the
 * supplied filter.
 *
 * @template T Table name constrained to `Database['public']['Tables']` keys
 * @param client Typed supabase client
 * @param table Target table name
 * @param where Closure to apply filters to the builder
 * @returns Error (if any)
 */
export function deleteSingle<T extends TableName>(
  client: TypedClient,
  table: T,
  where: (qb: TableFilterBuilder) => TableFilterBuilder
): Promise<
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
/**
 * Fetches a single row from the specified table, returning null if not found.
 * Uses `.maybeSingle()` instead of `.single()` to avoid PGRST116 errors.
 * A `where` closure receives the fluent query builder to apply filters
 * (`eq`, `in`, etc.) prior to selecting the row.
 * Validates output using Zod schemas when available.
 *
 * @template T Table name constrained to `Database['public']['Tables']` keys
 * @param client Typed supabase client
 * @param table Target table name
 * @param where Closure to apply filters to the builder
 * @returns Selected row (validated) or null, and error (if any)
 */
export function getMaybeSingle<T extends TableName>(
  client: TypedClient,
  table: T,
  where: (qb: TableFilterBuilder) => TableFilterBuilder
): Promise<
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// Validate output if schema exists
⋮----
/**
 * Upserts a row into the specified table and returns the single selected row.
 * Uses `.upsert()` with onConflict to perform insert-or-update operations.
 * Validates input and output using Zod schemas when available.
 *
 * @template T Table name constrained to `Database['public']['Tables']` keys
 * @param client Typed supabase client
 * @param table Target table name
 * @param values Upsert payload (validated via Zod schema)
 * @param onConflict Column name(s) to determine conflict (e.g., "user_id")
 * @returns Selected row (validated) and error (if any)
 */
export function upsertSingle<T extends keyof Database["public"]["Tables"]>(
  client: TypedClient,
  table: T,
  values: InsertTables<T>,
  onConflict: string
): Promise<
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Supabase query builder typing
⋮----
// Chain select/single to return the upserted row
⋮----
// Validate output if schema exists
````

## File: src/lib/telemetry/degraded-mode.ts
````typescript
/**
 * @fileoverview Deduped operational alerts for degraded infrastructure fallbacks.
 */
⋮----
import type { OperationalAlertOptions } from "@/lib/telemetry/alerts";
import { emitOperationalAlert } from "@/lib/telemetry/alerts";
import { isPlainObject } from "@/lib/utils/type-guards";
⋮----
const MAX_DEDUPE_ENTRY_AGE_MS = 24 * 60 * 60 * 1000; // 24h
const CLEANUP_INTERVAL_MS = 10 * 60 * 1000; // 10m
⋮----
function normalizeForStableJson(value: unknown): unknown
⋮----
function stableStringifyAttributes(attributes: Record<string, unknown>): string
⋮----
function maybeCleanup(now: number): void
⋮----
export function emitOperationalAlertOncePerWindow(
  params: {
    event: string;
    windowMs: number;
  } & OperationalAlertOptions
): void
⋮----
export function resetDegradedModeAlertStateForTests(): void
````

## File: src/lib/telemetry/identifiers.ts
````typescript
/**
 * @fileoverview Telemetry-safe identifier helpers (stable hashing, opt-in via secret).
 */
⋮----
import { createHmac } from "node:crypto";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
⋮----
function hashTelemetryValue(value: string): string | null
⋮----
/**
 * Hashes an identifier intended for telemetry attributes (e.g., user/session IDs).
 *
 * This is a stable pseudonymization primitive (HMAC-SHA256) that only activates when
 * `TELEMETRY_HASH_SECRET` is configured. Prefer this for low-cardinality identifiers.
 *
 * @param identifier - The identifier string to hash
 * @returns Hex-encoded HMAC-SHA256 hash, or `null` if `TELEMETRY_HASH_SECRET` is not configured
 *          or if the input is empty/whitespace-only. Callers should handle `null` gracefully
 *          (e.g., by omitting the attribute or using a placeholder).
 */
export function hashTelemetryIdentifier(identifier: string): string | null
⋮----
/**
 * Hashes an arbitrary value for telemetry fingerprinting (e.g., hashing long/high-cardinality
 * text for dedupe). Callers should typically store only a short prefix of the hash.
 *
 * @param value - The value string to hash
 * @returns Hex-encoded HMAC-SHA256 hash, or `null` if `TELEMETRY_HASH_SECRET` is not configured
 *          or if the input is empty/whitespace-only. Callers should handle `null` gracefully
 *          (e.g., by using a fallback or omitting the fingerprint).
 */
export function hashTelemetryFingerprint(value: string): string | null
````

## File: src/lib/url/server-origin.ts
````typescript
/**
 * @fileoverview Server-side URL origin resolution utilities.
 *
 * Provides safe origin resolution for server actions and API routes.
 * Prevents SSRF by using trusted environment variables instead of user input.
 */
⋮----
import type { NextRequest } from "next/server";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/**
 * Default localhost origin for development environments.
 *
 * WARNING: This fallback should only be used in development. In production,
 * ensure APP_BASE_URL or NEXT_PUBLIC_SITE_URL is set to prevent SSRF risks
 * from misconfigured environments. The localhost fallback is acceptable for
 * local development but must not be used in production deployments.
 */
⋮----
/**
 * Whether the application is running in production mode.
 */
⋮----
/**
 * Validates that a host value is well-formed and doesn't contain suspicious characters.
 * Blocks userinfo segments (@), control characters, and other injection vectors.
 */
function isValidHost(host: string): boolean
⋮----
// Block userinfo segments (evil.com@trusted.com), control chars, spaces
⋮----
// Basic hostname pattern: alphanumeric, dots, hyphens, optional port
// Allows: example.com, sub.example.com, localhost:3000, 192.168.1.1:8080
⋮----
function resolveConfiguredOrigin(): string | null
⋮----
// APP_BASE_URL not available, continue to next option
⋮----
// NEXT_PUBLIC_SITE_URL not available, continue to next option
⋮----
/**
 * Resolves the application origin for server-side requests.
 *
 * Uses environment variables in priority order; in production, missing configuration
 * will throw to avoid silently using localhost.
 */
export function getServerOrigin(): string
⋮----
/**
 * Resolves the application origin for server-side requests.
 * Throws an error in production if no valid origin is configured.
 *
 * Use this variant for critical operations (payments, webhooks) where
 * falling back to localhost would cause silent failures.
 *
 * @returns Application origin URL
 * @throws {Error} In production if no origin is configured
 */
export function getRequiredServerOrigin(): string
⋮----
/**
 * Converts a relative path to an absolute URL using the server origin.
 *
 * If the path is already absolute (starts with http:// or https://), returns it as-is.
 * Otherwise, resolves it relative to the server origin.
 *
 * @param path - Relative or absolute path/URL
 * @returns Absolute URL
 */
export function toAbsoluteUrl(path: string): string
⋮----
/**
 * Resolves the origin from a NextRequest, preferring configured origin for security.
 *
 * Priority (security-first):
 * 1. Configured origin from environment variables (most secure)
 * 2. x-forwarded-host + x-forwarded-proto (only when no configured origin)
 * 3. Request URL origin (final fallback)
 *
 * WARNING: Only uses x-forwarded-* headers when no configured origin is available.
 * These headers must be set/stripped by a trusted reverse proxy. For strict
 * security guarantees, use getRequiredServerOrigin() instead.
 *
 * @param request - The incoming NextRequest
 * @returns The resolved origin URL (e.g., "https://example.com")
 */
export function getOriginFromRequest(request: NextRequest): string
⋮----
// 1. Prefer configured origin (most secure - not influenced by request headers)
⋮----
// 2. Only if no configured origin, consider forwarded headers from trusted proxy
⋮----
// Validate protocol - only allow http/https, default to https for anything else
⋮----
// 3. Final fallback: request URL origin
````

## File: src/lib/variants/status.ts
````typescript
/**
 * @fileoverview CVA variants for status and urgency colors with Tailwind classes.
 * Provides consistent styling for badges, pills, and status indicators across the application.
 */
⋮----
import { cva, type VariantProps } from "class-variance-authority";
⋮----
/**
 * Status/action/urgency variants normalized to a single tone axis so only one
 * bg/text/ring set is ever emitted. `statusVariants` resolves precedence
 * status > action > urgency > tone fallback.
 *
 * Note: Some tone keys intentionally reuse the same color for semantic grouping:
 * - active/create/low/success all use green (positive/affirmative states)
 * - pending/medium both use amber (intermediate/waiting states)
 */
⋮----
export type ActionVariant = "calendar" | "create" | "deals" | "explore" | "search";
export type StatusVariant = "active" | "error" | "info" | "pending" | "success";
export type UrgencyVariant = "high" | "medium" | "low";
export type ToneVariant = ActionVariant | StatusVariant | UrgencyVariant | "unknown";
⋮----
export type StatusVariantInput = {
  action?: ActionVariant;
  status?: StatusVariant;
  urgency?: UrgencyVariant;
  tone?: ToneVariant;
  excludeRing?: boolean;
};
⋮----
/**
 * Color set for a tone variant with text, background, and border colors.
 */
export type ToneColorSet = {
  text: string;
  bg: string;
  border: string;
};
⋮----
/**
 * Static mapping of ToneVariant to ToneColorSet with explicit Tailwind classes.
 * Ensures all classes are statically present for Tailwind JIT compilation.
 */
⋮----
/**
 * Get the static color set for a tone variant.
 *
 * @param tone The tone variant to get colors for.
 * @returns Object with text, bg, and border color classes.
 */
export function getToneColors(tone: ToneVariant): ToneColorSet
⋮----
export type StatusVariantProps = VariantProps<typeof statusToneVariants> &
  StatusVariantInput;
⋮----
/** Type guard to check if a value is a valid ToneVariant. */
function isToneVariant(value: string): value is ToneVariant
⋮----
const resolveTone = (input: StatusVariantInput): ToneVariant =>
⋮----
export const statusVariants = (input: StatusVariantInput =
````

## File: src/lib/utils.ts
````typescript
/**
 * @fileoverview Small DOM-agnostic utilities for formatting and timing.
 * All helpers are pure and safe for both server and browser runtimes.
 *
 * NOTE: For session-related utilities that use browser storage,
 * see `@/lib/client/session.ts`.
 */
⋮----
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import { DateUtils } from "@/lib/dates/unified-date-utils";
⋮----
/**
 * Compose Tailwind class strings with conflict resolution.
 *
 * @param inputs Class tokens and conditional fragments.
 * @returns Merged className string.
 */
export function cn(...inputs: ClassValue[])
⋮----
/**
 * Format a date-like value as a long US date (e.g., January 1, 2025).
 *
 * @param input Date instance, timestamp, or ISO string.
 * @returns Human-readable date string.
 */
export function formatDate(input: string | number | Date): string
⋮----
/**
 * Test if a string is a syntactically valid URL.
 *
 * @param url Candidate URL string.
 * @returns True when `new URL(url)` succeeds.
 */
export function isValidUrl(url: string): boolean
⋮----
/**
 * Truncate a string and append an ellipsis when exceeded.
 *
 * @param str Source string.
 * @param length Maximum length before truncation.
 * @returns Original string or truncated with `...`.
 */
export function truncate(str: string, length: number): string
⋮----
/**
 * Format a number as currency in the en-US locale.
 *
 * @param amount Numeric amount.
 * @param currency ISO 4217 code (default: `USD`).
 * @returns Formatted currency string.
 */
export function formatCurrency(amount: number, currency = "USD"): string
⋮----
/**
 * Return a debounced function that postpones invocation until after `delay`.
 *
 * @typeParam T Callable type.
 * @param fn Target function to debounce.
 * @param delay Delay in milliseconds.
 * @returns Debounced function.
 */
export function debounce<T extends (...args: unknown[]) => unknown>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void
⋮----
/**
 * Return a throttled function that invokes at most once per `delay` window.
 *
 * @typeParam T Callable type.
 * @param fn Target function to throttle.
 * @param delay Minimum interval in milliseconds between calls.
 * @returns Throttled function.
 */
export function throttle<T extends (...args: unknown[]) => unknown>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void
⋮----
/**
 * Execute a promise without awaiting while observing rejections.
 *
 * @param promise Promise to execute in fire-and-forget mode.
 * @param onError Optional handler when the promise rejects.
 */
export function fireAndForget<T>(
  promise: Promise<T>,
  onError?: (error: unknown) => void
): void
⋮----
const handleRejection = (_error: unknown) =>
⋮----
// Warn about missing error handler in development
⋮----
// Swallow rejection silently when no handler provided
// Error tracking should be done at the call site with proper context
⋮----
/**
 * Clamp a number to the valid percentage range [0, 100].
 *
 * @param value Input value to clamp.
 * @returns Value constrained to [0, 100]. Returns 0 for NaN inputs.
 */
export function clampProgress(value: number): number
````

## File: src/test/helpers/api-route.ts
````typescript
/**
 * @fileoverview Unified API route testing utilities for Next.js.
 *
 * Provides:
 * - Request factories (makeJsonRequest, createRouteParamsContext)
 * - Hoisted mocks for withApiGuards dependencies
 * - Auth/cookies/rate-limiting test controls
 */
⋮----
import type { User } from "@supabase/supabase-js";
import { NextRequest } from "next/server";
import { afterEach, vi } from "vitest";
import {
  setRateLimitFactoryForTests,
  setSupabaseFactoryForTests,
} from "@/lib/api/factory";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { createMockSupabaseClient } from "@/test/mocks/supabase";
import { registerUpstashMocksWithVitest } from "@/test/upstash/setup";
import { getMockCookiesForTest } from "./route";
import { unsafeCast } from "./unsafe-cast";
⋮----
// ---- REQUEST FACTORIES ------------------------------------------------------
⋮----
/**
 * Create a NextRequest with JSON body for API route tests.
 *
 * @param url - Request URL (can be relative or absolute)
 * @param body - Request body (will be JSON stringified)
 * @param init - Optional headers and method overrides
 * @returns NextRequest instance
 *
 * @example
 * ```ts
 * const req = makeJsonRequest("/api/auth/mfa/verify", { code: "123456" });
 * const res = await POST(req, context);
 * ```
 */
export function makeJsonRequest(
  url: string,
  body: unknown,
  init?: { headers?: HeadersInit; method?: string }
): NextRequest
⋮----
// Re-export from route.ts to avoid duplication
⋮----
// ---- ROUTE MOCK STATE ------------------------------------------------------
⋮----
type RateLimitResult = {
  limit: number;
  remaining: number;
  reset: number;
  success: boolean;
};
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case
⋮----
// Create a lazily-initialized Supabase client holder
// The actual client is created after imports are resolved
⋮----
const getSupabaseClient = () =>
⋮----
/** Reset shared mocks to their default state (call in `beforeEach`). */
export function resetApiRouteMocks(): void
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case
⋮----
// Reset Supabase client with current state by resetting the lazy holder
⋮----
// Recreate the client with current STATE.user
⋮----
// Most API route tests should not depend on Redis/Upstash availability.
// Default to a deterministic allow response unless a test overrides this.
⋮----
/**
 * Override the mocked Supabase user returned by `withApiGuards`.
 *
 * Accepts partial user objects for convenience in tests and merges them with a
 * fully-populated default user to satisfy Supabase's required fields.
 *
 * @param user - The user to inject or null to simulate unauthenticated.
 */
export function mockApiRouteAuthUser(user: User | null | Partial<User>): void
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case fields
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case fields
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case fields
⋮----
// Explicitly merge metadata objects to preserve defaults
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case fields
⋮----
// biome-ignore lint/style/useNamingConvention: Supabase API uses snake_case fields
⋮----
// Ensure mfa methods are available on the mocked supabase auth client
const ensureMfaMock = (client: ReturnType<typeof createMockSupabaseClient>) =>
⋮----
/** Enable rate limiting (Redis available). */
export function enableApiRouteRateLimit(): void
⋮----
/** Disable rate limiting, simulating missing Redis configuration. */
export function disableApiRouteRateLimit(): void
⋮----
/**
 * Configure the next rate limit evaluation result.
 * Set `success` to false to return 429 responses from `withApiGuards`.
 */
export function mockApiRouteRateLimitOnce(overrides: Partial<RateLimitResult>): void
⋮----
/** Replace the cookie jar returned by mocked `cookies()`. */
export function mockApiRouteCookies(cookies: Record<string, string>): void
⋮----
/** Get the current Supabase client mock (lazy-initialized). */
export const getApiRouteSupabaseMock = ()
⋮----
/** Override the next redis.evalsha response returned to Upstash rate limiters. */
export function mockApiRouteRedisEvalshaOnce(result: RateLimitResult): void
⋮----
// Ensure Supabase factory resets between tests to avoid cross-suite leakage.
````

## File: src/test/msw/handlers/api-routes.ts
````typescript
/**
 * @fileoverview MSW handlers for Next.js API routes.
 *
 * Provides default mock responses for internal API routes.
 * Tests can override these handlers using server.use() for specific scenarios.
 */
⋮----
import { HttpResponse, http, type JsonBodyType } from "msw";
⋮----
// ===== SHARED RESPONSE DATA =====
⋮----
// ===== HANDLER FACTORY =====
⋮----
/** Creates handlers for both relative and absolute URL patterns. */
function createHandler<T extends JsonBodyType>(
  method: "get" | "post",
  path: string,
  response: T
): ReturnType<typeof http.get>[]
⋮----
const handler = ()
⋮----
// ===== HANDLERS =====
⋮----
/**
 * Default API route handlers providing happy-path responses.
 */
⋮----
// GET /api/accommodations/suggestions
⋮----
// POST /api/accommodations/search
⋮----
// POST /api/activities/search
⋮----
// GET /api/ping
⋮----
// GET /api/flights/popular-destinations
````

## File: src/ai/tools/server/calendar.ts
````typescript
/**
 * @fileoverview Calendar tools for AI SDK v6.
 *
 * Provides tools for creating calendar events, checking availability, and
 * exporting itineraries to ICS format.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import { TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import {
  createCalendarEventInputSchema,
  createCalendarEventOutputSchema,
  type EventDateTime,
  exportItineraryToIcsInputSchema,
  exportItineraryToIcsOutputSchema,
  freeBusyRequestSchema,
  getAvailabilityOutputSchema,
} from "@schemas/calendar";
import { createEvent, queryFreeBusy } from "@/lib/calendar/google";
import { generateIcsFromEvents } from "@/lib/calendar/ics";
⋮----
/**
 * Creates calendar events in Google Calendar.
 */
⋮----
const toIsoDateTime = (value: EventDateTime): string =>
⋮----
/**
 * Checks calendar availability and free/busy status.
 */
⋮----
/**
 * Exports calendar events to ICS format.
 */
⋮----
// biome-ignore lint/suspicious/useAwait: createAiTool requires Promise return type
````

## File: src/app/api/calendar/ics/export/route.ts
````typescript
/**
 * @fileoverview ICS export endpoint.
 *
 * Generates ICS file from events payload using shared generator.
 * Authentication required.
 */
⋮----
// Security: Route handlers are dynamic by default with Cache Components.
// Using withApiGuards({ auth: true }) ensures this route uses cookies/headers,
// making it dynamic and preventing caching of user-specific data.
⋮----
import { type IcsExportRequest, icsExportRequestSchema } from "@schemas/calendar";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { withApiGuards } from "@/lib/api/factory";
import { generateIcsFromEvents, sanitizeCalendarFilename } from "@/lib/calendar/ics";
⋮----
/**
 * Handles the ICS export request by validating payloads, enforcing rate
 * limits, and returning the generated calendar file.
 *
 * Uses the shared ICS generator to ensure consistency with AI tools.
 *
 * @param req - HTTP request containing calendar metadata and Google-style events.
 * @param routeContext - Route context from withApiGuards
 * @returns Response with the ICS attachment or JSON error payload.
 */
````

## File: src/app/auth/password/reset/route.ts
````typescript
/**
 * @fileoverview Password reset route handler using Supabase SSR.
 *
 * Accepts a password reset token and new password, verifies the token using
 * Supabase Auth, and then updates the user's password.
 */
⋮----
import { passwordResetPayloadSchema } from "@schemas/auth";
import type { EmailOtpType } from "@supabase/supabase-js";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
import { parseJsonBody } from "@/lib/api/route-helpers";
import { createServerSupabase } from "@/lib/supabase/server";
import { emitOperationalAlertOncePerWindow } from "@/lib/telemetry/degraded-mode";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
export async function POST(request: NextRequest): Promise<NextResponse>
⋮----
// Sanitize validation errors for auth endpoints - expose only field names, not internal codes
⋮----
// Verify the password recovery token.
⋮----
// Use uniform error code to avoid leaking which step failed
⋮----
// Use uniform error code to avoid leaking which step failed
````

## File: src/app/dashboard/trips/[id]/page.tsx
````typescript
/**
 * @fileoverview Trip details dashboard page that renders itinerary, budget,
 * and export actions for a specific trip id sourced from the store.
 */
⋮----
import {
  ArrowLeftIcon,
  CalendarIcon,
  DollarSignIcon,
  DownloadIcon,
  EditIcon,
  MapPinIcon,
  SettingsIcon,
  Share2Icon,
  UsersIcon,
} from "lucide-react";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useMemo, useRef } from "react";
import { BudgetTracker } from "@/components/features/trips/budget-tracker";
import { ItineraryBuilder } from "@/components/features/trips/itinerary-builder";
import { TripTimeline } from "@/components/features/trips/trip-timeline";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useToast } from "@/components/ui/use-toast";
import { useTrip } from "@/hooks/use-trips";
import { handleApiError } from "@/lib/api/error-types";
import { exportTripToIcs } from "@/lib/calendar/trip-export";
import { DateUtils } from "@/lib/dates/unified-date-utils";
import { ROUTES } from "@/lib/routes";
import { recordClientErrorOnActiveSpan } from "@/lib/telemetry/client-errors";
import { parseTripDate } from "@/lib/trips/parse-trip-date";
import { statusVariants } from "@/lib/variants/status";
import { useTripItineraryStore } from "@/stores/trip-itinerary-store";
⋮----
const sanitizeTripTitleForFilename = (title?: string) =>
⋮----
/**
 * Renders the trip dashboard for the requested trip id sourced from the URL.
 *
 * @returns Structured trip overview including itinerary views and calendar
 * export controls.
 */
⋮----
// Pass null to useTrip when tripId is invalid to prevent requests to /api/trips/NaN
⋮----
// Track handled errors to prevent duplicate toasts/redirects
⋮----
// Normalize error for consistent handling
⋮----
// Generate error key for deduplication
⋮----
// Skip if already handled this exact error
⋮----
// 401: Authentication required
⋮----
// 403: Access denied
⋮----
// 404: Not found
⋮----
// Network error
⋮----
// 5xx: Server error
⋮----
// Generic error fallback - use userMessage for friendly text
⋮----
const handleBackToTrips = () =>
⋮----
// Merge trip with destinations first so helpers can reference it
⋮----
// Parse start/end dates once to avoid duplicate telemetry/errors
⋮----
const getTripStatus = () =>
⋮----
const getTripDuration = () =>
⋮----
const formatParsedDate = (date: Date | null) =>
⋮----
/**
   * Maps trip status to statusVariants with fallback for neutral states.
   * Active/upcoming use statusVariants; draft/completed use neutral gray.
   */
type TripStatus = ReturnType<typeof getTripStatus>;
⋮----
const assertNever = (value: never): never =>
⋮----
const getStatusClassName = (status: TripStatus) =>
⋮----
const handleExportToCalendar = async (): Promise<void> =>
⋮----
{/* Header */}
⋮----
<Badge className=
⋮----
{/* Trip Overview */}
⋮----

⋮----
{/* Main Content Tabs */}
⋮----
{/* Timeline */}
⋮----
{/* Budget Tracker */}
⋮----
{/* Quick Stats */}
⋮----
{/* Additional budget features would go here */}
````

## File: src/components/auth/reset-password-form.tsx
````typescript
/**
 * @fileoverview Password reset form component.
 *
 * Handles password reset requests via Supabase Auth. Provides feedback for
 * success/error states and navigation.
 */
⋮----
import {
  AlertCircleIcon,
  ArrowLeftIcon,
  CheckCircle2Icon,
  Loader2Icon,
  MailIcon,
} from "lucide-react";
import Link from "next/link";
import React from "react";
import { z } from "zod";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { getClientEnv } from "@/lib/env/client";
import { cn } from "@/lib/utils";
import { statusVariants } from "@/lib/variants/status";
⋮----
/** Schema for validating password reset response payload. */
⋮----
/**
 * Props for the ResetPasswordForm component.
 */
interface ResetPasswordFormProps {
  /** Additional CSS classes for styling. */
  className?: string;
}
⋮----
/** Additional CSS classes for styling. */
⋮----
/**
 * Password reset form component.
 *
 * Allows users to request password reset emails. Handles form submission,
 * feedback messages, and navigation.
 *
 * @param props - Component props
 * @param props.className - Additional CSS classes
 * @returns The password reset form JSX element
 */
⋮----
// Memoize path calculations since they depend only on static env config
⋮----
const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) =>
⋮----
// Parse and validate response with Zod for runtime guarantees
⋮----
// Redirect back to login after a short delay for convenience.
⋮----
<Alert className=
⋮----
setIsSuccess(false);
setMessage(null);
setError(null);
⋮----
onChange=
⋮----
/**
 * Skeleton loading state for the password reset form.
 *
 * Displays placeholder content while the password reset form is loading.
 *
 * @returns The password reset form skeleton JSX element
 */
````

## File: src/components/features/security/security-dashboard.tsx
````typescript
/**
 * @fileoverview Server-first security dashboard rendering live security data.
 */
⋮----
import type { SecurityEvent } from "@schemas/security";
import { DefaultMetrics } from "@schemas/security";
import {
  ActivityIcon,
  AlertTriangleIcon,
  CheckCircle2Icon,
  LockIcon,
  MonitorIcon,
  ShieldIcon,
  UserCheckIcon,
} from "lucide-react";
import type React from "react";
import {
  ActiveSessionsList,
  ConnectionsSummary,
  SecurityEventsList,
} from "@/components/features/security/security-dashboard-client";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { getUserSecurityEvents, getUserSecurityMetrics } from "@/lib/security/service";
import { getCurrentSessionId, listActiveSessions } from "@/lib/security/sessions";
import { createAdminSupabase } from "@/lib/supabase/admin";
import { createServerSupabase, getCurrentUser } from "@/lib/supabase/server";
import { createServerLogger } from "@/lib/telemetry/logger";
⋮----
/**
 * Get the security data for the current user.
 *
 * @returns The security data.
 */
async function GetSecurityData()
⋮----
/** The risk color for each security event risk level. */
⋮----
/**
 * The security dashboard component.
 *
 * @returns The security dashboard component.
 */
export async function SecurityDashboard()
⋮----
/** Metric tile props. */
function MetricTile({
  label,
  value,
  icon,
}: {
  label: string;
  value: string;
  icon: React.ReactNode;
})
````

## File: src/hooks/use-authenticated-api.ts
````typescript
/**
 * @fileoverview React hook for authenticated API requests.
 *
 * Provides a thin, Supabase-SSR-aligned wrapper around the shared `apiClient`.
 * Authentication is enforced server-side via Supabase cookie sessions and
 * route guards; this hook does not manage JWTs or refresh tokens.
 */
⋮----
import { useCallback, useMemo, useRef } from "react";
import { apiClient } from "@/lib/api/api-client";
import { ApiError } from "@/lib/api/error-types";
⋮----
/**
 * Hook for authenticated API calls using Supabase SSR cookies.
 *
 * This hook provides typed HTTP method helpers (get, post, put, patch, delete,
 * upload) and request cancellation via AbortController. It assumes that all
 * `/api/*` routes enforce authentication via `withApiGuards` and Supabase
 * cookie-based sessions.
 *
 * @returns Object containing authenticated API methods, a low-level
 * `makeAuthenticatedRequest` helper, and a `cancelRequests` function.
 */
export function useAuthenticatedApi()
⋮----
/**
   * Options for authenticated requests.
   * Extends `RequestInit` with optional `params` for query string support.
   */
type AuthFetchOptions = RequestInit & {
    params?: Record<string, string | number | boolean>;
    retries?: number;
    timeout?: number;
  };
⋮----
// Build headers
⋮----
// Prepare body: support FormData, JSON strings, or plain objects
⋮----
// Do not force content-type for FormData
⋮----
data = options.body; // Fallback, but will be JSON.stringified downstream
⋮----
// ApiClient handles abort signals and timeouts internally, returning
// properly typed ApiError instances. Pass them through unchanged.
⋮----
// Detect network failures: fetch throws TypeError on network errors
// (DNS failure, connection refused, CORS blocked, etc.). This can
// happen even when navigator.onLine reports true, so we treat all
// fetch TypeErrors as network errors for consistent semantics.
⋮----
// Fallback for unexpected errors
⋮----
/**
   * Cancels any in-flight API requests.
   */
⋮----
/**
 * Return type of the useAuthenticatedApi hook.
 *
 * This type represents the complete return value of the useAuthenticatedApi hook,
 * including the authenticated API methods, low-level request helper, and
 * cancellation function.
 */
export type AuthenticatedApiReturn = ReturnType<typeof useAuthenticatedApi>;
⋮----
/**
 * Type of the authenticatedApi object returned by useAuthenticatedApi.
 *
 * This type represents just the API methods object (get, post, put, patch, delete, upload)
 * without the authentication state properties.
 */
export type AuthenticatedApi = AuthenticatedApiReturn["authenticatedApi"];
````

## File: src/lib/idempotency/redis.ts
````typescript
/**
 * @fileoverview Simple Redis-based idempotency helpers using Upstash REST.
 *
 * Implements configurable fail mode to control behavior when Redis
 * is unavailable:
 * - Fail open (default): Allow processing, may cause duplicates
 * - Fail closed: Throw error to prevent potential duplicate processing
 */
⋮----
import { z } from "zod";
⋮----
import { getRedis } from "@/lib/redis";
import { emitOperationalAlertOncePerWindow } from "@/lib/telemetry/degraded-mode";
import { warnRedisUnavailable } from "@/lib/telemetry/redis";
⋮----
// biome-ignore lint/style/useNamingConvention: Env var casing is uppercase by convention
⋮----
/**
 * Default fail mode from environment variable.
 * Set IDEMPOTENCY_FAIL_OPEN=false to fail closed (throw on Redis unavailable).
 * Evaluated once at module load; pass `failOpen` option per call to override at runtime.
 */
⋮----
// biome-ignore lint/style/useNamingConvention: Env var casing is uppercase by convention
⋮----
/**
 * Error thrown when idempotency check fails due to Redis unavailability
 * and fail mode is "closed".
 */
export class IdempotencyServiceUnavailableError extends Error
⋮----
constructor()
⋮----
/**
 * Options for reserving an idempotency key.
 */
export interface ReserveKeyOptions {
  /**
   * TTL for the idempotency key in seconds.
   * @default 300 (5 minutes)
   */
  ttlSeconds?: number;

  /**
   * Whether to fail open when Redis is unavailable.
   * - true (default): Return true (allow processing), log warning
   * - false: Throw IdempotencyServiceUnavailableError
   *
   * Can also be set globally via IDEMPOTENCY_FAIL_OPEN env var (read at module load).
   */
  failOpen?: boolean;

  /**
   * Alias for fail-open behavior with explicit naming.
   * When set, overrides failOpen.
   */
  degradedMode?: "fail_closed" | "fail_open";
}
⋮----
/**
   * TTL for the idempotency key in seconds.
   * @default 300 (5 minutes)
   */
⋮----
/**
   * Whether to fail open when Redis is unavailable.
   * - true (default): Return true (allow processing), log warning
   * - false: Throw IdempotencyServiceUnavailableError
   *
   * Can also be set globally via IDEMPOTENCY_FAIL_OPEN env var (read at module load).
   */
⋮----
/**
   * Alias for fail-open behavior with explicit naming.
   * When set, overrides failOpen.
   */
⋮----
function resolveDegradedMode(options: {
  degradedMode?: "fail_closed" | "fail_open";
  failOpen?: boolean;
}): "fail_closed" | "fail_open"
⋮----
function getIdempotencyNamespace(key: string): string
⋮----
/**
 * Attempt to reserve an idempotency key for a specified TTL.
 *
 * @param key - Unique key for this idempotent operation
 * @param ttlSecondsOrOptions - TTL in seconds (number) or options object
 * @returns true if reserved (first occurrence), false if duplicate
 * @throws IdempotencyServiceUnavailableError if Redis unavailable and failOpen=false
 *
 * @example
 * ```ts
 * // Basic usage (fail open by default)
 * const isUnique = await tryReserveKey("event:123", 300);
 *
 * // Fail closed for critical operations
 * const isUnique = await tryReserveKey("payment:456", { ttlSeconds: 600, failOpen: false });
 * ```
 */
export async function tryReserveKey(
  key: string,
  ttlSecondsOrOptions: number | ReserveKeyOptions = 300
): Promise<boolean>
⋮----
// Parse options (backwards compatible with number-only signature)
⋮----
// Fail open: allow processing (may cause duplicates during Redis outage)
⋮----
/**
 * Check if an idempotency key exists without reserving it.
 *
 * Unlike `tryReserveKey`, this function returns a boolean even on Redis errors
 * rather than throwing `IdempotencyServiceUnavailableError`. This asymmetry
 * is intentional:
 *
 * - **hasKey** is for read-only duplicate detection where callers need a simple
 *   boolean answer. Return values map to fail modes:
 *   - `fail_closed` → returns `true` (treat as duplicate, deny processing)
 *   - `fail_open` → returns `false` (treat as new, allow processing)
 *
 * - **tryReserveKey** must atomically reserve the key or fail explicitly for
 *   strict lock-acquisition semantics. Throwing on `fail_closed` forces callers
 *   to handle the outage scenario rather than silently proceeding.
 *
 * Operational alerts are emitted on Redis errors, so callers can rely on
 * centralized logging/monitoring rather than catching exceptions.
 *
 * @param key - Unique key to check
 * @param options - Optional overrides for fail mode
 * @returns true if key exists (is a duplicate), false if new
 */
export async function hasKey(
  key: string,
  options?: Pick<ReserveKeyOptions, "degradedMode" | "failOpen">
): Promise<boolean>
⋮----
// Fail-open: allow processing (treat as not found)
// Fail-closed: block processing by treating as duplicate
⋮----
/**
 * Release an idempotency key (for rollback scenarios).
 *
 * @param key - Unique key to release
 * @param options - Optional overrides for fail mode
 * @returns true if key was released, false if not found or Redis unavailable
 */
export async function releaseKey(
  key: string,
  options?: Pick<ReserveKeyOptions, "degradedMode" | "failOpen">
): Promise<boolean>
````

## File: src/lib/metrics/api-metrics.ts
````typescript
/**
 * @fileoverview API metrics recording helper.
 *
 * Fire-and-forget metrics recording for API routes. Records to both
 * Supabase (persistent) and Upstash Redis (real-time counters).
 * Uses OpenTelemetry for tracing.
 */
⋮----
import type { HttpMethod } from "@schemas/supabase";
import { getRedis, incrCounter } from "@/lib/redis";
import type { ApiMetricInsert } from "@/lib/supabase/database.types";
import { createServerSupabase } from "@/lib/supabase/server";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/**
 * API metric data for recording.
 */
export interface ApiMetric {
  /** Request duration in milliseconds */
  durationMs: number;
  /** Low-cardinality route key (e.g., a stable telemetry name or rateLimit key) */
  endpoint: string;
  /** Error class name for failed requests */
  errorType?: string;
  /** HTTP method (compile-time validated enum) */
  method: HttpMethod;
  /** Rate limit key used for this request */
  rateLimitKey?: string;
  /** HTTP response status code */
  statusCode: number;
  /** Authenticated user ID (undefined for anonymous) */
  userId?: string;
}
⋮----
/** Request duration in milliseconds */
⋮----
/** Low-cardinality route key (e.g., a stable telemetry name or rateLimit key) */
⋮----
/** Error class name for failed requests */
⋮----
/** HTTP method (compile-time validated enum) */
⋮----
/** Rate limit key used for this request */
⋮----
/** HTTP response status code */
⋮----
/** Authenticated user ID (undefined for anonymous) */
⋮----
/**
 * Records an API metric to Supabase and increments Redis counters.
 *
 * This is designed to be fire-and-forget to avoid blocking API responses.
 * Errors are silently swallowed to prevent metric recording from affecting
 * request handling.
 *
 * @param metric - API metric data to record
 */
export async function recordApiMetric(metric: ApiMetric): Promise<void>
⋮----
// Fire-and-forget batch operations
⋮----
// 1. Insert into Supabase api_metrics table
⋮----
// Supabase table columns use snake_case
⋮----
/* biome-ignore lint/style/useNamingConvention: Supabase column */
⋮----
/* biome-ignore lint/style/useNamingConvention: Supabase column */
⋮----
/* biome-ignore lint/style/useNamingConvention: Supabase column */
⋮----
/* biome-ignore lint/style/useNamingConvention: Supabase column */
⋮----
/* biome-ignore lint/style/useNamingConvention: Supabase column */
⋮----
// 2. Increment Redis counters
⋮----
// Total request counter (7-day TTL)
⋮----
// Error counter if status >= 400 (7-day TTL)
⋮----
// Endpoint-specific counter (1-day TTL)
⋮----
// Execute all operations in parallel, swallow errors
⋮----
/**
 * Utility to wrap metric recording as fire-and-forget.
 *
 * Prevents unhandled promise rejections while ensuring metrics
 * don't block the main request flow.
 *
 * @param metric - API metric data to record
 */
export function fireAndForgetMetric(metric: ApiMetric): void
⋮----
// Silently swallow - metrics should never affect request handling
````

## File: src/lib/supabase/factory.ts
````typescript
/**
 * @fileoverview Server-only Supabase SSR factories and cookie adapter helpers.
 */
⋮----
import {
  type CookieMethodsServer,
  createServerClient as createSsrServerClient,
} from "@supabase/ssr";
import type { SupabaseClient, User } from "@supabase/supabase-js";
import type { ReadonlyRequestCookies } from "next/dist/server/web/spec-extension/adapters/request-cookies";
import { getClientEnv } from "@/lib/env/client";
import { getServerEnv } from "@/lib/env/server";
import { TELEMETRY_SERVICE_NAME } from "@/lib/telemetry/constants";
import { hashTelemetryIdentifier } from "@/lib/telemetry/identifiers";
import { createServerLogger } from "@/lib/telemetry/logger";
import {
  recordErrorOnSpan,
  withTelemetrySpan,
  withTelemetrySpanSync,
} from "@/lib/telemetry/span";
import type { Database } from "./database.types";
⋮----
/** Type alias for server-side Supabase client with Database schema. */
export type ServerSupabaseClient = SupabaseClient<Database>;
⋮----
/** Type alias for browser-side Supabase client with Database schema. */
export type BrowserSupabaseClient = SupabaseClient<Database>;
⋮----
/** Options for creating a server Supabase client. */
type CookieSetAllArgs = Parameters<NonNullable<CookieMethodsServer["setAll"]>>[0];
⋮----
export interface CreateServerSupabaseOptions {
  /**
   * Cookie adapter for SSR cookie handling.
   *
   * Required: provide an explicit adapter at the boundary.
   * For Next.js Route Handlers / Server Components, prefer `createServerSupabase()`
   * from `./server` which wires up `cookies()` for you.
   */
  cookies: CookieMethodsServer;

  /**
   * Whether to enable OpenTelemetry tracing for this client.
   * @default true
   */
  enableTracing?: boolean;

  /**
   * Custom span name for telemetry.
   * @default 'supabase.init'
   */
  spanName?: string;
}
⋮----
/**
   * Cookie adapter for SSR cookie handling.
   *
   * Required: provide an explicit adapter at the boundary.
   * For Next.js Route Handlers / Server Components, prefer `createServerSupabase()`
   * from `./server` which wires up `cookies()` for you.
   */
⋮----
/**
   * Whether to enable OpenTelemetry tracing for this client.
   * @default true
   */
⋮----
/**
   * Custom span name for telemetry.
   * @default 'supabase.init'
   */
⋮----
/** Result of getCurrentUser operation. */
export interface GetCurrentUserResult {
  user: User | null;
  error: Error | null;
}
⋮----
function warnCookieAdapterFailureOnce(
  operation: "getAll" | "setAll",
  error: unknown
): void
⋮----
/**
 * Creates a Supabase server client with SSR cookie handling and OpenTelemetry tracing.
 *
 * This factory function creates a server-side Supabase client configured for Next.js
 * App Router (React Server Components and Route Handlers). Callers must provide an
 * explicit cookie adapter at the request boundary.
 *
 * @param options - Configuration options for the server client
 * @returns A typed Supabase client instance for server-side operations
 * @throws Error if required environment variables are missing
 */
export function createServerSupabaseClient(
  options: CreateServerSupabaseOptions
): ServerSupabaseClient
⋮----
// Validate environment variables using Zod schema
⋮----
const createClient = () =>
⋮----
// Use @supabase/ssr for proper SSR cookie handling
⋮----
// Wrap client creation in OpenTelemetry span (synchronous operation)
⋮----
/**
 * Creates a Supabase client for middleware with client-only environment variables.
 *
 * This factory function creates a server-side Supabase client specifically for middleware
 * running in the Edge runtime. It only validates client-safe environment variables
 * (NEXT_PUBLIC_*) to avoid dependency on server secrets that aren't available in Edge.
 *
 * @param options - Configuration options for the middleware client
 * @returns A typed Supabase client instance for middleware operations
 * @throws Error if required client environment variables are missing
 *
 * @example
 * const supabase = createMiddlewareSupabase({
 *   cookies: customCookieAdapter,
 *   enableTracing: false, // Disable tracing in Edge runtime
 * });
 */
export function createMiddlewareSupabase(
  options: CreateServerSupabaseOptions
): ServerSupabaseClient
⋮----
// Validate only client environment variables for Edge runtime compatibility
⋮----
// Use @supabase/ssr for proper SSR cookie handling
⋮----
// Wrap client creation in OpenTelemetry span (synchronous operation)
⋮----
/**
 * Gets the current authenticated user with OpenTelemetry tracing.
 *
 * This helper function provides a unified way to retrieve the current user,
 * eliminating duplicate auth.getUser() calls across middleware, route handlers,
 * and server components. It includes telemetry for observability and redacts
 * sensitive user information in logs.
 *
 * @param supabase - Supabase client instance
 * @param options - Optional configuration
 * @returns Promise resolving to user and error state
 */
export async function getCurrentUser(
  supabase: ServerSupabaseClient,
  options: { enableTracing?: boolean; spanName?: string } = {}
): Promise<GetCurrentUserResult>
⋮----
const fetchUser = async (): Promise<GetCurrentUserResult> =>
⋮----
// If there's an error, record it but don't throw (we return it in the result)
⋮----
/**
 * Creates a cookie adapter from Next.js ReadonlyRequestCookies.
 *
 * This utility function converts Next.js cookie store to the CookieMethodsServer interface
 * required by the Supabase factory. It's primarily used in server components and
 * route handlers.
 *
 * @param cookieStore - Next.js readonly request cookies
 * @returns Cookie adapter instance
 */
export function createCookieAdapter(
  cookieStore: ReadonlyRequestCookies
): CookieMethodsServer
⋮----
// Ignore cookie set errors (e.g., locked headers in Server Components).
⋮----
function createCookieMethods(adapter?: CookieMethodsServer): CookieMethodsServer
⋮----
// Ignore cookie set errors (e.g., locked headers).
⋮----
// Runtime-only utilities (e.g., isSupabaseClient) live in guards.ts to avoid
// coupling this server-only module to client bundles.
````

## File: src/lib/webhooks/handler.ts
````typescript
/**
 * @fileoverview Webhook handler factory with rate limiting, signature verification, idempotency, and telemetry.
 */
⋮----
import type { NextRequest, NextResponse } from "next/server";
import { ZodError } from "zod";
import {
  IdempotencyServiceUnavailableError,
  tryReserveKey,
} from "@/lib/idempotency/redis";
import { type Span, withTelemetrySpan } from "@/lib/telemetry/span";
import {
  WebhookDuplicateError,
  WebhookError,
  type WebhookErrorCode,
  WebhookServiceUnavailableError,
  WebhookValidationError,
} from "./errors";
import { buildEventKey, parseAndVerify, type WebhookPayload } from "./payload";
import { checkWebhookRateLimit, createWebhookResponse } from "./rate-limit";
⋮----
function normalizeWebhookError(error: unknown): WebhookError
⋮----
function getSafeErrorMessage(code: WebhookErrorCode, status: number): string
⋮----
// 5xx errors always return a generic message to avoid leaking details.
⋮----
// ===== TYPES =====
⋮----
/**
 * Result returned by a webhook handler.
 */
export type WebhookHandlerResult = Record<string, unknown>;
⋮----
/**
 * Configuration for creating a webhook handler.
 */
export interface WebhookHandlerConfig<T extends WebhookHandlerResult> {
  /**
   * Name of the webhook handler (used in telemetry span names).
   * Example: "trips", "files", "cache"
   */
  name: string;

  /**
   * Optional table filter - only process webhooks for this table.
   * If not set, all tables are processed.
   */
  tableFilter?: string;

  /**
   * Enable idempotency checking via Redis.
   * When enabled, duplicate events (by event key) are rejected.
   * @default true
   */
  enableIdempotency?: boolean;

  /**
   * TTL for idempotency keys in seconds.
   * @default 300 (5 minutes)
   */
  // biome-ignore lint/style/useNamingConvention: TTL is established acronym for Time To Live
  idempotencyTTL?: number;

  /**
   * Maximum request body size in bytes.
   * @default 65536 (64KB)
   */
  maxBodySize?: number;

  /**
   * Custom handler function to process the webhook payload.
   * Called after all validation and deduplication checks pass.
   *
   * @param payload - Verified webhook payload
   * @param eventKey - Unique event key for this webhook
   * @param span - OpenTelemetry span for adding attributes
   * @param req - Original request (for accessing headers, origin, etc.)
   * @returns Handler result object merged into response JSON
   */
  handle: (
    payload: WebhookPayload,
    eventKey: string,
    span: Span,
    req: NextRequest
  ) => Promise<T>;
}
⋮----
/**
   * Name of the webhook handler (used in telemetry span names).
   * Example: "trips", "files", "cache"
   */
⋮----
/**
   * Optional table filter - only process webhooks for this table.
   * If not set, all tables are processed.
   */
⋮----
/**
   * Enable idempotency checking via Redis.
   * When enabled, duplicate events (by event key) are rejected.
   * @default true
   */
⋮----
/**
   * TTL for idempotency keys in seconds.
   * @default 300 (5 minutes)
   */
// biome-ignore lint/style/useNamingConvention: TTL is established acronym for Time To Live
⋮----
/**
   * Maximum request body size in bytes.
   * @default 65536 (64KB)
   */
⋮----
/**
   * Custom handler function to process the webhook payload.
   * Called after all validation and deduplication checks pass.
   *
   * @param payload - Verified webhook payload
   * @param eventKey - Unique event key for this webhook
   * @param span - OpenTelemetry span for adding attributes
   * @param req - Original request (for accessing headers, origin, etc.)
   * @returns Handler result object merged into response JSON
   */
⋮----
// ===== HANDLER FACTORY =====
⋮----
/**
 * Creates a standardized webhook POST handler with built-in:
 * - Rate limiting (returns 429 if exceeded)
 * - Body size validation (returns 413 if too large)
 * - HMAC signature verification (returns 401 if invalid)
 * - Optional table filtering (returns skipped: true for non-matching tables)
 * - Optional idempotency checking (returns duplicate: true for repeated events)
 * - OpenTelemetry span instrumentation
 *
 * @param config - Handler configuration
 * @returns Next.js POST route handler function
 *
 * @example
 * ```ts
 * // src/app/api/hooks/trips/route.ts
 * export const POST = createWebhookHandler({
 *   name: "trips",
 *   tableFilter: "trip_collaborators",
 *   async handle(payload, eventKey, span, req) {
 *     // Custom processing logic
 *     const result = await enqueueJob("notify", { eventKey, payload }, "/api/jobs/notify");
 *     return { enqueued: !!result };
 *   },
 * });
 * ```
 */
export function createWebhookHandler<T extends WebhookHandlerResult>(
  config: WebhookHandlerConfig<T>
)
⋮----
// 1. Rate limiting
⋮----
// Helper to create responses with rate limit headers attached
const withRateLimitHeaders = (body: Record<string, unknown>, status?: number)
⋮----
// 2. Body size validation
⋮----
// 3. Parse and verify HMAC signature
⋮----
// 4. Build event key (used for global idempotency across handlers)
⋮----
// 5. Idempotency check (global)
⋮----
// 6. Table filtering (post-idempotency to prevent duplicate processing
// across multiple handlers that may receive the same event)
⋮----
// ===== EXPORTS =====
````

## File: src/lib/webhooks/payload.ts
````typescript
/**
 * @fileoverview Webhook payload parsing and HMAC verification with bounded, single-pass body reads.
 */
⋮----
import { createHash } from "node:crypto";
import type { WebhookPayload } from "@schemas/webhooks";
import { webhookPayloadSchema } from "@schemas/webhooks";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
import { PayloadTooLargeError, readRequestBodyBytesWithLimit } from "@/lib/http/body";
import { computeHmacSha256Hex, timingSafeEqualHex } from "@/lib/security/webhook";
import { emitOperationalAlertOncePerWindow } from "@/lib/telemetry/degraded-mode";
import { sanitizePathnameForTelemetry } from "@/lib/telemetry/route-key";
import { addEventToActiveSpan } from "@/lib/telemetry/span";
⋮----
/** Raw webhook payload structure from external source. */
type RawWebhookPayload = {
  record: Record<string, unknown> | null;
  schema?: string;
  table: string;
  type: "INSERT" | "UPDATE" | "DELETE";
} & {
  [OLD_RECORD_KEY]?: Record<string, unknown> | null;
  [OCCURRED_AT_KEY]?: string;
};
⋮----
// Re-export type from schemas
⋮----
/**
 * Normalizes raw webhook payload to internal structure.
 *
 * @param raw - The raw webhook payload from external source.
 * @return Normalized webhook payload (validated via Zod schema).
 */
function normalizeWebhookPayload(raw: RawWebhookPayload): WebhookPayload
⋮----
// Validate using Zod schema
⋮----
function recordVerificationFailure(req: Request, reason: string): void
⋮----
// Safely parse URL to avoid exceptions on malformed request URLs
⋮----
// Fall back to unknown if URL parsing fails
⋮----
export type ParseAndVerifyFailureReason =
  | "body_read_error"
  | "invalid_json"
  | "invalid_payload_shape"
  | "invalid_signature"
  | "missing_secret_env"
  | "missing_signature"
  | "payload_too_large";
⋮----
export type ParseAndVerifyResult =
  | { ok: true; payload: WebhookPayload }
  | { ok: false; reason: ParseAndVerifyFailureReason };
⋮----
/**
 * Parses and verifies a webhook request with HMAC signature.
 *
 * Uses a bounded single-pass body read:
 * 1. Read body bytes once (enforcing a max size)
 * 2. Verify HMAC on raw bytes
 * 3. Parse JSON from the same bytes
 *
 * @param req - The incoming webhook request.
 * @param options - Optional body size limit configuration.
 * @return Object with verification status and optional parsed payload.
 */
export async function parseAndVerify(
  req: Request,
  options: { maxBytes?: number } = {}
): Promise<ParseAndVerifyResult>
⋮----
// Get signature from header
⋮----
// Verify HMAC on raw bytes
⋮----
// Parse JSON from the already-read body
⋮----
// Normalize and validate payload
⋮----
/**
 * Builds a unique event key for webhook deduplication.
 *
 * @param payload - The webhook payload.
 * @return Unique event identifier string.
 */
export function buildEventKey(payload: WebhookPayload): string
````

## File: src/lib/query-keys.ts
````typescript
/**
 * @fileoverview Query key factory for consistent caching patterns across the
 * application. Follows React Query v5 key composition guidance.
 */
⋮----
import type { TimeWindow } from "@schemas/dashboard";
⋮----
// Agent Status & Monitoring
⋮----
// Authentication & User Management
⋮----
// Budget & Finance
⋮----
// Chat & Messages
⋮----
// Currency (external exchange rate data)
⋮----
// Dashboard & Metrics
⋮----
// External API Data
⋮----
// Files & Storage
⋮----
// Memory & Conversation Context
⋮----
// Supabase Real-time Subscriptions
⋮----
// Search & Discovery
⋮----
// Trips & Itineraries
⋮----
/**
 * Utility functions for query key manipulation
 */
⋮----
/**
   * Extract the base key from a query key for invalidation patterns
   */
⋮----
/**
   * Create invalidation patterns for specific entity types
   */
⋮----
/**
   * Check if two query keys share the same base
   */
⋮----
/**
 * Type helpers for query keys
 */
export type QueryKey = typeof queryKeys;
export type QueryKeyPath = keyof QueryKey;
⋮----
/**
 * Builds dynamic query key tuples.
 * @param baseKey - Base key string
 * @param params - Optional parameters object
 * @returns `[key]` or `[key, params]` depending on whether params are provided
 */
export function createQueryKey(
  baseKey: string,
  params?: Record<string, unknown>
): readonly [string] | readonly [string, Record<string, unknown>]
````

## File: AGENTS.md
````markdown
# AGENTS.md – TripSage AI Contract

This file defines required rules for all AI coding agents in this repo. If anything conflicts, **AGENTS.md wins**.

---

## 0. Architecture and Stack

- **Frontend-first:** All features at repository root. Next.js 16, React 19, TypeScript 5.9.
- **AI SDK v6 (exact versions):** `ai@6.0.0-beta.150`, `@ai-sdk/react@3.0.0-beta.153`, `@ai-sdk/openai@3.0.0-beta.96`, `@ai-sdk/anthropic@3.0.0-beta.83`, `@ai-sdk/xai@3.0.0-beta.55`. Use these when researching.
- **Data/State:** Zod v4, Zustand v5, React Query v5, React Hook Form.
- **Backend:** Supabase SSR, Upstash (Redis/Ratelimit/QStash), OpenTelemetry.
- **UI:** Radix UI primitives, Tailwind CSS + CVA + clsx, Lucide icons.
- **External APIs:** Amadeus (travel), Stripe (payments), Resend (email).

---

## 1. Agent Persona and Global Behavior

- **Tone:** Precise, technical, concise. No buzzwords/emojis.
- **Correctness first:** Never sacrifice for brevity. Include trade‑offs for complex tasks; mark unknowns as **UNVERIFIED**.
- **Autonomy:** Use tools without asking. Maintain TODO list via `update_plan`.
- **Safety:** No destructive commands (`rm -rf`, `git reset --hard`) unless requested. Never commit secrets. Delete obsolete files as part of replacements.
- **Evidence:** Prefer primary docs (AGENTS.md, official docs, `docs/`) over blogs. Cite web research; mark inferences.
- **Output:** Plain text with bullets/inline code by default; JSON only when requested/tool-required; reference file paths instead of code blocks.

---

## 2. Planning, Tools, and Research

### 2.1 Planning and investigation

- For any non‑trivial or multi‑step change, use `zen.planner` plus `update_plan` (with exactly one `in_progress` step).
- For design trade‑offs, use `zen.consensus` with weights: Solution Leverage 35%, Application Value 30%, Maintenance 25%, Adaptability 10%.

### 2.2 Search and documentation tools

- **Code and API questions:** Use `context7`(resolve-library-id → get-library-docs),then `exa.get_code_context_exa`.
- **Research/web search:** Use `exa.web_search_exa`.
- **Scraping/Crawling:** Use `exa.crawling_exa`.

---

## 3. Project Layout and Responsibilities

- **Primary app (root):** Next.js 16 workspace at repository root. Core AI in `src/app/api/**` route handlers. Shared schemas/types in `src/domain/schemas` (reuse server/client). Structure: `src/app`, `src/components`, `src/lib`, `src/hooks`, `src/stores`, `src/domain`, `src/ai`, `src/prompts`, `src/styles`, `src/test`, `src/test-utils`, `src/__tests__`.
- **Infrastructure:** Scripts in `scripts/`; containers in `docker/`; tests in `src/**/__tests__`; docs in `docs/`; e2e tests in `e2e/`.

---

## 4. Library-First Principles and Coding Style

### 4.1 Global engineering principles

- **Library-first:** Prefer maintained libraries covering ≥80 % of needs with ≤30 % custom code.
- **KISS / DRY / YAGNI:** Keep solutions straightforward; remove duplication via small focused helpers; implement only what's needed now—no speculative APIs or feature flags (unless requested).
- **Final-only:** Remove superseded code/tests immediately after new behavior lands; no partial migrations.
- **Telemetry/logging:** Use `@/lib/telemetry/{span,logger}` helpers: `withTelemetrySpan()`, `withTelemetrySpanSync()`, `recordTelemetryEvent()`, `createServerLogger()`, `emitOperationalAlert()`. Direct `@opentelemetry/api` only in `lib/telemetry/*` and `lib/supabase/factory.ts`. Client: `@/lib/telemetry/client`. See `docs/development/backend/observability.md`.
  - **Server code:** No `console.*` except test files and telemetry infra.
  - **Client-only UI (`"use client"` modules):** Dev-only `console.*` is allowed when guarded by `process.env.NODE_ENV === 'development'`. Bundlers eliminate these calls in prod builds.
  - **Zustand stores:** Use `createStoreLogger` from `@/lib/telemetry/store-logger` for error tracking via OTEL spans.

### 4.2 TypeScript and frontend style

- **TypeScript:** `strict: true`, `noUnusedLocals`, `noFallthroughCasesInSwitch`. Avoid `any`; use precise unions/generics. Handle `null`/`undefined` explicitly.
- **Unsafe casts:** `as unknown as T` casts are forbidden in production code (`src/**` excluding tests). CI runs `pnpm check:no-new-unknown-casts` on PRs to reject new violations. Use type guards, schema validation, or `satisfies` instead. For test mocks requiring unsafe casts, use `unsafeCast<T>()` from `@/test/helpers/unsafe-cast`.
- **Biome:** `pnpm format:biome`, `pnpm biome:check` (must pass), `pnpm biome:fix`. Do **not** edit `biome.json`; fix code instead.
- **File structure:**
  - Source (`.ts`, `.tsx`): Optional `@fileoverview`, blank line, `"use client"` (if needed), blank line, imports, implementation.
  - Test (`*.test.ts`, `*.spec.ts`): No `@fileoverview`. Use `@vitest-environment` only when overriding default.
- **JSDoc:** Use `/** ... */` for public APIs; `//` for notes. Document top‑level exports and non‑obvious functions. Avoid repeating types or TS‑duplicated tags.
- **IDs/timestamps:** Use `@/lib/security/random` (`secureUuid`, `secureId`, `nowIso`). Never `Math.random` or `crypto.randomUUID` directly.
- **Imports/exports:** Import from slice modules directly (e.g., `@/stores/auth/auth-core`). No barrel files or `export *`.
  - **Path aliases:** `@schemas/*` (Zod), `@domain/*`, `@ai/*`, `@/*` (generic). **Disallowed:** `@/domain/*`, `@/ai/*`, `@/domain/schemas/*`—use short forms.
  - **Relative imports:** Within feature slices prefer relative; cross-boundary use aliases.
  - **Icons:** `lucide-react` `*Icon` suffixed names (e.g., `AlertTriangleIcon`).

### 4.3 State management (frontend)

- **Libraries:** Use `zustand`, `@tanstack/react-query`, Supabase Realtime. No new state/websocket libs without approval.
- **Store organization:** Small stores (<300 LOC): single file. Large stores: slice composition in `stores/<feature>/*` with unified `index.ts`.
- **Middleware order:** `devtools` → `persist` → `withComputed` → store creator. Computed middleware innermost.
- **Computed properties:** Use `withComputed` from `@/stores/middleware/computed` for aggregations, counts, validation flags. Keep compute functions O(1) or O(n). Never use for simple access (use selectors), async ops, or React context-dependent values.
- **Imports:** See 4.2 path aliases; no barrel files.
- **Logging:** `createStoreLogger` for errors; see 4.1 for telemetry rules.
- **Selectors:** Export named selectors: `export const useSearchType = () => useStore(s => s.type);`
- **Details:** See `docs/development/standards/standards.md#zustand-stores` and `docs/development/frontend/zustand-computed-middleware.md`.

### 4.4 Zod v4 schemas

- **ONLY** use Zod v4 APIs; no Zod 3 deprecated APIs.
- **Error handling:** Use unified `error` option (`z.string().min(5, { error: "Too short" })`); avoid `message`, `invalid_type_error`, `required_error`, `errorMap`.
- **String helpers:** Use top‑level (`z.email()`, `z.uuid()`, `z.url()`, `z.ipv4()`, `z.ipv6()`, `z.base64()`, `z.base64url()`); avoid method style.
- **Enums:** Use `z.enum(MyEnum)` for TS enums; not `z.nativeEnum()`.
- **Objects/records:** Prefer `z.strictObject(...)`, `z.looseObject(...)`, `z.record(keySchema, valueSchema)`, `z.partialRecord(z.enum([...]), valueSchema)`. Avoid `z.record(valueSchema)`, `z.deepPartial()`, `.merge()`.
- **Numbers:** Use `z.number().int()` for integers.
- **Defaults/transforms:** Use `.default()` for output defaults; `.prefault()` when default must be parsed.
- **Functions:** Prefer `z.function({ input: [...], output }).implement(...)` or `.implementAsync(...)`; avoid `z.promise()` and `.args().returns()`.
- **Cross-field:** `.refine()` with `path`: `.refine(d => d.end > d.start, { error: "...", path: ["end"] })`.

### 4.5 Schema organization

- **Single file per domain:** Core business + tool input schemas together (e.g., `calendar.ts`, `memory.ts`).
- **Import path:** `@schemas/domain-name`; see 4.2 for aliases.
- **Section markers:** `// ===== CORE SCHEMAS =====`, `// ===== FORM SCHEMAS =====`, `// ===== TOOL INPUT SCHEMAS =====`.
- **Details:** See `docs/development/standards/zod-schema-guide.md`.

---

## 5. Frontend Architecture and Patterns

### 5.1 Next.js route handlers and adapters

- Route Handlers: `src/app/api/**/route.ts` for all server‑side HTTP entrypoints.
- Adapters: parse `NextRequest`, construct SSR clients/ratelimiters/config **inside** handler (no module‑scope), delegate to DI handlers (`_handler.ts`).
- DI handlers: pure functions; accept `supabase`, `resolveProvider`, `limit`, `stream`, `clock`, `logger`, `config`. No `process.env` or global state.

**Import restrictions (scope: `src/app/api/**`):**

| Rule | Required | Exceptions |
|------|----------|------------|
| No direct `createClient` from `@supabase/supabase-js` | `createServerSupabase()` from `@/lib/supabase/server` | Tests, QStash handlers, scripts — use shared helper or add comment |
| No inline `NextResponse.json({ error })` | `errorResponse()` from `@/lib/next/route-helpers` | CLI tools, background handlers (non-route code) |

PR reviewers: enforce in `src/app/api/**`; approve exceptions with justification.

### 5.2 AI SDK v6 usage

- Use AI SDK v6 primitives only; no custom streaming/tool-calling.
- Chat/streaming: `convertToModelMessages()` → `streamText(tools, outputs)` → `result.toUIMessageStreamResponse()`.
- Structured JSON: use `generateObject` or `streamObject` with Zod schemas from `@schemas/*`.

### 5.3 Models and providers

- **Vercel AI Gateway (primary):** `createGateway()` with `AI_GATEWAY_API_KEY`.
- **BYOK registry (alternative):** `src/ai/models/registry.ts`; supports `openai`, `openrouter`, `anthropic`, `xai`.
- **BYOK routes:** Must import `"server-only"`; dynamic by default (never `'use cache'`).
- **Per route:** Use Gateway OR BYOK; never mix.

### 5.4 Caching, Supabase SSR, and performance

- **Caching:** `cacheComponents: true` enabled. Directives (`'use cache'`/`'use cache: private'`) cannot access `cookies()`/`headers()`; public routes only. Auth/BYOK: dynamic. See ADR-0024.
- **Supabase SSR:** `createServerSupabase()` (server-only, auto-dynamic). Never access cookies in Client Components.
- **Performance:** `next/font`, `next/image`, Server Components, Suspense, `useActionState`/`useOptimistic`.

### 5.5 Rate limiting and ephemeral state

- **Rate limiting:** Use `@upstash/ratelimit` + `@upstash/redis`; initialize inside handlers (not module-scope) via `Redis.fromEnv()` and `Ratelimit` per request.
- **Background tasks:** Use Upstash QStash with idempotent, stateless handlers.

### 5.6 Agent configuration

- **Routes (SPEC-0029/ADR-0052):** `/api/config/agents/:agentType` (GET/PUT), versions, rollback. Source: `src/lib/agents/config-resolver.ts`.

### 5.7 Forms and Server Actions

- **Client forms:** `useZodForm` (`@/hooks/use-zod-form`), `useSearchForm`. Components: `Form`, `FormField`, `FormControl`, `FormMessage` from `@/components/ui/form`. Mode: `onChange`; use `form.trigger()` for programmatic validation/step gating; `AbortController` for async cleanup.
- **Server actions:** `"use server"` + `"server-only"` import; Zod validation; `createServerSupabase()`. Location: `src/app/(route)/actions.ts` or `src/lib/*/actions.ts`.
- **Returns:** Serializable data or `redirect()`. Revalidate via `revalidatePath()`/`revalidateTag()`.
- **Integration:** `useActionState` for progressive enhancement; `form.handleSubmitSafe()` with telemetry (see 4.1).
- **Details:** See `docs/development/frontend/forms.md` and `docs/development/backend/server-actions.md`.

---

## 6. Testing and Quality Gates

### 6.1 Frontend testing

- **Principle:** Test behavior, not implementation. Lightest test that proves behavior: unit → component → API → integration → E2E.
- **Framework:** Vitest + jsdom, Playwright (e2e). Tests: `src/**/__tests__`; mocks: `src/test`; factories: `@/test/factories`.
- **Environment (MANDATORY):** `/** @vitest-environment jsdom */` first line for DOM/React; `node` for routes/actions.
- **MSW-first:** Network mocking via MSW only; never `vi.mock("fetch")`. Handlers in `src/test/msw/handlers/*`.
- **Mock order:** Mock `next/headers` BEFORE importing modules that read cookies. Use `vi.hoisted()` for spies.
- **Timers:** No global `vi.useFakeTimers()`; use `withFakeTimers` wrapper from `@/test/utils/with-fake-timers`.
- **AI SDK tests:** Use `MockLanguageModelV3`, `createMockModelWithTracking` from `@/test/ai-sdk/*`.
- **Coverage:** ≥85% overall; meet `vitest.config.ts` thresholds.
- **Details:** See `docs/development/testing/testing.md`.

### 6.2 Quality gates (mandatory)

Before finalizing any work that includes code changes (`.ts`, `.tsx`, schemas, or config affecting builds), run at repository root:

1. `pnpm biome:fix` — fix all issues; resolve any remaining errors manually.
2. `pnpm type-check` — must pass with zero errors.
3. `pnpm test:affected` — runs changed test files + tests related to changed source files; all must pass.

**Skip for:** doc-only (`.md`), comments, non-code config, questions, or analysis.

Do not return final response until all gates pass for code changes.

**During iteration:** Prefer the smallest relevant shard (`pnpm test:unit`, `pnpm test:api`, `pnpm test:components`, `pnpm test:schemas`, `pnpm test:integration`). Run `pnpm test` only when changing test harness/config (e.g. `vitest.config.ts`, `src/test/**`) or before merging.

**If Vitest hangs after finishing:** run `VITEST_DEBUG_OPEN_HANDLES=1 pnpm test` and ensure MSW is not bypassing unhandled requests (`MSW_ON_UNHANDLED_REQUEST=error`).

### Upstash testing

- **Mocking:** `setupUpstashMocks()` with `__reset()` in `beforeEach`. No ad-hoc mocks; use MSW handlers.
- **Commands:** `pnpm test:upstash:{unit,int,smoke}`. See `src/test/upstash/` for emulator setup.

---

## 7. Security and Secrets

- Never commit/log secrets; use `.env` and env vaults.
- Keep provider keys server‑side only; never expose to client.
- Do not publicly cache user‑specific or cookie-dependent data.
- Use maintained security libraries; no custom crypto/auth.

---

## 8. Git, Commits, and PRs

- Use Conventional Commit messages with scopes: i.e. `feat(scope): ...`
- Small commits and focused; group related changes.
````

## File: src/ai/agents/memory-agent.ts
````typescript
/**
 * @fileoverview Memory update agent using AI SDK v6 streaming.
 *
 * Wraps memory tools (addConversationMemory) with guardrails (rate limiting,
 * telemetry) and executes streaming text generation to confirm memory writes.
 *
 * Note: memory writes are intentionally not cached to avoid cross-user cache
 * collisions and unintended idempotency.
 *
 * Note: This agent uses streamText directly, not ToolLoopAgent, because
 * memory persistence is a batch operation followed by a summary - not
 * an agentic multi-step workflow.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import { toolRegistry } from "@ai/tools";
import { TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import type { MemoryUpdateRequest } from "@schemas/agents";
import {
  addConversationMemoryInputSchema,
  addConversationMemoryOutputSchema,
} from "@schemas/memory";
import type { LanguageModel } from "ai";
import { streamText } from "ai";
import type { z } from "zod";
import { buildRateLimit } from "@/lib/ratelimit/config";
import type { ChatMessage } from "@/lib/tokens/budget";
import { clampMaxTokens } from "@/lib/tokens/budget";
⋮----
// Note: no wrapped tools are exposed here; we execute persistence directly with guardrails.
⋮----
/** Maximum number of memory records allowed per request. */
⋮----
/**
 * Execute the memory agent with AI SDK v6 streaming.
 *
 * Builds system instructions and messages, wraps core tools with guardrails,
 * and streams a model-guided confirmation message for memory writes.
 *
 * @param deps Language model, model identifier, and request-scoped utilities.
 * @param input Validated memory update request.
 * @returns AI SDK stream result for UI consumption.
 */
export function runMemoryAgent(
  deps: {
    model: LanguageModel;
    modelId: string;
    identifier: string;
  },
  config: import("@schemas/configuration").AgentConfig,
  input: MemoryUpdateRequest
)
⋮----
/** Result of a memory persistence operation. */
type PersistOutcome = {
  successes: Array<{ id: string; createdAt: string; category: string }>;
  failures: Array<{ index: number; error: string }>;
};
⋮----
/** Type alias for the input schema of the addConversationMemory tool. */
type AddConversationMemoryInput = z.infer<typeof addConversationMemoryInputSchema>;
type AddConversationMemoryOutput = z.infer<typeof addConversationMemoryOutputSchema>;
⋮----
/** Type alias for individual memory records from the update request. */
type MemoryRecordInput = MemoryUpdateRequest["records"][number];
⋮----
/** Valid memory category values accepted by the schema. */
⋮----
const isAsyncIterable = (
  value: unknown
): value is AsyncIterable<AddConversationMemoryOutput>
⋮----
/**
 * Normalizes a memory category string to a valid schema value.
 *
 * Validates the category against allowed values and defaults to "other"
 * if the provided category is invalid or undefined.
 *
 * @param category - Raw category string from user input.
 * @returns Validated category value or "other" as fallback.
 */
function normalizeMemoryCategory(
  category?: string
): AddConversationMemoryInput["category"]
⋮----
/**
 * Persists memory records and streams a summary of the operation.
 *
 * Executes persistence operations in parallel, aggregates statistics by category,
 * and streams model-generated summary. Uses token budgeting for concise summaries.
 *
 * @param deps - Language model and request-scoped dependencies.
 * @param input - Validated memory update request with records to persist.
 * @returns AI SDK stream result with memory operation summary.
 */
async function persistAndSummarize(
  deps: { model: LanguageModel; modelId: string; identifier: string },
  config: import("@schemas/configuration").AgentConfig,
  input: MemoryUpdateRequest
)
⋮----
// Token budgeting: clamp max output tokens based on prompt length
⋮----
const desiredMaxTokens = 512; // Short summary for memory confirmations
⋮----
// biome-ignore lint/style/useNamingConvention: AI SDK API uses snake_case
⋮----
/**
 * Persists multiple memory records with guardrails applied.
 *
 * Creates guardrailed tools for each record, executes operations in parallel,
 * collects outcomes. Validates limits, normalizes categories, handles errors gracefully.
 *
 * @param identifier - User or session identifier for rate limiting.
 * @param input - Validated memory update request with records to persist.
 * @returns Promise resolving to operation outcomes (successes and failures).
 * @throws {Error} When record count exceeds MAX_MEMORY_RECORDS_PER_REQUEST.
 */
export async function persistMemoryRecords(
  identifier: string,
  input: MemoryUpdateRequest
): Promise<PersistOutcome>
⋮----
type ToolBinding = {
    description?: string;
    execute?: (params: unknown, callOptions?: unknown) => Promise<unknown> | unknown;
  };
⋮----
// Output validation is enabled; type narrowing is safe after validation passes
````

## File: src/ai/lib/tool-factory.ts
````typescript
/**
 * @fileoverview Canonical factory for AI SDK tools with guardrails.
 *
 * Provides a single entry point for creating AI tools that automatically
 * apply telemetry spans, optional rate limiting, and Redis caching. Inspired by
 * agent guardrails (lib/agents/guarded-tool.ts) but generalized for any tool.
 */
⋮----
import type { RateLimitResult } from "@ai/tools/schemas/tools";
import { rateLimitResultSchema } from "@ai/tools/schemas/tools";
import { createToolError, type ToolErrorCode } from "@ai/tools/server/errors";
import type { AgentWorkflowKind } from "@schemas/agents";
import { Ratelimit } from "@upstash/ratelimit";
import type { FlexibleSchema, Tool, ToolCallOptions } from "ai";
import { asSchema, tool } from "ai";
import { headers } from "next/headers";
import { hashInputForCache } from "@/lib/cache/hash";
import { getCachedJson, setCachedJson } from "@/lib/cache/upstash";
import { getClientIpFromHeaders } from "@/lib/http/ip";
import { normalizeRateLimitResetToMs } from "@/lib/ratelimit/headers";
import { hashIdentifier, normalizeIdentifier } from "@/lib/ratelimit/identifier";
import { getRedis } from "@/lib/redis";
import {
  type Span,
  type TelemetrySpanAttributes,
  withTelemetrySpan,
} from "@/lib/telemetry/span";
⋮----
/**Maximum length for rate limit identifiers to prevent abuse. */
⋮----
/** Type alias for rate limit window duration accepted by Upstash Ratelimit. */
type RateLimitWindow = Parameters<typeof Ratelimit.slidingWindow>[1];
⋮----
/**
 * Signature for tool execution functions that receive validated input and call options.
 *
 * @template InputValue - The validated input type for the tool.
 * @template OutputValue - The output type returned by the tool.
 */
type ToolExecute<InputValue, OutputValue> = (
  params: InputValue,
  callOptions: ToolCallOptions
) => Promise<OutputValue>;
⋮----
/** Transform function to convert tool output for model consumption. */
export type ToModelOutputFn<OutputValue> = (output: OutputValue) => unknown;
⋮----
export type ToolOptions<InputValue, OutputValue> = {
  /** Unique tool identifier used for telemetry and cache namespacing. */
  name: string;
  /** Human-readable description passed to the model. */
  description: string;
  /** Schema accepted by AI SDK tools (supports Zod/Flexible schemas). */
  inputSchema: FlexibleSchema<InputValue>;
  /** Optional output schema for runtime validation of tool results. */
  outputSchema?: FlexibleSchema<OutputValue>;
  /** Business logic implementation. */
  execute: ToolExecute<InputValue, OutputValue>;
  /** Transform tool output for model consumption. */
  toModelOutput?: ToModelOutputFn<OutputValue>;
  /** Whether to validate output against outputSchema at runtime. Defaults to false. */
  validateOutput?: boolean;
};
⋮----
/** Unique tool identifier used for telemetry and cache namespacing. */
⋮----
/** Human-readable description passed to the model. */
⋮----
/** Schema accepted by AI SDK tools (supports Zod/Flexible schemas). */
⋮----
/** Optional output schema for runtime validation of tool results. */
⋮----
/** Business logic implementation. */
⋮----
/** Transform tool output for model consumption. */
⋮----
/** Whether to validate output against outputSchema at runtime. Defaults to false. */
⋮----
/**
 * Lifecycle hooks for streaming tool input progress.
 *
 * These callbacks are invoked during streamText when the model is generating
 * tool input parameters, enabling real-time UI feedback before execution.
 *
 * @template InputValue - The input type for the tool.
 */
export type LifecycleHooks<InputValue> = {
  /** Called when tool input streaming starts. */
  onInputStart?: () => void;
  /** Called for each chunk of streamed input text. */
  onInputDelta?: (delta: { inputTextDelta: string }) => void;
  /** Called when complete input is available and validated. */
  onInputAvailable?: (available: { input: InputValue }) => void;
};
⋮----
/** Called when tool input streaming starts. */
⋮----
/** Called for each chunk of streamed input text. */
⋮----
/** Called when complete input is available and validated. */
⋮----
export type TelemetryOptions<InputValue> = {
  /** Optional custom span name suffix (defaults to tool name). */
  name?: string;
  /** Attribute builder invoked before the span starts. */
  attributes?: (params: InputValue) => TelemetrySpanAttributes;
  /** Keys whose values should be redacted on the span. */
  redactKeys?: string[];
  /** Optional agent workflow identifier for workflow-specific telemetry. */
  workflow?: AgentWorkflowKind;
};
⋮----
/** Optional custom span name suffix (defaults to tool name). */
⋮----
/** Attribute builder invoked before the span starts. */
⋮----
/** Keys whose values should be redacted on the span. */
⋮----
/** Optional agent workflow identifier for workflow-specific telemetry. */
⋮----
export type CacheHitMeta = {
  startedAt: number;
};
⋮----
export type CacheOptions<InputValue, OutputValue> = {
  /** Function that produces a cache key suffix; returning undefined disables caching. */
  key: (params: InputValue) => string | undefined;
  /** Optional namespace prefix (defaults to `tool:${name}`). */
  namespace?: string;
  /** If true, hash the input using SHA-256 and append first 16 hex chars to key. */
  hashInput?: boolean;
  /** Serialize result before persistence. Returning undefined skips caching. */
  serialize?: (result: OutputValue, params: InputValue) => unknown;
  /** Deserialize cached payload back into the expected result shape. */
  deserialize?: (payload: unknown, params: InputValue) => OutputValue;
  /** Transform cached value before returning to caller (meta includes request start time). */
  onHit?: (cached: OutputValue, params: InputValue, meta: CacheHitMeta) => OutputValue;
  /** Decide whether a given request should bypass caching entirely. */
  shouldBypass?: (params: InputValue) => boolean;
  /** TTL seconds (number or function of (params, result)). */
  ttlSeconds?:
    | number
    | ((params: InputValue, result: OutputValue) => number | undefined);
};
⋮----
/** Function that produces a cache key suffix; returning undefined disables caching. */
⋮----
/** Optional namespace prefix (defaults to `tool:${name}`). */
⋮----
/** If true, hash the input using SHA-256 and append first 16 hex chars to key. */
⋮----
/** Serialize result before persistence. Returning undefined skips caching. */
⋮----
/** Deserialize cached payload back into the expected result shape. */
⋮----
/** Transform cached value before returning to caller (meta includes request start time). */
⋮----
/** Decide whether a given request should bypass caching entirely. */
⋮----
/** TTL seconds (number or function of (params, result)). */
⋮----
export type RateLimitOptions<InputValue> = {
  /** Error code to emit when the limit is exceeded. */
  errorCode: ToolErrorCode;
  /** Optional identifier override using params and/or ToolCallOptions. */
  identifier?: (
    params: InputValue,
    callOptions?: ToolCallOptions
  ) => string | undefined | null;
  /** Sliding window limit. */
  limit: number;
  /** Sliding window duration string (e.g., "1 m"). */
  window: RateLimitWindow | string;
  /** Optional prefix override for limiter namespace. */
  prefix?: string;
};
⋮----
/** Error code to emit when the limit is exceeded. */
⋮----
/** Optional identifier override using params and/or ToolCallOptions. */
⋮----
/** Sliding window limit. */
⋮----
/** Sliding window duration string (e.g., "1 m"). */
⋮----
/** Optional prefix override for limiter namespace. */
⋮----
/**
 * Configuration options for tool guardrails including caching, rate limiting, and telemetry.
 *
 * @template InputValue - The input type for the tool.
 * @template OutputValue - The output type for the tool.
 */
export type GuardrailOptions<InputValue, OutputValue> = {
  cache?: CacheOptions<InputValue, OutputValue>;
  rateLimit?: RateLimitOptions<InputValue>;
  telemetry?: TelemetryOptions<InputValue>;
};
⋮----
/**
 * Complete configuration for creating an AI tool with optional guardrails.
 *
 * @template InputValue - The input type for the tool.
 * @template OutputValue - The output type for the tool.
 */
export type CreateAiToolOptions<InputValue, OutputValue> = ToolOptions<
  InputValue,
  OutputValue
> & {
  guardrails?: GuardrailOptions<InputValue, OutputValue>;
  /** Optional lifecycle hooks for streaming tool input progress. */
  lifecycle?: LifecycleHooks<InputValue>;
};
⋮----
/** Optional lifecycle hooks for streaming tool input progress. */
⋮----
/**
 * Result of a cache lookup operation indicating whether a cached value was found.
 *
 * @template OutputValue - The cached value type.
 */
type CacheLookupResult<OutputValue> =
  | { hit: true; value: OutputValue }
  | { hit: false };
⋮----
/**
 * Cache of Ratelimit instances by configuration key.
 *
 * Design decision: Upstash Ratelimit instances are stateless Redis clients,
 * so reusing them across requests is safe and reduces instantiation overhead.
 * Each unique (prefix, limit, window) combination gets its own cached instance.
 * The cache key format is `${namespace}:${limit}:${window}` to ensure distinct
 * configurations don't share limiters.
 */
⋮----
/**
 * Builds lifecycle hooks object from options, including only defined hooks.
 *
 * @template InputValue - Input type for the tool.
 * @param lifecycle - Optional lifecycle hooks configuration.
 * @returns Object containing only the defined lifecycle hooks.
 */
function buildLifecycleHooks<InputValue>(
  lifecycle?: LifecycleHooks<InputValue>
): Partial<LifecycleHooks<InputValue>>
⋮----
/**
 * Creates an AI SDK v6 tool with optional guardrails (caching, rate limiting, telemetry).
 *
 * @template InputValue - Input schema type for the tool.
 * @template OutputValue - Output type returned by the tool.
 * @param options - Tool configuration including guardrails and output validation.
 * @returns AI SDK tool instance with guardrails applied.
 */
export function createAiTool<InputValue, OutputValue>(
  options: CreateAiToolOptions<InputValue, OutputValue>
): Tool<InputValue, OutputValue>
⋮----
// Build output validator if validation is requested
⋮----
// AI SDK v6 tool() cannot infer generics from object literals; safe assertion since structure matches.
// biome-ignore lint/suspicious/noExplicitAny: Type assertion needed for AI SDK v6 tool() generic inference
⋮----
// Validate output if requested
⋮----
// Lifecycle hooks for streaming tool input progress (AI SDK v6)
⋮----
/**
 * Builds an output validator function from a FlexibleSchema.
 *
 * Uses AI SDK's asSchema to convert the schema for validation.
 *
 * @template OutputValue - Output type to validate.
 * @param schema - Flexible schema for validation.
 * @param toolName - Tool name for error messages.
 * @returns Async validator function.
 */
function buildOutputValidator<OutputValue>(
  schema: FlexibleSchema<OutputValue>,
  toolName: string
): (output: unknown) => Promise<
⋮----
// Schema doesn't support validation, consider it valid
⋮----
/**
 * Builds telemetry attributes for an OpenTelemetry span.
 *
 * Combines base tool attributes with custom attributes from telemetry configuration.
 *
 * @template InputValue - Input type for the tool.
 * @param toolName - Name of the tool being executed.
 * @param telemetry - Optional telemetry configuration.
 * @param params - Input parameters for attribute generation.
 * @returns Attributes object for the telemetry span.
 */
function buildTelemetryAttributes<InputValue>(
  toolName: string,
  telemetry: TelemetryOptions<InputValue> | undefined,
  params: InputValue
): TelemetrySpanAttributes
⋮----
/**
 * Attempts to read a cached result from Redis.
 *
 * Resolves cache key, checks for cached data, applies deserialization if configured.
 * Records cache events and handles Redis/deserialization errors gracefully.
 *
 * @template InputValue - Input type for the tool.
 * @template OutputValue - Output type for the tool.
 * @param cache - Cache configuration options.
 * @param toolName - Tool name for key namespacing.
 * @param params - Input parameters for key resolution and deserialization.
 * @param span - OpenTelemetry span for event recording.
 * @param startedAt - Request start timestamp for cache hit metadata.
 * @returns Cache lookup result with hit status and value if found.
 */
async function readFromCache<InputValue, OutputValue>(
  cache: CacheOptions<InputValue, OutputValue>,
  toolName: string,
  params: InputValue,
  span: Span,
  startedAt: number
): Promise<CacheLookupResult<OutputValue>>
⋮----
// Apply deserialization if provided
⋮----
// Apply onHit transformation if provided
⋮----
/**
 * Writes a tool execution result to Redis cache.
 *
 * Resolves cache key, applies serialization if configured, stores result with TTL.
 * Records cache events and handles Redis/serialization errors gracefully.
 *
 * @template InputValue - Input type for the tool.
 * @template OutputValue - Output type for the tool.
 * @param cache - Cache configuration options.
 * @param toolName - Tool name for key namespacing.
 * @param params - Input parameters for key resolution and serialization.
 * @param result - Execution result to cache.
 * @param span - OpenTelemetry span for event recording.
 */
async function writeToCache<InputValue, OutputValue>(
  cache: CacheOptions<InputValue, OutputValue>,
  toolName: string,
  params: InputValue,
  result: OutputValue,
  span: Span
): Promise<void>
⋮----
// Use existing helper which handles Redis unavailability gracefully
⋮----
/**
 * Resolves the full Redis cache key from cache configuration and parameters.
 *
 * Applies bypass logic, key generation, input hashing if enabled, and namespacing.
 *
 * @template InputValue - Input type for the tool.
 * @template OutputValue - Output type for the tool.
 * @param cache - Cache configuration options.
 * @param toolName - Tool name for default namespacing.
 * @param params - Input parameters for key generation.
 * @returns Full Redis key string or null if caching is bypassed.
 */
function resolveCacheKey<InputValue, OutputValue>(
  cache: CacheOptions<InputValue, OutputValue>,
  toolName: string,
  params: InputValue
): string | null
⋮----
// Apply SHA-256 hashing if enabled
⋮----
/**
 * Enforces rate limiting using Upstash Ratelimit.
 *
 * Resolves identifier, creates cached limiter instance, checks limit, throws if exceeded.
 * Records events and handles Redis unavailability gracefully.
 *
 * @template InputValue - Input type for the tool.
 * @param config - Rate limit configuration options.
 * @param toolName - Tool name for limiter namespacing.
 * @param params - Input parameters for identifier resolution.
 * @param callOptions - Tool call options for identifier resolution.
 * @param span - OpenTelemetry span for event recording.
 * @throws {ToolError} When rate limit is exceeded.
 */
async function enforceRateLimit<InputValue>(
  config: RateLimitOptions<InputValue>,
  toolName: string,
  params: InputValue,
  callOptions: ToolCallOptions,
  span: Span
): Promise<void>
⋮----
// Validate rate limit result structure using schema
⋮----
/**
 * Sanitizes a rate limit identifier by trimming whitespace and validating length.
 *
 * Returns undefined if the identifier is null, undefined, or empty after trimming.
 *
 * @param identifier - Raw identifier string from configuration or headers.
 * @returns Sanitized identifier or undefined if invalid.
 */
function sanitizeRateLimitIdentifier(identifier?: string | null): string | undefined
⋮----
// Truncate overly long identifiers
⋮----
/**
 * Convert a raw identifier into a stable, hashed limiter identifier.
 *
 * - Preserves an explicit `{prefix}:{value}` form by hashing only the value.
 * - Otherwise uses `id:{sha256(raw)}` to avoid leaking raw identifiers in Redis keys.
 */
function toHashedLimiterIdentifier(raw: string): string
⋮----
/**
 * Derives a rate limit identifier from request headers.
 *
 * Extracts user ID from x-user-id header first, then falls back to first IP
 * from trusted client IP headers.
 * Returns "unknown" if no valid identifier found.
 *
 * @returns Hashed rate limit identifier in format "user:{sha256}", "ip:{sha256}", or "unknown".
 */
async function getRateLimitIdentifier(): Promise<string>
⋮----
// headers() throws when executed outside of a request context. Fall through.
````

## File: src/ai/tools/schemas/accommodations.ts
````typescript
/**
 * @fileoverview Accommodation tool model output schemas.
 */
⋮----
import { z } from "zod";
⋮----
// ===== MODEL OUTPUT SCHEMAS =====
⋮----
/** GeoCode for model consumption. */
⋮----
/**
 * Coerce string-or-number to number, returning undefined for non-parseable values.
 */
⋮----
/**
 * Accommodation listing entry for model consumption.
 * Fields are normalized to numbers via transforms to ensure type safety downstream.
 */
⋮----
/** Accommodation search result output schema for model consumption. */
⋮----
export type AccommodationModelOutput = z.infer<typeof accommodationModelOutputSchema>;
````

## File: src/app/api/ai/stream/route.ts
````typescript
/**
 * @fileoverview Demo streaming route using AI SDK v6. Returns a UI Message Stream
 * suitable for AI Elements and AI SDK UI readers.
 */
⋮----
import { openai } from "@ai-sdk/openai";
import { streamText } from "ai";
import type { NextRequest } from "next/server";
import { z } from "zod";
import { type RouteParamsContext, withApiGuards } from "@/lib/api/factory";
import { errorResponse } from "@/lib/api/route-helpers";
import { getServerEnvVarWithFallback } from "@/lib/env/server";
import {
  type ChatMessage,
  clampMaxTokens,
  countPromptTokens,
} from "@/lib/tokens/budget";
import { getModelContextLimit } from "@/lib/tokens/limits";
⋮----
// Allow streaming responses up to 30 seconds
/** Maximum duration (seconds) to allow for streaming responses. */
⋮----
/**
 * Handle POST requests by streaming a simple demo message via AI SDK.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context from withApiGuards
 * @returns A Response implementing the UI message stream protocol (SSE).
 */
// auth: true required to identify the user making streaming requests.
// Compare with /api/telemetry/ai-demo which uses internal-key auth for backend telemetry.
⋮----
// Build message list if not provided
⋮----
// If prompt already exhausts the model context window, return a 400 with reasons
⋮----
// Prefer messages when available; otherwise prompt.
⋮----
// Return a UI Message Stream response suitable for AI Elements consumers
⋮----
/**
 * Feature-flagged POST handler for AI streaming demo.
 *
 * @param req - Next.js request object
 * @param routeContext - Route context with params
 * @returns 404 error response when ENABLE_AI_DEMO is disabled, otherwise delegates to guardedPOST
 */
export const POST = async (req: NextRequest, routeContext: RouteParamsContext) =>
````

## File: src/domain/schemas/calendar.ts
````typescript
/**
 * @fileoverview Canonical Zod v4 schemas for calendar entities, Google Calendar API
 * integration, and calendar tool input validation.
 *
 * Core schemas: Calendar entities, events, API responses
 * Tool schemas: Input validation for calendar tools (create events, export ICS)
 */
⋮----
import { z } from "zod";
import { primitiveSchemas } from "./registry";
⋮----
// ===== CORE SCHEMAS =====
// Core business logic schemas for calendar management
⋮----
/** Zod schema for Google Calendar event visibility levels. */
⋮----
/** TypeScript type for event visibility. */
export type EventVisibility = z.infer<typeof eventVisibilitySchema>;
⋮----
/** Zod schema for Google Calendar event status values. */
⋮----
/** TypeScript type for event status. */
export type EventStatus = z.infer<typeof eventStatusSchema>;
⋮----
/** Zod schema for attendee response status values. */
⋮----
/** TypeScript type for attendee response status. */
export type AttendeeResponseStatus = z.infer<typeof attendeeResponseStatusSchema>;
⋮----
/** Zod schema for reminder notification methods. */
⋮----
/** TypeScript type for reminder methods. */
export type ReminderMethod = z.infer<typeof reminderMethodSchema>;
⋮----
/** Zod schema for Google Calendar event date/time with timezone support. */
⋮----
/** TypeScript type for event date/time. */
export type EventDateTime = z.infer<typeof eventDateTimeSchema>;
⋮----
/** Zod schema for Google Calendar event reminders. */
⋮----
/** TypeScript type for event reminders. */
export type EventReminder = z.infer<typeof eventReminderSchema>;
⋮----
/** Zod schema for Google Calendar event attendees. */
⋮----
/** TypeScript type for event attendees. */
export type EventAttendee = z.infer<typeof eventAttendeeSchema>;
⋮----
/** Zod schema for Google Calendar conference data. */
⋮----
/** TypeScript type for conference data. */
export type ConferenceData = z.infer<typeof conferenceDataSchema>;
⋮----
/** Zod schema for Google Calendar extended properties. */
⋮----
/** TypeScript type for extended properties. */
export type ExtendedProperties = z.infer<typeof extendedPropertiesSchema>;
⋮----
/**
 * Zod schema for Google Calendar events.
 */
⋮----
/** TypeScript type for calendar events. */
export type CalendarEvent = z.infer<typeof calendarEventSchema>;
⋮----
// ===== API SCHEMAS =====
// Request/response schemas for calendar API endpoints
⋮----
/**
 * Zod schema for creating new Google Calendar events.
 * Validates event parameters including dates, attendees, and reminders.
 */
⋮----
/** TypeScript type for create event requests. */
export type CreateEventRequest = z.infer<typeof createEventRequestSchema>;
⋮----
/** Zod schema for updating existing Google Calendar events. */
⋮----
/** TypeScript type for update event requests. */
export type UpdateEventRequest = z.infer<typeof updateEventRequestSchema>;
⋮----
/** Zod schema for Google Calendar list entries. */
⋮----
/** TypeScript type for calendar list entries. */
export type CalendarListEntry = z.infer<typeof calendarListEntrySchema>;
⋮----
/** Zod schema for Google Calendar list responses. */
⋮----
/** TypeScript type for calendar list responses. */
export type CalendarList = z.infer<typeof calendarListSchema>;
⋮----
/** Zod schema for free/busy calendar items. */
⋮----
/** TypeScript type for free/busy calendar items. */
export type FreeBusyCalendarItem = z.infer<typeof freeBusyCalendarItemSchema>;
⋮----
/**
 * Zod schema for Google Calendar free/busy requests.
 * Validates parameters for checking calendar availability.
 */
⋮----
/** TypeScript type for free/busy requests. */
export type FreeBusyRequest = z.infer<typeof freeBusyRequestSchema>;
⋮----
/** Zod schema for Google Calendar free/busy responses. */
⋮----
/** TypeScript type for free/busy responses. */
export type FreeBusyResponse = z.infer<typeof freeBusyResponseSchema>;
⋮----
/** Zod schema for Google Calendar events list requests. */
⋮----
/** TypeScript type for events list requests. */
export type EventsListRequest = z.infer<typeof eventsListRequestSchema>;
⋮----
/** Zod schema for Google Calendar events list responses. */
⋮----
/** TypeScript type for events list responses. */
export type EventsListResponse = z.infer<typeof eventsListResponseSchema>;
⋮----
/**
 * Zod schema for POST /api/calendar/ics/import request body.
 * Validates ICS import request parameters for route handlers.
 */
⋮----
/** TypeScript type for ICS import requests. */
export type IcsImportRequest = z.infer<typeof icsImportRequestSchema>;
⋮----
/**
 * Zod schema for POST /api/calendar/ics/export request body.
 * Validates ICS export request parameters for route handlers.
 */
⋮----
/** TypeScript type for ICS export requests. */
export type IcsExportRequest = z.infer<typeof icsExportRequestSchema>;
⋮----
/**
 * Calendar connection status response type.
 * Used by calendar status API and components.
 */
export interface CalendarStatusResponse {
  connected: boolean;
  calendars?: Array<{
    id: string;
    summary: string;
    description?: string;
    timeZone?: string;
    primary?: boolean;
    accessRole?: string;
  }>;
  message?: string;
}
⋮----
// ===== TOOL INPUT SCHEMAS =====
// Schemas for calendar tool input validation and processing
⋮----
/**
 * Schema for creating calendar events with Google Calendar.
 * Validates calendar event creation parameters for AI tools.
 */
⋮----
/**
 * Schema for exporting calendar events to ICS format.
 * Validates itinerary export parameters for AI tools.
 */
⋮----
// ===== TOOL OUTPUT SCHEMAS =====
// Schemas for calendar tool output validation
⋮----
/**
 * Schema for createCalendarEvent tool output.
 */
⋮----
export type CreateCalendarEventOutput = z.infer<typeof createCalendarEventOutputSchema>;
⋮----
/**
 * Schema for getAvailability tool output.
 */
⋮----
export type GetAvailabilityOutput = z.infer<typeof getAvailabilityOutputSchema>;
⋮----
/**
 * Schema for exportItineraryToIcs tool output.
 */
⋮----
export type ExportItineraryToIcsOutput = z.infer<
  typeof exportItineraryToIcsOutputSchema
>;
````

## File: src/lib/security/sessions.ts
````typescript
/**
 * @fileoverview Server-only security session data accessors shared by routes and RSC.
 */
⋮----
import { type ActiveSession, activeSessionSchema } from "@schemas/security";
import { nowIso } from "@/lib/security/random";
import type { TypedAdminSupabase } from "@/lib/supabase/admin";
import type { Database } from "@/lib/supabase/database.types";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { hashTelemetryIdentifier } from "@/lib/telemetry/identifiers";
import { createServerLogger } from "@/lib/telemetry/logger";
import { withTelemetrySpan } from "@/lib/telemetry/span";
⋮----
/** Shape of a session row from the auth.sessions table. */
type SessionRow = Database["auth"]["Tables"]["sessions"]["Row"];
⋮----
type SessionRowForMapping = Pick<
  SessionRow,
  "created_at" | "id" | "ip" | "refreshed_at" | "updated_at" | "user_agent"
>;
⋮----
export class SessionsListError extends Error
⋮----
constructor(message: string, cause?: unknown)
⋮----
/** Decodes a base64url string to UTF-8 text. */
function decodeBase64Url(payload: string): string
⋮----
/** Extracts the session_id claim from a Supabase access token, if present. */
function parseSessionIdFromToken(
  accessToken: string | null | undefined
): string | null
⋮----
/** Returns the current session id from the authenticated Supabase session token. */
export async function getCurrentSessionId(
  supabase: TypedServerSupabase
): Promise<string | null>
⋮----
/**
 * Extracts the IP address from a session row.
 *
 * @param ipValue - The IP address value to extract.
 * @returns The IP address string or "Unknown" if not found.
 */
function getIpAddress(ipValue: unknown): string
⋮----
function isIpObject(value: unknown): value is
⋮----
/**
 * Maps a session row to an ActiveSession DTO.
 *
 * @param row - The session row to map.
 * @param currentSessionId - The current session id.
 * @returns The mapped session DTO.
 */
export function mapSessionRow(
  row: SessionRowForMapping,
  currentSessionId: string | null
): ActiveSession
⋮----
/**
 * Lists active sessions for a user, excluding expired records.
 *
 * @param adminSupabase - Admin Supabase client.
 * @param userId - User ID to list sessions for.
 * @param opts - Options including current session id.
 * @returns Active sessions as DTOs.
 */
export async function listActiveSessions(
  adminSupabase: TypedAdminSupabase,
  userId: string,
  opts: { currentSessionId?: string | null } = {}
): Promise<ActiveSession[]>
````

## File: src/lib/webhooks/rate-limit.ts
````typescript
/**
 * @fileoverview Rate limiting for webhook handlers.
 *
 * Uses Upstash Ratelimit with sliding window algorithm to protect against DoS
 * attacks and resource exhaustion. Configured for 100 requests per minute per IP.
 */
⋮----
import { Ratelimit } from "@upstash/ratelimit";
import { NextResponse } from "next/server";
import type { DegradedMode } from "@/lib/api/factory";
import { getClientIpFromHeaders } from "@/lib/http/ip";
import { createRateLimitHeaders as createStandardRateLimitHeaders } from "@/lib/ratelimit/headers";
import { hashIdentifier } from "@/lib/ratelimit/identifier";
import { getRedis } from "@/lib/redis";
import { emitOperationalAlertOncePerWindow } from "@/lib/telemetry/degraded-mode";
import { warnRedisUnavailable } from "@/lib/telemetry/redis";
import { sanitizePathnameForTelemetry } from "@/lib/telemetry/route-key";
import { recordTelemetryEvent } from "@/lib/telemetry/span";
⋮----
/**
 * Result of a rate limit check.
 */
export interface RateLimitResult {
  /** Whether the request is allowed */
  success: boolean;
  /** Why the check failed (only set when success === false) */
  reason?: "limiter_unavailable" | "rate_limited";
  /** Unix timestamp (ms) when the rate limit window resets */
  reset?: number;
  /** Number of requests remaining in the current window */
  remaining?: number;
  /** Maximum requests allowed in the window */
  limit?: number;
}
⋮----
/** Whether the request is allowed */
⋮----
/** Why the check failed (only set when success === false) */
⋮----
/** Unix timestamp (ms) when the rate limit window resets */
⋮----
/** Number of requests remaining in the current window */
⋮----
/** Maximum requests allowed in the window */
⋮----
/**
 * Extract client IP address from request headers.
 *
 * Checks headers in order:
 * 1. X-Real-IP (Vercel canonical)
 * 2. X-Forwarded-For (first IP in comma-separated list)
 * 3. CF-Connecting-IP (Cloudflare)
 * 4. Fallback to "unknown" (logged for monitoring)
 *
 * @param req - The incoming request
 * @returns Client IP address string
 */
export function getClientIp(req: Request): string
⋮----
// Log fallback when no IP headers are present (rate-limited via telemetry)
⋮----
// Single shared bucket to prevent UA rotation from bypassing rate limits
⋮----
/**
 * Check rate limit for a webhook request.
 *
 * Defaults to fail-closed (returns 503) when Redis is unavailable to avoid
 * accepting unthrottled traffic. Use `checkWebhookRateLimitWithPolicy` with
 * `{ degradedMode: "fail_open" }` to allow processing during outages.
 *
 * @param req - The incoming request
 * @returns Rate limit check result
 */
export async function checkWebhookRateLimit(req: Request): Promise<RateLimitResult>
⋮----
export async function checkWebhookRateLimitWithPolicy(
  req: Request,
  options: { degradedMode?: DegradedMode } = {}
): Promise<RateLimitResult>
⋮----
/**
 * Create rate limit headers for HTTP response.
 *
 * @param result - Rate limit check result
 * @returns Headers object with rate limit information
 */
export function createRateLimitHeaders(
  result: RateLimitResult
): Record<string, string>
⋮----
/**
 * Response payload structure for webhook responses.
 */
interface WebhookResponsePayload {
  /** Response body (will be JSON-serialized) */
  body: Record<string, unknown>;
  /** HTTP status code (defaults to 200) */
  status?: number;
}
⋮----
/** Response body (will be JSON-serialized) */
⋮----
/** HTTP status code (defaults to 200) */
⋮----
/**
 * Create a NextResponse with rate limit headers attached.
 *
 * This helper combines response creation and header attachment in a single call,
 * reducing boilerplate at call sites.
 *
 * @param rateLimitResult - Rate limit check result for headers
 * @param payload - Response body and optional status code
 * @returns NextResponse with rate limit headers attached
 *
 * @example
 * ```ts
 * return createWebhookResponse(rateLimitResult, {
 *   body: { code: "RATE_LIMITED", error: "rate_limit_exceeded" },
 *   status: 429,
 * });
 * ```
 */
export function createWebhookResponse(
  rateLimitResult: RateLimitResult,
  payload: WebhookResponsePayload
): NextResponse
````

## File: next.config.ts
````typescript
/**
 * @fileoverview Next.js configuration for TripSage AI (Turbopack root, build optimizations, and security headers).
 */
⋮----
import { existsSync } from "node:fs";
import { dirname, isAbsolute } from "node:path";
import { fileURLToPath } from "node:url";
import withBundleAnalyzer from "@next/bundle-analyzer";
import { withBotId } from "botid/next/config";
import type { NextConfig } from "next";
⋮----
// Build-time assertion: turbopack.root must be absolute and exist
⋮----
// Enable Cache Components (required for "use cache" directives in codebase)
⋮----
// Explicit root avoids Next.js selecting an unrelated lockfile in a parent directory.
⋮----
// Remove console.log statements in production
⋮----
// Performance optimizations
⋮----
// Package import optimization by allowlist
⋮----
// Enable Turbopack file system caching for faster dev builds
// Note: turbopackFileSystemCacheForBuild requires canary version
⋮----
// Headers for security and performance
headers()
⋮----
// Cache static assets for better performance
⋮----
// Image optimization with modern formats
⋮----
// Enable image optimization for better performance
⋮----
minimumCacheTTL: 86400, // 24 hours
⋮----
// Define remote patterns for external images if needed
⋮----
// Add patterns for external image domains if needed
// {
//   protocol: 'https',
//   hostname: 'example.com',
//   port: '',
//   pathname: '/images/**',
// },
⋮----
// Deployment optimization
⋮----
// Output configuration
poweredByHeader: false, // Remove X-Powered-By header
⋮----
// React Compiler is supported in Next 16
⋮----
// Strict mode recommended for dev
⋮----
// Redirects for authentication
redirects()
⋮----
// Enable static exports optimization
⋮----
// Streamdown uses Shiki for code blocks. Force bundling to avoid
// "Package shiki can't be external" warnings in Next.js/Turbopack.
````

## File: src/ai/tools/server/accommodations.ts
````typescript
/**
 * @fileoverview Accommodation search, booking, and details tools wired through the accommodations service.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import {
  type AccommodationModelOutput,
  coerceToNumber,
} from "@ai/tools/schemas/accommodations";
import {
  createToolError,
  TOOL_ERROR_CODES,
  type ToolErrorCode,
} from "@ai/tools/server/errors";
import { getAccommodationsService } from "@domain/accommodations/container";
import { ProviderError } from "@domain/accommodations/errors";
import {
  type AccommodationBookingRequest,
  type AccommodationBookingResult,
  type AccommodationCheckAvailabilityParams,
  type AccommodationCheckAvailabilityResult,
  type AccommodationDetailsParams,
  type AccommodationDetailsResult,
  type AccommodationSearchParams,
  type AccommodationSearchResult,
  accommodationBookingInputSchema,
  accommodationBookingOutputSchema,
  accommodationCheckAvailabilityInputSchema,
  accommodationCheckAvailabilityOutputSchema,
  accommodationDetailsInputSchema,
  accommodationDetailsOutputSchema,
  accommodationSearchInputSchema,
  accommodationSearchOutputSchema,
} from "@schemas/accommodations";
import { headers } from "next/headers";
import { processBookingPayment } from "@/lib/payments/booking-payment";
import { secureUuid } from "@/lib/security/random";
import { createServerSupabase } from "@/lib/supabase/server";
import { requireApproval } from "./approvals";
⋮----
/**
 * Accommodations service instance for tool execution.
 *
 * This service is initialized at module scope, creating a singleton instance.
 * Singleton initialization is appropriate here because:
 * - The service manages connection pooling and shared adapters.
 * - Avoids redundant creation of service instances for each tool execution.
 * - The service is lightweight and always needed for all exported tools.
 *
 * If future requirements change and lazy initialization is needed, refactor accordingly.
 */
⋮----
/** Search for accommodations using Amadeus Self-Service API with Google Places enrichment. */
⋮----
/**
   * Simplifies accommodation results for model consumption to reduce token usage.
   * Strips photos, searchParameters, and compresses nested rates to essential pricing.
   */
⋮----
/**
     * Compute the actual lowest price across all rooms and rates for a listing.
     * Falls back to undefined if no valid prices found.
     */
const computeLowestPrice = (
      rooms?: Array<{ rates?: Array<{ price?: { total?: number | string } }> }>
): number | undefined =>
⋮----
/** Retrieve comprehensive details for a specific accommodation property from Amadeus and Google Places. */
⋮----
/** Check final availability and lock pricing for a specific rate. Returns a booking token that must be used quickly to finalize the booking. */
⋮----
/** Complete an accommodation booking via Amadeus. Requires a bookingToken from checkAvailability, payment method, and prior approval. */
⋮----
/** Extract user identifier from request headers or return undefined if not found. */
async function maybeGetUserIdentifier(): Promise<string | undefined>
⋮----
// Fall back to header inspection below.
⋮----
// headers() can throw outside of a request context.
⋮----
/** Get user identifier from request headers or throw an error if not found. */
async function getAuthenticatedUserId(errorCode: ToolErrorCode): Promise<string>
⋮----
/**
 * Map provider errors to tool errors.
 *
 * @param error Provider error to map.
 * @param codes Error code mappings for different provider error types.
 * @returns ToolError instance with appropriate error code and message.
 */
function mapProviderError(
  error: unknown,
  codes: {
    notFound: ToolErrorCode;
    rateLimited: ToolErrorCode;
    unauthorized: ToolErrorCode;
    failed: ToolErrorCode;
  }
)
````

## File: src/lib/api/error-types.ts
````typescript
/**
 * @fileoverview Consolidated error types for API and React Query integration.
 * Single ApiError class with error codes replaces separate error classes.
 */
⋮----
/** Standard error codes for API errors. */
export type ApiErrorCode =
  | "NETWORK_ERROR"
  | "TIMEOUT_ERROR"
  | "VALIDATION_ERROR"
  | "REQUEST_CANCELLED"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "NOT_FOUND"
  | "RATE_LIMITED"
  | "SERVER_ERROR"
  | "UNKNOWN_ERROR"
  | "RESPONSE_VALIDATION_ERROR"
  | `HTTP_${number}`; // Allow custom HTTP codes while preserving type safety
⋮----
| `HTTP_${number}`; // Allow custom HTTP codes while preserving type safety
⋮----
/** API error response interface. */
export interface ApiErrorResponse {
  message: string;
  status: number;
  code?: string;
  details?: Record<string, unknown>;
  timestamp?: string;
  path?: string;
}
⋮----
/** Validation result type for API errors. */
export interface ValidationResult<T> {
  success: boolean;
  errors?: Array<{
    code: string;
    context: string;
    field?: string;
    message: string;
    path?: string[];
    timestamp: Date;
    value?: T;
  }>;
}
⋮----
/** Field-level validation errors for form validation. */
export type FieldValidationErrors = Record<string, string[]>;
⋮----
/**
 * Unified API error class with error codes.
 * Replaces separate NetworkError, TimeoutError, ValidationError classes.
 */
export class ApiError extends Error
⋮----
constructor(
    messageOrOptions:
      | string
      | {
          code?: ApiErrorCode;
          data?: unknown;
          endpoint?: string;
          fieldErrors?: FieldValidationErrors;
          message: string;
          status: number;
          validationErrors?: ValidationResult<unknown>;
        },
    statusArg?: number,
    code?: ApiErrorCode,
    data?: unknown,
    endpoint?: string,
    validationErrors?: ValidationResult<unknown>,
    fieldErrors?: FieldValidationErrors
)
⋮----
/** Derive error code from HTTP status. */
public static codeFromStatus(status: number): ApiErrorCode
⋮----
/** Check if this is a client error (4xx). */
get isClientError(): boolean
⋮----
/** Check if this is a server error (5xx). */
get isServerError(): boolean
⋮----
/** Check if this error should be retried. */
get shouldRetry(): boolean
⋮----
/** Get user-friendly error message. */
get userMessage(): string
⋮----
/** Get user-friendly message for validation errors. */
private getValidationUserMessage(): string
⋮----
/** Get total count of validation errors. */
private getValidationErrorCount(): number
⋮----
/** Get first field error message if available. */
private getFirstFieldError(): string | undefined
⋮----
/** Checks if this error was caused by validation failures. */
public isValidationError(): boolean
⋮----
/** Extracts validation error messages from the error. */
public getValidationErrors(): string[]
⋮----
/** Convert to JSON for logging */
// biome-ignore lint/style/useNamingConvention: Standard JSON serialization method
toJSON()
⋮----
/** Factory for network errors. */
static network(message = "Network error occurred"): ApiError
⋮----
/** Factory for timeout errors. */
static timeout(message = "Request timed out"): ApiError
⋮----
/** Factory for validation errors. */
static validation(message: string, fieldErrors?: FieldValidationErrors): ApiError
⋮----
/** Factory for unknown errors. */
static unknown(message = "An unknown error occurred"): ApiError
⋮----
/** Type guard for ApiError. */
export const isApiError = (error: unknown): error is ApiError =>
⋮----
/** Check if an error is a network error (code-based). */
export const isNetworkError = (error: unknown): error is ApiError =>
⋮----
/** Check if an error is a timeout error (code-based). */
export const isTimeoutError = (error: unknown): error is ApiError =>
⋮----
/** Check if an error is a validation error (code-based or has validation details). */
export const isValidationError = (error: unknown): error is ApiError =>
⋮----
// ApiError: use instance method which checks code, fieldErrors, and validationErrors
⋮----
// Legacy support for Error with name "ValidationError"
⋮----
/** Union type for app errors (now just ApiError). */
export type AppError = ApiError;
⋮----
/** Error handler utility - normalizes all errors to ApiError. */
export const handleApiError = (error: unknown): ApiError =>
⋮----
// Check for network/timeout by name (legacy compatibility)
⋮----
// AbortError handling: Treats raw AbortError as external cancellation
// (REQUEST_CANCELLED / 499). The api-client module must wrap timeout-induced
// aborts with a distinct TIMEOUT_ERROR (408) before errors reach here;
// without such wrapping, it's impossible to distinguish timeout vs external
// cancellation. api-client uses an internal `abortedByTimeout` flag to
// determine abort source and throws the appropriate ApiError directly.
⋮----
// Try to parse as API error if it has status
⋮----
// Default to unknown error for generic errors
⋮----
// Fallback for unknown error types
⋮----
/** Error boundary helper for React Query errors */
export const getErrorMessage = (error: unknown): string =>
⋮----
/** Check if an error should trigger a retry */
export const shouldRetryError = (error: unknown): boolean =>
````

## File: src/lib/api/factory.ts
````typescript
/**
 * @fileoverview Higher-order function factory for Next.js route handlers.
 *
 * Wraps route handlers with authentication, rate limiting, error handling, and
 * telemetry. Per ADR-0029 and ADR-0032.
 */
⋮----
import type { User } from "@supabase/supabase-js";
import { Ratelimit } from "@upstash/ratelimit";
import type { NextRequest, NextResponse } from "next/server";
import type { z } from "zod";
import {
  checkAuthentication,
  errorResponse,
  getTrustedRateLimitIdentifier,
  parseJsonBody,
  unauthorizedResponse,
  withRequestSpan,
} from "@/lib/api/route-helpers";
import { type ApiMetric, fireAndForgetMetric } from "@/lib/metrics/api-metrics";
import { applyRateLimitHeaders } from "@/lib/ratelimit/headers";
import { hashIdentifier, normalizeIdentifier } from "@/lib/ratelimit/identifier";
import { ROUTE_RATE_LIMITS, type RouteRateLimitKey } from "@/lib/ratelimit/routes";
import { getRedis } from "@/lib/redis";
import {
  assertHumanOrThrow,
  BOT_DETECTED_RESPONSE,
  isBotDetectedError,
} from "@/lib/security/botid";
import type { TypedServerSupabase } from "@/lib/supabase/server";
import { createServerSupabase } from "@/lib/supabase/server";
import { emitOperationalAlertOncePerWindow } from "@/lib/telemetry/degraded-mode";
import { createServerLogger } from "@/lib/telemetry/logger";
import { sanitizePathnameForTelemetry } from "@/lib/telemetry/route-key";
⋮----
export type DegradedMode = "fail_closed" | "fail_open";
⋮----
/**
 * Configuration for route handler guards.
 */
export interface GuardsConfig<T extends z.ZodType = z.ZodType> {
  /** Whether authentication is required. Defaults to false. */
  auth?: boolean;
  /**
   * Enable BotID protection to block automated bots.
   * - true: Basic mode (free) - validates browser sessions
   * - "deep": Deep Analysis mode ($1/1000 calls) - Kasada-powered analysis
   * - { mode, allowVerifiedAiAssistants }: Advanced configuration
   *
   * Verified AI assistants (ChatGPT, Perplexity, Claude, etc.) are allowed
   * through by default but still subject to rate limiting. Set
   * allowVerifiedAiAssistants to false to block them on specific routes.
   *
   * @see https://vercel.com/docs/botid
   */
  botId?: BotIdGuardConfig;
  /** Rate limit key from ROUTE_RATE_LIMITS registry. */
  rateLimit?: RouteRateLimitKey;
  /**
   * Controls behavior when rate limiting infrastructure is unavailable.
   *
   * - fail_closed: deny the request when rate limiting can't be enforced
   * - fail_open: allow the request, but emit an operational alert
   */
  degradedMode?: DegradedMode;
  /** Telemetry span name for observability. */
  telemetry?: string;
  /** Optional Zod schema for request body validation. */
  schema?: T;
  /**
   * Override maximum JSON request body size (bytes) for schema parsing.
   *
   * Defaults to `API_CONSTANTS.maxBodySizeBytes` (64KB).
   */
  maxBodyBytes?: number;
}
⋮----
/** Whether authentication is required. Defaults to false. */
⋮----
/**
   * Enable BotID protection to block automated bots.
   * - true: Basic mode (free) - validates browser sessions
   * - "deep": Deep Analysis mode ($1/1000 calls) - Kasada-powered analysis
   * - { mode, allowVerifiedAiAssistants }: Advanced configuration
   *
   * Verified AI assistants (ChatGPT, Perplexity, Claude, etc.) are allowed
   * through by default but still subject to rate limiting. Set
   * allowVerifiedAiAssistants to false to block them on specific routes.
   *
   * @see https://vercel.com/docs/botid
   */
⋮----
/** Rate limit key from ROUTE_RATE_LIMITS registry. */
⋮----
/**
   * Controls behavior when rate limiting infrastructure is unavailable.
   *
   * - fail_closed: deny the request when rate limiting can't be enforced
   * - fail_open: allow the request, but emit an operational alert
   */
⋮----
/** Telemetry span name for observability. */
⋮----
/** Optional Zod schema for request body validation. */
⋮----
/**
   * Override maximum JSON request body size (bytes) for schema parsing.
   *
   * Defaults to `API_CONSTANTS.maxBodySizeBytes` (64KB).
   */
⋮----
export type BotIdGuardConfig =
  | boolean
  | "deep"
  | {
      mode: boolean | "deep";
      allowVerifiedAiAssistants?: boolean;
    };
⋮----
/**
 * Context injected into route handlers by the factory.
 */
export interface RouteContext {
  /** Supabase client instance. */
  supabase: TypedServerSupabase;
  /** Authenticated user, or null if auth disabled or unauthenticated. */
  user: User | null;
}
⋮----
/** Supabase client instance. */
⋮----
/** Authenticated user, or null if auth disabled or unauthenticated. */
⋮----
/**
 * Next.js route params context. Always present per Next.js 16 route handler signature.
 */
export type RouteParamsContext = { params: Promise<Record<string, string>> };
⋮----
type RateLimitResult = {
  limit: number;
  remaining: number;
  reset: number;
  reason?: "timeout";
  success: boolean;
};
⋮----
type RateLimitFactory = (
  key: RouteRateLimitKey,
  identifier: string
) => Promise<RateLimitResult>;
⋮----
// Test-only override to inject deterministic rate limiting behaviour.
export function setRateLimitFactoryForTests(factory: RateLimitFactory | null): void
⋮----
// Test-only override for Supabase factory to avoid Next.js request-store dependencies.
export function setSupabaseFactoryForTests(
  factory: (() => Promise<TypedServerSupabase>) | null
): void
⋮----
/**
 * Route handler function signature.
 *
 * Supports static routes (req only) and dynamic routes (req + route params).
 * When a schema is provided in GuardsConfig, the handler receives validated
 * data as the third argument.
 */
export type RouteHandler<Data = unknown> = (
  req: NextRequest,
  context: RouteContext,
  data: Data,
  routeContext: RouteParamsContext
) => Promise<Response> | Response;
⋮----
/**
 * Retrieves rate limit configuration for a given key.
 *
 * @param key Rate limit key from registry.
 * @returns Configuration object or null if not found.
 */
function getRateLimitConfig(
  key: RouteRateLimitKey
):
⋮----
function parseRateLimitWindowMs(window: string): number | null
⋮----
function defaultDegradedModeForRateLimitKey(key: RouteRateLimitKey): DegradedMode
⋮----
function getSafeRouteKeyForTelemetry(options: {
  telemetry?: string;
  rateLimit?: RouteRateLimitKey;
  pathname: string;
}): string
⋮----
/**
 * Handles rate limit timeout by either failing closed (503) or failing open with an alert.
 *
 * @returns Response if should fail closed, null if failing open
 */
function handleRateLimitTimeout(
  rateLimitKey: RouteRateLimitKey,
  windowMs: number,
  degradedMode: DegradedMode
): NextResponse | null
⋮----
/**
 * Enforces rate limiting for a route.
 *
 * @param rateLimitKey Rate limit key from registry.
 * @param identifier User ID or IP address for rate limiting.
 * @returns Error response if limit exceeded, null otherwise.
 */
async function enforceRateLimit(
  rateLimitKey: RouteRateLimitKey,
  identifier: string,
  options: { degradedMode: DegradedMode }
): Promise<NextResponse | null>
⋮----
// At this point, rateLimitFactory is falsy, so redis must be defined
⋮----
return null; // Should not reach here due to earlier check, but satisfy TypeScript
⋮----
/**
 * Wraps a route handler with authentication, rate limiting, error handling, and telemetry.
 *
 * @param config Guard configuration.
 * @returns Function that accepts a route handler and returns a guarded handler.
 *
 * @example
 * ```typescript
 * export const GET = withApiGuards({
 *   auth: true,
 *   rateLimit: "user-settings:get",
 *   telemetry: "user-settings.get",
 * })(async (req, { user, supabase }) => {
 *   const data = await fetchData(user!.id);
 *   return NextResponse.json(data);
 * });
 * ```
 *
 * @example
 * ```typescript
 * export const POST = withApiGuards({
 *   auth: true,
 *   schema: RequestSchema,
 * })(async (req, { user }, body) => {
 *   // body is typed as z.infer<typeof RequestSchema>
 *   return NextResponse.json({ success: true });
 * });
 * ```
 */
export function withApiGuards<SchemaType extends z.ZodType>(
  config: GuardsConfig<SchemaType> & { schema: SchemaType }
): (
  handler: RouteHandler<z.infer<SchemaType>>
)
export function withApiGuards(
  config: GuardsConfig
): (
  handler: RouteHandler<unknown>
)
export function withApiGuards<SchemaType extends z.ZodType>(
  config: GuardsConfig<SchemaType>
): (
  handler: RouteHandler<SchemaType extends z.ZodType ? z.infer<SchemaType> : unknown>
) => (req: NextRequest, routeContext: RouteParamsContext) => Promise<Response>
⋮----
// Validate rate limit key exists if provided
⋮----
// Handle authentication if required
⋮----
// Handle BotID protection if configured (after auth, before rate limiting)
// Bot traffic shouldn't count against rate limits
⋮----
// Handle rate limiting if configured
⋮----
// Parse and validate request body if schema is provided
⋮----
// Execute handler with telemetry if configured
const executeHandler = async () =>
⋮----
// Record metric (fire-and-forget)
⋮----
// Record error metric (fire-and-forget)
````

## File: src/ai/tools/server/web-crawl.ts
````typescript
/**
 * @fileoverview Firecrawl-backed web scrape/crawl tools with Redis caching.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import {
  crawlSiteInputSchema,
  crawlSiteOutputSchema,
  crawlUrlInputSchema,
  crawlUrlOutputSchema,
} from "@ai/tools/schemas/web-crawl";
import type { z } from "zod";
⋮----
type RawScrapeOptions = z.infer<typeof crawlSiteInputSchema.shape.scrapeOptions>;
⋮----
type ScrapeFormat =
  | "markdown"
  | "html"
  | "links"
  | "screenshot"
  | "summary"
  | {
      type: "json";
      prompt?: string;
      schema?: Record<string, unknown>;
    };
⋮----
type ScrapeOptions = {
  actions?: Record<string, unknown>[];
  formats?: ScrapeFormat[];
  location?: { country?: string; languages?: string[] };
  maxAge?: number;
  onlyMainContent?: boolean;
  parsers?: string[];
  proxy?: "basic" | "stealth" | "auto";
};
⋮----
type JsonFormatInput = {
  type: "json";
  prompt?: string | null;
  schema?: Record<string, unknown> | null;
};
⋮----
function isJsonFormat(value: unknown): value is JsonFormatInput
⋮----
/**
 * Normalizes URL for cache key generation.
 */
function kv(s: string): string
⋮----
/**
 * Generates cache key for scrape including all options affecting results.
 */
function scrapeCacheKey(url: string, scrapeOptions?: ScrapeOptions): string
⋮----
/**
 * Generates cache key for crawl including all options affecting results.
 */
function crawlCacheKey(
  url: string,
  limit: number,
  includePaths?: string[],
  excludePaths?: string[],
  sitemap?: string,
  scrapeOptions?: ScrapeOptions
): string
⋮----
function normalizeScrapeOptionsForCache(
  scrapeOptions: RawScrapeOptions
): ScrapeOptions | undefined
⋮----
/**
 * Builds scrape request body with cost-safe defaults.
 */
function buildScrapeBody(
  url: string,
  scrapeOptions?: ScrapeOptions
): Record<string, unknown>
⋮----
body.parsers = []; // Cost-safe: avoid PDF parsing unless explicit
⋮----
body.proxy = so.proxy ?? "basic"; // Cost-safe: avoid stealth unless needed
⋮----
/**
 * Builds crawl request body with cost-safe defaults.
 */
function buildCrawlBody(
  url: string,
  limit: number,
  includePaths?: string[],
  excludePaths?: string[],
  sitemap?: string,
  scrapeOptions?: ScrapeOptions
): Record<string, unknown>
⋮----
/**
 * Polls crawl status until completion or timeout.
 */
async function pollCrawlStatus(
  baseUrl: string,
  apiKey: string,
  crawlId: string,
  options: {
    pollInterval?: number;
    timeoutMs?: number;
    maxPages?: number;
    maxResults?: number;
    maxWaitTime?: number;
  }
): Promise<Record<string, unknown>>
⋮----
// Normalize missing configuration into a tool-specific error code
````

## File: src/ai/tools/server/web-search-batch.ts
````typescript
/**
 * @fileoverview Batch web search tool with bounded concurrency and optional top-level rate limiting.
 */
⋮----
import { createAiTool } from "@ai/lib/tool-factory";
import {
  WEB_SEARCH_BATCH_OUTPUT_SCHEMA,
  WEB_SEARCH_OUTPUT_SCHEMA,
  webSearchInputSchema,
} from "@ai/tools/schemas/web-search";
import {
  type WebSearchBatchModelOutput,
  webSearchBatchInputSchema,
} from "@ai/tools/schemas/web-search-batch";
import { createToolError, TOOL_ERROR_CODES } from "@ai/tools/server/errors";
import { normalizeWebSearchResults } from "@ai/tools/server/web-search-normalize";
import { Ratelimit } from "@upstash/ratelimit";
import type { ToolCallOptions } from "ai";
import { z } from "zod";
import { hashInputForCache } from "@/lib/cache/hash";
import { hashIdentifier, normalizeIdentifier } from "@/lib/ratelimit/identifier";
import { getRedis } from "@/lib/redis";
import { createServerLogger } from "@/lib/telemetry/logger";
import { webSearch } from "./web-search";
⋮----
function isAsyncIterable(value: unknown): value is AsyncIterable<unknown>
⋮----
async function resolveToolResult(result: unknown): Promise<unknown>
⋮----
/**
 * Build Upstash rate limiter for batch web search tool.
 *
 * Returns undefined if Upstash env vars are missing. Uses sliding window:
 * 20 requests per minute per user.
 *
 * @returns Rate limiter instance or undefined if not configured.
 */
⋮----
function buildToolRateLimiter(): InstanceType<typeof Ratelimit> | undefined
⋮----
/**
 * Input schema for batch web search tool.
 *
 * Validates 1-10 queries and shared search parameters (sources, categories,
 * location, tbs, scrapeOptions). All queries use the same configuration.
 */
⋮----
/**
 * Batch web search tool using Firecrawl v2.5 API.
 *
 * Executes multiple queries concurrently (pool size 5). Reuses webSearch tool per
 * query, inheriting caching and rate limiting. All queries share the same search
 * configuration. Falls back to direct HTTP only for unexpected internal errors.
 *
 * @returns Batch results with array of query results and total execution time.
 * @throws {Error} Error with code:
 *   - "web_search_rate_limited": Top-level rate limit exceeded (429)
 *   - Query errors are returned in results array, not thrown
 */
⋮----
// Optional top-level rate limiting (in addition to per-query limits)
⋮----
// Bounded concurrency runner with pool size 5
⋮----
const runOne = async (q: string) =>
⋮----
// Check for typed error with code property first, then fall back to message parsing
const hasCode = (e: unknown): e is
⋮----
// Fallback to direct HTTP for unexpected errors (not rate/auth/payment)
⋮----
// Proper env access via validated server env helpers
⋮----
// Build body with only defined fields to avoid API rejection
⋮----
// Clamp timeouts to safe bounds to avoid too-short/unbounded requests and align with provider expectations.
⋮----
// Normalize fallback HTTP response to ensure strict schema compliance
⋮----
// Debug aid with safe context (no sensitive data)
⋮----
// Debug aid with safe context (no sensitive data)
⋮----
// Sequential index allocation (safe due to JS single-threaded event loop)
⋮----
const getNextIndex = (): number
⋮----
// Validate final output against strict schema
⋮----
/**
   * Simplifies batch search results for model consumption to reduce token usage.
   * Strips snippets, publishedAt dates, and limits results per query.
   */
⋮----
// Cap to 5 results per query to fit token budgets; raise/make configurable if higher recall is needed.
````

## File: package.json
````json
{
  "name": "tripsage-ai-frontend",
  "version": "1.21.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "build:analyze": "ANALYZE=true next build",
    "start": "next start",
    "lint": "biome lint ./src ./e2e ./scripts",
    "format:biome": "biome format ./src --write",
    "biome:check": "biome check ./src ./e2e ./scripts",
    "biome:fix": "biome check ./src ./e2e ./scripts --fix",
    "type-check": "tsc --noEmit",
    "test": "vitest run",
    "test:short": "vitest run --test-timeout=3000 --hook-timeout=3000 --teardown-timeout=3000",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage.enabled --coverage.provider=v8",
    "test:benchmark": "node scripts/run-benchmark.mjs",
    "test:quick": "vitest run --reporter=dot",
    "test:ci": "vitest run --reporter=dot --reporter=github-actions",
    "test:unit": "vitest run --project=unit",
    "test:schemas": "vitest run --project=schemas",
    "test:components": "vitest run --project=component",
    "test:api": "vitest run --project=api",
    "test:integration": "vitest run --project=integration",
    "test:shard": "vitest run --reporter=blob --shard=$VITEST_SHARD",
    "test:pr": "vitest run --changed origin/main --passWithNoTests",
    "test:upstash:unit": "vitest run src/test/upstash/upstash.unit.test.ts",
    "test:upstash:int": "UPSTASH_USE_EMULATOR=1 vitest run --project=integration src/__tests__/contracts/upstash-int.integration.test.ts",
    "test:upstash:smoke": "UPSTASH_SMOKE=1 vitest run --project=integration src/__tests__/contracts/upstash.smoke.integration.test.ts",
    "test:changed": "vitest run --changed",
    "test:affected": "vitest run --changed --passWithNoTests && git diff -z --name-only HEAD -- 'src/**/*.ts' 'src/**/*.tsx' ':!**/*.test.ts' ':!**/*.test.tsx' | xargs -0 -r vitest related --run --passWithNoTests",
    "test:coverage:shard": "vitest run --coverage.enabled --coverage.provider=v8 --reporter=blob --shard=$VITEST_SHARD",
    "test:merge": "vitest --merge-reports",
    "test:e2e": "playwright test",
    "ops": "tsx scripts/ops.ts",
    "test:analyze": "pnpm ops test analyze failures",
    "test:analyze:all": "pnpm ops test analyze all",
    "boundary:check": "node scripts/check-boundaries.mjs",
    "ai-tools:check": "node scripts/check-ai-tools.mjs",
    "check:no-new-unknown-casts": "node scripts/check-no-new-unknown-casts.mjs",
    "check:no-unknown-casts": "node scripts/check-no-unknown-casts.mjs",
    "deps:cycles": "madge --circular --extensions ts,tsx --ts-config ./tsconfig.json src/ai/agents"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "3.0.0-beta.83",
    "@ai-sdk/openai": "3.0.0-beta.96",
    "@ai-sdk/react": "3.0.0-beta.153",
    "@ai-sdk/togetherai": "2.0.0-beta.49",
    "@ai-sdk/xai": "3.0.0-beta.55",
    "@hello-pangea/dnd": "^18.0.1",
    "@hookform/resolvers": "^5.2.2",
    "@icons-pack/react-simple-icons": "^13.8.0",
    "@opentelemetry/api": "^1.9.0",
    "@opentelemetry/core": "^2.2.0",
    "@opentelemetry/exporter-trace-otlp-http": "^0.208.0",
    "@opentelemetry/instrumentation": "^0.208.0",
    "@opentelemetry/instrumentation-fetch": "^0.208.0",
    "@opentelemetry/resources": "^2.2.0",
    "@opentelemetry/sdk-node": "^0.208.0",
    "@opentelemetry/sdk-trace-base": "^2.2.0",
    "@opentelemetry/sdk-trace-web": "^2.2.0",
    "@opentelemetry/semantic-conventions": "^1.38.0",
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-alert-dialog": "^1.1.15",
    "@radix-ui/react-avatar": "^1.1.11",
    "@radix-ui/react-checkbox": "^1.3.3",
    "@radix-ui/react-collapsible": "^1.1.12",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-hover-card": "^1.1.15",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-menubar": "^1.1.16",
    "@radix-ui/react-navigation-menu": "^1.2.14",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-progress": "^1.1.8",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slider": "^1.3.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-toggle": "^1.1.10",
    "@radix-ui/react-toggle-group": "^1.1.11",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@supabase/postgrest-js": "^2.87.3",
    "@supabase/ssr": "^0.8.0",
    "@supabase/supabase-js": "^2.87.3",
    "@tanstack/react-query": "^5.90.12",
    "@upstash/qstash": "^2.8.4",
    "@upstash/ratelimit": "2.0.7",
    "@upstash/redis": "^1.35.8",
    "@vercel/otel": "^2.1.0",
    "ai": "6.0.0-beta.150",
    "amadeus": "^11.0.0",
    "botid": "^1.5.10",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^4.1.0",
    "file-type": "^21.1.1",
    "html-to-text": "^9.0.5",
    "i18n-iso-countries": "^7.14.0",
    "ical-generator": "^10.0.0",
    "ical.js": "^2.2.1",
    "import-in-the-middle": "^2.0.0",
    "js-tiktoken": "^1.0.21",
    "lucide-react": "^0.561.0",
    "mem0ai": "^2.1.38",
    "motion": "^12.23.26",
    "next": "^16.0.10",
    "next-themes": "^0.4.6",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "react-error-boundary": "^6.0.0",
    "react-hook-form": "^7.68.0",
    "recharts": "^3.6.0",
    "require-in-the-middle": "^8.0.1",
    "resend": "^6.6.0",
    "shiki": "^3.20.0",
    "sonner": "^2.0.7",
    "streamdown": "^1.6.10",
    "stripe": "^20.0.0",
    "tailwind-merge": "^3.4.0",
    "use-stick-to-bottom": "^1.1.1",
    "vaul": "^1.1.2",
    "web-vitals": "^5.1.0",
    "zod": "^4.2.1",
    "zustand": "^5.0.9"
  },
  "devDependencies": {
    "@biomejs/biome": "^2.3.9",
    "@next/bundle-analyzer": "^16.0.10",
    "@playwright/test": "^1.57.0",
    "@semantic-release/changelog": "^6.0.3",
    "@semantic-release/git": "^10.0.1",
    "@tailwindcss/postcss": "^4.1.18",
    "@tanstack/react-query-devtools": "^5.91.1",
    "@testing-library/dom": "^10.4.1",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@testing-library/user-event": "^14.6.1",
    "@types/google.maps": "^3.58.1",
    "@types/html-to-text": "^9.0.4",
    "@types/jscodeshift": "^17.3.0",
    "@types/luxon": "^3.7.1",
    "@types/node": "^25.0.2",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.2",
    "@vitest/coverage-v8": "^4.0.15",
    "@vitest/ui": "^4.0.15",
    "babel-plugin-react-compiler": "^1.0.0",
    "madge": "^6.1.0",
    "conventional-changelog-conventionalcommits": "^9.1.0",
    "jose": "^6.1.3",
    "jscodeshift": "^17.3.0",
    "jsdom": "^27.3.0",
    "jsondiffpatch": "^0.7.3",
    "msw": "^2.12.4",
    "semantic-release": "^25.0.2",
    "tailwindcss": "^4.1.18",
    "tailwindcss-animate": "^1.0.7",
    "tsx": "^4.21.0",
    "typescript": "^5.9.3",
    "unified": "^11.0.5",
    "vitest": "^4.0.15"
  },
  "engines": {
    "node": "24.x",
    "pnpm": ">=9.0.0"
  },
  "pnpm": {
    "packageExtensions": {
      "openai@*": {
        "dependencies": {
          "zod": "3.25.76"
        }
      }
    },
    "peerDependencyRules": {
      "allowedVersions": {
        "openai>zod": "^4.2.0"
      },
      "ignoreMissing": [
        "@anthropic-ai/sdk",
        "@cloudflare/workers-types",
        "@google/genai",
        "@langchain/core",
        "@mistralai/mistralai",
        "@qdrant/js-client-rest",
        "@types/jest",
        "@types/pg",
        "@types/sqlite3",
        "@valibot/to-json-schema",
        "cloudflare",
        "effect",
        "groq-sdk",
        "neo4j-driver",
        "ollama",
        "pg",
        "redis",
        "sqlite3",
        "valibot"
      ]
    },
    "overrides": {
      "axios": "1.13.2",
      "prismjs": ">=1.30.0",
      "undici": "5.29.0",
      "brace-expansion": ">=2.0.2"
    },
    "ignoredBuiltDependencies": [
      "esbuild",
      "msw"
    ]
  }
}
````
