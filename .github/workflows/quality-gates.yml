name: Quality Gates

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]
  workflow_run:
    workflows: ["Backend CI", "Frontend CI", "Security Scanning", "Code Coverage Analysis"]
    types: [completed]
  workflow_dispatch:

permissions:
  contents: read
  checks: write
  pull-requests: write
  statuses: write

env:
  # Quality thresholds
  BACKEND_COVERAGE_THRESHOLD: 85
  FRONTEND_COVERAGE_THRESHOLD: 80
  MAX_CRITICAL_VULNERABILITIES: 0
  MAX_HIGH_VULNERABILITIES: 2
  MAX_CODE_DUPLICATION: 10  # percentage

jobs:
  quality-gate-check:
    name: Quality Gate Validation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Wait for required workflows
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const requiredWorkflows = ['Backend CI', 'Frontend CI', 'Security Scanning'];
          const sha = context.payload.pull_request?.head?.sha || context.sha;
          
          // Wait for all required workflows to complete
          for (const workflowName of requiredWorkflows) {
            console.log(`Waiting for workflow: ${workflowName}`);
            
            let completed = false;
            let attempts = 0;
            const maxAttempts = 30; // 5 minutes with 10-second intervals
            
            while (!completed && attempts < maxAttempts) {
              const runs = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                head_sha: sha,
                status: 'completed'
              });
              
              const workflowRun = runs.data.workflow_runs.find(run => 
                run.name === workflowName && run.head_sha === sha
              );
              
              if (workflowRun) {
                console.log(`âœ… ${workflowName} completed with status: ${workflowRun.conclusion}`);
                completed = true;
              } else {
                console.log(`â³ Waiting for ${workflowName}... (attempt ${attempts + 1}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds
                attempts++;
              }
            }
            
            if (!completed) {
              console.log(`âš ï¸ ${workflowName} did not complete within timeout`);
            }
          }

    - name: Collect workflow results
      id: collect-results
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const sha = context.payload.pull_request?.head?.sha || context.sha;
          
          const runs = await github.rest.actions.listWorkflowRunsForRepo({
            owner,
            repo,
            head_sha: sha,
            per_page: 100
          });
          
          const workflowResults = {};
          const requiredWorkflows = [
            'Backend CI',
            'Frontend CI', 
            'Security Scanning',
            'Code Coverage Analysis'
          ];
          
          for (const workflowName of requiredWorkflows) {
            const run = runs.data.workflow_runs.find(r => 
              r.name === workflowName && r.head_sha === sha
            );
            
            if (run) {
              workflowResults[workflowName] = {
                status: run.status,
                conclusion: run.conclusion,
                url: run.html_url,
                id: run.id
              };
            } else {
              workflowResults[workflowName] = {
                status: 'not_found',
                conclusion: 'not_found',
                url: null,
                id: null
              };
            }
          }
          
          console.log('Workflow Results:', JSON.stringify(workflowResults, null, 2));
          
          // Set outputs for later steps
          core.setOutput('backend-ci', workflowResults['Backend CI']?.conclusion || 'not_found');
          core.setOutput('frontend-ci', workflowResults['Frontend CI']?.conclusion || 'not_found');
          core.setOutput('security', workflowResults['Security Scanning']?.conclusion || 'not_found');
          core.setOutput('coverage', workflowResults['Code Coverage Analysis']?.conclusion || 'not_found');
          
          return workflowResults;

    - name: Download artifacts from related workflows
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const { owner, repo } = context.repo;
          const sha = context.payload.pull_request?.head?.sha || context.sha;
          
          // Get recent workflow runs for this SHA
          const runs = await github.rest.actions.listWorkflowRunsForRepo({
            owner,
            repo,
            head_sha: sha,
            per_page: 50
          });
          
          // Try to download artifacts from coverage and security workflows
          for (const run of runs.data.workflow_runs) {
            if (['Code Coverage Analysis', 'Security Scanning'].includes(run.name)) {
              try {
                const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                  owner,
                  repo,
                  run_id: run.id
                });
                
                console.log(`Found ${artifacts.data.artifacts.length} artifacts in ${run.name}`);
                
                // Log artifact names for debugging
                for (const artifact of artifacts.data.artifacts) {
                  console.log(`- ${artifact.name} (${artifact.size_in_bytes} bytes)`);
                }
              } catch (error) {
                console.log(`Could not access artifacts for ${run.name}: ${error.message}`);
              }
            }
          }

    - name: Evaluate quality gates
      id: quality-gates
      run: |
        echo "Quality Gate Evaluation"
        echo "======================="
        
        # Initialize gate status
        BACKEND_CI="${{ steps.collect-results.outputs.backend-ci }}"
        FRONTEND_CI="${{ steps.collect-results.outputs.frontend-ci }}"
        SECURITY="${{ steps.collect-results.outputs.security }}"
        COVERAGE="${{ steps.collect-results.outputs.coverage }}"
        
        echo "Backend CI: $BACKEND_CI"
        echo "Frontend CI: $FRONTEND_CI"
        echo "Security: $SECURITY"
        echo "Coverage: $COVERAGE"
        
        # Quality gate checks
        GATES_PASSED=true
        FAILED_GATES=""
        
        # Critical gates (must pass)
        if [ "$BACKEND_CI" != "success" ]; then
          GATES_PASSED=false
          FAILED_GATES="$FAILED_GATES Backend-CI"
          echo "âŒ CRITICAL: Backend CI failed"
        fi
        
        if [ "$FRONTEND_CI" != "success" ]; then
          GATES_PASSED=false
          FAILED_GATES="$FAILED_GATES Frontend-CI"
          echo "âŒ CRITICAL: Frontend CI failed"
        fi
        
        # Security gates (must pass for main branch)
        if [ "${{ github.ref }}" = "refs/heads/main" ] && [ "$SECURITY" = "failure" ]; then
          GATES_PASSED=false
          FAILED_GATES="$FAILED_GATES Security"
          echo "âŒ CRITICAL: Security scan failed (main branch)"
        elif [ "$SECURITY" = "failure" ]; then
          echo "âš ï¸ WARNING: Security scan failed (not main branch)"
        fi
        
        # Coverage gates (warning for PR, failure for main)
        if [ "$COVERAGE" = "failure" ]; then
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            GATES_PASSED=false
            FAILED_GATES="$FAILED_GATES Coverage"
            echo "âŒ CRITICAL: Coverage below threshold (main branch)"
          else
            echo "âš ï¸ WARNING: Coverage below threshold"
          fi
        fi
        
        # Set outputs
        echo "gates_passed=$GATES_PASSED" >> $GITHUB_OUTPUT
        echo "failed_gates=$FAILED_GATES" >> $GITHUB_OUTPUT
        
        if [ "$GATES_PASSED" = "true" ]; then
          echo "âœ… All quality gates passed!"
        else
          echo "âŒ Quality gates failed:$FAILED_GATES"
        fi

    - name: Update PR status checks
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const sha = context.payload.pull_request.head.sha;
          const gatesPassed = '${{ steps.quality-gates.outputs.gates_passed }}' === 'true';
          const failedGates = '${{ steps.quality-gates.outputs.failed_gates }}';
          
          // Create status check
          await github.rest.repos.createCommitStatus({
            owner,
            repo,
            sha,
            state: gatesPassed ? 'success' : 'failure',
            description: gatesPassed ? 
              'All quality gates passed' : 
              `Failed gates: ${failedGates}`,
            context: 'Quality Gates'
          });
          
          // Create detailed check run
          await github.rest.checks.create({
            owner,
            repo,
            name: 'Quality Gates Summary',
            head_sha: sha,
            status: 'completed',
            conclusion: gatesPassed ? 'success' : 'failure',
            output: {
              title: gatesPassed ? 'âœ… Quality Gates Passed' : 'âŒ Quality Gates Failed',
              summary: gatesPassed ? 
                'All quality requirements have been met.' :
                `The following quality gates failed: ${failedGates}`,
              text: `
                ## Quality Gate Results
                
                | Gate | Status |
                |------|--------|
                | Backend CI | ${{ steps.collect-results.outputs.backend-ci == 'success' && 'âœ…' || 'âŒ' }} ${{ steps.collect-results.outputs.backend-ci }} |
                | Frontend CI | ${{ steps.collect-results.outputs.frontend-ci == 'success' && 'âœ…' || 'âŒ' }} ${{ steps.collect-results.outputs.frontend-ci }} |
                | Security Scanning | ${{ steps.collect-results.outputs.security == 'success' && 'âœ…' || steps.collect-results.outputs.security == 'failure' && 'âŒ' || 'âš ï¸' }} ${{ steps.collect-results.outputs.security }} |
                | Code Coverage | ${{ steps.collect-results.outputs.coverage == 'success' && 'âœ…' || steps.collect-results.outputs.coverage == 'failure' && 'âŒ' || 'âš ï¸' }} ${{ steps.collect-results.outputs.coverage }} |
                
                ${gatesPassed ? 
                  'ðŸŽ‰ **All quality gates have passed!** This PR meets all quality requirements.' :
                  'âš ï¸ **Quality gates failed.** Please address the issues above before merging.'
                }
              `
            }
          });

    - name: Create quality gate comment
      if: github.event_name == 'pull_request' && steps.quality-gates.outputs.gates_passed != 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const failedGates = '${{ steps.quality-gates.outputs.failed_gates }}';
          
          const comment = `## âŒ Quality Gates Failed
          
          The following quality gates need to be addressed before this PR can be merged:
          
          **Failed Gates:** ${failedGates}
          
          ### Next Steps:
          1. Review the failed workflow runs linked above
          2. Address any issues found in the reports
          3. Push fixes to update the PR
          4. Wait for quality gates to re-run automatically
          
          ### Quality Requirements:
          - âœ… Backend CI must pass (build, tests, linting)
          - âœ… Frontend CI must pass (build, tests, linting) 
          - âœ… Security scans must not find critical vulnerabilities
          - âœ… Code coverage must meet thresholds (Backend: ${process.env.BACKEND_COVERAGE_THRESHOLD}%, Frontend: ${process.env.FRONTEND_COVERAGE_THRESHOLD}%)
          
          ðŸ“Š [View detailed reports](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

    - name: Fail workflow if gates failed
      if: steps.quality-gates.outputs.gates_passed != 'true'
      run: |
        echo "âŒ Quality gates failed. See above for details."
        exit 1

  merge-readiness-check:
    name: Merge Readiness
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [quality-gate-check]
    if: github.event_name == 'pull_request' && needs.quality-gate-check.result == 'success'
    
    steps:
    - name: Check merge readiness
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const pr = context.payload.pull_request;
          
          // Get PR details
          const prData = await github.rest.pulls.get({
            owner,
            repo,
            pull_number: pr.number
          });
          
          // Check for merge conflicts
          const mergeable = prData.data.mergeable;
          const mergeableState = prData.data.mergeable_state;
          
          // Get reviews
          const reviews = await github.rest.pulls.listReviews({
            owner,
            repo,
            pull_number: pr.number
          });
          
          // Check for required approvals
          const latestReviews = {};
          reviews.data.forEach(review => {
            latestReviews[review.user.login] = review.state;
          });
          
          const approvals = Object.values(latestReviews).filter(state => state === 'APPROVED').length;
          const hasApproval = approvals > 0;
          
          // Create readiness summary
          const readinessChecks = [
            { name: 'Quality Gates', status: true, description: 'All CI checks passed' },
            { name: 'Merge Conflicts', status: mergeable !== false, description: mergeable === false ? 'Has conflicts' : 'No conflicts' },
            { name: 'Code Review', status: hasApproval, description: hasApproval ? `${approvals} approval(s)` : 'Needs approval' },
            { name: 'Draft Status', status: !pr.draft, description: pr.draft ? 'Still in draft' : 'Ready for review' }
          ];
          
          const allReady = readinessChecks.every(check => check.status);
          
          const comment = `## ðŸš€ Merge Readiness Check
          
          | Check | Status | Details |
          |-------|--------|---------|
          ${readinessChecks.map(check => 
            `| ${check.name} | ${check.status ? 'âœ…' : 'âŒ'} | ${check.description} |`
          ).join('\\n')}
          
          ${allReady ? 
            'ðŸŽ‰ **This PR is ready to merge!** All requirements have been met.' :
            'âš ï¸ **This PR is not ready to merge yet.** Please address the failing checks above.'
          }
          
          ### Merge Guidelines:
          - Use **Squash and merge** for feature branches
          - Use **Rebase and merge** for hotfixes
          - Ensure commit message follows conventional commit format
          - Delete feature branch after merging
          `;
          
          github.rest.issues.createComment({
            issue_number: pr.number,
            owner,
            repo,
            body: comment
          });

  quality-metrics:
    name: Quality Metrics
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Collect quality metrics
      run: |
        echo "Collecting quality metrics for main branch..."
        
        # Create metrics directory
        mkdir -p .quality-metrics
        
        # Basic repository metrics
        echo "Repository Metrics:" > .quality-metrics/repo-metrics.md
        echo "==================" >> .quality-metrics/repo-metrics.md
        echo "- Commit SHA: ${{ github.sha }}" >> .quality-metrics/repo-metrics.md
        echo "- Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> .quality-metrics/repo-metrics.md
        echo "- Branch: ${{ github.ref_name }}" >> .quality-metrics/repo-metrics.md
        
        # Count files by type
        echo "" >> .quality-metrics/repo-metrics.md
        echo "Code Statistics:" >> .quality-metrics/repo-metrics.md
        echo "- Python files: $(find . -name "*.py" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.venv/*" | wc -l)" >> .quality-metrics/repo-metrics.md
        echo "- TypeScript files: $(find . -name "*.ts" -o -name "*.tsx" -not -path "./node_modules/*" -not -path "./.git/*" | wc -l)" >> .quality-metrics/repo-metrics.md
        echo "- Test files: $(find . -name "*test*.py" -o -name "*test*.ts" -o -name "*test*.tsx" -o -name "*.spec.*" -not -path "./node_modules/*" -not -path "./.git/*" | wc -l)" >> .quality-metrics/repo-metrics.md
        
        # Lines of code (approximate)
        echo "- Total Python LOC: $(find . -name "*.py" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.venv/*" -exec cat {} \; | wc -l)" >> .quality-metrics/repo-metrics.md
        echo "- Total TypeScript LOC: $(find . -name "*.ts" -o -name "*.tsx" -not -path "./node_modules/*" -not -path "./.git/*" -exec cat {} \; | wc -l)" >> .quality-metrics/repo-metrics.md

    - name: Store quality trends
      run: |
        # Create or append to quality trends file
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        
        # Store basic metrics in CSV format for trending
        if [ ! -f .quality-metrics/quality-trends.csv ]; then
          echo "timestamp,commit_sha,python_files,typescript_files,test_files,python_loc,typescript_loc" > .quality-metrics/quality-trends.csv
        fi
        
        PYTHON_FILES=$(find . -name "*.py" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.venv/*" | wc -l)
        TS_FILES=$(find . -name "*.ts" -o -name "*.tsx" -not -path "./node_modules/*" -not -path "./.git/*" | wc -l)
        TEST_FILES=$(find . -name "*test*.py" -o -name "*test*.ts" -o -name "*test*.tsx" -o -name "*.spec.*" -not -path "./node_modules/*" -not -path "./.git/*" | wc -l)
        PYTHON_LOC=$(find . -name "*.py" -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.venv/*" -exec cat {} \; | wc -l)
        TS_LOC=$(find . -name "*.ts" -o -name "*.tsx" -not -path "./node_modules/*" -not -path "./.git/*" -exec cat {} \; | wc -l)
        
        echo "$TIMESTAMP,${{ github.sha }},$PYTHON_FILES,$TS_FILES,$TEST_FILES,$PYTHON_LOC,$TS_LOC" >> .quality-metrics/quality-trends.csv
        
        echo "Quality metrics updated for commit ${{ github.sha }}"

    - name: Commit quality metrics
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        if [ -n "$(git status --porcelain .quality-metrics/)" ]; then
          git add .quality-metrics/
          git commit -m "docs: update quality metrics [skip ci]"
          git push
        else
          echo "No quality metric changes to commit"
        fi