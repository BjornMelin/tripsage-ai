name: PR Automation & Quality Checks

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled]
    branches: [main, dev]
  pull_request_review:
    types: [submitted]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

jobs:
  pr-labeling:
    name: Auto Label PR
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.action == 'opened' || github.event.action == 'synchronize'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Auto-label based on file changes
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo, number } = context.issue;
          
          // Get list of changed files
          const files = await github.rest.pulls.listFiles({
            owner,
            repo,
            pull_number: number
          });
          
          const changedFiles = files.data.map(file => file.filename);
          const labels = [];
          
          // Label based on file patterns
          if (changedFiles.some(f => f.startsWith('frontend/'))) {
            labels.push('frontend');
          }
          
          if (changedFiles.some(f => f.endsWith('.py'))) {
            labels.push('backend');
          }
          
          if (changedFiles.some(f => f.includes('test') || f.includes('spec'))) {
            labels.push('tests');
          }
          
          if (changedFiles.some(f => f.includes('doc') || f.endsWith('.md'))) {
            labels.push('documentation');
          }
          
          if (changedFiles.some(f => f.includes('docker') || f.includes('Dockerfile'))) {
            labels.push('infrastructure');
          }
          
          if (changedFiles.some(f => f.includes('.github/workflows/'))) {
            labels.push('ci/cd');
          }
          
          if (changedFiles.some(f => f.includes('requirements') || f.includes('package.json') || f.includes('pyproject.toml'))) {
            labels.push('dependencies');
          }
          
          if (changedFiles.some(f => f.includes('migration') || f.includes('schema'))) {
            labels.push('database');
          }
          
          // Security-related patterns
          if (changedFiles.some(f => f.includes('auth') || f.includes('security'))) {
            labels.push('security');
          }
          
          // Performance-related patterns
          if (changedFiles.some(f => f.includes('cache') || f.includes('performance'))) {
            labels.push('performance');
          }
          
          // Add size labels based on number of changed lines
          const totalChanges = files.data.reduce((sum, file) => sum + file.changes, 0);
          
          if (totalChanges < 50) {
            labels.push('size: small');
          } else if (totalChanges < 200) {
            labels.push('size: medium');
          } else if (totalChanges < 500) {
            labels.push('size: large');
          } else {
            labels.push('size: extra large');
          }
          
          // Apply labels
          if (labels.length > 0) {
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: number,
              labels
            });
            
            console.log(`Added labels: ${labels.join(', ')}`);
          }

  pr-title-check:
    name: Check PR Title
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.action == 'opened' || github.event.action == 'synchronize'
    
    steps:
    - name: Validate PR title format
      uses: actions/github-script@v7
      with:
        script: |
          const title = context.payload.pull_request.title;
          const conventionalCommitPattern = /^(feat|fix|docs|style|refactor|test|chore|ci|perf|build|revert)(\(.+\))?: .{1,50}/;
          
          if (!conventionalCommitPattern.test(title)) {
            const comment = `## ‚ùå PR Title Check Failed
            
            Your PR title doesn't follow the conventional commit format.
            
            **Expected format:** \`type(scope): description\`
            
            **Examples:**
            - \`feat: add user authentication\`
            - \`fix(api): resolve trip creation bug\`
            - \`docs: update API documentation\`
            - \`test(frontend): add unit tests for auth flow\`
            
            **Valid types:** feat, fix, docs, style, refactor, test, chore, ci, perf, build, revert
            
            Please update your PR title to match this format.`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
            
            // Set check status to failure
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'PR Title Check',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: 'failure',
              output: {
                title: 'PR title does not follow conventional commit format',
                summary: 'Please update the PR title to follow the conventional commit format: type(scope): description'
              }
            });
            
            core.setFailed('PR title does not follow conventional commit format');
          } else {
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'PR Title Check',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: 'success',
              output: {
                title: 'PR title follows conventional commit format',
                summary: 'Great! Your PR title follows the expected format.'
              }
            });
          }

  pr-description-check:
    name: Check PR Description
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.action == 'opened' || github.event.action == 'synchronize'
    
    steps:
    - name: Validate PR description
      uses: actions/github-script@v7
      with:
        script: |
          const body = context.payload.pull_request.body || '';
          const minLength = 50;
          
          // Check for minimum description length
          if (body.trim().length < minLength) {
            const comment = `## ‚ùå PR Description Check Failed
            
            Your PR description is too short (${body.trim().length} characters, minimum ${minLength} required).
            
            Please provide a more detailed description including:
            - **What**: What changes are you making?
            - **Why**: Why are these changes needed?
            - **How**: How did you implement the changes?
            - **Testing**: How did you test these changes?
            
            A good description helps reviewers understand your changes and speeds up the review process.`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
            
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'PR Description Check',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: 'failure',
              output: {
                title: 'PR description is too short',
                summary: `Description should be at least ${minLength} characters. Current: ${body.trim().length}`
              }
            });
            
            core.setFailed('PR description is too short');
          } else {
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'PR Description Check',
              head_sha: context.payload.pull_request.head.sha,
              status: 'completed',
              conclusion: 'success',
              output: {
                title: 'PR description meets requirements',
                summary: 'Great! Your PR has a detailed description.'
              }
            });
          }

  breaking-changes-check:
    name: Check for Breaking Changes
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event.action == 'opened' || github.event.action == 'synchronize'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check for breaking changes
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo, number } = context.issue;
          
          // Get changed files
          const files = await github.rest.pulls.listFiles({
            owner,
            repo,
            pull_number: number
          });
          
          const changedFiles = files.data.map(file => file.filename);
          let hasBreakingChanges = false;
          const breakingChangeIndicators = [];
          
          // Check for breaking change patterns
          const breakingPatterns = [
            {
              pattern: /database.*migration/i,
              files: changedFiles.filter(f => f.includes('migration')),
              description: 'Database migrations detected'
            },
            {
              pattern: /api.*schema/i,
              files: changedFiles.filter(f => f.includes('schema') && f.includes('api')),
              description: 'API schema changes detected'
            },
            {
              pattern: /requirements.*txt|pyproject\.toml/,
              files: changedFiles.filter(f => f.includes('requirements') || f.includes('pyproject.toml')),
              description: 'Python dependency changes detected'
            },
            {
              pattern: /package\.json/,
              files: changedFiles.filter(f => f.includes('package.json')),
              description: 'Node.js dependency changes detected'
            }
          ];
          
          // Check PR title and description for breaking change keywords
          const title = context.payload.pull_request.title.toLowerCase();
          const body = (context.payload.pull_request.body || '').toLowerCase();
          
          if (title.includes('breaking') || body.includes('breaking change')) {
            hasBreakingChanges = true;
            breakingChangeIndicators.push('Explicitly marked as breaking change');
          }
          
          // Check for major version bumps
          for (const file of files.data) {
            if (file.filename.includes('package.json') || file.filename.includes('pyproject.toml')) {
              // Simple check for major version changes in the patch
              if (file.patch && file.patch.includes('+  "version"')) {
                breakingChangeIndicators.push(`Version change in ${file.filename}`);
              }
            }
          }
          
          // Check each pattern
          for (const pattern of breakingPatterns) {
            if (pattern.files.length > 0) {
              breakingChangeIndicators.push(`${pattern.description}: ${pattern.files.join(', ')}`);
            }
          }
          
          if (breakingChangeIndicators.length > 0) {
            hasBreakingChanges = true;
            
            // Add breaking change label
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: number,
              labels: ['breaking change']
            });
            
            // Create warning comment
            const comment = `## ‚ö†Ô∏è Potential Breaking Changes Detected
            
            This PR may contain breaking changes:
            
            ${breakingChangeIndicators.map(indicator => `- ${indicator}`).join('\n')}
            
            **Before merging:**
            1. Ensure you've updated the version appropriately
            2. Document breaking changes in the release notes
            3. Consider migration guides for users
            4. Notify the team about deployment considerations
            
            If these are not breaking changes, please clarify in the PR description.`;
            
            await github.rest.issues.createComment({
              issue_number: number,
              owner,
              repo,
              body: comment
            });
          }

  code-quality-summary:
    name: Code Quality Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [pr-title-check, pr-description-check, breaking-changes-check]
    if: always() && (github.event.action == 'opened' || github.event.action == 'synchronize')
    
    steps:
    - name: Create quality summary comment
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo, number } = context.issue;
          
          // Get PR details
          const pr = await github.rest.pulls.get({
            owner,
            repo,
            pull_number: number
          });
          
          // Check if this is a draft PR
          const isDraft = pr.data.draft;
          
          // Get changed files count
          const files = await github.rest.pulls.listFiles({
            owner,
            repo,
            pull_number: number
          });
          
          const stats = {
            filesChanged: files.data.length,
            additions: files.data.reduce((sum, file) => sum + file.additions, 0),
            deletions: files.data.reduce((sum, file) => sum + file.deletions, 0),
            changes: files.data.reduce((sum, file) => sum + file.changes, 0)
          };
          
          // Create summary
          const comment = `## üìä PR Summary
          
          **Statistics:**
          - üìÅ Files changed: ${stats.filesChanged}
          - ‚ûï Additions: ${stats.additions}
          - ‚ûñ Deletions: ${stats.deletions}
          - üîÑ Total changes: ${stats.changes}
          
          **Checks:**
          - PR Title: ${{ needs.pr-title-check.result === 'success' ? '‚úÖ' : '‚ùå' }}
          - PR Description: ${{ needs.pr-description-check.result === 'success' ? '‚úÖ' : '‚ùå' }}
          - Breaking Changes: ${{ needs.breaking-changes-check.result === 'success' ? '‚úÖ None detected' : '‚ö†Ô∏è Detected' }}
          
          ${isDraft ? 'üìù **This is a draft PR** - mark as ready for review when complete.' : ''}
          
          ---
          *Automated quality checks by GitHub Actions*`;
          
          // Find existing bot comments to update instead of creating new ones
          const comments = await github.rest.issues.listComments({
            owner,
            repo,
            issue_number: number
          });
          
          const botComment = comments.data.find(comment => 
            comment.user.type === 'Bot' && comment.body.includes('üìä PR Summary')
          );
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: botComment.id,
              body: comment
            });
          } else {
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: number,
              body: comment
            });
          }

  merge-conflict-check:
    name: Check for Merge Conflicts
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.action == 'synchronize'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check for merge conflicts
      run: |
        # Fetch the target branch
        git fetch origin ${{ github.base_ref }}
        
        # Check if PR branch can be merged without conflicts
        if git merge-tree $(git merge-base HEAD origin/${{ github.base_ref }}) HEAD origin/${{ github.base_ref }}) | grep -q "<<<<<<< "; then
          echo "merge_conflicts=true" >> $GITHUB_ENV
        else
          echo "merge_conflicts=false" >> $GITHUB_ENV
        fi

    - name: Comment on merge conflicts
      if: env.merge_conflicts == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const comment = `## ‚ö†Ô∏è Merge Conflicts Detected
          
          This PR has merge conflicts with the base branch \`${{ github.base_ref }}\`.
          
          **To resolve:**
          1. Merge or rebase the latest changes from \`${{ github.base_ref }}\`
          2. Resolve any conflicts
          3. Push the updated changes
          
          \`\`\`bash
          git checkout ${{ github.head_ref }}
          git merge origin/${{ github.base_ref }}
          # Resolve conflicts, then:
          git add .
          git commit -m "resolve merge conflicts"
          git push
          \`\`\``;
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

  reviewer-assignment:
    name: Auto-assign Reviewers
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.action == 'opened' && !github.event.pull_request.draft
    
    steps:
    - name: Auto-assign reviewers
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo, number } = context.issue;
          const author = context.payload.pull_request.user.login;
          
          // Define potential reviewers (customize based on your team)
          const coreReviewers = ['BjornMelin']; // Add team members
          const reviewers = coreReviewers.filter(reviewer => reviewer !== author);
          
          if (reviewers.length > 0) {
            try {
              await github.rest.pulls.requestReviewers({
                owner,
                repo,
                pull_number: number,
                reviewers: reviewers.slice(0, 2) // Limit to 2 reviewers
              });
              
              console.log(`Assigned reviewers: ${reviewers.slice(0, 2).join(', ')}`);
            } catch (error) {
              console.log('Could not assign reviewers:', error.message);
            }
          }

  ready-for-review:
    name: Ready for Review Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.action == 'ready_for_review' || (github.event.action == 'opened' && !github.event.pull_request.draft)
    
    steps:
    - name: Mark as ready for review
      uses: actions/github-script@v7
      with:
        script: |
          const comment = `## üéâ PR Ready for Review!
          
          This PR is now ready for review. Here's what happens next:
          
          **Automated Checks:**
          - ‚úÖ CI/CD pipelines will run automatically
          - ‚úÖ Security scans will be performed
          - ‚úÖ Code quality checks will be executed
          
          **Review Process:**
          - üë• Team members have been notified
          - üìù Please ensure all CI checks pass
          - üîç Address any feedback from reviewers
          
          **Before Merging:**
          - [ ] All CI checks are green
          - [ ] At least one approval from a team member
          - [ ] No merge conflicts
          - [ ] Documentation updated (if needed)
          
          Thank you for your contribution! üöÄ`;
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });