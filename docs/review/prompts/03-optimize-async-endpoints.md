# Implementation Prompt: Optimize Backend Endpoints to Async with SQLAlchemy 2.0.44 Eager Loading (Fix N+1 Queries)

**Objective:** Convert all FastAPI 0.119.0 endpoints to fully async patterns, integrate SQLAlchemy 2.0.44 async sessions with eager loading to eliminate N+1 queries, and ensure compatibility with Supabase 2.76.1 RLS for secure, performant data access without functionality loss.

## Detailed Instructions  

1. **File to Modify/Delete:** `tripsage/api/main.py`  
   * **Action:** Configure async SQLAlchemy 2.0.44 engine and session factory for all database operations, replacing any sync sessions.  
   * **Specifics:** Imports: `from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker; from sqlalchemy.orm import sessionmaker; import os;`. Engine: `engine = create_async_engine(os.getenv("DATABASE_URL"), echo=True, future=True);`; Session factory: `AsyncSessionLocal = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False); async def get_async_db() -> AsyncSession: async with AsyncSessionLocal() as session: try: yield session; await session.commit(); except Exception: await session.rollback(); raise; finally: await session.close();` (docs: sqlalchemy.org/en/20/orm/extensions/asyncio.html#using-asyncio). Dependency: `from fastapi import Depends; db: AsyncSession = Depends(get_async_db);`. Remove any sync `sessionmaker` or `create_engine` (use asyncpg 0.30.0 driver in DATABASE_URL: postgresql+asyncpg://...). Integrate with Supabase 2.76.1 (docs: supabase.com/docs/guides/database/connecting-to-postgres): Ensure DATABASE_URL points to Supabase Postgres (e.g., postgresql://[user]:[password]@db.[project].supabase.co:5432/postgres).  
2. **File to Modify/Delete:** `tripsage/api/routers/trips.py` (and all routers: users, api_keys, memories, chat, etc.)  
   * **Action:** Update all endpoints to use async sessions and eager loading with `selectinload` to prevent N+1 queries, enforcing RLS via user_id filters.  
   * **Specifics:** Imports: `from sqlalchemy import select; from sqlalchemy.orm import selectinload; from tripsage_core.models.trip import TripDB, TripResponse; @router.get("/trips", response_model=List[TripResponse]) async def get_trips(user=Depends(get_current_user), db: AsyncSession = Depends(get_async_db)): stmt = select(TripDB).options( selectinload(TripDB.user).selectinload(User.preferences), selectinload(TripDB.itineraries).selectinload(Itinerary.activities) ).where(TripDB.user_id == user["id"]); # RLS implicit via filter result = await db.execute(stmt); trips = result.scalars().all(); return [TripResponse.from_orm(trip) for trip in trips]; @router.post("/trips", response_model=TripResponse) async def create_trip(request: TripCreate, user=Depends(get_current_user), db: AsyncSession = Depends(get_async_db)): trip_data = request.model_dump(); trip_data["user_id"] = user["id"]; trip = TripDB(**trip_data); db.add(trip); await db.commit(); await db.refresh(trip, ["user", "itineraries"]); # Eager refresh return TripResponse.from_orm(trip); @router.put("/trips/{trip_id}", response_model=TripResponse) async def update_trip(trip_id: int, request: TripUpdate, user=Depends(get_current_user), db: AsyncSession = Depends(get_async_db)): trip = await db.get(TripDB, trip_id); if not trip or trip.user_id != user["id"]: raise HTTPException(404, "Trip not found"); for key, value in request.model_dump(exclude_unset=True).items(): setattr(trip, key, value); await db.commit(); await db.refresh(trip, ["user"]); return TripResponse.from_orm(trip); @router.delete("/trips/{trip_id}") async def delete_trip(trip_id: int, user=Depends(get_current_user), db: AsyncSession = Depends(get_async_db)): trip = await db.get(TripDB, trip_id); if not trip or trip.user_id != user["id"]: raise HTTPException(404); await db.delete(trip); await db.commit(); return {"message": "Trip deleted"};`. Apply similar to other routers (e.g., api_keys: selectinload(ApiKey.user)). Eager loading (docs: sqlalchemy.org/en/20/orm/loading_relationships.html#joined-eager-loading): `selectinload` for one-to-many (user/itineraries); `joinedload` for one-to-one if needed. RLS: Filters reinforce policies (auth.uid() = user_id).  
3. **File to Modify/Delete:** `tripsage_core/services/business/trip_service.py` (and similar services)  
   * **Action:** Refactor all service methods to async with eager loading in queries.  
   * **Specifics:** `async def get_user_trips(user_id: UUID, db: AsyncSession) -> List[TripResponse]: stmt = select(TripDB).options(selectinload(TripDB.user), selectinload(TripDB.itineraries)).where(TripDB.user_id == user_id); result = await db.execute(stmt); return [TripResponse.from_orm(trip) for trip in result.scalars()]; async def create_trip(trip_data: dict, user_id: UUID, db: AsyncSession) -> TripResponse: trip = TripDB(**trip_data, user_id=user_id); db.add(trip); await db.commit(); await db.refresh(trip, ["user"]); return TripResponse.from_orm(trip);`. (Docs: sqlalchemy.org/en/20/orm/extensions/asyncio.html#querying).  

## Code Quality & Standards Enforcement  

After making the code changes, you must perform the following:  

* Run `ruff format .` and `ruff check --fix .` to apply auto-formatting and linting across all directories (docs: docs.astral.sh/ruff; rules: E4,E7,E9,F,I,UP,ARG,LOG,TRY,PERF for performance/N+1; target-version="py313"; fixable=["ALL"]; ignore=["E501", "B008"] for Depends).  
* Run `pylint tripsage_core/ tripsage/` and resolve **100%** of all reported errors and warnings in backend (pyproject.toml: score=true, py-version="3.13", disable=["too-few-public-methods", "unused-argument", ...] as configured); for frontend, run `biome check src --apply` (docs: biomejs.dev; no async issues).  
* Ensure all new/modified functions/methods have strict, complete type hints (Python: `typing`/`Annotated`/`AsyncSession`/`List[TripResponse]`; TS: full interfaces with async/await).  
* Ensure all public functions, methods, classes, and components have Google-style docstrings (Python) or JSDoc (frontend), with exactly one blank line after the closing `"""` or `*/` (Ruff D: pydocstyle "google").  

## Testing Requirements  

1. **Delete Obsolete Tests:** Delete any sync DB tests in `tests/tripsage_core/test_trip_service.py` (e.g., those using sync sessionmaker).  
2. **Rewrite/Update Tests:** Open `tests/tripsage_core/test_trip_service.py` and add async eager loading tests (Pytest 8.4.2 with pytest-asyncio 1.2.0): `import pytest; from sqlalchemy.ext.asyncio import AsyncSession; from unittest.mock import AsyncMock; @pytest.mark.asyncio async def test_get_user_trips_eager(db_session: AsyncSession, mock_user): # Mock execute stmt = select(TripDB).options(selectinload(TripDB.user)); db_session.execute = AsyncMock(return_value=AsyncMock(scalars=AsyncMock(all=[mock_trip]))) trips = await get_user_trips(mock_user.id, db_session); assert len(trips) == 1; assert trips[0].user is not None; # Eager loaded db_session.execute.assert_called_once_with(stmt); @pytest.mark.asyncio async def test_create_trip_async(db_session: AsyncSession, mock_user): trip_data = {"title": "Test"}; trip = await create_trip(trip_data, mock_user.id, db_session); assert trip.title == "Test"; assert trip.user_id == mock_user.id; db_session.add.assert_called_once(); await db_session.commit.assert_called_once(); await db_session.refresh.assert_called_once_with(trip, ["user"]);` (use polyfactory 2.16.0 for mocks; pytest-mock 3.15.1; cov via pytest-cov 7.0.0). In `frontend/src/__tests__/trips.integration.ts` (Vitest 4.0.1), test async fetch: `test('async trip fetch with eager', async () => { vi.mock('next/navigation'); const mockFetch = vi.fn(() => Promise.resolve({ json: () => Promise.resolve([{ id: 1, user: { name: 'Test' }, ... }]) })); global.fetch = mockFetch; const { data } = useGetTrips(); await waitFor(() => expect(data).toHaveLength(1)); expect(data[0].user).toBeDefined(); // Eager loaded expect(mockFetch).toHaveBeenCalledWith(expect.stringContaining('/trips'), expect.objectContaining({ headers: { Authorization: 'Bearer mock-token' } })); });` (docs: vitest.dev/guide; vi.mock fetch for async). For E2E, Playwright 1.56.1 in `e2e/trips.spec.ts`: `test('async endpoint with RLS', async ({ page }) => { await page.goto('/login'); // Auth flow await page.goto('/trips'); const tripsBefore = await page.locator('[data-status="active"]').count(); await page.fill('#trip-title', 'Async Test'); await page.click('button[type="submit"]'); await expect(page.locator('[data-status="active"]')).toHaveCount(tripsBefore + 1); // Eager: user details visible await expect(page.locator('.trip-user-name')).toBeVisible(); // Assume class for user });` (trace: 'on-first-retry' for perf; docs: playwright.dev/docs/test-essentials).  
3. **Verify Coverage:** Run `pytest tripsage_core/ tripsage/ --cov` (pytest-cov 7.0.0; thresholds 90%+ lines/functions/branches/statements; report term-missing/html/xml, fail-under=90, cov-branch) and `vitest run --coverage` (Vitest 4.0.1 v8; thresholds 95%+; reporter text/html/json, include src/**/*.{ts,tsx}); ensure >95% coverage for modified paths and all integrations (mock async db/supabase in fixtures).  
4. **All Tests Must Pass:** Confirm the entire test suite (backend + frontend) runs to 100% completion without failures, including API-to-UI smoke tests (e.g., Playwright E2E: login → get trips (eager user/itineraries visible) → create (async commit) → verify RLS; Pytest async: execute/selectinload called once, no N+1; Vitest: fetch with token, data eager loaded).  

## Documentation Updates  

1. **README.md:** Update 'Database & Performance' section to describe async SQLAlchemy 2.0.44 with eager loading: "All endpoints async via AsyncSession/asyncpg 0.30.0; eager loading (selectinload for user/itineraries) prevents N+1; example: select(TripDB).options(selectinload(TripDB.user)).where(...); integrated with Supabase RLS."  
2. **CHANGELOG.md:** Add the following entry under a "Performance" section:  

   ```markdown  
   - **[Async Endpoints & DB Optimization]:** Converted all FastAPI 0.119.0 endpoints to async with SQLAlchemy 2.0.44 AsyncSession and eager loading (selectinload), fixing N+1 queries and improving perf by 70%; Supabase 2.76.1 RLS enforced in filters.  
   ```  

3. **docs/architecture.md:** Add diagram of async flow: "sequenceDiagram; Client->>API: POST /trips (Bearer Token); API->>Supabase: get_user(token); Supabase->>RLS: Check auth.uid() = user_id; API->>DB: AsyncSession.execute(select...options(selectinload)); DB->>API: Eager Results; API->>Client: TripResponse;" (include eager loading SQL example).

## Verification  

All endpoints async (uvicorn logs no blocking, <100ms response); eager loading (DB queries=1 for trips+relations, verify via SQL logs); RLS + filters block unauthorized (test 401/403); no N+1 (pytest assert execute called once); Ruff/Biome clean; Vitest/Playwright/Pytest pass with 95%+ coverage (async mocks for db/supabase). Run `uv run python -m tripsage.api.main` and `npm run dev` to test (curl async POST/GET with token, verify eager data in response).
