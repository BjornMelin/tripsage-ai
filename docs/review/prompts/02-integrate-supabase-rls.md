# Implementation Prompt: Integrate Supabase 2.76.1 RLS for Authentication and Authorization

**Objective:** Fully integrate and enhance the existing partial Supabase 2.76.1 authentication setup across the backend (FastAPI 0.119.0 endpoints, services, middleware, and routers) and frontend (Zustand store, hooks, and components), building on the Supabase client in auth_service.py (with get_supabase_client and get_current_user using supabase.auth.get_user(token)) and custom Principal/middleware in middlewares.authentication.py. Replace remaining custom logic (e.g., _authenticate_jwt/_authenticate_api_key in middleware, manual user resolution in trips.py) with native Supabase JWT validation via the existing get_user function, enforce Row Level Security (RLS) policies on all relevant tables (trips, users, api_keys, memories, chat, etc.) using auth.uid() = user_id, and ensure seamless wiring between backend API layers and frontend using @supabase/auth-helpers-nextjs for SSR/CSR auth flows. This update aligns with the current codebase: Supabase client already in auth_service.py for get_user(token) with TokenData model (including user_id/email/role), custom Principal in middlewares.authentication.py for request.state.user (with auth_method), mocked Zustand auth-store.ts (with mock signInWithPassword), and Supabase hooks in use-authenticated-api.ts/use-trips-supabase.ts/etc. (using supabase.from for DB ops with auth.getUser() for user_id)—transforming mocks to real flows, enhancing middleware to use auth_service, and adding missing capabilities like email verification, session refresh, and multi-tenant support via user_metadata (role/tenant_id) without introducing new custom complexity.

## Detailed Instructions

1. **File to Modify/Delete:** `tripsage/api/core/auth.py` (enhance existing Supabase integration, no deletion)  
   * **Action:** Refine the existing Supabase client and get_current_user function to use Supabase 2.76.1 async patterns for JWT validation, incorporating user_metadata for roles (e.g., admin/user) and tenant_id (for multi-tenant if present), ensuring compatibility with Pydantic 2.12.3 TokenData model and async FastAPI 0.119.0. Remove any redundant custom token handling if present (e.g., manual format validation).  
   * **Specifics:** Imports (keep/enhance): `from supabase import Client, create_client; from fastapi import Depends, HTTPException, status; from fastapi.security import HTTPBearer; from tripsage_core.config import get_settings; from tripsage_core.models.base_core_model import TripSageModel; from typing import Optional; import os;`. Client (update if needed): `def get_supabase_client() -> Client: settings = get_settings(); return create_client(settings.supabase_url, settings.supabase_service_key.get_secret_value(), options=ClientOptions(async_mode=True, global_headers={"x-client-info": "tripsage-api-v0.2.0"}));` (docs: supabase.com/docs/reference/python/initializing; async via httpx 0.28.1). Enhance get_current_user (align with existing): `security = HTTPBearer(); async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> Optional[TokenData]: token = credentials.credentials; if not token: raise HTTPException(status.HTTP_401_UNAUTHORIZED, "No token provided"); supabase = get_supabase_client(); try: result = await supabase.auth.get_user(token); user = result.user; if not user: raise HTTPException(status.HTTP_401_UNAUTHORIZED, "Invalid token"); # Extract metadata for roles/tenant_id tenant_id = user.user_metadata.get("tenant_id") if user.user_metadata else None; role = user.user_metadata.get("role", "user") if user.user_metadata else "user"; return TokenData( user_id=str(user.id), email=user.email, role=role, aud="authenticated", tenant_id=tenant_id ); except Exception as e: logger.warning(f"Supabase auth validation failed: {e}"); raise HTTPException(status.HTTP_401_UNAUTHORIZED, "Invalid token");` (docs: supabase.com/docs/reference/python/auth-admin#get-user; async get_user for server-side validation; custom claims: supabase.com/docs/guides/auth/custom-claims for role/tenant_id in user_metadata). Ensure TokenData includes tenant_id/role: Update model `class TokenData(TripSageModel): user_id: str; email: Optional[str] = None; role: str = "user"; aud: str = "authenticated"; tenant_id: Optional[str] = None;`. For multi-tenant, add tenant_id validation if needed (e.g., from JWT claims via user.user_metadata). Remove any manual token format checks—Supabase handles JWT verification internally (docs: supabase.com/docs/guides/auth/jwts).  
2. **File to Modify/Delete:** `tripsage/api/middlewares/authentication.py` (replace custom Principal/middleware with Supabase-enhanced version)  
   * **Action:** Update the existing AuthenticationMiddleware to leverage the refined get_current_user from auth_service.py, populating request.state.user with TokenData (including role/tenant_id), and remove any custom _authenticate_jwt/_authenticate_api_key logic—use Supabase get_user for unified validation. Align with existing auth_method (e.g., set to "jwt" for Supabase).  
   * **Specifics:** Imports: `from starlette.middleware.base import BaseHTTPMiddleware; from fastapi import Request; from .auth import get_current_user, TokenData; import logging; logger = logging.getLogger(__name__);`. Middleware (enhance existing): `class SupabaseAuthMiddleware(BaseHTTPMiddleware): async def dispatch(self, request: Request, call_next): if self._should_skip_auth(request.url.path): response = await call_next(request); return response; try: # Extract token from Authorization header token = request.headers.get("Authorization", "").replace("Bearer ", ""); if not token: request.state.user = None; response = await call_next(request); return response; # Validate with Supabase (from auth_service.py) user = await get_current_user(token); request.state.user = user; # Set TokenData for Depends (align with existing Principal usage) response = await call_next(request); return response; except HTTPException: request.state.user = None; response = await call_next(request); return response; def _should_skip_auth(self, path: str) -> bool: skip_paths = [ "/api/health", "/api/auth/login", "/api/auth/register", "/api/auth/token", "/api/auth/reset-password", "/api/auth/verify", # For email verification "/api/auth/confirm", # For confirmation ]; return any(path.startswith(skip) for skip in skip_paths); app.add_middleware(SupabaseAuthMiddleware);` (docs: supabase.com/docs/guides/auth/server-side; middleware extracts token, calls get_current_user for validation, sets state.user as TokenData with role/tenant_id). Remove custom_authenticate_jwt/_authenticate_api_key—use Supabase get_user for all (align with existing auth_method="jwt"). Update Principal to TokenData alias if needed: `from .auth import TokenData; Principal = TokenData;` (align with existing router usage like require_principal → Depends(get_current_user)). For API keys (if multi-tenant), extend get_current_user to check user_metadata.api_keys or separate RLS policy (docs: supabase.com/docs/guides/auth/custom-claims). Ensure async (no blocking calls).  
3. **File to Modify/Delete:** `tripsage/api/routers/trips.py` (and all routers: users.py, api_keys.py, memories.py, chat.py, etc.)  
   * **Action:** Update all endpoints to use the enhanced get_current_user dependency (returning TokenData with role/tenant_id), reinforcing RLS with explicit user_id/tenant_id filters where needed (e.g., in WHERE clauses as backup), and remove any custom Principal checks or manual user resolution (_get_user_details_by_id → use TokenData.email/user_id directly).  
   * **Specifics:** Imports (update): `from .auth import get_current_user, TokenData; from sqlalchemy import select; from sqlalchemy.orm import selectinload;`. Dependency change: Replace `principal: Principal = Depends(require_principal)` with `user: TokenData = Depends(get_current_user)`. Endpoint example (align with existing): `@router.post("/trips", response_model=TripResponse) async def create_trip(request: TripCreate, user: TokenData = Depends(get_current_user), db: AsyncSession = Depends(get_async_db)): if not user: raise HTTPException(401, "Unauthorized"); # Role check if needed (from metadata): if user.role != "admin" and not user.tenant_id: raise HTTPException(403, "Insufficient role for operation"); trip_data = request.model_dump(); trip_data["user_id"] = user.user_id; trip_data["tenant_id"] = user.tenant_id; # RLS enforces via policy, reinforce in code trip = TripDB(**trip_data); db.add(trip); await db.commit(); await db.refresh(trip); return TripResponse.from_orm(trip); @router.get("/trips", response_model=List[TripResponse]) async def get_trips(user: TokenData = Depends(get_current_user), db: AsyncSession = Depends(get_async_db)): # RLS filters by auth.uid() = user_id, reinforce with where stmt = select(TripDB).where(TripDB.user_id == user.user_id, TripDB.tenant_id == user.tenant_id if user.tenant_id else True); # Optional explicit filter result = await db.execute(stmt); return [TripResponse.from_orm(trip) for trip in result.scalars()];`. For update/delete/share: Add `if trip.user_id != user.user_id or (user.tenant_id and trip.tenant_id != user.tenant_id): raise HTTPException(403);` as RLS backup (docs: supabase.com/docs/guides/auth/row-level-security). Apply to all routers: users.py (self-access: where User.id == user.user_id); api_keys.py (owner: where ApiKey.user_id == user.user_id); memories.py (where Memory.user_id == user.user_id); chat.py (where Chat.user_id == user.user_id). For multi-tenant, ensure tenant_id column exists in tables (if not, ALTER TABLE trips ADD COLUMN tenant_id UUID REFERENCES tenants(id);), and policies: USING (auth.uid() = user_id AND (auth.jwt() ->> 'tenant_id' = tenant_id OR auth.jwt() ->> 'role' = 'admin')). Remove_get_user_details_by_id calls—use user.email/user.user_id directly from TokenData (no service call needed, as Supabase get_user already provides).  
4. **File to Modify/Delete:** `frontend/src/stores/auth-store.ts` (replace mocks with real Supabase integration)  
   * **Action:** Update Zustand store to use real Supabase auth from @supabase/supabase-js 2.76.1, integrating with @supabase/auth-helpers-nextjs for SSR/CSR, and syncing session/token with use-authenticated-api.ts hooks for API calls. Remove all mocks and use real signInWithPassword/signUp/signOut/resend.  
   * **Specifics:** Imports: `import { create } from 'zustand'; import { devtools, persist } from 'zustand/middleware'; import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'; import type { User, Session } from '@/types/api'; const supabase = createClientComponentClient();`. Store (enhance existing mocked structure): `interface AuthState { isAuthenticated: boolean; user: User | null; session: Session | null; isLoading: boolean; loginError: string | null; // ... (keep existing states like isLoggingIn, etc.) login: (credentials: { email: string; password: string; rememberMe?: boolean }) => Promise<boolean>; register: (credentials: { email: string; password: string; confirmPassword: string; firstName?: string; lastName?: string; acceptTerms: boolean }) => Promise<boolean>; logout: () => Promise<void>; resendVerification: () => Promise<boolean>; // Add for missing capability logoutAllDevices: () => Promise<void>; // If needed } export const useAuthStore = create<AuthState>()( devtools( persist( (set, get) => ({ // Initial state isAuthenticated: false, user: null, session: null, isLoading: false, loginError: null, // ... (keep existing) login: async (credentials) => { set({ isLoading: true, loginError: null }); try { const { data, error } = await supabase.auth.signInWithPassword({ email: credentials.email, password: credentials.password }); if (error) throw error; if (data.user) { set({ isAuthenticated: true, user: data.user, session: data.session, isLoading: false }); return true; } return false; } catch (error) { set({ isLoading: false, loginError: error.message }); return false; } }, register: async (credentials) => { set({ isLoading: true, loginError: null }); try { if (credentials.password !== credentials.confirmPassword) throw new Error('Passwords do not match'); if (!credentials.acceptTerms) throw new Error('Accept terms required'); const { data, error } = await supabase.auth.signUp({ email: credentials.email, password: credentials.password, options: { data: { firstName: credentials.firstName, lastName: credentials.lastName, tenant_id: 'default-tenant' // For multi-tenant if needed } }); if (error) throw error; set({ isAuthenticated: true, user: data.user, session: data.session, isLoading: false }); return true; } catch (error) { set({ isLoading: false, loginError: error.message }); return false; } }, logout: async () => { set({ isLoading: true }); try { const { error } = await supabase.auth.signOut(); if (error) throw error; set({ isAuthenticated: false, user: null, session: null, isLoading: false, loginError: null }); } catch (error) { set({ isLoading: false, loginError: error.message }); } }, resendVerification: async () => { const { user } = get(); if (!user || user.email_confirmed_at) return false; set({ isLoading: true }); try { const { error } = await supabase.auth.resend({ type: 'signup', email_redirect_to: window.location.origin }); if (error) throw error; set({ isLoading: false }); return true; } catch (error) { set({ isLoading: false, loginError: error.message }); return false; } }, logoutAllDevices: async () => { set({ isLoading: true }); try { const { error } = await supabase.auth.signOut({ scope: 'global' }); if (error) throw error; set({ isAuthenticated: false, user: null, session: null, isLoading: false }); return true; } catch (error) { set({ isLoading: false, loginError: error.message }); return false; } }, // ... (update other actions: changePassword, verifyEmail with real calls, e.g., supabase.auth.updateUser, supabase.auth.verifyOtp) }), { name: 'auth-storage', partialize: (state) => ({ user: state.user, session: state.session, isAuthenticated: state.isAuthenticated // Persist non-sensitive }) } ), { name: 'AuthStore' } ) );`. Remove all mocks (e.g., mockUser/mockTokenInfo, new Promise mocks)—use real supabase.auth.signInWithPassword/signUp/signOut/resend/verifyOtp (docs: supabase.com/docs/reference/javascript/auth-signinwithpassword). For SSR, ensure layout.tsx uses createServerComponentClient from @supabase/auth-helpers-nextjs (docs: supabase.com/docs/guides/auth/server-side). Sync with use-authenticated-api.ts: Export session from store for token in fetch headers (e.g., useAuthStore((state) => state.session?.access_token)).  
5. **File to Modify/Delete:** `frontend/src/hooks/use-authenticated-api.ts` (enhance with store integration and real session handling)  
   * **Action:** Update hook to use auth-store's real session/token from Zustand, ensuring automatic refresh on 401 errors, integration with Supabase for session management, and compatibility with existing fetchApi.  
   * **Specifics:** Imports: `import { useAuthStore } from '@/stores/auth-store'; import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';`. Hook (enhance existing): `export function useAuthenticatedApi() { const { session, isAuthenticated, refreshToken, logout } = useAuthStore(); const supabase = createClientComponentClient(); const makeAuthenticatedRequest = useCallback(async (endpoint: string, options: FetchOptions = {}) => { if (!isAuthenticated || !session?.access_token) { const refreshed = await refreshToken(); if (!refreshed) { await logout(); throw new Error('Not authenticated'); } } const token = session.access_token; return fetchApi(endpoint, { ...options, headers: { ...options.headers, Authorization:`Bearer ${token}`}, }); }, [isAuthenticated, session, refreshToken, logout] ); // ... (keep existing logic, but use store's session instead of local getSession; add 401 handling: if (response.status === 401) { const refreshed = await refreshToken(); if (refreshed) return makeAuthenticatedRequest(endpoint, options); // Retry await logout(); throw new Error('Session expired'); } }` (docs: supabase.com/docs/reference/javascript/auth-getsession; integrate with Zustand for reactive state). Remove local getSession calls—use store. For SSR, ensure server components use createServerComponentClient in layout.tsx (docs: supabase.com/docs/guides/auth/server-side). Add error handling for token expiry (use store's isTokenExpired).  

## Code Quality & Standards Enforcement

After making the code changes, you must perform the following:  

* Run `ruff format .` and `ruff check --fix .` to apply auto-formatting and linting across all directories (docs: docs.astral.sh/ruff; rules: E4,E7,E9,F,I,UP,ARG,LOG,TRY for errors/imports/upgrades/args/logging/exceptions; target-version="py313"; fixable=["ALL"]; ignore=["E501"] for line length).  
* Run `pylint tripsage_core/ tripsage/` and resolve **100%** of all reported errors and warnings in backend (pyproject.toml tool.pylint: score=true, py-version="3.13", disable=["too-few-public-methods", "invalid-name", ...] as configured); for frontend, run `biome check src --apply` (docs: biomejs.dev/guides/migrate-from-eslint-and-prettier; replaces ESLint/Prettier with no unused vars).  
* Ensure all new/modified functions/methods have strict, complete type hints (Python: `typing`/`Annotated`/`Literal`/`AsyncSession`/`TokenData`; TS: full Zod-inferred with `z.infer<typeof LoginCredentials>` for credentials, `Session` from Supabase types via @supabase/supabase-js).  
* Ensure all public functions, methods, classes, and components have Google-style docstrings (Python) or JSDoc (frontend), with exactly one blank line after the closing `"""` or `*/` (Ruff D rules: pydocstyle "google" convention).  

## Testing Requirements

1. **Delete Obsolete Tests:** Delete any remaining mock-based auth tests in `tests/tripsage/api/test_auth.py` and `frontend/src/__tests__/auth.spec.ts` (e.g., those using mockUser or custom token mocks); remove any mock-based auth tests in `frontend/src/stores/__tests__/auth-store.test.ts` and `frontend/src/hooks/__tests__/use-authenticated-api.test.ts`.  
2. **Rewrite/Update Tests:** Open `tests/integration/test_rls.py` (Pytest 8.4.2) and add comprehensive async RLS tests with real Supabase mocks: `import pytest; from httpx import AsyncClient; from unittest.mock import patch, AsyncMock; from supabase import Client; @pytest.mark.asyncio async def test_create_trip_rls(client: AsyncClient): # Mock invalid token (Supabase get_user returns None) with patch('supabase.auth.get_user', new_callable=AsyncMock, return_value=AsyncMock(user=None)): response = await client.post("/trips", json={"title": "Test"}, headers={"Authorization": "Bearer invalid"}); assert response.status_code == 401; assert "Invalid token" in response.json()["detail"]; # Mock valid token with role/tenant_id with patch('supabase.auth.get_user', new_callable=AsyncMock, return_value=AsyncMock(user=AsyncMock(id="valid-uuid", user_metadata={"role": "user", "tenant_id": "tenant-123"}))): response = await client.post("/trips", json={"title": "Test"}, headers={"Authorization": "Bearer valid"}); assert response.status_code == 201; trip = response.json(); assert trip["user_id"] == "valid-uuid"; assert trip.get("tenant_id") == "tenant-123"; # RLS read own/tenant only response = await client.get("/trips", headers={"Authorization": "Bearer valid"}); assert len(response.json()) == 1; assert response.json()[0]["title"] == "Test"; assert response.json()[0].get("tenant_id") == "tenant-123"; # Update own/tenant response = await client.patch(f"/trips/{trip['id']}", json={"title": "Updated"}, headers={"Authorization": "Bearer valid"}); assert response.status_code == 200; assert response.json()["title"] == "Updated"; assert response.json().get("tenant_id") == "tenant-123"; # Delete own/tenant response = await client.delete(f"/trips/{trip['id']}", headers={"Authorization": "Bearer valid"}); assert response.status_code == 200; # Unauthorized (different tenant/role) with patch('supabase.auth.get_user', new_callable=AsyncMock, return_value=AsyncMock(user=AsyncMock(id="other-uuid", user_metadata={"role": "user", "tenant_id": "other-tenant"}))): response = await client.delete(f"/trips/{trip['id']}", headers={"Authorization": "Bearer other"}); assert response.status_code == 403; # RLS blocks` (use pytest-mock 3.15.1 for AsyncMock; pytest-httpx 0.35.0 for AsyncClient; pytest-asyncio 1.2.0 for async; cov via pytest-cov 7.0.0; mock supabase.auth.get_user with user_metadata for role/tenant_id). In `frontend/src/__tests__/auth-store.test.ts` (Vitest 4.0.1), update with real Supabase mocks: `import { expect, test, vi } from 'vitest'; import { useAuthStore } from '../auth-store'; vi.mock('@supabase/supabase-js', () => ({ createClient: vi.fn(() => ({ auth: { signInWithPassword: vi.fn(() => Promise.resolve({ data: { user: { id: 'test-uuid', email: 'test@example.com', user_metadata: { role: 'user', tenant_id: 'tenant-123' } }, session: { access_token: 'mock-token' } }) }), signUp: vi.fn(() => Promise.resolve({ data: { user: { id: 'new-uuid', email: 'new@example.com', user_metadata: { role: 'user', tenant_id: 'tenant-123' } }, session: { access_token: 'new-token' } }) }), signOut: vi.fn(() => Promise.resolve({ error: null })), resend: vi.fn(() => Promise.resolve({ error: null })) } })) }); test('login with Supabase (role/tenant)', async () => { const { login, isAuthenticated, user } = useAuthStore(); const result = await login({ email: 'test@example.com', password: 'pass' }); expect(result).toBe(true); expect(isAuthenticated).toBe(true); expect(user).toEqual({ id: 'test-uuid', email: 'test@example.com', user_metadata: { role: 'user', tenant_id: 'tenant-123' } }); expect(supabase.auth.signInWithPassword).toHaveBeenCalledWith({ email: 'test@example.com', password: 'pass' }); }); test('register with metadata', async () => { const { register } = useAuthStore(); const result = await register({ email: 'new@example.com', password: 'pass', confirmPassword: 'pass', acceptTerms: true }); expect(result).toBe(true); expect(supabase.auth.signUp).toHaveBeenCalledWith({ email: 'new@example.com', password: 'pass', options: { data: { tenant_id: 'tenant-123' } } }); }); test('resend verification', async () => { const { resendVerification } = useAuthStore(); const { user } = useAuthStore.getState(); useAuthStore.setState({ user: { id: 'test-uuid', email_confirmed_at: null } }); const result = await resendVerification(); expect(result).toBe(true); expect(supabase.auth.resend).toHaveBeenCalledWith({ type: 'signup', email_redirect_to: window.location.origin }); });` (docs: vitest.dev/guide/mocking; mock createClient for auth calls with user_metadata). For E2E, Playwright 1.56.1 in `e2e/auth.spec.ts`: `import { test, expect } from '@playwright/test'; test.describe('Supabase Auth & RLS Integration', () => { test('login, register, and create trip with RLS/tenant', async ({ page, context }) => { // Login await page.goto('/login'); await page.fill('#email', 'test@example.com'); await page.fill('#password', 'password'); await page.click('button[type="submit"]'); await expect(page.locator('[role="alert"]').getByText('Welcome')).toBeVisible(); // Auth success // Register new user (if needed) await page.goto('/register'); await page.fill('#email', 'new@example.com'); await page.fill('#password', 'newpass'); await page.fill('#confirm-password', 'newpass'); await page.click('#accept-terms'); await page.click('button[type="submit"]'); await expect(page.locator('[role="alert"]').getByText('Check email')).toBeVisible(); // Register success // Create trip (RLS/tenant enforced) await page.goto('/trips'); await page.fill('#trip-title', 'Tenant Test'); await page.click('button[type="submit"]'); await expect(page.locator('[data-status="active"]')).toBeVisible(); // Own trip via RLS/tenant }); test('unauthorized access fails (different tenant)', async ({ page, context }) => { // Mock different tenant (via context or storage) await page.addInitScript(() => { localStorage.setItem('supabase.auth.token', JSON.stringify({ access_token: 'other-token', user_metadata: { tenant_id: 'other-tenant' } })); }); await page.goto('/trips'); await page.click('button[type="submit"]'); await expect(page.locator('[role="alert"]').getByText('Unauthorized')).toBeVisible(); // RLS blocks different tenant }); test('role-based access (admin vs user)', async ({ page }) => { // Admin user (mock metadata) await page.addInitScript(() => { localStorage.setItem('supabase.auth.token', JSON.stringify({ access_token: 'admin-token', user_metadata: { role: 'admin', tenant_id: 'tenant-123' } })); }); await page.goto('/admin/trips'); await expect(page.locator('[data-admin="true"]')).toBeVisible(); // Admin sees all }); });` (docs: playwright.dev/docs/test-essentials; trace: 'on-first-retry' for videos; mock localStorage for tenant/role).  
3. **Verify Coverage:** Run `pytest tripsage_core/ tripsage/ --cov` (pytest-cov 7.0.0; thresholds 90%+ lines/functions/branches; report term-missing/html/xml, fail-under=90, cov-branch) and `vitest run --coverage` (Vitest 4.0.1 v8 provider; thresholds 95%+; reporter text/html/json, include src/**/*.{ts,tsx}); ensure >95% coverage for modified paths and all integrations (mock Supabase auth in fixtures/mocks for get_user/signInWithPassword/resend with user_metadata).  
4. **All Tests Must Pass:** Confirm the entire test suite (backend + frontend) runs to 100% completion without failures, including API-to-UI smoke tests (e.g., Playwright E2E: login with real Supabase test user → register new with metadata → resend verification → create trip → verify RLS/tenant (own trip visible, other tenant 403); Pytest async for endpoint 401/201 with mocked get_user (role/tenant_id in metadata); Vitest for Zustand actions with mocked supabase.auth calls (signInWithPassword/signUp/resend, verify metadata)).  

## Documentation Updates

1. **README.md:** Update 'Authentication' section to reflect enhanced Supabase 2.76.1 integration: "Full auth via Supabase client (signInWithPassword/signUp/signOut/resend in Zustand store with @supabase/auth-helpers-nextjs SSR); server-side validation with get_user async (TokenData with role/tenant_id from metadata); RLS policies on all tables (e.g., trips: SELECT/INSERT/UPDATE/DELETE USING auth.uid() = user_id AND (auth.jwt() ->> 'tenant_id' = tenant_id OR auth.jwt() ->> 'role' = 'admin')); middleware extracts Bearer token and sets request.state.user; frontend hooks/stores use real session.access_token for API calls. Supports email verification (resend) and multi-tenant (tenant_id in metadata). No custom JWT—leverage Supabase native for security." Include example: "Policy: CREATE POLICY 'Users read own/tenant trips' ON trips FOR SELECT USING (auth.uid() = user_id AND (auth.jwt() ->> 'tenant_id' = tenant_id OR auth.jwt() ->> 'role' = 'admin'));" (run in Supabase dashboard).  
2. **CHANGELOG.md:** Add the following entry under a "Refactor" section:  

   ```markdown  
   - **[Supabase Auth & RLS Enhanced Integration v2.0]:** Built on existing auth_service.py Supabase client for async JWT validation (get_user with metadata for role/tenant_id); updated middleware to use native get_current_user; replaced custom Principal with TokenData; integrated real Zustand store/actions (signInWithPassword/signUp/signOut/resend/verifyOtp) and hooks with @supabase/auth-helpers-nextjs SSR; enforced RLS on all tables (policies for SELECT/INSERT/UPDATE/DELETE via auth.uid() = user_id + tenant_id/role checks), adding email verification/MFA/multi-tenant support while reducing custom code by 70%.  
   ```  

3. **docs/architecture.md:** Update auth flow diagram with Mermaid: "graph TD; Frontend[Zustand Store/@supabase/auth-helpers-nextjs] -->|signInWithPassword| SupabaseAuth[Supabase Auth]; SupabaseAuth -->|Session + Token (metadata: role/tenant_id)| Store[Zustand AuthState]; Store -->|access_token| API[FastAPI Endpoint]; API -->|Bearer Token| Middleware[SupabaseAuthMiddleware]; Middleware -->|get_current_user(token)| Supabase[Supabase Auth.get_user]; Supabase -->|User (id/role/tenant_id)| RLS[RLS Policy Check (auth.uid() = user_id AND tenant_id/role)]; RLS -->|Allowed| DB[Postgres Query]; DB -->|Results| API; RLS -->|Denied| Error[401/403]; Frontend -->|API Calls (token from store)| API;" (include policy SQL examples with tenant_id/role and Zustand action snippets for signUp with metadata).

## Verification

All endpoints (create/get/update/delete trips, users, api_keys, memories, chat) use Supabase get_user for validation (async, returns TokenData with id/email/role/tenant_id from metadata); RLS blocks unauthorized/different tenant (test POST with invalid token: 401 via get_user; own/tenant data only: 201/200 success, other tenant/role 403 via policy); frontend Zustand store uses real Supabase (login/register/resend calls signInWithPassword/signUp/signOut/signOutAllDevices/resend with metadata, no mocks; test user signup/login with tenant_id); middleware extracts token and sets state.user (logs verify get_user called with metadata); no custom auth files/middleware remain beyond Supabase-enhanced (git diff clean, remove old Principal if aliased); benchmarks show <50ms auth overhead (Supabase get_user async); Ruff/Biome clean (0 errors); Vitest/Playwright/Pytest pass with 95%+ coverage (mocks for supabase.auth in Vitest/Pytest with metadata; E2E with test user: login → register with tenant → create trip → verify own/tenant visibility/anon/other-tenant fail). Run `uv run python -m tripsage.api.main` and `npm run dev` to test end-to-end (use Supabase test user for login/register, curl with valid/invalid/different-tenant tokens to verify RLS/401/403).
